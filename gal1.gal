class Gal_Class
{
}

class Symbol [is Gal_Class]
{
    comment definition `a bound property entity representing the entity's relationship with this attribute`;
    property entity Symbol_Owner;
    property variant Symbol_Value;
}

class Number_Symbol [is Symbol]
{
    property number Symbol_Value;
}

class String_Symbol [is Symbol]
{
    property string Symbol_Value;
}

class Entity_Symbol [is Symbol]
{
    property entity Symbol_Value;
}

class Flag_Symbol [is Symbol]
{
    property flag Symbol_Value;
}

class Attribute [is Symbol]
{
    comment definition `A single-valued attribute having a primitive data type.`;
    property entity Attribute_Entity;
    property variant Attribute_Value;
    property number Attribute_Certainty 0;
    method void Assign [variant Value, number Certainty 0]
    {
        my= Attribute_Value Value;
        my= Attribute_Certainty Certainty;
    }
    method variant Get_Value
    {
        return [my Attribute_Value];
    }
    method variant Get_Certainty
    {
        return [my Attribute_Certainty];
    }
}
comment 'Token.gal';

forward Factory;
forward Block;
forward Statement;
forward Operation;
forward Syntax;
forward Keyvalue;
forward Compiler;

class Token
{
    property string Input;
    property entity Document;
    property integer Start_Position;
    property integer End_Position;
    property string Gal;
    property string Fallback;
    property string Debug;
    property string Python;
    property string Javascript;
    property string Mumps;
    property string Error;
    property flag Is_Verb [false];
    property string Usage;
    property entity Method_Context;
    property entity Variable_Context;
    property entity Parent;
    property entity Class_Owner;
    property entity Method_Name;
    method string Get_Input
    {
        return [my Input];
    }
    method string To_String
    {
        string String [class.name] " " [my Input] " " 
            [my Start_Position] '-' [my End_Position];
        if (defined [my Error])
        {
            append String ' ERROR<' [my Error] '>';
        }
        return String;
    }
    method integer Compare [entity Element]
    {
        integer My_End [my End_Position];
        integer Elem_End [. Element End_Position];
        returnif (greater My_End Elem_End) 1;
        returnif (less My_End Elem_End) -1;
        integer My_Start [my Start_Position];
        integer Elem_Start [. Element Start_Position];
        returnif (greater My_Start Elem_Start) -1;
        returnif (less My_Start Elem_Start) 1;
        return 0;
    }
    classmethod flag Predict [string Character, string Next]
    {
        return [false];
    }
    method flag Append [string Character, string Next]
    {
        returnif (not (we Predict Character Next)) [false];
        append [my Input] Character;
        increment [my End_Position];
        return [true];
    }
    method void Attributes;
    method void Process_Arguments;
    method void Structure;
    method void Model;
    method void Class_Export;
    method void Verb_Export;
    method void Gal_Generate
    {
        my= Gal [my Input];
    }
    method void Fallback_Generate
    {
        my= Fallback [my Input];
    }
    method void Debug_Generate
    {
        my= Debug [my Input];
    }
    method void Python_Generate
    {
        my= Python [my Input];
    }
    method void Javascript_Generate
    {
        my= Javascript [my Input];
    }
    method void Mumps_Generate
    {
        my= Mumps [my Input];
    }
    method string Python_Atom [integer Precedence]
    {
        return [my Python];
    }
    method string Javascript_Atom [integer Precedence]
    {
        string Code [my Javascript];
        return Code;
    }
    method string Gal_Code
    {
        return [my Input];
    }
}
class Token_Space [is Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (whitespace Character);
    }
}
class Value_Token [is Token];
class Token_Name [is Value_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        returnif (whitespace Character) [false];
        returnif (contains '[]{}<>();,"`' Character) [false];
        returnif (string.eq Character "'") [false];
        return [true];
    }
    method flag Append [string Character, string Next]
    {
        returnif (whitespace Character) [false];
        returnif (contains '[]{}<>();,"`' Character) [false];
        returnif (string.eq Character "'") [false];
        append [my Input] Character;
        increment [my End_Position];
        return [true];
    }

    method void Python_Generate
    {
        string Code [my Input];
        if (contains Code ':')
        {
            if (string.eq (firstchar Code) ':')
            {
                = Code (substring Code 1);
            }
            replace Code ':' '_';
            comment writeline 'Token.Name ' [my Input] '-->' Code;
        }
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code [my Input];
        if (contains Code ':')
        {
            if (string.eq (firstchar Code) ':')
            {
                = Code (substring Code 1);
            }
            replace Code ':' '_';
        }
        my= Javascript Code;
    }
    method string Unquoted
    {
        string Text [my Input];
        return Text;
    }
}
class Token_Class_Name [is Token_Name]
{
    classmethod flag Predict [string Character, string Next]
    {
        returnif (whitespace Character) [false];
        returnif (string.ne Character ':') [false];
        returnif (whitespace Next) [false];
        return [true];
    }
}
class Number [is Value_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (contains '0123456789.-' Character);
    }
}
class Quote [is Value_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (or (or (string.eq Character '"')
                   (string.eq Character "'"))
                   (string.eq Character '`'));
    }
    method flag Append [string Character, string Next]
    {
        string Text [my Input];
        string First (firstchar Text);
        string Last (lastchar Text);
        returnif (and (string.eq First Last) (greater (length Text) 1)) [false];
        append [my Input] Character;
        increment [my End_Position];
        return [true];
    }
    method string Unquoted
    {
        string Text [my Input];
        integer Length (length Text);
        string Middle (substring Text 1 (- Length 2));
        return Middle;
    }
    method void Gal_Generate
    {
        string Code [my Input];
        if (contains [my Input] [line]) 
        {
            string Line;
            string Expressions '';
            string Q (firstchar Code);
            = Code (substring Code 1 (- (length Code) 2));
            foreach (split Code [line]) Line
            {
                if (string.ne Expressions '')
                {
                    append Expressions ' [line] ';
                }
                append Expressions Q Line Q;
            }
            = Code (append '(append ' Expressions ')');
        }
        my= Gal Code;
    }
    method void Fallback_Generate
    {
        string Code [my Input];
        if (contains [my Input] [line]) 
        {
            string Line;
            string Expressions '';
            string Q (firstchar Code);
            = Code (substring Code 1 (- (length Code) 2));
            foreach (split Code [line]) Line
            {
                if (string.ne Expressions '')
                {
                    append Expressions ' [line] ';
                }
                append Expressions Q Line Q;
            }
            = Code (append '(append ' Expressions ')');
        }
        my= Fallback Code;
    }
    method void Python_Generate
    {
        string Input [my Input];
        if (contains Input [backslash])
        {
            replace Input [backslash] [backslash 2];
        }
        string Q (firstchar Input);
        string Middle (substring Input 1 (- (length Input) 2));
        if (or (contains Middle [line]) (s= Q '`')) 
        {
            = Q "'''";
        }
        string Code Q Middle Q;
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Input [my Input];
        if (contains Input [backslash])
        {
            replace Input [backslash] [backslash 2];
        }
        my= Javascript Input;
    }
}

class Boundary_Token [is Token]
{
    method flag Append [string Character, string Next]
    {
        return [false];
    }
}
class Start_Token [is Boundary_Token];
class End_Token [is Boundary_Token];
class Token_Semi [is End_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character ';');
    }
}
class Token_Block_Start [is Start_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character '{');
    }
}
class Token_Block_End [is End_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character '}');
    }
}
class Token_Operation_Start [is Start_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character '(');
    }
}
class Token_Operation_End [is End_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character ')');
    }
}
class Token_Syntax_Start [is Start_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character '[');
    }
}
class Token_Syntax_End [is End_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character ']');
    }
}
class Token_Keyvalue_Start [is Start_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character '<');
    }
}
class Token_Keyvalue_End [is End_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character '>');
    }
}
class Token_Comma [is Boundary_Token]
{
    classmethod flag Predict [string Character, string Next]
    {
        return (string.eq Character ',');
    }
}

comment 'Element.gal';

forward Gal;
forward Python;
forward Javascript;
forward Sql;

class Element
{
    class.property integer Js_Precedence 99;
    class.property flag Verbose [false];
    property string Dialect '';
    property string Input '';
    property integer Start_Position -1;
    property integer End_Position -1;
    property entity Document;
    property entity Parent;
    property string Gal;
    property string Debug;
    property string Fallback;
    property string Python;
    property string Javascript;
    property string Mumps;
    property string Php;
    property string Java;
    property string Sql;
    property string Gal_Declaration;
    property string Fallback_Declaration;
    property list Tokens;
    property entity Class_Context;
    property entity Method_Context;
    property entity Variable_Context;
    property list Document_Body;
    property list Elements;
    property string Error;
    property flag Is_Verb [false];
    property string Usage '';
    property flag Re_Structure [true];
    property entity Block;
    property string Data_Type;
    property string Method_Signature '';
    property entity Class_Owner;
    property entity Method_Name;

    class.method void Test [list Errors, flag Verbose]
    {
        string Error_Message [class.name] ' does not override base Test method.';
        list.append Errors Error_Message;
        if Verbose
        {
            writeline Error_Message;
        }
    }
    method flag Validate
    {
        return [true];
    }
    method entity Lookup [string Element_Name]
    {
        returnif [my Parent] (. [my Parent] Lookup Element_Name);
        return [false];
    }
    method void Model;
    method void Pre_Fallback;
    method string To_String
    {
        string String [class.name] ': ';
        try
        {
            append String [my Start_Position];
        }
        catch
        {
            append String '<Start?>';
        }
        try
        {
            append String '-' [my End_Position];
        }
        catch
        {
            append String '-<End?>';
        }
        try
        {
            if (defined [my Error])
            {
                append String ' ERROR <' [my Error] '>';
            }
        }
        catch
        {
            append String ' ok';
        }
        append String ' <' (i Get_Input) '> ';
        return String;
    }
    method flag Am [entity Other]
    {
        string My_Text (i To_String);
        string Other_Text (. Other To_String);
        return (s= My_Text Other_Text);
    }

    method flag Am_Earlier [entity Other]
    {
        returnif (not (isa Other Element)) [true];
        returnif (lt [. Other Start_Position] 0) [true];
        returnif (lt [my Start_Position] 0) [false];
        return (lt [my Start_Position] [. Other Start_Position]);
    }

    method string String_Info
    {
        return '.';
    }
    method string Get_Input
    {

        returnif (not (defined [my Document])) '<no document>';
        returnif (lt [my Start_Position] 0) '<negative start>';
        integer String_Length (+ (- [my End_Position] [my Start_Position]) 1);
        string Input [my Document Input];
        integer Start [my Start_Position];
        string Text (substring Input Start String_Length);
        return Text;
    }
    method integer Compare [entity Element]
    {
        integer My_End [my End_Position];
        integer Elem_End [. Element End_Position];
        returnif (greater My_End Elem_End) 1;
        returnif (less My_End Elem_End) -1;
        integer My_Start [my Start_Position];
        integer Elem_Start [. Element Start_Position];
        returnif (greater My_Start Elem_Start) -1;
        returnif (less My_Start Elem_Start) 1;
        return 0;
    }
    method entity Inference_Context
    {
    	returnif (not (defined [my Parent])) [null];
    	return (. [my Parent] Inference_Context);
    }
    method void Gal_Generate
    {
        error "Must Override Gal_Generate";
    }
    method void Debug_Generate
    {
        error "Must Override Debug_Generate";
    }
    method void Fallback_Generate
    {
        my= Fallback [my Gal];
    }
    method void Php_Generate
    {
        error "Must Override Php_Generate";
    }
    method void Java_Generate
    {
        error "Must Override Java_Generate";
    }
    method integer Gal_Add_Token [entity Token]
    {
        return -1;
    }
    method void Gal_Add_Element [entity Child_Element]
    {
        comment writeline 'append element ' [class.name];
        if (gt [. Child_Element End_Position] [my End_Position])
        {
            my= End_Position [. Child_Element End_Position];
        }
        push [my Elements] Child_Element;
    }

    method flag Gal_Tokenize
    {
        string Text [my Input];
        string Char (substring Text 0 1);
        string Next (substring Text 1 1);
        integer End (- (length Text) 1);
        integer Position 0;
        entity Token (: Factory Create_Token Char Next Position);
        if (not (isa Token Token_Space))
        {
            push [my Tokens] Token;
        }
        for.range Position 1 End
        {
            = Char (substring Text Position 1);
            if (lt Position End)
            {
                = Next (substring Text (+ Position 1) 1);
            }
            else
            {
                = Next '';
            }
            continue.if (. Token Append Char Next);
            = Token (: Factory Create_Token Char Next Position);
            returnif (not Token) [false];
            contif (isa Token Token_Space);
            push [my Tokens] Token;
        }
        return [true];
    }

    method void Gal_Parse
    {
        : Gal Parse_Element [self];
    }

    method void Javascript_Parse
    {
        todo "Parse this element's tokens into Javascript language elements.";
        : Javascript Parse_Element [self];
    }
    method void Python_Parse
    {
        todo "Parse this element's tokens into Python language elements.";
        : Python Parse_Element [self];
    }
    method void Sql_Parse
    {
        todo "Parse this element's tokens into SQL language elements.";
        : Sql Parse_Element [self];
    }

    method void Structure
    {
        returnif (not [my Re_Structure]);
        my= Re_Structure [false];
        comment writeline '     Element Structure ' [class.name];
        i Base_Structure;
        entity Element;
        foreach [my Elements] Element
        {
            if (and (defined [my Method_Context])
                    (not (defined [. Element Method_Context])))
            {
                .= Element Method_Context [my Method_Context];
            }
            if (and (defined [my Variable_Context])
                    (not (defined [. Element Variable_Context])))
            {
                .= Element Variable_Context [my Variable_Context];
            }
            comment .= Element Parent [self];
            . Element Structure;
        }
    }
    method void Base_Model
    {
        comment writeline '     Element Model ' [class.name];
        entity This_Element;
        foreach [my Document_Body] This_Element
        {
            comment `writeline ' - model ' (. This_Element To_String);`;
            try
            {
                . This_Element Model;
            }
            catch Error
            {
                debug;
                writeline "ERROR modeling " (. This_Element To_String) ': ' Error;
                .= This_Element Error Error;
            }
        }
    }
    method void Base_Structure;
    method void Child_Attributes
    {
        entity Element;
        foreach [my Document_Body] Element
        {
            string Error;
            try
            {
                . Element Attributes;
                . Element Process_Arguments;
            }
            catch Error
            {
                debug;
                writeline 'Child_Attributes error <' Error '> on Element ' (. Element To_String);
                .= Element Error Error;
            }
        }
    }

    method void Attributes;
    method void Process_Arguments;
    
    method flag Validate 
    {
        return [true]; 
    }

    method void Class_Export;
    method void Verb_Export;
    
    method void Javascript_Generate
    {
        error [class.name] ' must override Javascript_Generate';
    }

    method void Python_Generate
    {
        error [class.name] ' must override Python_Generate';
    }

    method void Sql_Generate
    {
        error [class.name] ' must override Sql_Generate';
    }

    method void Mumps_Generate
    {
        error [class.name] ' must override Mumps_Generate';
    }

    method string Gal_Block
    {
        string Gal_Code ';';
        if (and (defined [my Block]) (defined [my Block Gal]))
        {
            = Gal_Code [my Block Gal];
        }
        return Gal_Code;
    }
    
    method string Fallback_Block
    {
        returnif (defined [my Block]) [my Block Fallback];
        return ';';
    }
    
    method string Python_Block
    {
        forgive
        {
            if (and (defined [my Block]) (defined [my Block Python]))
            {
                returnif  (string.gt [my Block Python] '') [my Block Python];
            }
        }
        return (append ':' [line, indent] 'pass' [line]);
    }

    method string Python_Statements
    {
        forgive
        {
            if (and (defined [my Block]) (defined [my Block Python_Statements]))
            {
                returnif  (string.gt [my Block Python_Statements] '') [my Block Python_Statements];
            }
        }
        return '';
    }

    method string Javascript_Block
    {
        forgive
        {
            if (and (defined [my Block]) (defined [my Block Javascript]))
            {
                returnif  (string.gt [my Block Javascript] '') [my Block Javascript];
            }
        }
        return ' { } ';
    }
    
    method string Javascript_Statements
    {
        forgive
        {
            if (and (defined [my Block]) (defined [my Block Javascript_Statements]))
            {
                returnif  (string.gt [my Block Javascript_Statements] '') [my Block Javascript_Statements];
            }
        }
        return '';
    }
    
    method string Fallback_Args
    {
        entity Argument;
        string Args_Gal '';
        foreach [my Listargs] Argument
        {
            string Arg_Gal [. Argument Fallback];
            append Args_Gal ' ' Arg_Gal;
        }
        return Args_Gal;
    }

    method string Python_Args [string Separator]
    {
        entity Argument;
        string Args_Py '';
        string Between '';
        foreach [my Listargs] Argument
        {
            if (not (defined [. Argument Python]))
            {
                error 'Argument Python not defined: ' [. Argument Gal];
            }
            string Arg_Py [. Argument Python];
            append Args_Py Between Arg_Py;
            = Between Separator;
        }
        return Args_Py;
    }

    method string Python_String_Args [string Separator]
    {
        entity Argument;
        string Args_Py '';
        string Between '';
        foreach [my Listargs] Argument
        {
            if (not (defined [. Argument Python]))
            {
                error 'Argument Python not defined: ' [. Argument Gal];
            }
            string Arg_Py [. Argument Python];
            if (isa Argument Quote)
            {
                append Args_Py Between Arg_Py;
            }
            else
            {
                append Args_Py Between 'str(' Arg_Py ')';
            }
            = Between Separator;
        }
        return Args_Py;
    }

    method string Javascript_Args [string Separator]
    {
        entity Argument;
        string Args_Js '';
        string Between '';
        foreach [my Listargs] Argument
        {
            if (not (defined [. Argument Javascript]))
            {
                error 'Argument Javascript not defined: ' [. Argument Gal];
            }
            string Arg_Js [. Argument Javascript];
            append Args_Js Between Arg_Js;
            = Between Separator;
        }
        return Args_Js;
    }

    method string Mumps_Args [string Separator]
    {
        entity Argument;
        string Args_M '';
        string Between '';
        foreach [my Listargs] Argument
        {
            string Arg_M [. Argument Mumps];
            append Args_M Between Arg_M;
            = Between Separator;
        }
        return Args_M;
    }

    method string Fallback_Arguments
    {
        entity Argument;
        string Args_Code '';
        foreach [my Arguments] Argument
        {
            append Args_Code ' ' [. Argument Fallback];
        }
        return Args_Code;
    }

    method string Argument_String
    {
        entity Argument;
        string Args_Code '';
        string Between '';
        foreach [my Arguments] Argument
        {
            if (isa Argument Quote)
            {
                append Args_Code (. Argument Unquoted);
            }
            else
            {
                append Args_Code Between (. Argument Gal_Code);
                = Between ' ';
            }
        }
        return Args_Code;
    }

    method string Python_Arguments [string Separator]
    {
        entity Argument;
        string Args_Py '';
        string Between '';
        foreach [my Arguments] Argument
        {
            string Arg_Py [. Argument Python];
            append Args_Py Between Arg_Py;
            = Between Separator;
        }
        return Args_Py;
    }

    method string Javascript_Arguments [string Separator]
    {
        entity Argument;
        string Args_Js '';
        string Between '';
        foreach [my Arguments] Argument
        {
            string Arg_Js [. Argument Javascript];
            append Args_Js Between Arg_Js;
            = Between Separator;
        }
        return Args_Js;
    }

    method string Mumps_Arguments [string Separator]
    {
        entity Argument;
        string Args_M '';
        string Between '';
        foreach [my Arguments] Argument
        {
            string Arg_M [. Argument Mumps];
            append Args_M Between Arg_M;
            = Between Separator;
        }
        return Args_M;
    }
    
    method string Indent [string Input]
    {
        list.copy Lines (split Input [line]);
        string Line;
        string Indented '';
        foreach Lines Line
        {
            if (string.gt Line '')
            {
                append Indented [indent] Line [line];
            }
        }
        return Indented;
    }

    method string Pascal_Case [string Input]
    {
        string Name (lowercase Input);
        list.copy Words (split Name '_');
        string Pascal '';
        integer I;
        integer End (- (list.length Words) 1);
        string W;
        string Between '';
        string One_Word;
        for.range I 0 End
        {
            = W (list.get Words I);
            = One_Word (append (uppercase (firstchar W)) (substring W 1));
            append Pascal Between One_Word;
            = Between '_';
        }
        return Pascal;
    }

    method string Python_Atom [integer Precedence]
    {
        string Code [my Python];
        forgive
        {
            if (gt Precedence [class.property Js_Precedence])
            {
                = Code (append '(' Code ')');
            }
        }
        return Code;
    }

    method string Javascript_Atom [integer Precedence]
    {
        string Code [my Javascript];
        forgive
        {
            if (gt Precedence [class.property Js_Precedence])
            {
                = Code (append '(' Code ')');
            }
        }
        return Code;
    }

    method string Code_Context
    {
        integer Start [my Start_Position];
        integer End [my End_Position];
        integer Length (+ (- End Start) 1);
        integer Window 50;
        integer Before (- Start Window);
        integer BL Window;
        if (lt Before 0)
        {
            = BL (+ Window Before);
            = Before 0;
        }
        string Prefix (substring [my Document Input] Before BL);
        string Middle (substring [my Document Input] Start Length);
        string Suffix (substring [my Document Input] (+ End 1) Window);
        string Context Prefix '<*' Middle '*>' Suffix;
        return Context;
    }

	method string Enquote [string Input]
	{
		returnif (not (contains Input "'")) (append "'" Input "'");
		returnif (not (contains Input '"')) (append '"' Input '"');
		returnif (not (contains Input '`')) (append '`' Input '`');
		debug;
		error 'Fix this here';
		return Input;
	}

    method string Gal_Code
    {
        integer Start [my Start_Position];
        integer End [my End_Position];
        integer Length (+ (- End Start) 1);
        string Code (substring [my Document Input] Start Length);
        return Code;
    }

    method string Failure_Message [string Problem_Desc]
    {
        string Message Problem_Desc '. ';
        append Message (i Gal_Code) ' ';
        append Message (i Code_Context);
        return Message;
    }
}

class Named_Element [is Element]
{
    class.property string Gal_Keyword;
    class.property string Gs_Keyword;
    property string Verb;
    property list Listargs;
    property list Arguments;
    method string String_Info
    {
        string String '';
        try
        {
            entity Argument;
            foreach [my Arguments] Argument
            {
                string Arg_Str [class.name Argument];
                append String ' ' Arg_Str;
            }
        }
        catch
        {
            append String '<invalid Arguments>';
        }
        append String '.';
        return String;
    }
    method void Base_Structure
    {
        entity Argument;
        entity Previous;
        foreach [my Arguments] Argument
        {
            if (and (isa Argument Syntax)
               (and (defined Previous)
                    (isa Previous Syntax)))
            {
                .= Previous Chain_Forward [true];
                .= Argument Chain_Backward [true];
            }
            = Previous Argument;
        }
    }
    method void Gal_Add_Element [entity Child_Element]
    {
        comment writeline 'append element argument ' [class.name];
        if (gt [. Child_Element End_Position] [my End_Position])
        {
            my= End_Position [. Child_Element End_Position];
        }
        push [my Elements] Child_Element;
        push [my Arguments] Child_Element;
        push [my Listargs] Child_Element;
    }
}

comment 'Statement.gal';

forward Comment_Statement;

class Statement [is Named_Element]
{
    property flag In_Block [false];
    property entity Block;
    property entity Verb_Owner;
    property entity Class_Owner;
    property string Infer_Inits '';
    method void Ensure_Block
    {
        returnif (defined [my Block]);
        entity.new Block Block;
        .= Block Document [my Document];
        .= Block Start_Position [my Start_Position];
        .= Block End_Position [my End_Position];
        my= Block Block;
    }
    method string String_Info
    {
        string String '';
        try
        {
            entity Argument;
            foreach [my Arguments] Argument
            {
                string Arg_Str [class.name Argument];
                append String ' ' Arg_Str;
            }
        }
        catch
        {
            append String '<invalid Arguments>';
        }
        try
        {
            if (defined [my Block])
            {
                append String ' ' (. [my Block] To_String);
            }
        }
        catch
        {
            append String '<invalid Block>';
        }
        append String '.';
        return String;
    }
    method void Structure
    {
        returnif (not [my Re_Structure]);
        my= Re_Structure [false];
        comment writeline '     Element Structure ' [class.name];
        i Base_Structure;
        if (defined [my Block])
        {
            if (defined [my Class_Context])
            {
                .= [my Block] Class_Context [my Class_Context];
            }
            if (defined [my Method_Context])
            {
                .= [my Block] Method_Context [my Method_Context];
            }
            if (defined [my Variable_Context])
            {
                .= [my Block] Variable_Context [my Variable_Context];
            }
            . [my Block] Structure;
        }
        entity Element;
        foreach [my Elements] Element
        {
            comment .= Element Parent [me];
            if (and (defined [my Method_Context])3
                    (not (defined [. Element Method_Context])))
            {
                .= Element Method_Context [my Method_Context];
            }
            . Element Structure;
        }
    }
    method void Base_Structure
    {
        entity Argument;
        entity Previous;
        foreach [my Arguments] Argument
        {
            if (and (isa Argument Syntax)
               (and (defined Previous)
                    (isa Previous Syntax)))
            {
                .= Previous Chain_Forward [true];
                .= Argument Chain_Backward [true];
            }
            = Previous Argument;
        }
    }
    method string Conditional_Debug
    {
        string Code ': Debugger Conditional ' [my Start_Position] ' ' [my End_Position] ';' [line];
        return Code;
    }
    method integer Gal_Add_Token [entity Token]
    {
        comment "Add token '" (. Token To_String) "' to statement '" (i To_String) "'";
        if (or (isa Token Token_Semi) (isa Token Token_Block_End))
        {
            comment 'Statement ' (i To_String) ' appends ' (. Token To_String) ' statement terminator';
            push [my Elements] Token;
            my= End_Position [. Token End_Position];
            if [my In_Block]
            {
                .= [my Block] End_Position [my End_Position];
            }
            return -1;
        }
        if (isa Token Token_Block_Start)
        {
            comment 'Statement ' (i To_String) ' appends ' (. Token To_String) ' block start';
            push [my Elements] Token;
            integer Here [. Token End_Position];
            my= End_Position Here;
            new [my Block] Block;
            .= [my Block] Document [my Document];
            .= [my Block] Start_Position Here;
            .= [my Block] End_Position Here;
            my= In_Block [true];
            push [my Elements] [my Block];
            return 0;
        }
        returnif (isa Token Start_Token) 1;
        if (isa Token End_Token)
        {
            comment 'Statement ' (i To_String) ' appends ' (. Token To_String) ' error end token';
            todo 'log error here';
            return -999;
        }
        push [my Elements] Token;
        if [my In_Block]
        {
            comment 'Statement ' (i To_String) ' appends ' (. Token To_String) ' in a block';
            return 1;
        }
        else
        {
            comment 'Statement ' (i To_String) ' appends ' (. Token To_String) ' as argument';
            push [my Arguments] Token;
            push [my Listargs] Token;
        }
        my= End_Position [. Token End_Position];
        return 0;
    }
    method void Gal_Add_Element [entity Child_Element]
    {
        comment writeline "Add element " (. Child_Element To_String) " to statement " (i To_String);
        if (gt [. Child_Element End_Position] [my End_Position])
        {
            my= End_Position [. Child_Element End_Position];
        }
        if [my In_Block]
        {
            . [my Block] Gal_Add_Element Child_Element;
        }
        else
        {
            push [my Elements] Child_Element;
            push [my Arguments] Child_Element;
            push [my Listargs] Child_Element;
        }
    }
    method void Gal_Generate
    {
        i Ensure_Block;
        . [my Block] Gal_Generate;
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Comma)
            {
                append Gal_Code ',';
                continue;
            }
            if (not (defined [. Argument Gal]))
            {
                my= Error "Argument Error";
                append Gal_Code "<Argument Error>";
                writeline (. Argument To_String) ": Argument Error";
            }
            else
            {
                append Gal_Code ' ' [. Argument Gal];
            }
        }
        append Gal_Code [my Block Gal];
        my= Gal Gal_Code;
    }
    method void Fallback_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            . Argument Fallback_Generate;
            append Gal_Code ' ' [. Argument Fallback];
        }
        if (defined [my Block])
        {
            . [my Block] Fallback_Generate;
            append Gal_Code (i Fallback_Block);
        }
        else
        {
            append Gal_Code ';';
        }
        my= Fallback Gal_Code;
    }
    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        append Gal_Code (i Conditional_Debug);
        my= Debug Gal_Code;
    }
}

class Block [is Element]
{
    property list Statements;
    property string Gal_Statements;
    property string Fallback_Statements;
    property string Python_Statements;
    property string Javascript_Statements;

    method void Add_Statement [entity Statement]
    {
        list.push [my Statements] Statement;
    }
    method string String_Info
    {
        string String [class.name] ': ';
        try
        {
            append String [my Start_Position];
        }
        catch
        {
            append String '<Start?>';
        }
        try
        {
            append String '-' [my End_Position];
        }
        catch
        {
            append String '-<End?>';
        }
        append String ' {';
        entity Statement;
        foreach [my Statements] Statement
        {
            string Stmt_Str [class.name Statement];
            append String ' ' Stmt_Str;
        }
        append String ' }';
        try
        {
            if (defined [my Error])
            {
                append String ' ERROR <' [my Error] '>';
            }
        }
        catch
        {
            append String ' ok';
        }
        return String;
    }
    method void Base_Structure
    {
        if (defined [my Method_Context])
        {
            comment writeline 'Block Method Context' ;
        }
        else
        {
            string Message '%% Block No Method Context in ';
            if (defined [my Parent])
            {
                append Message (. [my Parent] To_String);
            }
            append Message ' %%';
            comment writeline Message;
        }
        entity Statement;
        foreach [my Statements] Statement
        {
            if (defined [my Class_Context])
            {
                comment writeline '    ' (. Statement To_String);
                .= Statement Class_Context [my Class_Context];
            }
            if (defined [my Method_Context])
            {
                comment writeline '    ' (. Statement To_String);
                .= Statement Method_Context [my Method_Context];
            }
            if (defined [my Variable_Context])
            {
                .= Statement Variable_Context [my Variable_Context];
            }
            . Statement Structure;
            
        }
    }
    method void Gal_Add_Element [entity Child_Element]
    {
        comment writeline 'block append element ' [class.name];
        if (gt [. Child_Element End_Position] [my End_Position])
        {
            my= End_Position [. Child_Element End_Position];
        }
        push [my Elements] Child_Element;
        push [my Statements] Child_Element;
    }
    method void Gal_Generate
    {
        string Block_Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            if (not (defined [. Statement Gal]))
            {
                . Statement Gal_Generate;
            }
            append Block_Code [. Statement Gal] [line];
        }
        string Code ';';
        if (string.gt Block_Code '')
        {
            = Block_Code (i Indent Block_Code);
            = Code (append [line] '{' [line] Block_Code '}' [line]);
        }
        my= Gal_Statements Block_Code;
        my= Gal Code;
    }
    method void Debug_Generate
    {
        string Code [line] '{' [line];
        string Block_Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            append Block_Code [. Statement Gal] [line];
        }
        = Block_Code (i Indent Block_Code);
        my= Gal_Statements Block_Code;
        append Code Block_Code '}' [line];
        my= Debug Code;
    }
    method void Fallback_Generate
    {
        string Block_Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            if (not (defined [. Statement Fallback]))
            {
                . Statement Fallback_Generate;
            }
            append Block_Code [. Statement Fallback] [line];
        }
        string Code ';' [line];
        if (string.gt Block_Code '')
        {
            = Block_Code (i Indent Block_Code);
            = Code (append [line] '{' [line] Block_Code '}' [line]);
        }
        my= Fallback_Statements Block_Code;
        my= Fallback Code;
    }
    method void Python_Generate
    {
        flag Non_Comments [false];
        string Stmt_Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            string Statement_Py [. Statement Python];
            if (defined Statement_Py)
            {
                append Stmt_Code Statement_Py;
            }
            else
            {
                append Stmt_Code '# ERROR from ' (. Statement To_String);
            }
            if (not (isa Statement Comment_Statement))
            {
                = Non_Comments [true];
            }
        }
        if (not Non_Comments)
        {
            append Stmt_Code 'pass' [line];
        }
        = Stmt_Code (i Indent Stmt_Code);
        my= Python_Statements Stmt_Code;
        string Code ':' [line] Stmt_Code;
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Block_Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            string Statement_JS [. Statement Javascript];
            if (defined Statement_JS)
            {
                append Block_Code Statement_JS;
            }
            else
            {
                append Block_Code '// ERROR from ' (. Statement To_String) [line];
            }
        }
        comment writeline 'block: ' Block_Code;
        = Block_Code (i Indent Block_Code);
        comment writeline 'indented block: ' Block_Code;
        my= Javascript_Statements Block_Code;
        string Code [line] '{' [line] Block_Code '}' [line];
        comment writeline 'code: ' Code;
        my= Javascript Code;
    }
}

class Line_Statement [is Statement];

class Scoped_Statement [is Statement];

class Declare_Statement [is Line_Statement]
{
    argument Variable;
    optional Value;
    method void Javascript_Generate
    {
        if (not (defined [my Variable Javascript]))
        {
            error (i Failure_Message 'Variable Javascript is undefined');
        }
        string Variable_Javascript [my Variable Javascript];
        string Value_Javascript '';
        if (defined [my Value])
        {
            = Value_Javascript (append ' = ' [my Value Javascript]);
        }
        string Code 'var ' Variable_Javascript Value_Javascript ';' [line];
        my= Javascript Code;
    }
    method void Python_Generate
    {
        if (not (defined [my Variable Python]))
        {
            error (i Failure_Message 'Variable Python is undefined');
        }
        string Variable_Python [my Variable Python];
        string Value_Python 'None';
        if (defined [my Value])
        {
            if (not (defined [my Value Python]))
            {
                error (i Failure_Message 'Value Python is undefined');
            }
            = Value_Python [my Value Python];
        }
        string Code Variable_Python ' = ' Value_Python [line];
        my= Python Code;
    }
}

class Method_Statement [is Scoped_Statement]
{
    argument Return_Type;
    argument Method_Name;
    property string Python_Class 'cls';
    property entity Method_Context;
    property entity Variable_Context;
    property string Method_Signature;
    method void Attributes
    {
        my= Return_Type (shift [my Listargs]);
        my= Method_Name (shift [my Listargs]);
        my= Method_Context [me];
        todo 'add this to the compiled method list of the class.';
        string Header 'method';
        entity Argument;
        foreach [my Arguments] Argument
        {
            comment "The arguments must be consistent, because we need to know the header before generation begins.";
            append Header ' ' (. Argument Get_Input);
        }
        my= Method_Signature Header;
    }

    method void Model
    {
        returnif (not [my Class_Owner]);
        string Signature 'method';
        entity Argument;
        foreach [my Arguments] Argument
        {
            comment "The arguments must be consistent, because we need to know the header before generation begins.";
            append Signature ' ' (. Argument Get_Input);
        }
        my= Method_Signature Signature;
        dict.assign [my Class_Owner Signatures] Signature [me];
    }

    method void Verb_Export
    {
        writeline 'Method statement ' [my Method_Signature] ' Verb_Export begin';
        returnif (not [: Compiler Instance Verb_Export]);
        writeline 'flag on';
        entity Verb (. [: Compiler Instance] Get_Verb [my Method_Signature]);
        returnif (isnull Verb);
        writeline 'verb found';
        string My_Class_Name [my Class_Owner Class_Name Input];
        returnif (key.exists [. Verb Handler_Classes] My_Class_Name);
        writeline 'handler is new';
        todo `Generate a text copy of my gal code with the handler header.`;
        .= [my Block] End_Position [my End_Position];
        .= [my Block] Document [my Document];
        writeline 'getting block';
        i Ensure_Block;
        string Gal_Block (i Gal_Block);
        writeline 'generating handler';
        string Code 'handler ' My_Class_Name Gal_Block;
        todo `Add it as a text token to the verb's handler list.`;
        writeline 'creating token';
        entity.new New_Token Token;
        .= New_Token Input Code;
        .= New_Token Gal Code;
        .= New_Token Start_Position [my Start_Position];
        .= New_Token End_Position [my End_Position];
        writeline 'adding to verb block';
        . Verb Ensure_Block;
        . [. Verb Block] Add_Statement New_Token;
        dict.assign [. Verb Handler_Classes] My_Class_Name [me];
        todo `Check Class_Keep_Verbs compiler switch. Exit if true.`;
        returnif [: Compiler Instance Class_Keep_Verbs];
        todo `Delete this method from the class.`;
        . [my Class_Owner] Delete_Method [me];
        writeline 'Method statement ' [my Method_Signature] ' Verb_Export end';
    }
    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        my= Debug Gal_Code;
    }
}
class Class_Method_Statement [is Method_Statement];
class Property_Statement [is Line_Statement]
{

    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        my= Debug Gal_Code;
    }
}
class Class_Property_Statement [is Line_Statement]; 
class Constructor_Statement [is Method_Statement]
{
    method void Attributes
    {
    }
    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        my= Debug Gal_Code;
    }
}
class If_Statement [is Scoped_Statement]
{
    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        my= Debug Gal_Code;
    }
}
class Append_Args_Statement [is Line_Statement];
class Assign_Statement [is Line_Statement];
class Invocation_Statement [is Line_Statement];
class Argument_Statement [is Line_Statement]
{
    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        my= Debug Gal_Code;
    }
}
class Comment_Statement [is Append_Args_Statement]
{
    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        my= Debug Gal_Code;
    }
}
class For_Statement [is Scoped_Statement];

class Interface_Statement [is Scoped_Statement];

forward Statement_Classify;
class Verb_Statement [is Scoped_Statement]
{
    property string Method_Signature;
    property hash Handler_Classes;
    method void Base_Structure
    {
        my= Class_Context [me];
        entity Statement;
        if (and (defined [my Block]) (defined [my Block Statements]))
        {
            foreach [my Block Statements] Statement
            {
                if (isa Statement Statement_Classify)
                {
                    .= Statement Verb_Owner [me];
                    .= Statement Method_Signature [my Method_Signature];
                }
            }
        }
    }
    method void Model
    {
        . [: Compiler Instance] Add_Verb [me];
        comment ". [: Compiler Instance] Add_Class [me];";

    }

    method void Delete_Handler [entity Handler]
    {
        entity Statement;
        integer I;
        integer L (- (list.length [my Block Statements]) 1);
        for.range I 0 L
        {
            = Statement (list.get [my Block Statements] I);
            if (and (= [. Statement Start_Position] [. Handler Start_Position])
                    (= [. Statement End_Position] [. Handler End_Position]))
            {
                list.delete [my Block Statements] I 1;
                break;
            }
        }
    }
}

class Read_Statement [is Line_Statement];

class Class_Statement [is Scoped_Statement]
{
    property string Name_Prefix '';
    property flag Generate_Constructor [false];
    property flag Base_Class [false];
    property list Property_Statements;
    property list Class_Property_Statements;
    property list Method_Statements;
    property list Class_Method_Statements;
    property list Main_Body;
    property entity Constructor;
    property hash Signatures;

    method void Append_Statement [entity Statement]
    {
        .= Statement Class_Owner [me];
        if (isa Statement Constructor_Statement)
        {
            comment writeline 'Class_Statement.Append_Statement Constructor Statement Found';
            my= Constructor Statement;
        }
        else.if (isa Statement Class_Property_Statement)
        {
            comment writeline 'Class_Statement.Append_Statement - Class Property Statement: ' (. Statement To_String);
            push [my Class_Property_Statements] Statement;
        }
        else.if (isa Statement Property_Statement)
        {
            push [my Property_Statements] Statement;
            my= Generate_Constructor [true];
        }
        else.if (isa Statement Interface_Statement)
        {
            push [my Interface_Statements] Statement;
        }
        else
        {
            comment writeline 'Class_Statement.Append_Statement ' [my Class_Name Input] ' owns method ' [. Statement Method_Name Input]; 
            push [my Main_Body] Statement;
        }
    }

    method void Base_Structure
    {
        my= Class_Context [me];
        entity Statement;
        comment writeline 'Class Add to Index: ' [my Class_Name Input];
        if (and (defined [my Block]) (defined [my Block Statements]))
        {
            foreach [my Block Statements] Statement
            {
                comment writeline 'i append statement';
                i Append_Statement Statement;
            }
        }
        . [: Compiler Instance] Add_Class [me];
    }
    method void Model
    {
        comment writeline 'Model Class Statement ' (i To_String);
        . [: Compiler Instance] Add_Class [me];
    }
}


class Program [is Element]
{
    property list Statements;
    property string Gal_Statements;
    property string Fallback_Statements;
    property string Python_Statements;
    property string Javascript_Statements;
    property string Mumps_Statements;
    method void Gal_Add_Element [entity Child_Element]
    {
        if (gt [. Child_Element End_Position] [my End_Position])
        {
            my= End_Position [. Child_Element End_Position];
        }
        push [my Elements] Child_Element;
        push [my Statements] Child_Element;
    }
    method void Gal_Generate
    {
        string Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            if (defined [. Statement Gal])
            {
                if (sgt [. Statement Gal] '')
                {
                    append Code [. Statement Gal] [line];
                }
            }
            else
            {
                append Code '<Error no gal for ' (. Statement To_String) '>';
                debug;
            }
        }
        my= Gal_Statements Code;
        my= Gal Code;
    }
    method void Debug_Generate
    {
        string Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            if [. Statement Gal]
            {
                append Code [. Statement Gal] [line];
            }
            else
            {
                append Code '<Error no debug for ' (. Statement To_String) '>';
            }
        }
        my= Gal_Statements Code;
        my= Debug Code;
    }
    method void Fallback_Generate
    {
        string Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            . Statement Fallback_Generate;
            append Code [. Statement Fallback] [line];
        }
        my= Fallback_Statements Code;
        my= Fallback Code;
    }
    method void Python_Generate
    {
        string Code [line];
        entity Statement;
        foreach [my Statements] Statement
        {
            comment dv '$Statement';
            append Code [. Statement Python];
        }
        my= Python_Statements Code;
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code [line];
        entity Statement;
        foreach [my Statements] Statement
        {
            append Code [. Statement Javascript];
        }
        my= Javascript_Statements Code;
        my= Javascript Code;
    }
    method void Mumps_Generate
    {
        string Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            if [. Statement Mumps]
            {
                append Code [. Statement Mumps] [line];
            }
            else
            {
                append Code '<Error no mumps for ' (. Statement To_String) '>';
            }
        }
        my= Mumps_Statements Code;
        my= Mumps Code;
    }
}

class Gal_File [is Program]
{
    property integer Start_Position -1;
    property integer End_Position -1;
    property string File_Name;
    method void Read
    {
        string File_Name [my File_Name];
        string File_Text;
        file.readall File_Text File_Name;
        my= Input File_Text;
    }

    method void Write
    {
        string File_Name [my File_Name];
        string File_Text [my Input];
        file.dump File_Text File_Name;
    }
}

class Goal_Statement [is Class_Statement];
class Feature_Assignment_Statement [is Line_Statement]
{
    property string Class_Name;
    property string Property_Name;
    method void Fallback_Generate
    {
        string Prop [my Property_Name];
        string Cls [my Class_Name];
        string Parent '';
        if (defined [my Parent Name])
        {
            = Parent [my Parent Name Fallback];
        }
        string Code 
            '.= ' Parent ' ' Prop ' (new ' Cls (i Fallback_Args) ');';
        my= Fallback Code;
    }
}

class List_Feature_Statement [is Feature_Assignment_Statement]
{
    method void Fallback_Generate
    {
        string Prop [my Property_Name];
        string Cls [my Class_Name];
        string Parent '';
        if (defined [my Parent Name])
        {
            = Parent [my Parent Name Fallback];
        }
        string Code 
            'list List_' Prop  (i Fallback_Args) ';' [line];
        if (sgt Parent '')
        {
            append Code
                '.= ' Parent ' ' Prop ' List_' Prop ';';
        }
        my= Fallback Code;
    }

}


class Symbol_Statement [is Scoped_Statement]
{
    
}

class Entity_Definition_Statement [is Statement]
{
    method void Fallback_Generate
    {
        debug;
        string Name [my Name Fallback];
        string Parent '';
        if (defined [my Parent Name])
        {
            = Parent [my Parent Name Fallback];
        }
        string Code 
            'entity.new ' Name ' ' [my Class_Name] (i Fallback_Args) ';' [line];
        if (sgt Parent '')
        {
            append Code 
                '.= ' Parent ' ' Name ' ' Name ';' [line];
        }
        append Code 
            [my Block Fallback_Statements];
        my= Fallback Code;
    }
}
class Operation [is Named_Element]
{
    method integer Gal_Add_Token [entity Token]
    {
        returnif (isa Token Start_Token) 1;
        if (isa Token Token_Operation_End)
        {
            push [my Elements] Token;
            my= End_Position [. Token End_Position];
            return -1;
        }
        if (isa Token Token_Comma)
        {
            return -1;
        }
        if (isa Token End_Token)
        {
            my= Error 'Expected end-operation token';
            return -999;
        }
        todo 'handle comma here';
        returnif (isa Token Start_Token) 1;
        push [my Elements] Token;
        if (defined [my Verb])
        {
            push [my Arguments] Token;
            push [my Listargs] Token;
        }
        else
        {
            my= Verb [. Token Input];
            .= Token Is_Verb [true];
        }
        my= End_Position [. Token End_Position];
        return 0;
    }
    method void Gal_Generate
    {
        string Gal_Code '(' [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        append Gal_Code ')';
        my= Gal Gal_Code;
    }
    method void Debug_Generate
    {
        string Gal_Code '(' [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        append Gal_Code ')';
        my= Debug Gal_Code;
    }
    method void Fallback_Generate
    {
        string Gal_Code '(' [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code ')';
        my= Fallback Gal_Code;
    }
}

class Syntax [is Named_Element]
{
    property flag Chain_Backward [false];
    property flag Chain_Forward [false];
    method integer Gal_Add_Token [entity Token]
    {
        returnif (isa Token Start_Token) 1;
        if (isa Token Token_Syntax_End)
        {
            push [my Elements] Token;
            my= End_Position [. Token End_Position];
            return -1;
        }
        if (isa Token Token_Comma)
        {
            return -1;
        }
        if (isa Token End_Token)
        {
            my= Error 'Expected syntax end token';
            return -999;
        }
        todo 'handle comma here';
        returnif (isa Token Start_Token) 1;
        push [my Elements] Token;
        if (defined [my Verb])
        {
            push [my Arguments] Token;
            push [my Listargs] Token;
        }
        else
        {
            my= Verb [. Token Input];
            .= Token Is_Verb [true];
        }
        my= End_Position [. Token End_Position];
        return 0;
    }
    method void Gal_Generate
    {
        comment writeline 'Syntax Gal_Generate ' (i To_String);
        string First_Char '[';
        string Last_Char ']';
        if [my Chain_Backward] 
        {
            = First_Char '';
        }
        if [my Chain_Forward]
        {
            = Last_Char ',';
        }
        = First_Char '[';
        = Last_Char ']';
        string Gal_Code First_Char [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        append Gal_Code Last_Char;
        my= Gal Gal_Code;
    }
    method void Debug_Generate
    {
        string First_Char '[';
        string Last_Char ']';
        if [my Chain_Backward]
        {
            = First_Char '';
        }
        if [my Chain_Forward]
        {
            = Last_Char ',';
        }
        = First_Char '[';
        = Last_Char ']';
        string Gal_Code First_Char [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        append Gal_Code Last_Char;
        my= Debug Gal_Code;
    }
    method void Fallback_Generate
    {
        comment writeline 'Syntax Fallback_Generate ' (i To_String);
        string First_Char '[';
        string Last_Char ']';
        if [my Chain_Backward]
        {
            = First_Char '';
        }
        if [my Chain_Forward]
        {
            = Last_Char ',';
        }
        = First_Char '[';
        = Last_Char ']';
        string Gal_Code First_Char [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code Last_Char;
        my= Fallback Gal_Code;
    }
}

class Keyvalue [is Named_Element]
{
    method integer Gal_Add_Token [entity Token]
    {
        returnif (isa Token Start_Token) 1;
        if (isa Token Token_Keyvalue_End)
        {
            push [my Elements] Token;
            my= End_Position [. Token End_Position];
            return -1;
        }
        if (isa Token End_Token)
        {
            todo 'log error here';
            return -999;
        }
        push [my Elements] Token;
        push [my Arguments] Token;
        push [my Listargs] Token;
        my= End_Position [. Token End_Position];
        return 0;
    }
    method void Gal_Generate
    {
        string Gal_Code '<';
        string Between '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between [. Argument Gal];
            = Between ' ';
        }
        append Gal_Code '>';
        my= Gal Gal_Code;
    }
    method void Debug_Generate
    {
        string Gal_Code '<';
        string Between '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between [. Argument Gal];
            = Between ' ';
        }
        append Gal_Code '>';
        my= Debug Gal_Code;
    }
    method void Fallback_Generate
    {
        string Gal_Code '<';
        string Between '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between [. Argument Fallback];
            = Between ' ';
        }
        append Gal_Code '>';
        my= Fallback Gal_Code;
    }
}

class Repeating_Operation [is Operation]
{
    method void Mumps_Generate
    {
        string Between '';
        string Code '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Code Between (. Argument Mumps_Atom);
            = Between [class.property Mumps_Operator];
        }
        my= M_Expr Code;
    }
    method void Javascript_Generate
    {
        string Between '';
        string Operation ' ' [class.property Js_Operator] ' ';
        string Code '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Code Between (. Argument Javascript_Atom [class.property Js_Precedence]);
            = Between Operation;
        }
        my= Javascript Code;
    }
    method void Python_Generate
    {
        string Between '';
        string Operation ' ' [class.property Py_Operator] ' ';
        string Code '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Code Between (. Argument Python_Atom [class.property Py_Precedence]);
            = Between Operation;
        }
        my= Python Code;
    }
}

class Binary_Operation [is Operation]
{
    method void Mumps_Generate
    {
        entity First [node [my Arguments] 0];
        entity Second [node [my Arguments] 1];
        string First_M (. First M_Expression);
        string Second_M (. Second M_Atom);
        string Code First_M [class.property Mumps_Operator] Second_M;
        my= M_Expr Code;
    }
    method void Javascript_Generate
    {
        entity First [node [my Arguments] 0];
        entity Second [node [my Arguments] 1];
        integer Precedence [class.property Js_Precedence];
        string First_Js (. First Javascript_Atom Precedence);
        string Second_Js (. Second Javascript_Atom Precedence);
        string Code First_Js ' ' [class.property Js_Operator] ' ' Second_Js;
        my= Javascript Code;
    }
    method void Python_Generate
    {
        entity First [node [my Arguments] 0];
        entity Second [node [my Arguments] 1];
        integer Precedence [class.property Py_Precedence];
        string First_Py (. First Python_Atom Precedence);
        string Second_Py (. Second Python_Atom Precedence);
        string Code First_Py ' ' [class.property Py_Operator] ' ' Second_Py;
        my= Python Code;
    }
}
class String_Binary_Operation [is Operation]
{
    method void Mumps_Generate
    {
        entity First [node [my Arguments] 0];
        entity Second [node [my Arguments] 1];
        string First_M (. First M_Expression);
        string Second_M (. Second M_Atom);
        string Code First_M [class.property Mumps_Operator] Second_M;
        my= M_Expr Code;
    }
    method void Javascript_Generate
    {
        entity First [node [my Arguments] 0];
        entity Second [node [my Arguments] 1];
        integer Precedence [class.property Js_Precedence];
        string First_Js (. First Javascript_Atom Precedence);
        string Second_Js (. Second Javascript_Atom Precedence);
        string Code First_Js ' ' [class.property Js_Operator] ' ' Second_Js;
        my= Javascript Code;
    }
    method void Python_Generate
    {
        entity First [node [my Arguments] 0];
        entity Second [node [my Arguments] 1];
        integer Precedence [class.property Py_Precedence];
        string First_Py (. First Python_Atom Precedence);
        string Second_Py (. Second Python_Atom Precedence);
        if (not (isa First Quote)) {
            = First_Py (append 'str(' First_Py ')');
        }
        if (not (isa Second Quote)) {
            = Second_Py (append 'str(' Second_Py ')');
        }
        string Code First_Py ' ' [class.property Py_Operator] ' ' Second_Py;
        my= Python Code;
    }
}
class Invocation_Operation [is Operation];
class Unary_Operation [is Operation]
{
    argument First;
    method void Mumps_Generate
    {
        string First_M (. [my First] M_Atom);
        string Code [class.property Mumps_Operator] First_M;
        my= M_Atom Code;
    }
    method void Javascript_Generate
    {
        integer Precedence [class.property Js_Precedence];
        string First_Js (. [my First] Javascript_Atom Precedence);
        string Code [class.property Js_Operator] '(' First_Js ')';
        my= Javascript Code;
    }
    method void Python_Generate
    {
        integer Precedence [class.property Py_Precedence];
        string First_Py (. [my First] Python_Atom Precedence);
        string Code [class.property Py_Operator] ' ' First_Py;
        my= Python Code;
    }
}
class String_Unary_Operation [is Unary_Operation]
{
    argument First;
    method void Python_Generate
    {
        integer Precedence [class.property Py_Precedence];
        string First_Py (. [my First] Python_Atom Precedence);
        if (not (isa [my First] Quote)) 
        {
            debug;
            = First_Py (append 'str(' First_Py ')');
        }
        string Code [class.property Py_Operator] ' ' First_Py;
        my= Python Code;
    }
}
class Append_Args_Operation [is Repeating_Operation]
{
    method void Attributes
    {
        entity Argument;
        foreach [my Arguments] Argument
        {
            .= Argument Usge 'string';
        }
    }
}

class Noun_Syntax [is Syntax];
class Declare_Syntax [is Syntax]
{
    method void Python_Generate
    {
        string Code [my Variable Python];
        if (defined [my Value])
        {
            append Code ' = ' [my Value Python];
        }
        my= Python Code;
    }
    
    method void Javascript_Generate
    {
        string Code [my Variable Javascript];
        if (defined [my Value])
        {
            append Code ' = ' [my Value Javascript];
        }
        my= Javascript Code;
    }
}

comment 'Language.gal';

class Language
{
    class.property flag Verbose [false];
    class.property string Language_Name 'Language';
    class.property hash Languages;
    class.property string Generator_Name;
    class.method void Initialize
    {
        string Name [classprop Language_Name];
        comment `dict.assign [: Language Languages] Name [class.self]`;
    }
    method string Get [entity Element];
    method void Generate [entity Element];
}

gal.language Gal
{
    class.property flag Verbose [false];
    method string Get [entity Element]
    {
        returnif (defined [. Element Gal]) [. Element Gal];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Gal_Generate;
    }

    classmethod void Parse_Element [entity Element]
    {
        entity Token (list.get [. Element Tokens] 0);
        entity Next (list.get [. Element Tokens] 1);
        entity Parent Element;
        .= Parent Document Element;
        comment writeline 'Parent Equals Element: ' (. Parent To_String);
        entity Document Element;
        integer End (- (list.length [. Element Tokens]) 1);
        integer Position;
        string Comma_Mode 'unsupported';
        entity Child (: Factory Create_Element Token Next Document Parent Comma_Mode);
        list Stack;
        if [cp Verbose] { writeline "Gal_Parse push first child " (. Child To_String); }
        push Stack Child;
        = Parent Child;
        flag Comma [false];
        for.range Position 1 End
        {
            if [cp Verbose] { writeline ""; }
            = Token (list.get [. Element Tokens] Position);
            = Comma (isa Token Token_Comma);
            if [cp Verbose] { writeline "Parse Token " (. Token To_String) " with stack " (list.length Stack) ' comma ' Comma ' mode ' Comma_Mode; }
            comment writeline "Parse Token " (. Token To_String) " with stack " (list.length Stack) ' comma ' Comma ' mode ' Comma_Mode;
            if Child
            {
                integer Status (. Child Gal_Add_Token Token);
                if [cp Verbose] { writeline 
                    "    Element '" (. Child To_String) 
                    "' returned status '" Status 
                    "' on Token '" (. Token To_String) 
                    "' stack length " (list.length Stack) 
                    ' comma mode ' Comma_Mode;
                }
                if (= Status 0)
                {
                    if (and (isa Token Value_Token) (not [. Token Is_Verb]))
                    {
                        if [cp Verbose] { writeline "Appending value token to document body"; }
                        push [. Element Document_Body] Token;
                    }
                    continue;
                }
                if (less Status 0)
                {
                    integer Stack_Length (list.length Stack);
                    string Elem_String (. Child To_String);
                    if [cp Verbose] { writeline 
                        "Going to pop with " Stack_Length
                        " elements, element " Elem_String;
                    }
                    if (greater (list.length Stack) 0)
                    {
                        = Child (pop Stack);
                        if (greater (list.length Stack) 0)
                        {
                            = Parent (list.last Stack);
                            comment writeline 'Parent Stack Last: ' (. Parent To_String);
                        }
                        else
                        {
                            = Parent Element;
                            comment writeline 'Parent must equal Element: ' (. Parent To_String);
                            comment writeline 'Child was ' (. Child To_String);
                        }
                        if (isa Child Syntax)
                        {
                            = Comma_Mode 'syntax';
                        }
                        else.if (isa Child Operation)
                        {
                            = Comma_Mode 'operation';
                        }
                        else.if (isa Child Keyvalue)
                        {
                            = Comma_Mode 'keyvalue';
                        }
                        else
                        {
                            = Comma_Mode 'unsupported';
                        }
                        if (and (isa Child Statement)
                            (defined [. Child Block]))
                        {
                            push [. Element Document_Body] [. Child Block];
                        }
                        push [. Element Document_Body] Child;
                        if [cp Verbose] { writeline 'Adding element ' (. Child To_String) ' to parent ' (. Parent To_String); }
                        . Parent Gal_Add_Element Child;
                        if (greater (list.length Stack) 0)
                        {
                            = Child (list.last Stack);
                        }
                        else
                        {
                            = Child [null];
                            if [cp Verbose] { writeline "Stack empty, null element"; }
                        }
                    }
                    else
                    {
                        = Child [null];
                        = Parent Element;
                        if [cp Verbose] { writeline "Empty stack, element null"; }
                    }
                    continue.if (not Comma);
                }
                else
                {
                    if [cp Verbose] { writeline "Positive Status " Status " on Token " (. Token To_String) " in element " (. Element To_String) " stack length " (list.length Stack); }
                }
            }
            if (less Position End)
            {
                = Next (list.get [. Element Tokens] (+ Position 1));
            }
            else
            {
                = Next [null];
            }
            if (isa Token End_Token)
            {
                if [cp Verbose] { writeline "Detected End Token " (. Token To_String) " in element " (. Child To_String); }
            }
            = Child (: Factory Create_Element Token Next Document Parent Comma_Mode);
            push Stack Child;
            = Parent Child;
            if [cp Verbose] { writeline "Create/Push Element " (. Child To_String) " stack " (list.length Stack) " body elements " (list.length [. Element Document_Body]); }
        }
    }
}

gal.language Mumps
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Mumps]) [. Element Mumps];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Mumps_Generate;
    }
    method void Parse_Element [entity Element]
    {
    }
}

gal.language Fallback
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Fallback]) [. Element Fallback];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Fallback_Generate;
    }
    method void Parse_Element [entity Element]
    {
    }
}

gal.language Python
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Python]) [. Element Python];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Python_Generate;
    }
    method void Parse_Element [entity Element]
    {
    }
}

gal.language Javascript
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Javascript]) [. Element Javascript];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Javascript_Generate;
    }
    method void Parse_Element [entity Element]
    {
    }
}

gal.language Python_Fallback
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Python]) [. Element Python];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        comment 'Avoid causing undefined errors in parents.';
        my= Python '';
        forgive
        {
            . Element Python_Generate;
            .= Element Fallback [. Element Gal];
        }
    }
    method void Parse_Element [entity Element]
    {
    }
}

gal.language Javascript_Fallback
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Javascript]) [. Element Javascript];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        comment 'Avoid causing undefined errors in parents.';
        my= Javascript '';
        forgive
        {
            . Element Javascript_Generate;
            .= Element Fallback [. Element Gal];
        }
    }
    method void Parse_Element [entity Element]
    {
    }
}

gal.language Sql
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Sql]) [. Element Sql];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Sql_Generate;
    }
    method void Parse_Element [entity Element]
    {
    }
}

gal.language Debug
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Debug]) [. Element Debug];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Debug_Generate;
    }
}

gal.language Php
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Php]) [. Element Php];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Php_Generate;
    }
}

gal.language Java
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Java]) [. Element Java];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Java_Generate;
    }
}

gal.language Raku
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Raku]) [. Element Raku];
        return '<Undefined>';
    }
    method void Generate [entity Element]
    {
        . Element Raku_Generate;
    }
}

class Language_File [is Gal_File];

class Gal_Input [is Language_File]
{
    property entity Name;
    method void Tokenize
    {
        i Gal_Tokenize;
    }
    method void Parse
    {
        : Gal Parse_Element [me];
    }
}

class Gal_Output [is Language_File]
{
    method void Generate [entity Document]
    {
        entity This_Element;
        foreach [. Document Document_Body] This_Element
        {
            try
            {
                . This_Element Gal_Generate;
            }
            catch Error
            {
                comment 'debug;';
                string Input_Code (. This_Element Get_Input);
                writeline "error generating gal: " Error ' code: ' Input_Code;
                .= This_Element Error Error;
            }
        }
        . Document Gal_Generate;
    }
    method string Get [entity Element]
    {
        returnif (defined [. Element Gal]) [. Element Gal];
        return '';
    }
}

class Fallback_Output [is Language_File]
{
    method void Generate [entity Document]
    {
        entity.new Gal_Out Gal_Output;
        . Gal_Out Generate Document;
        entity This_Element;
        foreach [. Document Document_Body] This_Element
        {
            try
            {
                . This_Element Fallback_Generate;
            }
            catch Error
            {
                comment 'debug;';
                string Input_Code (. This_Element Get_Input);
                writeline "error generating fallback`: " Error ' code: ' Input_Code;
                .= This_Element Error Error;
            }
        }
        . Document Fallback_Generate;
    }
    method string Get [entity Element]
    {
        returnif (defined [. Element Fallback]) [. Element Fallback];
        return '';
    }

}
class Python_Output [is Language_File]
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Python]) [. Element Python];
        return '';
    }
    method void Generate [entity Document]
    {
        entity.new Gal_Out Gal_Output;
        . Gal_Out Generate Document;
        comment entity.new Fall_Out Fallback_Output;
        comment . Fall_Out Generate Document;
        entity This_Element;
        foreach [. Document Document_Body] This_Element
        {
            try
            {
                . This_Element Python_Generate;
            }
            catch Error
            {
                comment 'debug;';
                string Input_Code (. This_Element Get_Input);
                writeline "error generating python`: " Error ' code: ' Input_Code;
                .= This_Element Error Error;
            }
        }
        . Document Python_Generate;
    }
}
class Javascript_Output [is Language_File]
{
    method string Get [entity Element]
    {
        returnif (defined [. Element Javascript]) [. Element Javascript];
        return '';
    }
    method void Generate [entity Document]
    {
        entity.new Gal_Out Gal_Output;
        . Gal_Out Generate Document;
        comment entity.new Fall_Out Fallback_Output;
        comment . Fall_Out Generate Document;
        entity This_Element;
        foreach [. Document Document_Body] This_Element
        {
            try
            {
                . This_Element Javascript_Generate;
            }
            catch Error
            {
                comment 'debug;';
                string Input_Code (. This_Element Get_Input);
                writeline "error generating javascript`: " Error ' code: ' Input_Code;
                .= This_Element Error Error;
            }
        }
        . Document Javascript_Generate;
    }
}



comment 'Atomic_Operation.gal';

operation And and Repeating
{
    alias and & &&;
    class.property string Mumps_Operator '&';
    class.property integer Js_Precedence 6;
    class.property string Js_Operator '&&';
    class.property string Py_Operator 'and';
    class.property integer Py_Precedence 6;
    class.property string Php_Operator 'and';
    class.property integer Php_Precedence 6;
    method void Attributes
    {
        entity Argument;
        foreach [my Arguments] Argument
        {
            .= Argument Usage 'flag';
        }
    }
}

operation Add + Repeating
{
    alias add;
    class.property string Mumps_Operator '+';
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property integer Php_Precedence 6;
    class.property string Js_Operator '+';
    class.property string Py_Operator '+';
    class.property string Php_Operator '+';
    method void Attributes
    {
        entity Argument;
        foreach [my Arguments] Argument
        {
            .= Argument Usage 'number';
        }
    }
}

operation Append append Append_Args
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property integer Php_Precedence 6;
    class.property string Py_Operator ' + ';
    class.property string Js_Operator ' + ';
    class.property string Php_Operator ' + ';
    method void Attributes
    {
        entity Argument;
        foreach [my Arguments] Argument
        {
            .= Argument Usage 'string';
        }
    }
}
operation Call . Invocation
{
    alias call;
    argument Target 'value';
    argument Method 'method';
    python [my Target Python] '.' [my Method Python] '(' (i Python_Args ', ') ')';
    javascript [my Target Javascript] '.' [my Method Javascript] '(' (i Javascript_Args ', ') ')';
    comment php [my Target Php] '.' [my Method Php] '(' (i Php_Args ', ') ')';
}

operation Colon : Invocation
{
    alias cm classmethod class.method colon;
    argument Target 'class';
    argument Method 'method';
    python [my Target Python] '.' [my Method Python] '(' (i Python_Args ', ') ')';
    javascript [my Target Javascript] '.' [my Method Javascript] '(' (i Javascript_Args ', ') ')';
    comment php [my Target Php] '.' [my Method Php] '(' (i Php_Args ', ') ')';
}

operation Classpropget classpropget
{
    argument First;
    optional Second;
    method void Python_Generate
    {
        string Class_Name;
        string Property_Name;
        if (defined [my Second])
        {
            = Class_Name [my First Python];
            = Property_Name [my Second Python];
        }
        else
        {
            = Class_Name 'self.__class__';
            = Property_Name [my First Python];
        }
        string Code Class_Name '.' Property_Name;
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Class_Name;
        string Property_Name;
        if (defined [my Second])
        {
            = Class_Name [my First Javascript];
            = Property_Name [my Second Javascript];
        }
        else
        {
            = Class_Name 'this.constructor';
            if (and (defined [my Method_Context])
                    (isa [my Method_Context] Class_Method_Statement))
            {
                = Class_Name 'this';
            }
            = Property_Name [my First Javascript];
        }
        string Code Class_Name '.' Property_Name;
        my= Javascript Code;
    }
}
operation Contains contains Binary
{
    argument String;
    argument Search;
    python [my Search Python] ' in ' [my String Python];
    javascript [my String Javascript] '.includes(' [my Search Javascript] ')';
}

operation Defined defined Unary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;

    argument First;
    
    python [my First Python] ' is not None';
    javascript [my First Javascript] ' !== undefined';
}

operation Dictionary_Get dict.get
{
    alias key.get;
    argument Dictionary;
    argument Key;
    python [my Dictionary Python] '[' [my Key Python] ']';
    javascript [my Dictionary Javascript] '[' [my Key Javascript] ']';
}

operation Key_Exists key.exists
{
    alias dict.exists;
    argument Dictionary;
    argument Key;
    comment fallback '(defined [key ' [my Dictionary Fallback] ' ' [my Key Fallback] '])';
    python [my Key Python] ' in ' [my Dictionary Python] '.keys()';
    javascript [my Key Javascript] ' in ' [my Dictionary Javascript];
}

operation Divide / Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '/';
    class.property string Py_Operator '/';
}
operation Equal = Binary
{
    alias equal eq equals ==;
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '==';
    class.property string Py_Operator '==';
}
operation Greater greater Binary
{
    alias gt;
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '>';
    class.property string Py_Operator '>';
}
operation Greater_Equal ge Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '>=';
    class.property string Py_Operator '>=';
}
operation Http_Fetch http.fetch;
operation Isa isa Binary
{
    class.property integer Js_Precedence 6;
    argument Variable;
    argument Class_Name;
    javascript [my Variable Javascript] ' instanceof ' [my Class_Name Javascript];
    python 'isinstance(' [my Variable Python] ', ' [my Class_Name Python] ')';
}
operation Is_Null is.null
{
    argument Variable;
    javascript '(' [my Variable Javascript] ' === undefined || ' [my Variable Javascript] ' == "")';
    python '(' [my Variable Python] ' in (None, ""))';
}

operation Less less Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '<';
    class.property string Py_Operator '<';
}
operation Less_Equal le Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '<=';
    class.property string Py_Operator '<=';
}
operation List_Get list.get
{
    argument List;
    argument Node;
    method void Python_Generate
    {
        if (not (defined [my List Python]))
        {
            error (i Failure_Message 'List Python missing');
        }
        if (not (defined [my Node Python]))
        {
            error (i Failure_Message 'Node Python missing');
        }
        string Code [my List Python] '[' [my Node Python] ']';
        my= Python Code;
    }
    method void Javascript_Generate
    {
        if (not (defined [my List Javascript]))
        {
            error (i Failure_Message 'List Javascript missing');
        }
        if (not (defined [my Node Javascript]))
        {
            error (i Failure_Message 'Node Javascript missing');
        }
        string Code [my List Javascript] '[' [my Node Javascript] ']';
        my= Javascript Code;
    }
}
operation List_Last list.last Unary
{
    argument First;
    method void Python_Generate
    {
        if (not (defined [my First Python]))
        {
            error (i Failure_Message 'List Python missing');
        }
        string Code [my First Python] '[-1]';
        my= Python Code;
    }
    method void Javascript_Generate
    {
        if (not (defined [my First Javascript]))
        {
            error (i Failure_Message 'List Javascript missing');
        }
        string Code [my First Javascript] '[' [my First Javascript] '.length-1]';
        my= Javascript Code;
    }
}
operation List_Length list.length Unary
{
    argument First;
    python 'len(' [my First Python] ')';
    javascript [my First Javascript] '.length';
}
operation List_Pop pop Unary
{
    alias list.pop;
    argument First;
    python [my First Python] '.pop()';
    javascript [my First Javascript] '.pop()';
}
operation List_Shift shift Unary
{
    alias list.shift;
    argument First;
    python [my First Python] '.pop(0)';
    javascript [my First Javascript] '.shift()';
}
operation List_Split split Binary
{
    alias list.split;
    argument String;
    argument Delimiter;
    javascript [my String Javascript] '.split(' [my Delimiter Javascript] ')';
    python [my String Python] '.split(' [my Delimiter Python] ')';
}
operation Lowercase lowercase Unary
{
    argument First;
    python [my First Python] '.lower()';
    javascript [my First Javascript] '.toLowerCase()';
}

operation Is_Lowercase islower Unary
{
    alias is.lower is.lowercase;
    argument First;
    python [my First Python] '.islower)';
    javascript [my First Javascript] '.match(/[a-z]/)';
}

operation Is_Alpha isalpha Unary
{
    alias is.lower is.lowercase;
    argument First;
    python [my First Python] '.isalpha()';
    javascript [my First Javascript] '.match(/[a-zA-Z]/)';
}


operation Multiply * Repeating
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '*';
    class.property string Py_Operator '*';
}
operation New new Invocation
{
    argument Class_Name;
    python [my Class_Name Python] '(' (i Python_Args ', ') ')';
    javascript 'new ' [my Class_Name Javascript] '(' (i Javascript_Args ', ') ')';
}
operation Not not Unary
{
    argument First;
    alias !;
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '!';
    class.property string Py_Operator 'not';
}
operation Not_Equal != Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '!=';
    class.property string Py_Operator '!=';
}

operation Not_Null not.null
{
    argument Variable;
    javascript '(' [my Variable Javascript] ' !== undefined && ' [my Variable Javascript] ' > "")';
    python [my Variable Python] ' > ""';
}

operation Or or Repeating
{
    alias |;
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '||';
    class.property string Py_Operator 'or';
}

operation Round round
{
    argument Number;
    argument Decimals;
    python 'round(' [my Number Python] ', ' [my Decimals Python] ')';
    javascript [my Number Javascript] '.toFixed(' [my Decimals Javascript] ')';
}

operation Sql_Escape sql.escape Unary
{
    argument First;
}
operation Sql_Query sql.query Unary
{
    argument First;
}
operation String string Unary
{
    argument First;
}
operation String_Equal s= String_Binary
{
    alias string.eq;
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '==';
    class.property string Py_Operator '==';
}
operation String_Greater string.gt String_Binary
{
    alias string.gt;
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '>';
    class.property string Py_Operator '>';
}
operation String_Greater_Equal string.ge String_Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '>=';
    class.property string Py_Operator '>=';
}
operation String_Length string.length String_Unary
{
    argument First;
    alias length;
    python 'len(' [my First Python] ')';
    javascript [my First Javascript] '.length';
}
operation String_Less string.lt String_Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '<';
    class.property string Py_Operator '<';
}
operation String_Less_Equal string.le String_Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '<=';
    class.property string Py_Operator '<=';
}
operation String_Not_Equal string.ne String_Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '!=';
    class.property string Py_Operator '!=';
}
operation Substring substring
{
    argument String_Value;
    argument Start_Index;
    optional Length;
    method void Javascript_Generate
    {
        string Code [my String_Value Javascript] '.substr(' [my Start_Index Javascript];
        if (defined [my Length])
        {
            append Code ', ' [my Length Javascript];
        }
        append Code ')';
        my= Javascript Code;
    }
    method void Python_Generate
    {
        string SVal [my String_Value Python];
        string Start [my Start_Index Python];
        string Code;
        if (defined [my Length])
        {
            string Len [my Length Python];
            if (string.eq Len '1')
            {
                = Code (append SVal '[' Start ']');
            }
            else
            {
                = Code (append SVal '[' Start ':(' Start ')+(' Len ')]');
            }
        }
        else
        {
            = Code (append SVal '[' Start ':]');
        }
        my= Python Code;
    }
}
operation Subtract - Binary
{
    class.property integer Js_Precedence 6;
    class.property integer Py_Precedence 6;
    class.property string Js_Operator '-';
    class.property string Py_Operator '-';
}

operation Time_String time.string
{
	python 'datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")';
	javascript '(new Date().toISOString())';
}

operation Uppercase uppercase Unary
{
    argument First;
    python [my First Python] '.upper()';
    javascript [my First Javascript] '.toUpperCase()';
}

operation Is_Uppercase isupper Unary
{
    alias is.upper is.uppercase;
    argument First;
    python [my First Python] '.isupper()';
    javascript [my First Javascript] '.match(/[A-Z]/)';
}

operation We we Invocation
{
    argument Method;
    python 'self.__class__.' [my Method Python] '(' (i Python_Args ', ') ')';
    method void Javascript_Generate
    {
        string Class_Name 'this.constructor';
        if (and (defined [my Method_Context])
                (isa [my Method_Context] Class_Method_Statement))
        {
            = Class_Name 'this';
        }
        string Code Class_Name '.' [my Method Javascript] '(' (i Javascript_Args ', ') ')';
        my= Javascript Code;
    }
}

operation Whitespace whitespace Unary
{
    argument First;
    javascript '!' [my First Javascript] '.match(/\S/)';
    python 'not(re.match(r"\S",' [my First Python] '))';
}
syntax Is is
{
    method void Attributes
    {
        my= Superclass (list.shift [my Listargs]);
        comment writeline 'IS ToString: ' (i To_String);
        comment writeline 'Parent ToString: ' (. [my Parent] To_String);
        .= [my Parent] Base_Class [true];
    }
    argument Superclass;
    python '(' [my Superclass Python] ')';
    javascript ' extends ' [my Superclass Javascript];
}
syntax Dot .
{
    python (i Python_Arguments '.');
    javascript (i Javascript_Arguments '.');
}
syntax Colon :
{
    python (i Python_Arguments '.');
    javascript (i Javascript_Arguments '.');
}

syntax Key key
{
    argument Dictionary;
    argument Key;
    python [my Dictionary Python] '[' [my Key Python] ']';
    javascript [my Dictionary Javascript] '[' [my Key Javascript] ']';
}

syntax Node node
{
    argument List;
    argument Node;
    python [my List Python] '[' [my Node Python] ']';
    javascript [my List Javascript] '[' [my Node Javascript] ']';
}

syntax Line line
{
    optional Count;
    method void Python_Generate
    {
        string Code "'\n'";
        if (defined [my Count])
        {
            append Code '*' [my Count Python];
        }
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code '"\n"';
        if (defined [my Count])
        {
            append Code '.repeat(' [my Count Javascript] ')';
        }
        my= Javascript Code;
    }
}

syntax Tab tab
{
    optional Count;
    method void Python_Generate
    {
        string Code '"\t"';
        if (defined [my Count])
        {
            append Code '*' [my Count Python];
        }
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code '"\t"';
        if (defined [my Count])
        {
            append Code '.repeat(' [my Count Javascript] ')';
        }
        my= Javascript Code;
    }
}

syntax Backslash backslash
{
    optional Count;
    method void Python_Generate
    {
        string Code "gal.backslash(";
        if (defined [my Count])
        {
            append Code [my Count Python];
        }
        append Code ')';
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code "gal.backslash(";
        if (defined [my Count])
        {
            append Code [my Count Javascript];
        }
        append Code ')';
        my= Javascript Code;
    }
}

syntax Indent indent
{
    optional Count;
    method void Python_Generate
    {
        string Code '"    "';
        if (defined [my Count])
        {
            append Code '*' [my Count Python];
        }
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code '"    "';
        if (defined [my Count])
        {
            append Code '.repeat(' [my Count Javascript] ')';
        }
        my= Javascript Code;
    }
}
syntax String string Declare
{
    argument Variable;
    optional Value;
}
syntax Number number Declare
{
    argument Variable;
    optional Value;
}
syntax Integer integer Declare
{
    argument Variable;
    optional Value;
}
syntax Entity entity Declare
{
    argument Variable;
    optional Value;
}
syntax Variant variant Declare
{
    argument Variable;
    optional Value;
}
syntax Flag flag Declare
{
    argument Variable;
    optional Value;
}
syntax Dictionary dictionary Declare
{
    argument Variable;
    optional Value;
}
syntax List list Declare
{
    argument Variable;
    optional Value;
}

syntax Class class
{
    optional Expression;
    method void Fallback_Generate
    {
        string Target 'our';
        if (defined [my Expression])
        {
            = Target (append ': ' [my Expression Fallback]);
        }
        string Code '[' Target ' Global]';
    }
    method void Python_Generate
    {
        string Entity 'self.__class__';
        if (defined [my Method_Context])
        {
            if (isa [my Method_Context] Class_Method_Statement)
            {
                = Entity 'cls';
            }
        }
        if (defined [my Expression])
        {
            = Entity (append [my Expression Python] '.__class__');
        }
        string Code Entity;
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Code '.' [. Argument Python];
        }
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Entity 'this';
        if (defined [my Expression])
        {
            = Entity [my Expression Javascript];
        }
        string Code Entity '.constructor';
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Code '.' [. Argument Javascript];
        }
        my= Javascript Code;
    }
}

syntax My_Class my.class
{
    alias self.class me.class us;
    python 'self.__class__';
    javascript 'this.constructor';
}

syntax Class_Name class.name
{
    optional Entity;
    method void Python_Generate
    {
        string Entity_Code 'self';
        if (defined [my Entity])
        {
            = Entity_Code (. [my Entity] Python_Atom 99);
        }
        string Code Entity_Code '.__class__.__name__';
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Entity_Code 'this';
        if (defined [my Entity])
        {
            = Entity_Code (. [my Entity] Javascript_Atom 99);
        }
        string Code Entity_Code '.constructor.name';
        my= Javascript Code;
    }
}

syntax Class_Property class.property
{
    argument First;
    optional Second;
    method void Python_Generate
    {
        string Class_Name;
        string Property_Name;
        if (defined [my Second])
        {
            = Class_Name [my First Python];
            = Property_Name [my Second Python];
        }
        else
        {
            comment writeline '************ debug this here *******************';
            if (not (defined [my Method_Context]))
            {
                debug;
                error 'No Method Context in class property ' [my First Python];
            }
            entity Context [my Method_Context];
            comment dv '$Context';
            = Class_Name [. Context Python_Class];
            comment dv '$Class_Name';
            = Property_Name [my First Python];
        }
        string Code Class_Name '.' Property_Name;
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Class_Name;
        string Property_Name;
        if (defined [my Second])
        {
            = Class_Name [my First Javascript];
            = Property_Name [my Second Javascript];
        }
        else
        {
            = Class_Name 'this.constructor';
            if (and (defined [my Method_Context])
                    (isa [my Method_Context] Class_Method_Statement))
            {
                = Class_Name 'this';
            }
            = Property_Name [my First Javascript];
        }
        string Code Class_Name '.' Property_Name;
        my= Javascript Code;
    }
}

syntax True true Noun
{
    python 'True';
    javascript 'true';
    mumps '1';
}

syntax False false Noun
{
    python 'False';
    javascript 'false';
    mumps '0';
}

syntax Null null Noun
{
    python 'None';
    javascript 'undefined';
    mumps '""';
}

syntax Infinity infinity
{
    python "float('inf')";
    javascript 'Infinity';
}

syntax Negative_Infinity -infinity
{
    python "-float('inf')";
    javascript 'Number.NEGATIVE_INFINITY';
}
comment 'Atomic_Statement_AK.gal';

statement Add add Line
{
    argument Variable;
    python [my Variable Python] ' += ' (i Python_Args ' + ') [line];
    javascript [my Variable Javascript] ' += ' (i Javascript_Args ' + ') ';' [line];
}

statement Append append Append_Args
{
    alias string.append;
    argument Variable;
    python [my Variable Python] ' += ' (i Python_String_Args ' + ') [line];
    javascript [my Variable Javascript] ' += ' (i Javascript_Args ' + ') ';' [line];
}

statement Assign = Scoped
{
    argument Variable;
    argument Value;
    method void Attributes
    {
        my= Variable (shift [my Listargs]);
        my= Value (shift [my Listargs]);
        if (greater (list.length [my Listargs]) 0)
        {
            string Message "Too many arguments: 2 expected";
            my= Error Message;
            error Message;
        }
    }
    mumps ' set ' [my Variable Mumps] '=' [my Value Mumps, line];
    javascript [my Variable Javascript] ' = ' [my Value Javascript] ';' [line];
    method void Python_Generate
    {
        if (not (defined [my Variable Python])) 
        {
            error (i Failure_Message 'missing Variable Python');
        }
        if (not (defined [my Value Python])) 
        {
            error (i Failure_Message 'missing Value Python');
        }
        string Code [my Variable Python] ' = ' [my Value Python] [line];
        my= Python Code;
    }
}

statement Break break Line
{
    python 'break' [line];
    javascript 'break;' [line];
}
statement Call . Invocation
{
    argument Target;
    argument Method;
    python [my Target Python] '.' [my Method Python] '(' (i Python_Args ', ') ')' [line];
    javascript [my Target Javascript] '.' [my Method Javascript] '(' (i Javascript_Args ', ') ');' [line];
}
statement Colon : Invocation
{
    alias c.;
    argument Target;
    argument Method;
    python [my Target Python] '.' [my Method Python] '(' (i Python_Args ', ') ')' [line];
    javascript [my Target Javascript] '.' [my Method Javascript] '(' (i Javascript_Args ', ') ');' [line];
}
statement Catch catch Scoped
{
    optional Variable;
    method void Python_Generate
    {
        string Code 'except Exception';
        if (defined [my Variable])
        {
            append Code ' as ' [my Variable Python];
        }
        append Code (i Python_Block);
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code 'catch';
        if (defined [my Variable])
        {
            append Code ' (' [my Variable Javascript] ')';
        }
        append Code (i Javascript_Block);
        my= Javascript Code;
    }
}

statement Continue continue Line
{
    python 'continue' [line];
    javascript 'continue;' [line];
}

statement Class_Method class.method Class_Method
{
    argument Return_Type;
    argument Method_Name;
    property string Python_Class 'cls';
    property string Method_Signature;
    method void Attributes
    {
        comment writeline 'Class Method attributes';
        my= Return_Type (shift [my Listargs]);
        my= Method_Name (shift [my Listargs]);
        my= Method_Context [self];
        string Header 'class.method';
        entity Argument;
        foreach [my Arguments] Argument
        {
            comment "The arguments must be consistent, because we need to know the header before generation begins.";
            append Header ' ' (. Argument Get_Input);
        }
        my= Method_Signature Header;
        comment writeline 'Saved class method header: ' Header;
    }
    method void Python_Generate
    {
        string Code '@classmethod' [line] 'def ' [my Method_Name Python] '(cls';
        string Args (i Python_Args ', ');
        if (string.gt Args '')
        {
            append Code ', ' Args;
        }
        append Code ')' (i Python_Block);
        my= Python Code;
    }
    javascript 'static ' [my Method_Name Javascript] '(' (i Javascript_Args ', ') ')' 
        (i Javascript_Block);
}

statement Class_Property class.property Class_Property
{
    argument Data_Type;
    argument Property_Name;
    optional Value;
    method void Python_Generate
    {
        string Name_Code [my Property_Name Python];
        string Value_Code 'None';
        string DT [my Data_Type Input];
        = DT (append ' ' DT ' ');
        if (contains ' dict dictionary hash ' DT)
        {
            = Value_Code '{}';
        }
        else.if (contains ' list array ' DT)
        {
            = Value_Code '[]';
        }
        if (defined [my Value])
        {
            = Value_Code [my Value Python];
        }
        string Code Name_Code ' = ' Value_Code [line];
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Name_Code [my Property_Name Javascript];
        string Value_Code 'undefined';
        string DT [my Data_Type Input];
        = DT (append ' ' DT ' ');
        if (contains ' dict dictionary hash ' DT)
        {
            = Value_Code '{}';
        }
        else.if (contains ' list array ' DT)
        {
            = Value_Code '[]';
        }
        if (defined [my Value])
        {
            = Value_Code [my Value Javascript];
        }
        string Code 'static ' Name_Code ' = ' Value_Code ';' [line];
        my= Javascript Code;
    }
}

statement Comment comment Comment
{
    fallback 'comment ' (i Enquote (i Argument_String)) ';';
    method void Python_Generate
    {
        string Code '';
        string Arg (i Get_Input);
        list.copy Lines (split Arg [line]);
        foreach Lines Arg
        {
            append Code '# ' Arg [line];
        }
        my= Python Code;
    }
    javascript '/* ' (i Get_Input) ' */' [line];
}

statement Constructor constructor Constructor
{
    method void Python_Generate
    {
        string Code 'def __init__(self';
        string Args (i Python_Args ', ');
        if (string.gt Args '')
        {
            append Code ', ' Args;
        }
        append Code '):' [line, indent]
            'super().__init__()' [line];
        if [my Parent Generate_Constructor]
        {
            append Code [indent] 'self.propinit()' [line];
        }
        append Code (i Python_Statements);
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Code 'constructor(';
        string Args (i Javascript_Args ', ');
        if (string.gt Args '')
        {
            append Code Args;
        }
        append Code ') {' [line, indent]
            'super();' [line];
        if [my Parent Generate_Constructor]
        {
            append Code [indent] 'this.propinit();' [line];
        }
        append Code (i Javascript_Statements) '}' [line];
        my= Javascript Code;
    }
}

statement Debug debug Line
{
    python 'zdebug.zbreak()' [line];
    javascript 'debugger;' [line];
}
statement Debug_If debugif Line
{
    python 'if ' (i Python_Args) ':' [line, indent] 'zdebug.zbreak()' [line];
    javascript 'if ' (i Javascript_Args) [line] '{' [line, indent] 'debugger;' [line] '}' [line];
}
statement Debug_Stack debug.stack Line;
statement Debug_Variable debug.variable Line
{
    method void Python_Generate
    {
        string Code "";
        entity Argument;
        foreach [my Arguments] Argument
        {
            string Arg_Name [. Argument Python];
            append Code 'try:' [line, indent]
                    'print("' Arg_Name ':", ' Arg_Name ');' [line]
                'except Exception:' [line, indent]
                    'print("' Arg_Name ':", "<ERROR>")' [line];
            my= Python Code;
        }
    }
    method void Javascript_Generate
    {
        string Code "";
        entity Argument;
        foreach [my Arguments] Argument
        {
            string Arg_Name [. Argument Javascript];
            append Code 'try {' [line, indent]
                    'console.log("' Arg_Name ':", ' Arg_Name ');' [line]
                '}' [line]
                'catch {' [line, indent]
                    'console.log("' Arg_Name ':", "<ERROR>");' [line]
                '}' [line];
            my= Javascript Code;
        }
    }
}

statement Dictionary dict Scoped
{
    argument Variable;
    method void Python_Generate
    {
        string Variable_Code [my Variable Python];
        string Value_Code "";
        string Between '';
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Value_Code Between [. Argument Python];
            = Between ', ';
        }
        string Code Variable_Code ' = {' Value_Code '}' [line];
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Variable_Code [my Variable Javascript];
        string Value_Code "";
        string Between '';
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Value_Code Between [. Argument Javascript];
            = Between ', ';
        }
        string Code 'var ' Variable_Code '= {' Value_Code '};' [line];
        my= Javascript Code;
    }
}

statement Dictionary_Assign dict.= Scoped
{
    argument Variable;
    argument Key;
    argument Value;
    python [my Variable Python] '[' [my Key Python] '] = ' [my Value Python] ';' [line];
    javascript [my Variable Javascript] '[' [my Key Javascript] '] = ' [my Value Javascript] ';' [line];
}

statement Else else If
{
    python 'else' (i Python_Block);
    javascript 'else' (i Javascript_Block);
}
statement Else_If else.if If
{
    argument Condition;
    python 'elif ' [my Condition Python] (i Python_Block);
    javascript 'else if (' [my Condition Javascript] ')' (i Javascript_Block);
}
statement Entity entity Declare
{
    argument Variable;
    optional Value;
}
statement Error error Append_Args
{
    python 'raise Exception(' (i Python_String_Args ' + ') ')' [line];
    javascript 'throw ' (i Javascript_Args ' + ') ';' [line];
}

statement File_Append file.append Line
{
	argument File_Name;
	argument Appended_Text;
	python 'gal.file_append(' [my File_Name Python] ',' [my Appended_Text Python] ')' [line];
	javascript 'gal.file_append(' [my File_Name Javascript] ',' [my Appended_Text Javascript] ');' [line];
}

statement File_Readall file.readall Line
{
    argument Variable;
    argument File_Name;
    python 
        '_FH = open(' [my File_Name Python] ', "r")' [line]
        [my Variable Python] ' = _FH.read()' [line]
        '_FH.close()' [line];

    method void Javascript_Generate
    {
        string Varname [my Variable Javascript];
        string File_Name [my File_Name Javascript];
        string Code Varname ' = gal.file_reader.readFileSync(' File_Name ",'utf8');" [line];
        my= Javascript Code;
    }
}

statement File_Dump file.dump Line
{
    argument File_Text;
    argument File_Name;
    python 
        '_FH = open(' [my File_Name Python] ', "w")' [line]
        '_FH.write(' [my File_Text Python] ')' [line]
        '_FH.close()' [line];
    javascript
        'gal.file_reader.writeFileSync(' [my File_Name Javascript] ', ' [my File_Text Javascript] ');' [line];
}

statement Flag flag Declare
{
    argument Variable;
    optional Value;
}

statement Foreach foreach Scoped
{
    argument List;
    argument Variable;
    python 'for ' [my Variable Python] ' in ' [my List Python] (i Python_Block);
    javascript 'for (' [my Variable Javascript] ' of ' [my List Javascript] ')' (i Javascript_Block);
}

statement Forever forever Scoped
{
    python 'while True' (i Python_Block);
    javascript 'while (true)' (i Javascript_Block);
}

statement Forgive forgive Scoped
{
    python 'try' (i Python_Block) 'except Exception:' [line, indent] 'pass' [line];
    javascript 'try' (i Javascript_Block) 'catch { } ' [line];
}

statement Forward forward Line
{
    argument Name;
    python '# forward ' [my Name Python] [line];
    javascript '// forward ' [my Name Javascript] [line];
}

statement For_Range for.range For
{
    argument Variable;
    argument Start_Index;
    argument End_Index;

    method void Python_Generate
    {
        if (not (defined [my Variable Python]))
        {
            error (i Failure_Message 'Variable Python not defined');
        }
        if (not (defined [my Start_Index Python]))
        {
            error (i Failure_Message 'Start Index Python not defined');
        }
        if (not (defined [my End_Index Python]))
        {
            error (i Failure_Message 'End Index Python not defined');
        }
        string Code 'for ' [my Variable Python] ' in range(' [my Start_Index Python] ', ' [my End_Index Python] '+1)'
            (i Python_Block);
        my= Python Code;
    }
    method void Javascript_Generate
    {
        if (not (defined [my Variable Javascript]))
        {
            error (i Failure_Message 'Variable Javascript not defined');
        }
        if (not (defined [my Start_Index Javascript]))
        {
            error (i Failure_Message 'Start Index Javascript not defined');
        }
        if (not (defined [my End_Index Javascript]))
        {
            error (i Failure_Message 'End Index Javascript not defined');
        }
        string Code 'for (' 
            [my Variable Javascript] '=' [my Start_Index Javascript] '; ' 
            [my Variable Javascript] '<=' [my End_Index Javascript] '; '
            [my Variable Javascript] '++)'
            (i Javascript_Block);
        my= Javascript Code;
    }
}

statement Increment increment
{
    argument Numeric;
    comment `python [my Numeric Python] ' += 1' [line];`;
    method void Python_Generate
    {
        string Python_Code [my Numeric Python] " += 1" [line];
        my= Python Python_Code;
    }
    method void Javascript_Generate
    {
        string Javascript_Code [my Numeric Javascript] "++;" [line];
        my= Javascript Javascript_Code;
    }
}

statement And and
{
    argument Flag;
    argument Value;
    method void Python_Generate
    {
        string Python_Code [my Flag Python] " &= "  [my Value Python, line];
        my= Python Python_Code;
    }
    method void Javascript_Generate
    {
        string Javascript_Code [my Flag Javascript] " &= "  [my Value Javascript] ';' [line];
        my= Javascript Javascript_Code;
    }
}

statement If if If
{
    argument Condition;
    python 'if ' [my Condition Python] (i Python_Block);
    javascript 'if (' [my Condition Javascript] ')' (i Javascript_Block);
}

statement Iterate iterate Scoped
{
    argument Dictionary;
    argument Key_Variable;
    argument Value_Variable;
    python 'for ' [my Key_Variable Python] ', ' [my Value_Variable Python] ' in ' [my Dictionary Python] (i Python_Block);
    javascript 'for ([' [my Key_Variable Javascript] ', ' [my Value_Variable Javascript] '] of Object.entries(' [my Dictionary Javascript] '))' (i Javascript_Block);
}

statement Integer integer Declare
{
    argument Variable;
    optional Value;
}

statement Join join Assign
{
    argument Variable;
    argument List;
    argument Delimiter;
    comment python [my Variable Python] ' = ' [my List Python] '.join(' [my Delimiter Python] ')' [line];
    python [my Variable Python] ' = ' [my Delimiter Python] '.join(' [my List Python] ')' [line];
    javascript [my Variable Javascript] ' = ' [my List Javascript] '.join(' [my Delimiter Javascript] ');' [line];
}

statement Know know Line;
comment 'Atomic_Statement_LZ.gal';

class Statement_List [is Declare_Statement]
{
    class.property string Gal_Keyword 'list';
    class.property string Gs_Keyword 'list';
    property entity Variable;
    method void Attributes
    {
        my= Variable (shift [my Listargs]);
    }
    method void Python_Generate 
    {
        string Variable [my Variable Python];
        string Args (i Python_Args ', ');
        string Code Variable ' = [' Args ']' [line];
        my= Python Code;
    }
    method void Javascript_Generate 
    {
        string Variable [my Variable Javascript];
        string Args (i Javascript_Args ', ');
        string Code 'var ' Variable ' = [' Args '];' [line];
        my= Javascript Code;
    }
}

class Statement_List_Copy [is Declare_Statement]
{
    class.property string Gal_Keyword 'list.copy';
    class.property string Gs_Keyword 'list.copy';
    property entity Variable;
    property entity Value;
    method void Attributes
    {
        my= Variable (shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Value (shift [my Listargs]);
        }
    }
    method void Python_Generate 
    {
        string Variable [my Variable Python];
        string Value '[]';
        if (defined [my Value])
        {
            = Value [my Value Python];
        }
        string Code Variable ' = ' Value [line];
        my= Python Code;
    }
    method void Javascript_Generate 
    {
        string Variable [my Variable Javascript];
        string Value '[]';
        if (defined [my Value])
        {
            = Value [my Value Javascript];
        }
        string Code 'var ' Variable ' = ' Value ';' [line];
        my= Javascript Code;
    }
}

statement List_Append push Append_Args
{
    argument List;
    alias list.push list.append;
    python [my List Python] '.extend([' (i Python_Args ', ') '])' [line];
    javascript [my List Javascript] '.push(' (i Javascript_Args ', ') ');' [line];
}

statement List_Delete list.delete Line
{
    alias list.remove list.splice;
    argument List;
    argument Index;
    argument Count;
    python 'del ' [my List Python] '[' [my Index Python] ':' [my Index Python] '+' [my Count Python] ']' [line];
    javascript [my List Javascript] '.splice(' [my Index Javascript] ', ' [my Count Javascript] ');' [line];
}

statement Main main Method
{
    property hash Signatures;
    property string Python_Class '__foobar__';
    method void Python_Generate
    {
        string Code "if __name__ == '__main__'";
        if (greater (list.length [my Listargs]) 0)
        {
            append Code ':' [line, indent]
                '(' (i Python_Args ', ') ') = sys.argv[1:]' [line];
            append Code (i Python_Statements);
        }
        else
        {
            append Code (i Python_Block);
        }
        my= Python Code;
    }

    method void Javascript_Generate
    {
        string Args_Code 'let [_node, _code, ' (i Javascript_Args ', ') '] = process.argv;' [line];
        entity Statement;
        string Statements_Code '';
        foreach [my Block Statements] Statement
        {
            append Statements_Code [. Statement Javascript];
        }
        string Code '/* Main Program Body */' [line]
            Args_Code
            Statements_Code [line];
        my= Javascript Code;
    }
    
    mumps 'main ; main entry point' [line]
        [my Block Mumps]
        [indent] 'quit' [line];
}

statement Method method Method
{
    argument Return_Type;
    argument Method_Name;
    property string Python_Class 'self.__class__';
    method void Attributes
    {
        my= Return_Type (shift [my Listargs]);
        my= Method_Name (shift [my Listargs]);
        my= Method_Context [self];
    }
    method void Python_Generate
    {
        string Code 'def ' [my Method_Name Python] '(self';
        string Args (i Python_Args ', ');
        string Block (i Python_Block);
        if (string.gt Args '')
        {
            append Code ', ' Args;
        }
        append Code ')' Block;
        my= Python Code;
    }
    javascript [my Method_Name Javascript] '(' (i Javascript_Args ', ') ')' 
        (i Javascript_Block);
}

statement Module module Line;

statement Number number Declare
{
    argument Variable;
    optional Value;
}

statement Property property Property
{
    argument Data_Type;
    argument Property_Name;
    optional Value;
    method void Python_Generate
    {
        string Name_Code [my Property_Name Python];
        string Value_Code 'None';
        string DT [my Data_Type Input];
        = DT (append ' ' DT ' ');
        if (contains ' dict dictionary hash ' DT)
        {
            = Value_Code '{}';
        }
        else.if (contains ' list array ' DT)
        {
            = Value_Code '[]';
        }
        comment writeline "property before defined";
        if (defined [my Value])
        {
            = Value_Code [my Value Python];
        }
        comment writeline "property after defined";
        string Code 'self.' Name_Code ' = ' Value_Code [line];
        comment writeline "Property Code " Code;
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Name_Code [my Property_Name Javascript];
        string Value_Code 'undefined';
        string DT [my Data_Type Input];
        = DT (append ' ' DT ' ');
        if (contains ' dict dictionary hash ' DT)
        {
            = Value_Code '{}';
        }
        else.if (contains ' list array ' DT)
        {
            = Value_Code '[]';
        }
        if (defined [my Value])
        {
            = Value_Code [my Value Javascript];
        }
        string Code 'this.' Name_Code ' = ' Value_Code ';' [line];
        my= Javascript Code;
    }
}

statement Propset .= Assign
{
    argument Target;
    argument Property;
    argument Expression;
    python [my Target Python] '.' [my Property Python] ' = ' [my Expression Python] [line];
    javascript [my Target Javascript] '.' [my Property Javascript] ' = ' [my Expression Javascript] ';' [line];
}

statement Classpropset := Assign
{
    argument Target;
    argument Property;
    argument Expression;
    python [my Target Python] '.' [my Property Python] ' = ' [my Expression Python] [line];
    javascript [my Target Javascript] '.' [my Property Javascript] ' = ' [my Expression Javascript] ';' [line];
}

statement Our_Equal our= Assign
{
    alias our.= us= us.= ours= ours.=;
    argument Property;
    argument Expression;
    python 'cls.' [my Property Python] ' = ' [my Expression Python] [line];
    todo 'javascript context this.prototype vs this';
    javascript 'this.' [my Property Javascript] ' = ' [my Expression Javascript] ';' [line];
}

statement Read_Line readline Read
{
	method void Python_Generate
	{
		entity Argument;
		string Argument_Python;
		string Code '';
		foreach [my Arguments] Argument
		{
			= Argument_Python [. Argument Python];
			if (isa Argument Quote)
			{
			}
			if (isa Argument Token_Name)
			{
				append Code Argument_Python ' = input()' [line];
			}
			else
			{
				append Code "print(" Argument_Python ",sep='',end='')" [line];
			}
		}
		my= Python Code;
	}	
	method void Javascript_Generate
	{
		entity Argument;
		string Argument_Javascript;
		string Code '';
		foreach [my Arguments] Argument
		{
			= Argument_Javascript [. Argument Javascript];
			if (isa Argument Quote)
			{
			}
			if (isa Argument Token_Name)
			{
				append Code Argument_Javascript ' = console.input();' [line];
			}
			else
			{
				append Code 'console.log(' Argument_Javascript ');' [line];
			}
		}
		my= Python Code;
	}	
}

statement Replace replace Line
{
    argument Variable;
    argument Search_Text;
    argument Replace_Text;
    python [my Variable Python] ' = ' [my Variable Python] '.replace(' [my Search_Text Python] ', ' [my Replace_Text Python] ')' [line];
    javascript [my Variable Javascript] ' = ' [my Variable Javascript] '.replaceAll(' [my Search_Text Javascript] ', ' [my Replace_Text Javascript] ');' [line];
}

statement Return return Line
{
    optional Value;
    method void Python_Generate
    {
        string Value_Python '';
        if (defined [my Value])
        {
            append Value_Python ' ' [my Value Python];
        }
        string Code 'return' Value_Python [line];
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Value_Javascript '';
        if (defined [my Value])
        {
            append Value_Javascript ' ' [my Value Javascript];
        }
        string Code 'return' Value_Javascript ';' [line];
        my= Javascript Code;
    }
}

statement Sort sort Line
{
    argument List;
    optional Method;
}

statement String string Append_Args
{
    property entity Variable;
    method void Attributes
    {
        my= Variable (shift [my Listargs]);
        .= [my Variable] Usage 'variable';
        entity Argument;
        foreach [my Listargs] Argument
        {
            .= Argument Usage 'string';
        }
    }
    method void Python_Generate
    {
        string Var_Code [my Variable Python];
        string Val_Code; 
        if (gt (list.length [my Listargs]) 0)
        {
            = Val_Code (i Python_String_Args ' + ');
        }
        else
        {
            = Val_Code "None";
        }
        string Code Var_Code ' = ' Val_Code [line];
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Var_Code [my Variable Javascript];
        string Val_Code; 
        if (gt (list.length [my Listargs]) 0)
        {
            = Val_Code (append ' = ' (i Javascript_Args ' + '));
        }
        else
        {
            = Val_Code "";
        }
        string Code 'var ' Var_Code Val_Code ';' [line];
        my= Javascript Code;
    }
}

statement Try try Scoped
{
    python 'try' (i Python_Block);
    javascript 'try' (i Javascript_Block);
}

statement Variant variant Declare
{
    argument Variable;
    optional Value;
}

statement While while Scoped
{
    argument Condition;
    python 'while ' [my Condition Python] (i Python_Block);
    javascript 'while (' [my Condition Javascript] ')' (i Javascript_Block);
}

statement Write write Append_Args
{
    method void Python_Generate
    {
        string Code 'print(' (i Python_Args ', ');
        if (gt (list.length [my Listargs]) 1)
        {
            append Code ",sep=''";
        }
        append Code ",end='')" [line];
        my= Python Code;
    }
}

statement Class class Class
{
    argument Class_Name 'class';

    method void Debug_Generate
    {
        string Gal_Code [class.property Gal_Keyword];
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code ' ' [. Argument Gal];
        }
        if (defined [my Block])
        {
            . [my Block] Debug_Generate;
            append Gal_Code [my Block Gal];
        }
        else
        {
            append Gal_Code ';';
        }
        my= Debug Gal_Code;
    }

    method void Fallback_Generate
    {
        string Name [my Class_Name Input];
        entity Owner_Class (. [: Compiler Instance] Get_Class Name);
        entity Statement;
        entity Argument;
        if (i Am Owner_Class)
        {
            string Ancestor '';
            if (gt (list.length [my Listargs]) 0)
            {
                append Ancestor ' ' [. (list.last [my Listargs]) Fallback];
            }
            string Arguments ' ' [my Class_Name Fallback] ' ' Ancestor;
            string Class_Properties '';
            entity Prop;
            foreach [my Class_Property_Statements] Prop
            {
                . Prop Fallback_Generate;
                append Class_Properties [. Prop Fallback];
            }
            string Block Class_Properties;
            if (defined [my Constructor])
            {
                . [my Constructor] Fallback_Generate;
                string Thiscon (i Indent [my Constructor Fallback]);
                append Block Thiscon;
            }
            string Prop_Code '';
            foreach [my Property_Statements] Prop
            {
                . Prop Fallback_Generate;
                append Block [. Prop Fallback] [line];
            }
            string MBGal '';
            foreach [my Main_Body] Statement
            {
                . Statement Fallback_Generate;
                append MBGal [. Statement Fallback];
            }
            append Block MBGal;
            = Block (i Indent Block);
            string Code 'class' Arguments [line] '{' [line] Block '}' [line];
            my= Fallback Code;
        }
        else
        {
            foreach [my Listargs] Argument
            {
                list.append [. Owner_Class Listargs] Argument;
            }
            foreach [my Block Statements] Statement
            {
                . [. Owner_Class Block] Add_Statement Statement;
                . Owner_Class Append_Statement Statement;
            }
            if (defined [. Owner_Class Block Fallback])
            {
                . [. Owner_Class Block] Fallback_Generate;
            }
            if (defined [. Owner_Class Fallback])
            {
                . Owner_Class Fallback_Generate;
            }
            my= Fallback '';
        }
    }

    method void Python_Generate
    {
        flag Null_Block [true];
        string Arguments (i Python_Arguments ' ');
        string Class_Properties '';
        string MBPy '';
        entity Prop; entity Statement;
        foreach [my Class_Property_Statements] Prop
        {
            append Class_Properties [. Prop Python];
            = Null_Block [false];
        }
        string Block '';
        append Block (i Indent Class_Properties);
        if (defined [my Constructor])
        {
            string Thiscon (i Indent [my Constructor Python]);
            append Block Thiscon;
            = Null_Block [false];
        }
        if [my Generate_Constructor]
        {
            = Null_Block [false];
            string Prop_Code '';
            foreach [my Property_Statements] Prop
            {
                append Prop_Code [. Prop Python];
            }
            string Function '__init__';
            string Super [indent] 'super().__init__()' [line];
            if (defined [my Constructor])
            {
                = Function 'propinit';
                = Super '';
            }
            string Constructor 'def ' Function '(self):' [line];
            append Constructor Super;
            append Constructor (i Indent Prop_Code);
            assign Constructor (i Indent Constructor);
            append Block Constructor;
        }
        foreach [my Main_Body] Statement
        {
            append MBPy [. Statement Python];
            = Null_Block [false];
        }
        = MBPy (i Indent MBPy);
        append Block MBPy;
        if Null_Block
        {
            append Block [indent] 'pass' [line];
        }
        string Code 'class ' Arguments ':' [line] Block;
        my= Python Code;
    }

    method void Javascript_Generate
    {
        string Arguments (i Javascript_Arguments ' ');
        if (not [my Base_Class]) {
            append Arguments ' extends gal';
        }
        string Class_Properties '';
        string MBjs '';
        entity Prop; entity Statement;
        foreach [my Class_Property_Statements] Prop
        {
            append Class_Properties [. Prop Javascript];
        }
        string Block ' {' [line];
        append Block (i Indent Class_Properties);
        if [my Generate_Constructor]
        {
            string Prop_Code '';
            foreach [my Property_Statements] Prop
            {
                append Prop_Code [. Prop Javascript];
            }
            string Constructor (i Indent Prop_Code);
            assign Constructor (i Indent Constructor);
            = Constructor (append [indent] 'constructor()' [line, indent] 
            '{' [line] 
            [indent 2] 'super();' [line]
            Constructor [indent] '}' [line]);
            append Block Constructor;
        }
        else.if (defined [my Constructor])
        {
            append Block [my Constructor Javascript];
        }
        string StmtJs;
        foreach [my Main_Body] Statement
        {
            if (not (defined [. Statement Javascript]))
            {
                error "Class method statement Javascript not defined: " (. Statement Gal_Code);
            }
            string Stmt_Js [. Statement Javascript];
            append MBjs Stmt_Js;
        }
        = MBjs (i Indent MBjs);
        append Block MBjs '}' [line];
        string Code 'class ' Arguments Block;
        my= Javascript Code;
    }
}

comment 'Fallback.gal';

class Definition_Statement [is Scoped_Statement]
{
    class.property string Gal_Keyword;
    class.property string Aliases;
    class.property string Base_Class;
    property entity Name_Arg;
    property entity Keyword; 
    property entity Root_Type;
    property entity Class_Name;

    property flag Generate_Attributes;
    property list Argument_Statements;
    property string Declarations '';
    property string Name_Prefix '';

    method void Attributes
    {
        my= Name_Arg (list.shift [my Listargs]);
        my= Keyword (list.shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Root_Type (list.shift [my Listargs]);
            comment writeline "Assign Root Type: " [my Root_Type Gal];
        }
        string Name [class.property Base_Class];
        append Name '_';
        append Name [my Name_Arg Input];
        entity.new Token_Entity Token_Name;
        .= Token_Entity Input Name;
        my= Class_Name Token_Entity;
        . [: Compiler Instance] Add_Class [me];
        . [: Compiler Instance] Add_Definition [me];
    }

    method void Append_Statement [entity Statement]
    {
        writeline 'definition statement append statement';
        list.append [my Block Statements] Statement;
    }

    method void Structure
    {
        returnif (not [my Re_Structure]);
        my= Re_Structure [false];
        i Base_Structure;
        my= Generate_Attributes [true];
        if (and (defined [my Block]) (defined [my Block Statements]))
        {
            comment writeline "Main Structure " [class.name] ' ' [my Name_Arg Input];
            foreach [my Block Statements] Statement
            {
                comment writeline "Structure Statement " [class.name Statement];
                if (and (isa Statement Method_Statement)
                             (string.eq [. Statement Method_Name Input] 'Attributes')) 
                {
                    my= Generate_Attributes [false];
                }
                else.if (isa Statement Argument_Statement)
                {
                    list.append [my Argument_Statements] Statement;
                }
            }
        }
        entity Element;
        foreach [my Elements] Element
        {
            comment .= Element Parent [me];
        }
        comment writeline '*** ' [class.name] ' ' [my Name_Arg Input] '.Structure determined Generate_Attributes is ' [my Generate_Attributes] ' ***';
    }

    method void Fallback_Generate
    {
        string Class_Name (classpropget Base_Class) '_' [my Name_Arg Fallback];
        string Gal_Code 'class ' Class_Name;
        if (defined [my Root_Type]) 
        {
            entity PC [my Root_Type];
            if (not (defined [. PC Fallback]))
            {
                . PC Fallback_Generate;
            }
            string Underscore '_';
            string PCFB [. PC Fallback];
            append Gal_Code ' [is ' PCFB;
            append Gal_Code Underscore;
            append Gal_Code (classpropget Base_Class) ']';
            comment writeline "PCFB " PCFB " entity: " (. PC To_String) ' self: ' (i To_String) ' gal: ' [my Gal];
        }
        else
        {
            append Gal_Code ' [is ' (classpropget Base_Class) ']';
        }
        append Gal_Code [line] '{' [line,
               indent] "class.property string Gal_Keyword '" [my Keyword Fallback] "';" [line,
               indent] "class.property string Gs_Keyword '" [my Keyword Fallback] "';" [line];
        if [my Block]
        {
            . [my Block] Fallback_Generate;
            append Gal_Code [my Block Fallback_Statements];
        }
        if [my Generate_Attributes]
        {
            string Attribute_Statements '';
            entity Statement;
            if [my Block]
            {
                foreach [my Block Statements] Statement
                {
                    if (defined [. Statement Gal_Declaration])
                    {
                        append Attribute_Statements [. Statement Gal_Declaration];
                    }
                }
                string Indented (i Indent Attribute_Statements);
                comment writeline '*** ' [class.name] ' ' [my Name_Arg Fallack] ' - Attribute Statements: ' Attribute_Statements [line] 'indented:' [line] Indented;
                string Attribute_Method 
                    'method void Attributes' [line]
                    '{' [line]
                    Indented
                    '}' [line];
                append Gal_Code (i Indent Attribute_Method);
            }
        }
        append Gal_Code '}' [line];
        string Definition ': ' Class_Name ' Initialize [self];';
        my= Fallback Gal_Code;
        my= Fallback_Declaration Definition;
    }
}

class Statement_Statement [is Definition_Statement]
{
    class.property string Gal_Keyword 'statement';
    class.property string Base_Class 'Statement';
}

class Statement_Operation [is Definition_Statement]
{
    class.property string Gal_Keyword 'operation';
    class.property string Base_Class 'Operation';
}

class Statement_Syntax [is Definition_Statement]
{
    class.property string Gal_Keyword 'syntax';
    class.property string Base_Class 'Syntax';
}

statement Argument argument Argument
{
    property entity Argument_Name;
    property entity Type_Value;
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required Argument_Name';
        }
        my= Argument_Name (list.shift [my Listargs]);
        .= [my Argument_Name] Usage 'variable';
        if (gt (list.length [my Listargs]) 0)
        {
            my= Type_Value (list.shift [my Listargs]);
            .= [my Type_Value] Usage 'value';
        }
    }
    method void Fallback_Generate
    {
        string Definition 'property entity ' [my Argument_Name Fallback] ';';
        string Code 
            "if (= (list.length [. [me] Listargs]) 0)" [line] 
            "{" [line, indent] 
                "error 'missing required argument " [my Argument_Name Fallback] "';" [line] 
            "}" [line];
        append Code '.= [me] ' [my Argument_Name Fallback] ' (list.shift [. [me] Listargs]);' [line];
        if (defined [my Type_Value])
        {
            append Code '.= [. [me] ' [my Argument_Name Fallback] '] Usage ' [my Type_Value Fallback] ';' [line];
        }
        my= Gal_Declaration Code;
        my= Fallback Definition;
    }
}

statement Keyword keyword Argument
{
    argument Argument_Name;
    optional Type_Value;

    method void Fallback_Generate
    {
        string Definition 'property entity ' [my Argument_Name Fallback] ';';
        string Code 
            "if (= (list.length [. [me] Keywords]) 0)" [line] 
            "{" [line, indent] 
                "error 'missing required keyword " [my Argument_Name Fallback] "';" [line] 
            "}" [line];
        append Code '.= [me] ' [my Argument_Name Fallback] ' (list.shift [. [me] Keywords]);' [line];
        if (defined [my Type_Value])
        {
            append Code '.= [. [me] ' [my Argument_Name Fallback] '] Usage ' [my Type_Value Fallback] ';' [line];
        }
        my= Gal_Declaration Code;
        my= Fallback Definition;
    }
}

statement Optional optional Argument
{
    property entity Argument_Name;
    property entity Type_Value;
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error [class.name] ' missing required Argument_Name';
        }
        my= Argument_Name (list.shift [my Listargs]);
        .= [my Argument_Name] Usage 'variable';
        if (gt (list.length [my Listargs]) 0)
        {
            my= Type_Value (list.shift [my Listargs]);
            .= [my Type_Value] Usage 'value';
        }
    }
    method void Fallback_Generate
    {
        string Definition 'property entity ' [my Argument_Name Fallback] ';';
        string Code 'if (gt (list.length [. [me] Listargs]) 0)' [line]
            '{' [line];
        append Code [indent]
            '.= [me] ' [my Argument_Name Fallback] ' (list.shift [. [me] Listargs]);' [line];
        if (defined [my Type_Value])
        {
            append Code [indent] '.= [. [me] ' [my Argument_Name Fallback];
            append Code '] Usage ' [my Type_Value Fallback] ';' [line];
        }
        append Code '}' [line];
        my= Gal_Declaration Code;
        my= Fallback Definition;
    }
}

class Statement_Fallback [is Append_Args_Statement]
{
    class.property string Gal_Keyword 'fallback';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Fallback_Generate' [line] 
            '{' [line, 
                indent] 'string Gal_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Fallback]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Fallback Gal_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Atomic [is Append_Args_Statement]
{
    class.property string Gal_Keyword 'atomic';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Atomic_Generate' [line] 
            '{' [line, 
                indent] 'string Atomic_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Atomic]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Atomic Atomic_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Gs [is Append_Args_Statement]
{
    class.property string Gal_Keyword 'gs';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Gs_Generate' [line] 
            '{' [line, 
                indent] 'string Gs_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Gs]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Gs Gs_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Javascript [is Append_Args_Statement]
{
    class.property string Gal_Keyword 'javascript';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Javascript_Generate' [line] 
            '{' [line, 
                indent] 'string Javascript_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if  (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Javascript]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Javascript Javascript_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}


class Statement_Mumps [is Append_Args_Statement]
{
    class.property string Gal_Keyword 'mumps';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Mumps_Generate' [line] 
            '{' [line, 
                indent] 'string Mumps_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if  (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Mumps]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Mumps Mumps_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Python [is Line_Statement]
{
    class.property string Gal_Keyword 'python';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Python_Generate' [line] 
            '{' [line, 
                indent] 'string Python_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Python]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Python Python_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Php [is Line_Statement]
{
    class.property string Gal_Keyword 'php';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Python_Generate' [line] 
            '{' [line, 
                indent] 'string Php_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if  (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Php]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Php Php_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Java [is Line_Statement]
{
    class.property string Gal_Keyword 'java';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Python_Generate' [line] 
            '{' [line, 
                indent] 'string Java_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if  (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Java]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Java Java_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Raku [is Line_Statement]
{
    class.property string Gal_Keyword 'raku';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Python_Generate' [line] 
            '{' [line, 
                indent] 'string Raku_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            = Argument_Code  [. Argument Fallback];
            if  (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Raku]');
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Raku Raku_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

class Statement_Gal_Language [is Definition_Statement]
{
    todo 'iterate handlers and append them to the target class. tell each handler the name of its generator method e.g. Python_Generate.';
    class.property string Base_Class 'Language';
    class.property string Gal_Keyword 'gal.language';
    property entity Language_Name;
    method void Attributes
    {
        my= Language_Name (list.shift [my Listargs]);
    }
    comment "method void Structure";
    method void Model;
    method void Fallback_Generate
    {
        string Gal_Body (i Indent [my Declarations]);
        if [my Block]
        {
            append Gal_Body [my Block Fallback_Statements];
        }
        string Gal_Code
            'class ' [my Language_Name Fallback] ' [is Language]' [line]
            '{' [line]
            Gal_Body
            '}' [line];
        my= Fallback Gal_Code;
    }
}

statement Classify isa Method
{
    argument Class_Name;

    property entity Method_Name;
    property entity Verb_Owner;
    property entity Method_Context;
    property entity Variable_Context;
    property entity Class_Name;
    property string Method_Signature;

    method void Attributes
    {
        my= Class_Name (list.shift [my Listargs]);
        my= Method_Context [me];
        my= Method_Signature (append 'method flag ' [my Class_Name Input]);
    }

    method void Model
    {
        if (defined [my Verb_Owner])
        {
            my= Method_Name [my Verb_Owner Class_Name];
        }
    }

    method void Fallback_Generate
    {
        string Header [my Parent Method_Signature];
        string Append_To [my Class_Name Fallback];
        string Method 
            Header [line] '{' [line]
                [my Block Fallback_Statements] 
                [indent] 'return [true];' [line]
            '}';
        string Code 'class.append ' Append_To [line]
            '{' [line]
                (i Indent Method)
            '}';
        my= Fallback Code;
    }
}

statement Infer infer Method
{
    comment `fallback 'method void Infer' [my Block Fallback];`;
    method void Fallback_Generate
    {
        string Block_Code '';
        forgive 
        {
            append Block_Code [my Block Fallback_Statements];
        }
        string Code 
            'method void Infer' [line] 
            '{' [line]
                Block_Code
            [indent] 'return [true];' [line]
            '}';
        my= Fallback Code;
    }
}

statement Verb verb Verb
{
    alias polymorph;
    argument DT;
    argument Class_Name;

    property string Method_Signature;
    property string Name_Prefix '';
    property string Property_Name;

    method void Attributes
    {
        string Header 'method';
        entity Argument;
        foreach [my Arguments] Argument
        {
            comment "The arguments must be consistent, because we need to know the header before generation begins.";
            append Header ' ' (. Argument Get_Input);
        }
        my= Method_Signature Header;
        my= DT (list.shift [my Listargs]);
        my= Class_Name (list.shift [my Listargs]);
        string Name_Text (. [my Class_Name] Get_Input);
        my= Property_Name Name_Text;
    }

    method entity Inference_Context
    {
    	return [me];
    }

    method void Gal_Generate
    {
        string Code [my Block Gal_Statements];
        my= Gal Code;
    }

    fallback '';
}

statement Oho oho
{
    method void Fallback_Generate
    {
        string Method_Name 'Oho';
        entity Arg;
        foreach [my Arguments] Arg
        {
            append Method_Name '_' [. Arg Fallback];
        }
        string Code 'comment ". [class] ' Method_Name ';";';
        my= Fallback Code;
    }
}

class Statement_Gal [is Append_Args_Statement]
{
    class.property string Gal_Keyword 'gal';
    method void Fallback_Generate
    {
        string Gal_Code 
            'method void Gal_Generate' [line] 
            '{' [line, 
                indent] 'string Gal_Code';
        entity Argument;
        string Argument_Code;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Name) 
            {
                = Argument_Code (append '[my ' Argument_Code ' Gal]');
            }
            else
            {
                = Argument_Code  [. Argument Gal];
            }
            append Gal_Code ' ' Argument_Code;
        }
        append Gal_Code ';' [line, indent] 
            'my= Gal Gal_Code;' [line] 
            '}' [line];
        my= Fallback Gal_Code;
    }
}

statement Inference inference Verb
{
    alias polymorph cuckoo;
    argument DT;
    argument Class_Name;

    property string Method_Signature;
    property string Method_Name;
    property string Property_Name;

    method void Attributes
    {
        my= DT (list.shift [my Listargs]);
        my= Class_Name (list.shift [my Listargs]);
        string Name_Text (. [my Class_Name] Get_Input);
        my= Property_Name Name_Text;
        my= Method_Name (append 'Infer_' Name_Text);
        comment "we need to know the header before generation begins.";
        string Header 'method flag ' [my Method_Name];
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Header ' ' (. Argument Get_Input);
        }
        my= Method_Signature Header;
    }

    method entity Inference_Context
    {
    	return [me];
    }

    fallback 
        'class Inference_' [my Class_Name Fallback] ' [is Inference]' [line]
        '{' [line, indent]
            'method flag Infer' [line, indent]
            '{' [line, indent 2]
                'returnif (not (. [my Owner] Infer_' [my Class_Name Fallback] ')) [false];' [line, indent 2]
                'return [true];' [line, indent]
            '}' [line]
        '}' [line]
        [my Block Fallback_Statements];
}
comment 'Additions.gal';

syntax My my
{
    alias self i me this;
    property flag Has_Arguments [false];
    method void Attributes
    {
        comment 'look up the first argument in the parent context to know that it is a list.';
        my= Has_Arguments (gt (list.length [my Listargs]) 0);
        if [my Has_Arguments]
        {
            entity Argument (list.shift [my Listargs]);
            todo 'this must be a token';
            if (not (isa Argument Token))
            {
                error (i Failure_Message "Property name must be a token");
            }
            string Property [. Argument Input];
            entity Definition (i Lookup Property);
            returnif (not Definition);
            string Data_Type [. Definition Data_Type];
            returnif (not Data_Type);
            .= Argument Data_Type Data_Type;
            my= Data_Type Data_Type;
        }
    }
    method void Fallback_Generate
    {
        entity Argument;
        if [my Has_Arguments]
        {
            string Gal_Code '[. [self]';
            foreach [my Arguments] Argument
            {
                append Gal_Code ' ' [. Argument Fallback];
            }
            append Gal_Code ']';
            my= Fallback Gal_Code;
        }
        else
        {
            my= Fallback '[self]';
        }
    }
    method void Python_Generate
    {
        comment debug;
        my= Python 'self';
    }
    javascript 'this';
}

operation Begins begins
{
    argument String_Value;
    argument Begin_Value;
    comment fallback '(substring ' [my String_Value Fallback] ' 0 (string.length ' [my Begin_Value Fallback] '))';
    python [my String_Value Python] '[:len(' [my Begin_Value Python] ')] == ' [my Begin_Value Python];
    javascript [my String_Value Javascript] '.substr(0,' [my Begin_Value Javascript] '.length) == ' [my Begin_Value Javascript];
}

operation Firstchar firstchar Unary
{
    argument String_Value;
    comment fallback '(substring ' [my String_Value Fallback] ' 0 1)';
    python [my String_Value Python] '[0]';
    javascript [my String_Value Javascript] '.charAt(0)';
}

operation Lastchar lastchar Unary
{
    argument String_Value;
    comment fallback '(substring ' [my String_Value Fallback] ' (- (length ' [my String_Value Fallback] ')) 1)';
    python [my String_Value Python] '[-1]';
    javascript [my String_Value Javascript] '.charAt(' [my String_Value Javascript] '.length-1)';
}

operation I i Invocation
{
    argument Method;
    alias self me this;
    fallback '(. [self]' (i Fallback_Arguments) ')';
    python 'self.' [my Method Python] '(' (i Python_Args ',') ')';
    javascript 'this.' [my Method Javascript] '(' (i Javascript_Args ',') ')';
}

operation Key_Get key.get
{
    argument Dictionary;
    argument Key;
    fallback '[key ' [my Dictionary Fallback] ' ' [my Key Fallback] ']';
}

statement I i Invocation
{
    alias self this me my;
    fallback '. [self]' (i Fallback_Arguments) ';';
}

statement We we Invocation
{
    alias us;
    fallback '. [class]' (i Fallback_Arguments) ';';
}

statement Myclass myclass Invocation
{
    alias my.class;
    fallback '. [my.class]' (i Fallback_Arguments) ';';
}

statement Entity_New entity.new Declare
{
    argument Variable;
    argument Class;
    method void Fallback_Generate
    {
        entity Argument;
        string Gal_Code 'entity ' [my Variable Fallback] ' (new ' [my Class Fallback];
        foreach [my Listargs] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code ');';
        my= Fallback Gal_Code;
    }
}

statement Entity_My_Class entity.my.class Declare
{
    argument Variable;
    method void Fallback_Generate
    {
        entity Argument;
        string Gal_Code 'entity ' [my Variable Fallback] ' (new [my.class]';
        foreach [my Listargs] Argument
        {
            append Gal_Code ' ' [. Argument Fallback];
        }
        append Gal_Code ');';
        my= Fallback Gal_Code;
    }
}

statement Contif continue.if Line
{
    alias contif;
    argument Condition;
    fallback 'if ' [my Condition Fallback, line]
        '{' [line,
        indent] 'continue;' [line]
        '}' [line];
}

statement Breakif break.if Line
{
    alias breakif;
    argument Condition;
    fallback 'if ' [my Condition Fallback, line]
        '{' [line,
        indent] 'break;' [line]
        '}' [line];
}

statement Alias alias Line
{
    method void Fallback_Generate
    {
        string Code 'class.property string Aliases "';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Code ' ' [. Argument Fallback];
        }
        append Code ' ";';
        my= Fallback Code;
    }
}

operation Dictionary_Default dict.default
{
    argument Dictionary;
    argument Key;
    argument Default;

    fallback '(. [: Runtime] Dict_Default ' [my Dictionary Fallback] ' ' [my Key Fallback] ' ' [my Default Fallback] ')';
}

operation Dictionary_Defined dict.defined
{
    argument Dictionary;
    argument Key;
    fallback '(. [: Runtime] Dict_Defined ' [my Dictionary Fallback] ' ' [my Key Fallback] ' ' [my Default Fallback] ')';
}

statement Entities entities Line
{
    method void Fallback_Generate
    {
        string Gal_Code '';
        string Between '';
        string Keyword 'entities';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between Keyword ' ' [. Argument Fallback] ';';
            = Between [line];
        }
        my= Fallback Gal_Code;
    }
}

statement My_Equal my= Assign
{
    alias self.= i.=;
    argument Property;
    argument Value;
    fallback '.= [self] ' [my Property Fallback] ' ' [my Value Fallback] ';';
    python 'self.' [my Property Python] ' = ' [my Value Python] [line];
    javascript 'this.' [my Property Javascript] ' = ' [my Value Javascript] ';' [line];
}

statement Integers integers Line
{
    method void Fallback_Generate
    {
        string Gal_Code '';
        string Between '';
        string Keyword 'integer';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between Keyword ' ' [. Argument Fallback] ';';
            = Between [line];
        }
        my= Fallback Gal_Code;
    }
}

statement Numbers numbers Line
{
    method void Fallback_Generate
    {
        string Gal_Code '';
        string Between '';
        string Keyword 'number';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between Keyword ' ' [. Argument Fallback] ';';
            = Between [line];
        }
        my= Fallback Gal_Code;
    }
}

statement Strings strings Line
{
    method void Fallback_Generate
    {
        string Gal_Code '';
        string Between '';
        string Keyword 'string';
        entity Argument;
        foreach [my Arguments] Argument
        {
            append Gal_Code Between Keyword ' ' [. Argument Fallback] ';';
            = Between [line];
        }
        my= Fallback Gal_Code;
    }
}

statement Return_If returnif Line
{
    alias return.if;
    argument Condition 'value';
    optional Return_Value 'value';
    method void Fallback_Generate
    {
        string Code 'if ' [my Condition Fallback, line] '{' [line, indent] 'return';
        if (defined [my Return_Value])
        {
            append Code ' ' [my Return_Value Fallback];
        }
        append Code ';' [line] '}' [line];
        my= Fallback Code;
    }
}

statement Ifdef ifdef Scoped
{
    method void Python_Generate
    {
        string Ifargs "";
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Ifargs "ifdef = " [. Argument Python] [line];
        }
        = Ifargs (i Indent Ifargs);
        string Block (i Python_Block);
        string Code "try:" [line] Ifargs Block;
        append Code "except ValueError:" [line, indent] "pass" [line];
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Ifargs "";
        string Between "";
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Ifargs Between [. Argument Javascript] "!= null";
            = Between " && ";
        }
        string Block (i Javascript_Block);
        string Code "if (" Ifargs ")" Block;
        my= Javascript Code;
    }
}

statement Undef undef Scoped
{
    method void Python_Generate
    {
        string Ifargs "";
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Ifargs "undef = " [. Argument Python] [line];
        }
        = Ifargs (i Indent Ifargs);
        string Block (i Python_Block);
        string Code "try:" [line] Ifargs;
        append Code "except ValueError" Block;
        my= Python Code;
    }
    method void Javascript_Generate
    {
        string Ifargs "";
        string Between "";
        entity Argument;
        foreach [my Listargs] Argument
        {
            append Ifargs Between [. Argument Javascript] " === undefined";
            = Between " || ";
        }
        string Block (i Javascript_Block);
        string Code "if (" Ifargs ")" Block;
        my= Javascript Code;
    }
}


statement New new Line
{
    argument Variable;
    argument Class;
    python [my Variable Python] ' = ' [my Class Python] '(' (i Python_Args ', ') ')' [line];
    javascript [my Variable Javascript] ' = new ' [my Class Javascript] '(' (i Javascript_Args ', ') ');' [line];
}

statement Verbose verbose Line
{
    fallback 'if Verbose { writeline' (i Fallback_Arguments) '; }';
}

statement Verbosity verbosity Line
{
    optional Setting;
    method void Fallback_Generate
    {
        string Setting '[false]';
        if (defined [my Setting])
        {
            = Setting [my Setting Fallback];
        }
        string Code 'flag Verbose ' Setting ';';
        my= Fallback Code;
    }
}

statement Todo todo Comment
{
    fallback 'comment "TODO:" ' (i Enquote (i Argument_String)) ';';
}
statement Flowerbox flowerbox Comment
{
    fallback 'comment "**** " ' (i Enquote (i Argument_String)) '" ****";';
}
statement Question question Comment
{
    fallback 'comment "QUESTION:" ' (i Enquote (i Argument_String)) ';';
}
statement Answer question Comment
{
    fallback 'comment "ANSWER:" ' (i Enquote (i Argument_String)) ';';
}

statement Write_Line writeline Append_Args
{
    method void Python_Generate
    {
        string Code 'print(' (i Python_Args ', ');
        if (gt (list.length [my Listargs]) 1)
        {
            append Code ",sep=''";
        }
        append Code ")" [line];
        my= Python Code;
    }
    javascript 'console.log(' (i Javascript_Args ', ') ');' [line];
    mumps ' write ' (i Mumps_Args ',') ',!';
}

operation M_Atom m.atom Invocation
{
    argument Element;
    fallback '(. ' [my Element Fallback] ' M_Atom)';
}
operation M_Expr m.expr Invocation
{
    argument Element;
    fallback '(. ' [my Element Fallback] ' M_Expr)';
}
operation Mumps mumps Invocation
{
    argument Element;
    fallback '(. ' [my Element Fallback] ' Mumps)';
}
statement M_Atom m.atom Invocation
{
    argument Element;
    argument Value;
    fallback '.= ' [my Element Fallback] ' M_Atom ' [my Value Fallback] ';';
}
statement M_Expr m.expr Invocation
{
    argument Element;
    argument Value;
    fallback '.= ' [my Element Fallback] ' M_Expr ' [my Value Fallback] ';';
}
statement M m Invocation
{
    argument Element;
    argument Value;
    fallback '.= ' [my Element Fallback] ' Mumps ' [my Value Fallback] ';';
}

statement Unless unless If
{
    argument Condition;
    fallback 'if (not ' [my Condition Fallback] ')' (i Fallback_Block);
}
statement Parser parser Class
{
    argument Class_Name;
    fallback 'class ' [my Class_Name Fallback] '_Parser'
        ' [is Parser]'
        (i Fallback_Args) 
        (i Fallback_Block);
}

statement Sequence sequence Method
{
    argument Rule_Name;
    method void Fallback_Generate
    {
        string Body 'comment "sequence ' [my Rule_Name Fallback] '";' [line]
            'integer Start [my Position];' [line]
            'list My_Elements;' [line];
        entity Argument;
        foreach [my Listargs] Argument
        {
            if (isa Argument Token) 
            {
                string Name [. Argument Fallback];
                append Body 
                    '= Last Start;' [line]
                    'if (not (. [self] Parse_' Name ' My_Elements)) { return [false]; }' [line];
            }
            else
            {
                append Body [. Argument Fallback];
            }
        }
        append Body
            'integer End [my Position];' [line]
            'entity Element (new ' [my Rule_Name Fallback] ');' [line]
            '.= Element Start_Position Start;' [line]
            '.= Element End_Position End;' [line]
            '.= Element Document [self];' [line]
            '.= Element Elements My_Elements;' [line]
            'i Add_Element Element;' [line]
            'list.append Parent_Elements Element;' [line]
            'return [true];' [line];

        = Body (i Indent Body);
        string Code 'method flag Parse_' [my Rule_Name Fallback] 
            ' [list Parent_Elements]' [line] 
            '{' [line]
            Body
            '}';
        my= Fallback Code;
    }
}

statement Either either Method
{
    argument Rule_Name;
    method void Fallback_Generate
    {
        string Body 'comment "either ' [my Rule_Name Fallback] '";' [line];
        entity Argument;
        foreach [my Listargs] Argument
        {
            if (isa Argument Token) 
            {
                append Body 'returnif (. [self] Parse_' [. Argument Fallback] ' Parent_Elements) [true];' [line];
            }
            else
            {
                append Body [. Argument Fallback];
            }
        }
        = Body (i Indent Body);
        string Code 'method flag Parse_' [my Rule_Name Fallback] 
            ' [list Parent_Elements]' [line] 
            '{' [line]
            Body
            [indent] 'return [false];' [line]
            '}';
        my= Fallback Code;
    }
}

statement Token token Method
{
    argument Class_Name;
    method void Fallback_Generate
    {
        string Name [my Class_Name Fallback];
        string Code 
            'method flag Parse_' Name ' [list Parent_Elements]' [line]
            '{' [line]
            [indent] 'entity Top_Token (. [self] Top_Token);' [line]
            [indent] 'returnif (not (isa Top_Token ' Name ')) [false];' [line]
            [indent] 'list.append Parent_Elements Top_Token;' [line]
            [indent] 'i Consume_Token;' [line]
            [indent] 'return [true];' [line]
            '}';
        my= Fallback Code;
    }
}

statement Tokens tokens Method
{
    method void Fallback_Generate
    {
        string Code '';
        entity Argument;
        string Between '';
        foreach [my Arguments] Argument
        {
            string Name [. Argument Fallback];
            append Code Between
                'method flag Parse_' Name ' [list Parent_Elements]' [line]
                '{' [line]
                [indent] 'entity Top_Token (. [self] Top_Token);' [line]
                [indent] 'returnif (not (isa Top_Token ' Name ')) [false];' [line]
                [indent] 'list.append Parent_Elements Top_Token;' [line]
                [indent] 'i Consume_Token;' [line]
                [indent] 'return [true];' [line]
                '}';
                = Between [line];
        }
        my= Fallback Code;
    }
}

syntax Repeating repeating
{
    alias required.repeating;
    argument Rule;
    fallback 'comment "repeating ' [my Rule Fallback] '";' [line]
        'returnif (not (. [self] Parse_' [my Rule Fallback] ' My_Elements)) [false];' [line]
        'forever' [line] 
        '{' [line,
        indent] 'breakif (not (. [self] Parse_' [my Rule Fallback] ' My_Elements));' [line]
        '}' [line];
}

syntax Optional optional
{
    argument Rule;
    fallback 'comment "optional ' [my Rule Fallback] '";' [line]
        'i Parse_' [my Rule Fallback] '  My_Elements;';
}

syntax Optrep optrep
{
    alias optional.repeating;
    argument Rule;
    fallback 'comment "optional.repeating ' [my Rule Fallback] '";' [line]
        'forever' [line] 
        '{' [line,
        indent] 'breakif (not (. [self] Parse_' [my Rule Fallback] ' My_Elements));' [line]
        '}' [line];
}

syntax Exclude exclude
{
    alias except;
    method void Fallback_Generate
    {
        string Code 'comment "[exclude ' (. [self] Fallback_Args) ']";' [line]
            'list Excluded;' [line];
        entity Argument;
        foreach [my Arguments] Argument
        {
            comment "rule name tokens are required, right?";
            append Code 'returnif (. [self] Parse_' [. Argument Fallback] ' Excluded) [false];' [line];
        }
        my= Fallback Code;
    }
}

statement Task task
{
    argument Task_Id;
    method void Fallback_Generate
    {
        string Task_Id [my Task_Id Fallback];
        string Code 'entity Task_' Task_Id ' (new Task);' [line];
        entity Argument;
        flag Odd [true];
        string Property;
        string Value;
        foreach [my Listargs] Argument
        {
            if (isa Argument Token_Comma)
            {
                = Odd [true];
                continue;
            }
            todo 'do this with keyvalues instead?';
            if Odd 
            {
                = Property (i Pascal_Case [. Argument Fallback]);
            }
            else
            {
                = Value [. Argument Fallback];
                append Code '.= Task_' Task_Id ' ' Property ' ' Value ';' [line];
            }
            = Odd (not Odd);
        }
        my= Fallback Code;
    }
}

statement Subtask subtask
{
    argument Headline;
    method void Fallback_Generate
    {
        string Variable [my Parent Variable];
        string Code '. ' Variable ' Add_Subtask ' [my Headline Fallback] ';';
        my= Fallback Code;
    }
}

statement Book_Gal book.gal
{
    method void Fallback_Generate
    {
        string Code 'my= Gal';
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Name)
            {
                append Code ' [my ' [. Argument Fallback] ' Fallback]';
            }
            else
            {
                append Code ' ' [. Argument Fallback];
            }
        }
        if (gt (list.length [my Arguments]) 1)
        {
            = Code (append '(append ' Code ')');
        }
        append Code ';';
        my= Fallback Code;
    }
}

statement Book_Fallback book.fallback
{
    method void Fallback_Generate
    {
        string Code 'my= Fallback';
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Name)
            {
                append Code ' [my ' [. Argument Fallback] ' Fallback]';
            }
            else
            {
                append Code ' ' [. Argument Fallback];
            }
        }
        if (gt (list.length [my Arguments]) 1)
        {
            = Code (append '(append ' Code ')');
        }
        append Code ';';
        my= Fallback Code;
    }
}

statement Book_Raku book.raku
{
    method void Fallback_Generate
    {
        string Code 'my= Raku';
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Name)
            {
                append Code ' [my ' [. Argument Fallback] ' Fallback]';
            }
            else
            {
                append Code ' ' [. Argument Fallback];
            }
        }
        if (gt (list.length [my Arguments]) 1)
        {
            = Code (append '(append ' Code ')');
        }
        append Code ';';
        my= Fallback Code;
    }
}

statement Book_Python book.python
{
    method void Fallback_Generate
    {
        string Code 'my= Python';
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Name)
            {
                append Code ' [my ' [. Argument Fallback] ' Fallback]';
            }
            else
            {
                append Code ' ' [. Argument Fallback];
            }
        }
        if (gt (list.length [my Arguments]) 1)
        {
            = Code (append '(append ' Code ')');
        }
        append Code ';';
        my= Fallback Code;
    }
}

statement Book_Javascript book.javascript
{
    method void Fallback_Generate
    {
        string Code 'my= Javascript';
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Name)
            {
                append Code ' [my ' [. Argument Fallback] ' Fallback]';
            }
            else
            {
                append Code ' ' [. Argument Fallback];
            }
        }
        if (gt (list.length [my Arguments]) 1)
        {
            = Code (append '(append ' Code ')');
        }
        append Code ';';
        my= Fallback Code;
    }
}

statement Book book
{

}

statement Chapter chapter
{
    alias chap;

}

statement Section section
{

}

statement Overview overview
{

}

statement Expository expository
{
    alias exposition expo;

}

statement Paragraph paragraph
{
    alias p;
}

statement Shell shell
{
    alias linux;

}

statement Summary summary
{
    
}

statement Title title
{
    
}

statement Description description
{
    alias desc;
    
}

statement Codefile codefile
{
    alias code;

}

syntax Italic italic
{
}

statement Definition definition Comment
{
    fallback 'comment "DEFINITION: "' (i Fallback_Args) ';';
}

statement Token_Mode tokenmode Line
{
    argument Mode_Name;
    fallback '= Mode ' (i Enquote [my Mode_Name Fallback]) ';';
}

operation Token_Mode tokenmode
{
    argument Mode_Name;
    fallback '(s= Mode ' (i Enquote [my Mode_Name Fallback]) ')';
}

operation Is_Ident isident
{
    argument Character;
    fallback '(or (isalpha ' [my Character Fallback] ') (contains "0123456789_" ' [my Character Fallback] '))';
}

statement Token_Append token.append Line
{
    argument Token_Entity;
    argument Character;
    argument Position;
    fallback 
        'append [. ' [my Token_Entity Fallback] ' Input] ' [my Character Fallback] ';' [line]
        '= [. ' [my Token_Entity Fallback] ' Location End_Position] ' [my Position Fallback] ';';
}

statement New_Token newtoken Line
{
    argument Token_Entity;
    argument Class;
    argument Mode;
    argument Character;
    argument Start;
    argument End;
    fallback 
        '= ' [my Token_Entity Fallback] ' (new Token_' [my Class Fallback] ' [self] ' [my Character Fallback] ' ' [my Start Fallback] ' ' [my End Fallback] ');' [line]
        'list.append [my Tokens Symbol_Value] ' [my Token_Entity Fallback] ';' [line]
        '= Mode ' (i Enquote [my Mode Fallback]) ';';
}

statement Skip_Token skiptoken Line
{
    argument Token_Entity;
    argument Class;
    argument Mode;
    argument Character;
    argument Start;
    argument End;
    fallback 
        '= ' [my Token_Entity Fallback] ' (new Token_' [my Class Fallback] ' [self] ' [my Character Fallback] ' ' [my Start Fallback] ' ' [my End Fallback] ');' [line]
        'comment `' [my Class Fallback] ' tokens are not appended to the token list.`' [line]
        '= Mode ' (i Enquote [my Mode Fallback]) ';';
}

statement Generate generate Method
{
    argument Class_Name;

    property entity Method_Name;
    property entity Verb_Owner;
    property entity Method_Context;
    property entity Variable_Context;
    property entity Class_Name;
    property string Method_Signature;
    property string Property_Name;

    method void Attributes
    {
        my= Class_Name (list.shift [my Listargs]);
    }

    method void Fallback_Generate
    {
        entity Context (i Inference_Context);
        string Property_Name [. Context Property_Name];
        string Header [my Parent Method_Signature];
        string Append_To [my Class_Name Fallback];

        string Args_Code '';
        entity Argument;
        foreach [my Listargs] Argument
        {
            if (isa Argument Token_Name)
            {
                append Args_Code ' [. [self] ' [. Argument Fallback] ' ' Property_Name ']';
            }
            else
            {
                append Args_Code ' ' [. Argument Fallback];
            }
        }
        if (sgt Args_Code '          ')
        {
            = Args_Code (append 'string Gen ' Args_Code ';' [line] 
                '.= [self] ' Property_Name ' Gen;' [line]);
            = Args_Code (i Indent Args_Code);
        }

        string Statements '';
        if (and (defined [my Block Fallback_Statements])
                (sgt [my Block Fallback_Statements] ''))
        {
            = Statements [my Block Fallback_Statements];
        }
        string Method_Code 
            Header [line]
            '{' [line]
                Statements
                Args_Code
                [indent] 'return [true];' [line]
            '}' [line];
        = Method_Code (i Indent Method_Code);
        string Code 
            'class.append ' Append_To [line]
            '{' [line]
                Method_Code
            '}';
        my= Fallback Code;
    }
}

statement I_Equal i= Assign
{
    alias self=;
    argument Value;
    optional Certainty;
    method void Fallback_Generate
    {
        entity Context (i Inference_Context);
        string Property_Name [. Context Property_Name];
        comment writeline "Property Name " Property_Name;
        string Code  'my= ' Property_Name ' ' [my Value Fallback] ';';
        comment append Code [line] 'writeline "properrty ' Property_Name 
            ': <" [my ' Property_Name 
            '] ">";';
        my= Fallback Code;
    }
}

statement Arguments arguments Scoped
{
    fallback 'method void Process_Arguments' (i Fallback_Block);
}

statement Symbol symbol Class
{
    argument Value_Type;
    argument Class_Name;
    property string Property_Name;
    method void Process_Arguments
    {
        my= Property_Name [my Class_Name Input];
    }
    method void Fallback_Generate
    {
        string Class_Name [my Class_Name Fallback];
        string Statements '';
        if (and (defined [my Block Fallback_Statements])
                (sgt [my Block Fallback_Statements] ''))
        {
            = Statements [my Block Fallback_Statements];
        }
        string Ancestor_Name 'Symbol';
        string Type [my Value_Type Fallback];
        string Body
            `{` [line, indent]
                `property entity Symbol_Entity;` [line, indent]
                `property ` Type ` Symbol_Value;` [line, indent]
                `constructor [entity Entity]` [line, indent]
                `{` [line, indent 2]
                    `my= Symbol_Entity Entity;` [line, indent]
                `}` [line]
            Statements
            `}`;
        string Code 'class ' Class_Name ' [is ' Ancestor_Name ']' Body;
        my= Fallback Code;
    }
}

statement Contest contest Class
{
    argument Class_Name;
    method void Fallback_Generate
    {
        string Class_Name 'Contest_' [my Class_Name Fallback];
        string Statements '';
        if (and (defined [my Block Fallback_Statements])
                (sgt [my Block Fallback_Statements] ''))
        {
            = Statements [my Block Fallback_Statements];
        }
        string Ancestor_Name 'Contest';
        string Body
            `{` [line, indent]
                `attribute number Score;` [line, indent]
                `attribute entity Winner;` [line]
            Statements
            `}`;
        string Code 'class ' Class_Name ' [is ' Ancestor_Name ']' Body;
        my= Fallback Code;
    }
}

statement Currency currency Class
{
    argument Class_Name;
    method void Fallback_Generate
    {
        string Class_Name 'Currency_' [my Class_Name Fallback];
        string Statements '';
        if (and (defined [my Block Fallback_Statements])
                (sgt [my Block Fallback_Statements] ''))
        {
            = Statements [my Block Fallback_Statements];
        }
        string Ancestor_Name 'Currency';
        string Body
            `{` [line, indent]
                `class.attribute list Instances;` [line, indent]
                `attribute number Amount;` [line, indent]
                `attribute entity Owner;` [line, indent]
                `constructor` [line, indent]
                `{` [line, indent 2]
                `list.append [. [my.class] Instances] [self];` [line, indent 2]
                `` [line, indent]
                `}` [line]
            Statements
            `}`;
        string Code 'class ' Class_Name ' [is ' Ancestor_Name ']' Body;
        my= Fallback Code;
    }
}

statement Principle principle Scoped
{
    argument Name;
    method void Gal_Generate
    {
        string Body_Code '';
        string Class_Code '';
        entity Statement;
        foreach [my Block Statements] Statement
        {
            if (isa Statement Class_Statement) 
            {
                append Class_Code [. Statement Gal] [line];
            }
            else
            {
                append Body_Code [. Statement Gal] [line];
            }
        }
        comment 'separation due to apparent bug in bootstrap compiler.';
        string Code [line] 'class Principle_' [my Name Gal] [line] '{' [line];
        append Code Body_Code '}' [line 2];
        append Code Class_Code [line];
        append Code 'comment "Principle ' [my Name Gal] ' ends.";' [line 2];
        my= Gal_Statements Code;
        my= Gal Code;
    }
}

statement English english Line
{
    method void Fallback_Generate
    {
        string Args (i Fallback_Arguments);
        if (gt (list.length [my Arguments]) 1)
        {
            = Args (append '(append ' Args ')');
        }
        string Code 'class.property string English ' Args ';';
        my= Fallback '';
        my= Fallback_Declaration Code;
    }
}

statement Require_That require.that Line
{
    argument Condition;
    fallback 'returnif (not ' [my Condition Fallback] ') [false];';
}

statement Require_That_I require.that.i Line
{
    fallback 'returnif (not (i ' (i Fallback_Arguments) ')) [false];';
}

statement Dialect dialect Scoped
{
    argument Name 'string';
    optional English 'string';
    method flag Fallback_Generate
    {
        string Name [my Name Fallback];
        string Body '';
        string Fback '';
        if (defined [my English])
        {
            append Body 'property string English ' [my English Fallback] ';' [line];
        }
        entity Statement;
        foreach [my Block Statements] Statement
        {
            if (defined [. Statement Fallback_Declaration])
            {
                append Body [. Statement Fallback_Declaration] [line];
            }
            if (defined [. Statement Fallback])
            {
                append Fback [. Statement Fallback] [line];
            }
        }
        string Method 
            'method flag Initialize'  [line] '{' [line] 
                (i Indent Fback) [line, indent] 
                'return [true];' [line]
                '}';

        = Body (i Indent Body);
        = Method (i Indent Method);
        string Code 'class Dialect_' Name ' [is Dialect]' [line] '{' [line]
                (i Indent Method)
                (i Indent Body)
            '}' [line];
        my= Fallback Code;
    }
}

statement Statements statements Line
{
    method flag Fallback_Generate
    {
        entity Arg;
        string Statement 'ERROR_UNKNOWN_STATEMENT';
        string Keyword 'ERROR_UNKNOWN_KEYWORD';
        string Code '';
        foreach [my Arguments] Arg
        {
            contif (isa Arg Token_Comma);
            if (isa Arg Quote) {
                = Keyword [. Arg Fallback];
                append Code 'dict.= [my Statements] ' Keyword ' (new ' Statement ');' [line];
            }
            else.if (isa Arg Token_Name) {
                = Statement [. Arg Fallback];
            }
            else
            {
                error 'unexpected statements argument';
            }
        }
        my= Fallback Code;
    }
}

statement Operations operations Line
{
    method flag Fallback_Generate
    {
        entity Arg;
        string Operation 'ERROR_UNKNOWN_OPERATION';
        string Keyword 'ERROR_UNKNOWN_KEYWORD';
        string Code '';
        foreach [my Arguments] Arg
        {
            contif (isa Arg Token_Comma);
            if (isa Arg Quote) {
                = Keyword [. Arg Fallback];
                append Code 'dict.= [my Operations] ' Keyword ' (new ' Operation ');' [line];
            }
            else.if (isa Arg Token_Name) {
                = Operation [. Arg Fallback];
            }
            else
            {
                error 'unexpected operations argument';
            }
        }
        my= Fallback Code;
    }
}

statement Syntaxes syntaxes Line
{
    method flag Fallback_Generate
    {
        entity Arg;
        string Syntax 'ERROR_UNKNOWN_SYNTAX';
        string Keyword 'ERROR_UNKNOWN_KEYWORD';
        string Code '';
        foreach [my Arguments] Arg
        {
            contif (isa Arg Token_Comma);
            if (isa Arg Quote) {
                = Keyword [. Arg Fallback];
                append Code 'dict.= [my Syntaxes] ' Keyword ' (new ' Syntax ');' [line];
            }
            else.if (isa Arg Token_Name) {
                = Syntax [. Arg Fallback];
            }
            else
            {
                error 'unexpected syntaxes argument';
            }
        }
        my= Fallback Code;
    }
}

statement Requirement requirement Scoped
{
    argument Class_Name;
    method void Fallback_Generate
    {
        string Name [my Class_Name Fallback];
        string Full_Name 'Requirement_' Name;

        string Fallback_Lines '';
        string Fallback_Declarations '';

        entity Statement;
        foreach [my Block Statements] Statement
        {
            append Fallback_Lines [. Statement Fallback] [line];
            if (defined [. Statement Fallback_Declaration])
            {
                comment append Fallback_Declarations [. Statement Fallback_Declaration] [line];
            }
        }

        string Fallback_Block [line] '{' [line] (i Indent Fallback_Declarations) '}';

        string Code 'class ' Full_Name ' [is Requirement]' Fallback_Block;
        append Code Fallback_Lines;
        my= Fallback Code;
    }       
}

statement Spell spell Scoped
{
    argument Class_Name;
    method void Fallback_Generate
    {
        string Name [my Class_Name Fallback];
        string Full_Name 'Spell_' Name;

        string Fallback_Lines '';
        string Fallback_Declarations '';

        entity Statement;
        foreach [my Block Statements] Statement
        {
            append Fallback_Lines [. Statement Fallback] [line];
            if (defined [. Statement Fallback_Declaration])
            {
                comment append Fallback_Declarations [. Statement Fallback_Declaration] [line];
            }
        }

        string Fallback_Block [line] '{' [line] (i Indent Fallback_Declarations) '}';

        string Code 'class ' Full_Name ' [is Spell]' Fallback_Block;
        append Code Fallback_Lines;
        my= Fallback Code;
    }       
}

statement Goal goal Scoped
{
    argument Class_Name;
    method void Fallback_Generate
    {
        string Name [my Class_Name Fallback];
        string Full_Name 'Goal_' Name;

        string Fallback_Lines '';
        string Fallback_Declarations '';

        entity Statement;
        foreach [my Block Statements] Statement
        {
            append Fallback_Lines [. Statement Fallback] [line];
            if (defined [. Statement Fallback_Declaration])
            {
                comment append Fallback_Declarations [. Statement Fallback_Declaration] [line];
            }
        }

        string Fallback_Block [line] '{' [line] (i Indent Fallback_Declarations) '}';

        string Code 'class ' Full_Name ' [is Goal]' Fallback_Block;
        append Code Fallback_Lines;
        my= Fallback Code;
    }       
}

syntax Class_Lookup lookup
{
    argument Name;
    fallback '(. [: Compiler Instance] Get_Class ' [my Name Fallback] ')';
}

statement File_Copy file.copy Line
{
    argument Source_File;
    argument Target_File;
    fallback 
        `shell 'cp "` 
        (. [my Source_File] Unquoted) 
        `" "` 
        (. [my Target_File] Unquoted)
        `"';`;
}

statement File_Append_File file.append.file Line
{
    argument Source_File;
    argument Target_File;
    fallback 
        `shell 'cat "` 
        (. [my Source_File] Unquoted) 
        `">>"` 
        (. [my Target_File] Unquoted)
        `"';`;
}

operation File_Exists file.exists
{
    argument File_Name;
    python 'gal.file_exists(' [my File_Name Python] ')';
    javascript 'gal.file_exists(' [my File_Name Javascript] ');';
}

statement Infers infers Line
{
    argument Inference;
    method void Model
    {
        string Inference_Name [my Inference Input];
        string Class_Name 'Unknown';
        if (defined [my Class_Context])
        {
            = Class_Name [my Class_Context Class_Name Input];
        }
        else.if (and (defined [my Parent]) (defined [my Parent Class_Name]))
        {
            = Class_Name [my Parent Class_Name Input];
        }
        entity Owner_Class (. [: Compiler Instance] Get_Class Class_Name);
        if (and Owner_Class (defined [. Owner_Class Infer_Inits]))
        {
            append [. Owner_Class Infer_Inits] 
                'list.append [my Inferences Symbol_Value] (new Inference_' Inference_Name ' [self]);' [line];
        }
    }
    method void Fallback_Generate
    {
        my= Fallback '';
    }
}

statement Infer_Inits infer.inits Line
{
    method void Fallback_Generate
    {
        string Class_Name [my Class_Context Class_Name Fallback];
        entity Owner_Class (. [: Compiler Instance] Get_Class Class_Name);
        my= Fallback [. Owner_Class Infer_Inits];
    }
}

syntax Symbol attribute
{
    method void Fallback_Generate
    {
        entity Arg;
        string Code '[. ';
        foreach [my Arguments] Arg
        {
            append Code ' ' [. Arg Fallback];
        }
        append Code ' Symbol_Value]';
        my= Fallback Code;
    }
}

syntax Class_Symbol class.attribute
{
    method void Fallback_Generate
    {
        entity Arg;
        string Code '[: ';
        foreach [my Arguments] Arg
        {
            append Code ' ' [. Arg Fallback];
        }
        append Code ' Symbol_Value]';
        my= Fallback Code;
    }
}

syntax My_Symbol my.attribute
{
    method void Fallback_Generate
    {
        entity Arg;
        string Code '[my ';
        foreach [my Arguments] Arg
        {
            append Code ' ' [. Arg Fallback];
        }
        append Code ' Symbol_Value]';
        my= Fallback Code;
    }
}

statement Goalspell goalspell Scoped
{
    argument Name;
    argument Description;
    fallback 'goal ' [my Name Fallback] ' ' [my Description Fallback] ';' [line]
        'spell ' [my Name Fallback] (i Fallback_Block);
}

class Statement_Read_Character [is Line_Statement]
{
    class.property string Gal_Keyword 'read.char';
    class.property string Goalspell_Keyword 'read.char';
    property entity Variable;
    method void Python_Generate
    {
        string Python_Code [my Variable Python] ' = gal.read_char()' [line];
        my= Python Python_Code;
    }
    method void Javascript_Generate
    {
        string Javascript_Code [my Variable Javascript] ' = gal.read_char();' [line];
        my= Javascript Javascript_Code;
    }
    comment "c '// TODO: read character ' Variable [line];";
    method void Mumps_Generate
    {
        string Mumps_Code 'read *' [my Variable Mumps] [line];
        my= Mumps Mumps_Code;
    }
    method void Attributes
    {
        if (= (list.length [. [me] Listargs]) 0)
        {
            error 'missing required Variable';
        }
        .= [me] Variable (list.shift [. [me] Listargs]);
    }
}

class Statement_Read_Character_Timed [is Line_Statement]
{
    class.property string Gal_Keyword 'read.char.timed';
    class.property string Goalspell_Keyword 'read.char.timed';
    property entity Variable;
    property entity Timeout;
    method void Python_Generate
    {
        string Python_Code [my Variable Python] ' = gal.read_char_timed(' [my Timeout Python] ')' [line];
        my= Python Python_Code;
    }
    comment "c '// TODO: read character ' Variable ' timeout ' Timeout [line];";
    method void Mumps_Generate
    {
        string Mumps_Code [indent] 'read *' [my Variable Mumps] ':' [my Timeout Mumps] [line] [indent] 'set ' [my Variable Mumps] '=$char(' [my Variable Mumps] ')' [line];
        my= Mumps Mumps_Code;
    }
    method void Attributes
    {
        if (= (list.length [. [me] Listargs]) 0)
        {
            error 'missing required Variable';
        }
        .= [me] Variable (list.shift [. [me] Listargs]);
        if (= (list.length [. [me] Listargs]) 0)
        {
            error 'missing required Timeout';
        }
        .= [me] Timeout (list.shift [. [me] Listargs]);
    }
}

statement Feature feature Symbol
{
    argument Type;
    argument Name;
    argument Keyword;
    argument Symbol_Class;

    fallback [line] 
        'symbol ' [my Type Fallback] ' ' [my Name Fallback] ' ' [my Symbol_Class Fallback] 
            (i Fallback_Block) [line] 
        'statement ' [my Name Fallback] ' ' [my Keyword Fallback] ' Feature_Assignment' [line] '{' [line, indent] 
            'property string Property_Name ' (i Enquote [my Name Fallback]) ';' [line, indent] 
            `fallback 'entity.new ' ` [my Name Fallback] ` ' ' ` [my Symbol_Class Fallback] ` (i Fallback_Args) ';' [line]` [line,indent 2] 
                `[my Block Fallback_Statements];` [line] '}' [line];
}

statement Thing thing Symbol
{
    argument Name;
    argument Keyword;

    fallback [line]
        'class Thing_' [my Name Fallback]
            (i Fallback_Block) [line] 
        'statement ' [my Name Fallback] ' ' [my Keyword Fallback] ' Entity_Definition' [line] '{' [line, indent] 
            `fallback 'entity.new ' ` [my Name Fallback] ` ' ' Thing_` [my Name Fallback] ` (i Fallback_Args) ';' [line]` [line, indent 2] 
                `[my Block Fallback_Statements];` [line] '}' [line];
}

statement Camera camera Entity_Definition
{
    property string Class_Name 'Camera';
    argument Name;
}

statement Scene scene Entity_Definition
{
    property string Class_Name 'Scene';
    argument Name;
}

statement Box box Entity_Definition
{
    property string Class_Name 'Box';
    argument Name;
}

statement Position position Entity_Definition
{
    property string Class_Name 'Position';
    argument Name;
}

statement Animation animation Entity_Definition
{
    property string Class_Name 'Animation';
    argument Name;
}

statement Center center List_Feature
{
    property string Property_Name 'Center';
    property string Class_Name 'List';
}

statement Color color List_Feature
{
    property string Property_Name 'Color';
    property string Class_Name 'List';
}
statement Rotation rotation List_Feature
{
    property string Property_Name 'Rotation';
    property string Class_Name 'List';
}
statement Size size List_Feature
{
    property string Property_Name 'Size';
    property string Class_Name 'List';
}
statement Texture texture Feature_Assignment
{
    property string Property_Name 'Texture';
    property string Class_Name 'String';
}
statement X x Feature_Assignment
{
    property string Property_Name 'X';
    property string Class_Name 'Number';
}
statement Y y Feature_Assignment
{
    property string Property_Name 'Y';
    property string Class_Name 'Number';
}
statement Z z Feature_Assignment
{
    property string Property_Name 'Z';
    property string Class_Name 'Number';
}

syntax Red red
{
    method void Javascript_Generate
    {
        debug;
        writeline 'Generate Javascript for red';
    }
}

statement Resource resource Feature_Assignment
{
    property string Property_Name 'Resource';
    property string Class_Name 'String';
}

statement Workaround workaround Feature_Assignment
{
    property string Property_Name 'Workaround';
    property string Class_Name 'String';
}

statement Status status Feature_Assignment
{
    property string Property_Name 'Status';
    property string Class_Name 'String';
}
statement Start start Feature_Assignment
{
    property string Property_Name 'Start';
    property string Class_Name 'Date';
}
statement End end Feature_Assignment
{
    property string Property_Name 'End';
    property string Class_Name 'Date';
}

statement Foo foo Entity_Definition
{
    property string Class_Name 'Foo';
    argument Name;
}

statement Bar bar Feature_Assignment
{
    property string Property_Name 'Bar';
    property string Class_Name 'String';
}
comment 'Goal.gal';

statement Tilda ~ Invocation
{
    argument Definition 'entity';
    fallback '. [. ' [my Definition Fallback] ' Implementor]' (i Fallback_Args) ';';
}

operation Tilda ~ Invocation
{
    argument Definition 'entity';
    fallback '(. [. ' [my Definition Fallback] ' Implementor]' (i Fallback_Args) ')';
}

syntax Tilda ~
{
    argument Definition 'entity';
    fallback '[. ' [my Definition Fallback] ' Implemetor' (i Fallback_Args) ']';
}

statement TildaI ~i Invocation
{
    argument Method 'method';
    fallback '. [. [self] Implementor] ' [my Method Fallback] (i Fallback_Args) ';';
}
operation TildaI ~i Invocation
{
    argument Method 'method';
    fallback '(. [. [self] Implementor] ' [my Method Fallback] (i Fallback_Args) ')';
}
syntax TildaI ~i
{
    fallback '[. [. [self] Implementor] ' (i Fallback_Args) ']';
}

statement Interface interface Interface
{
    argument Interface_Name;
    method void Fallback_Generate
    {
        string Owner_Class [my Class_Context Class_Name];
        replace Owner_Class ':' '';
        string Class_Name [my Interface_Name Fallback];
        replace Class_Name ':' '';
        string Interface_Name "'" Class_Name "'";
        comment `= Class_Name (append ":Interface_" Owner_Class "_" Class_Name)`;
        string Kludge ":Interface_" Owner_Class;
        append Kludge "_" Class_Name;
        = Class_Name Kludge;
        comment 'Generate the interface class as specified.';
        string Class_Args (i Fallback_Args);
        string Class_Body (i Fallback_Block);
        string Class_Code 'class ' Class_Name Class_Args ' [is Interface]' Class_Body;
        comment 'Generate goal interface class property assignment.';
        string Interface_Assignment 'class.property ' Interface_Name ' [: ' Class_Name '];' [line]; 
        my= Fallback_Declaration Interface_Assignment;
        my= Fallback Class_Code;
    }
}

statement Implementor implementor Line
{
    argument Interface;
    argument Implementor;
    method void Fallback_Generate
    {
        string Interface_Fallback "'" [my Interface Fallback] "'";
        string Implementor_Fallback [my Implementor Fallback];
        string Interface_Assignment 'dict.assign [classprop Interfaces] ' Interface_Fallback ' ' Implementor_Fallback ';'; 
        my= Fallback Interface_Assignment;
    }
}

statement Attribute attribute Property
{
    argument Data_Type;
    argument Property_Name;
    optional Class_Name;
    method entity Inference_Context
    {
    	return [me];
    }
    method void Fallback_Generate
    {
        string Property_Fallback [my Property_Name Fallback];
        string Type_Fallback [my Data_Type Fallback];
        string Ancestor_Fallback 'Attribute';
        string Class_Fallback;
        if (defined [my Class_Name])
        {
            = Class_Fallback [my Class_Name Fallback];
        }
        else
        {
            string Type_Name (upper (firstchar Type_Fallback)) (substring Type_Fallback 1);
            = Class_Fallback Type_Name;
        }
        string Code 'property entity ' Property_Fallback ' (new ' Class_Fallback ' [self]);' [line];
        my= Fallback Code;
    }
}

statement Class_Attribute class.attribute Property
{
    argument Data_Type;
    argument Property_Name;
    optional Class_Name;
    method entity Inference_Context
    {
    	return [me];
    }
    method void Fallback_Generate
    {
        string Property_Fallback [my Property_Name Fallback];
        string Type_Fallback [my Data_Type Fallback];
        string Ancestor_Fallback 'Attribute';
        string Class_Fallback;
        if (defined [my Class_Name])
        {
            = Class_Fallback [my Class_Name Fallback];
        }
        else
        {
            string Type_Name (upper (firstchar Type_Fallback)) (substring Type_Fallback 1);
            = Class_Fallback Type_Name;
        }
        comment `Class Property entities don't know their owner!`;
        string Code 'class.property entity ' Property_Fallback ' (new Class_' Class_Fallback ');' [line];
        my= Fallback Code;
    }
}

statement Behavior behavior Method
{
    method void Fallback_Generate
    {
        string Code 'method' (i Fallback_Args) (i Fallback_Block);
        my= Fallback Code;
    }
}

syntax Attribute attribute
{
    alias att get value;
    fallback '[. ' (i Fallback_Args) ' Attribute_Value]';
}

syntax Certainty certainty
{
    alias cert;
    fallback '[. ' (i Fallback_Args) ' Attribute_Certainty]';
}

class Statement_Old_Goal [is Goal_Statement]
{
    class.property string Gal_Keyword 'goal';
    class.property string Gs_Keyword 'goal';
    property entity Class_Name;
    method void Fallback_Generate
    {
        string Name [my Class_Name Fallback];
        string Definitions '';
        string Subgoals '';
        entity Statement;
        foreach [my Block Statements] Statement
        {
            string Definition [. Statement Fallback_Declaration];
            string Subgoal [. Statement Fallback];
            if (not.null Definition)
            {
                append Definitions Definition [line];
            }
            if (not.null Subgoal)
            {
                append Subgoals Subgoal [line];
            }
        }
        string Code 'class Goal_' Name ' [is Goal]' [line] '{' [line] (. [self] Indent Definitions) '}' (. [self] Indent Subgoals) 'comment `End of Goal_' Name ' scope.`;' [line 2];
        .= [self] Fallback Code;
        my= Fallback_Declaration (append 'property entity Goal_' Name ' (new Goal_' Name ');');
    }
    method void Attributes
    {
        if (= (list.length [. [me] Listargs]) 0)
        {
            error 'missing required Class_Name';
        }
        .= [me] Class_Name (list.shift [. [me] Listargs]);
    }
}

class  Statement_Test [is Goal_Statement]
{
    class.property string Gal_Keyword 'test';
    class.property string Gs_Keyword 'test';
    property entity Class_Name;
    method void Fallback_Generate
    {
        string Name [my Class_Name Fallback];
        string Definitions '';
        string Subgoals '';
        entity Statement;
        foreach [my Block Statements] Statement
        {
            string Definition [. Statement Fallback_Declaration];
            string Subgoal [. Statement Fallback];
            if (not.null Definition)
            {
                append Definitions Definition [line];
            }
            if (not.null Subgoal)
            {
                append Subgoals Subgoal [line];
            }
        }
        string Args (. [self] Fallback_Args);
        string Code 'goal Test_' Name ' ' Args [line] '{' [line] (. [self] Indent Definitions) '}' (. [self] Indent Subgoals) 'comment `End of Test_' Name ' scope.`;' [line 2];
        .= [self] Fallback Code;
        my= Fallback_Declaration (append 'property entity Goal_' Name ' (new Goal_' Name ');');
    }
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required Class_Name';
        }
        my= Class_Name (shift [my Listargs]);
    }
}

comment 'Factory.gal';

class Factory
{
    class.property hash Element_Index;
    class.method void Add_Index [entity Element]
    {
        try
        {
            increment [key [classprop Element_Index] [classname Element]];
        }
        catch
        {
            = [key [classprop Element_Index] [classname Element]] 1;
        }
    }
    class.method entity Create_Token [string Char, string Next, integer Position]
    {
        entity New_Token;
        if (: Token_Operation_Start Predict Char Next)
        {
            new New_Token Token_Operation_Start;
        }
        else.if (: Token_Operation_End Predict Char Next)
        {
            new New_Token Token_Operation_End;
        }
        else.if (: Token_Syntax_Start Predict Char Next)
        {
            new New_Token Token_Syntax_Start;
        }
        else.if (: Token_Syntax_End Predict Char Next)
        {
            new New_Token Token_Syntax_End;
        }
        else.if (: Token_Block_Start Predict Char Next)
        {
            new New_Token Token_Block_Start;
        }
        else.if (: Token_Block_End Predict Char Next)
        {
            new New_Token Token_Block_End;
        }
        else.if (: Token_Semi Predict Char Next)
        {
            new New_Token Token_Semi;
        }
        else.if (: Token_Comma Predict Char Next)
        {
            new New_Token Token_Comma;
        }
        else.if (: Token_Class_Name Predict Char Next)
        {
            new New_Token Token_Class_Name;
        }
        else.if (: Token_Name Predict Char Next)
        {
            new New_Token Token_Name;
        }
        else.if (: Token_Keyvalue_Start Predict Char Next)
        {
            new New_Token Token_Keyvalue_Start;
        }
        else.if (: Token_Keyvalue_End Predict Char Next)
        {
            new New_Token Token_Keyvalue_End;
        }
        else.if (: Quote Predict Char Next)
        {
            new New_Token Quote;
        }
        else.if (: Token_Space Predict Char Next)
        {
            new New_Token Token_Space;
        }
        else.if (: Number Predict Char Next)
        {
            new New_Token Number;
        }
        else
        {
            new New_Token Token_Name;
        }

        .= New_Token Input Char;
        .= New_Token Start_Position Position;
        .= New_Token End_Position Position;
        : Factory Add_Index New_Token;

        return New_Token;
    }

    class.method entity Create_Statement [entity Input_Token, entity Next, entity Document, entity Parent_Element]
    {
        string Verb ' ' (lowercase [. Input_Token Input]) ' ';
        entity Element;
        if (contains ' = assign ' Verb) { new Element Statement_Assign; }
        else.if (contains ' . call ' Verb) { new Element Statement_Call; }
        else.if (contains ' : c. ' Verb) { new Element Statement_Colon; }
        else.if (contains ' .= property.assign property.set propset ' Verb) { new Element Statement_Propset; }
        else.if (contains ' := cp.= classpropset ' Verb) { new Element Statement_Classpropset; }
        else.if (contains ' ~ tilda ' Verb) { new Element Statement_Tilda; }
        else.if (contains ' ~i tildai ' Verb) { new Element Statement_TildaI; }
        else.if (contains ' add + += ' Verb) { new Element Statement_Add; }
        else.if (contains ' and & &= ' Verb) { new Element Statement_And; }
        else.if (contains ' alias ' Verb) { new Element Statement_Alias; }
        else.if (contains ' answer ' Verb) { new Element Statement_Answer; }
        else.if (contains ' append string.append s+ ' Verb) { new Element Statement_Append; }
        else.if (contains ' argument ' Verb) { new Element Statement_Argument; }
        else.if (contains ' arguments ' Verb) { new Element Statement_Arguments; }
        else.if (contains ' atomic ' Verb) { new Element Statement_Atomic; }
        else.if (contains ' attribute ' Verb) { new Element Statement_Attribute; }
        else.if (contains ' behavior ' Verb) { new Element Statement_Behavior; }
        else.if (contains ' break ' Verb) { new Element Statement_Break; }
        else.if (contains ' break.if breakif ' Verb) { new Element Statement_Breakif; }
        else.if (contains ' catch ' Verb) { new Element Statement_Catch; }
        else.if (contains ' class class.append class.addendum ' Verb) { new Element Statement_Class; }
        else.if (contains ' class.attribute ' Verb) { new Element Statement_Class_Attribute; }
        else.if (contains ' class.method classmethod ' Verb) { new Element Statement_Class_Method; }
        else.if (contains ' class.property classprop setting our ' Verb) { new Element Statement_Class_Property; }
        else.if (contains ' comment ' Verb) { new Element Statement_Comment; }
        else.if (contains ' constructor ' Verb) { new Element Statement_Constructor; }
        else.if (contains ' contest ' Verb) { new Element Statement_Contest; }
        else.if (contains ' continue ' Verb) { new Element Statement_Continue; }
        else.if (contains ' continue.if contif ' Verb) { new Element Statement_Contif; }
        else.if (contains ' currency ' Verb) { new Element Statement_Currency; }
        else.if (contains ' debug d debugger; ' Verb) { new Element Statement_Debug; }
        else.if (contains ' debugif di ' Verb) { new Element Statement_Debug_If; }
        else.if (contains ' debug.stack ds ' Verb) { new Element Statement_Debug_Stack; }
        else.if (contains ' debug.variable dv ' Verb) { new Element Statement_Debug_Variable; }
        else.if (contains ' definition ' Verb) { new Element Statement_Definition; }
        else.if (contains ' dialect ' Verb) { new Element Statement_Dialect; }
        else.if (contains ' dictionary dict hash ' Verb) { new Element Statement_Dictionary; }
        else.if (contains ' dictionary.= dict.= hash.= dictionary.assign dict.assign hash.assign ' Verb) { new Element Statement_Dictionary_Assign; }
        else.if (contains ' either ' Verb) { new Element Statement_Either; }
        else.if (contains ' else ' Verb) { new Element Statement_Else; }
        else.if (contains ' else.if elsif elseif ' Verb) { new Element Statement_Else_If; }
        else.if (contains ' english ' Verb) { new Element Statement_English; }
        else.if (contains ' entities ' Verb) { new Element Statement_Entities; }
        else.if (contains ' entity object ' Verb) { new Element Statement_Entity; }
        else.if (contains ' entity.my.class entity.myclass entity.self.class entity.selfclass object.my.class object.myclass object.self.class object.selfclass ' Verb) { new Element Statement_Entity_My_Class; }
        else.if (contains ' entity.new new.entity object.new new.object ' Verb) { new Element Statement_Entity_New; }
        else.if (contains ' error raise throw ' Verb) { new Element Statement_Error; }
        else.if (contains ' either ' Verb) { new Element Statement_Either; }
        else.if (contains ' fallback ' Verb) { new Element Statement_Fallback; }
        else.if (contains ' infer.inits ' Verb) { new Element Statement_Infer_Inits; }
        else.if (contains ' flag boolean bool ' Verb) { new Element Statement_Flag; }
        else.if (contains ' file.append ' Verb) { new Element Statement_File_Append; }
        else.if (contains ' file.append.file ' Verb) { new Element Statement_File_Append_File; }
        else.if (contains ' file.copy.file file.copy ' Verb) { new Element Statement_File_Copy; }
        else.if (contains ' file.readall readall ' Verb) { new Element Statement_File_Readall; }
        else.if (contains ' file.dump ' Verb) { new Element Statement_File_Dump; }
        else.if (contains ' for.range ' Verb) { new Element Statement_For_Range; }
        else.if (contains ' foreach list.foreach ' Verb) { new Element Statement_Foreach; }
        else.if (contains ' forever ' Verb) { new Element Statement_Forever; }
        else.if (contains ' forgive ' Verb) { new Element Statement_Forgive; }
        else.if (contains ' forward ' Verb) { new Element Statement_Forward; }
        else.if (contains ' gal general.abstract.language general_abstract_language ' Verb) { new Element Statement_Gal; }
        else.if (contains ' generate ' Verb) { new Element Statement_Generate; }
        else.if (contains ' goalspell ' Verb) { new Element Statement_Goalspell; }
        else.if (contains ' gs ' Verb) { new Element Statement_Gs; }
        else.if (contains ' isa is_a handle classify ' Verb) { new Element Statement_Classify; }
        else.if (contains ' i self me this ' Verb) { new Element Statement_I; }
        else.if (contains ' if ' Verb) { new Element Statement_If; }
        else.if (contains ' ifdef ' Verb) { new Element Statement_Ifdef; }
        else.if (contains ' infer ' Verb) { new Element Statement_Infer; }
        else.if (contains ' flowerbox ' Verb) { new Element Statement_Flowerbox; }
        else.if (contains ' increment ++ ' Verb) { new Element Statement_Increment; }
        else.if (contains ' integer int ' Verb) { new Element Statement_Integer; }
        else.if (contains ' inference ' Verb) { new Element Statement_Inference; }
        else.if (contains ' infers ' Verb) { new Element Statement_Infers; }
        else.if (contains ' integers ints ' Verb) { new Element Statement_Integers; }
        else.if (contains ' iterate dict.iterate dictionary.iterate hash.iterate ' Verb) { new Element Statement_Iterate; }
        else.if (contains ' javascript ' Verb) { new Element Statement_Javascript; }
        else.if (contains ' join list.join ' Verb) { new Element Statement_Join; }
        else.if (contains ' keyword ' Verb) { new Element Statement_Keyword; }
        else.if (contains ' know import use include ' Verb) { new Element Statement_Know; }
        else.if (contains ' gal.language ' Verb) { new Element Statement_Gal_Language; }
        else.if (contains ' list ' Verb) { new Element Statement_List; }
        else.if (contains ' list.append push list.push ' Verb) { new Element Statement_List_Append; }
        else.if (contains ' list.delete list.remove list.splice ' Verb) { new Element Statement_List_Delete; }
        else.if (contains ' list.copy ' Verb) { new Element Statement_List_Copy; }
        else.if (contains ' main ' Verb) { new Element Statement_Main; }
        else.if (contains ' method ' Verb) { new Element Statement_Method; }
        else.if (contains ' module ' Verb) { new Element Statement_Module; }
        else.if (contains ' mumps ' Verb) { new Element Statement_Mumps; }
        else.if (contains ' my= my.= self.= ' Verb) { new Element Statement_My_Equal; }
        else.if (contains ' i= it= self= ' Verb) { new Element Statement_I_Equal; }
        else.if (contains ' new ' Verb) { new Element Statement_New; }
        else.if (contains ' number ' Verb) { new Element Statement_Number; }
        else.if (contains ' numbers ' Verb) { new Element Statement_Numbers; }
        else.if (contains ' oho optimize.human.outcome optimize_human_outcome' Verb) { new Element Statement_Oho; }
        else.if (contains ' operation ' Verb) { new Element Statement_Operation; }
        else.if (contains ' operations ' Verb) { new Element Statement_Operations; }
        else.if (contains ' optional ' Verb) { new Element Statement_Optional; }
        else.if (contains ' our.= our= us.= us= ' Verb) { new Element Statement_Our_Equal; }
        else.if (contains ' parser ' Verb) { new Element Statement_Parser; }
        else.if (contains ' principle ' Verb) { new Element Statement_Principle; }
        else.if (contains ' property my ' Verb) { new Element Statement_Property; }
        else.if (contains ' python ' Verb) { new Element Statement_Python; }
        else.if (contains ' question ' Verb) { new Element Statement_Question; }
        else.if (contains ' readline read.line ' Verb) { new Element Statement_Read_Line; }
        else.if (contains ' replace string.replace ' Verb) { new Element Statement_Replace; }
        else.if (contains ' requirement ' Verb) { new Element Statement_Requirement; }
        else.if (contains ' spell ' Verb) { new Element Statement_Spell; }
        else.if (contains ' goal ' Verb) { new Element Statement_Goal; }
        else.if (contains ' read.char ' Verb) { new Element Statement_Read_Character; }
        else.if (contains ' read.char.timed ' Verb) { new Element Statement_Read_Character_Timed; }
        else.if (contains ' return ' Verb) { new Element Statement_Return; }
        else.if (contains ' require.that ' Verb) { new Element Statement_Require_That; }
        else.if (contains ' require.that.i ' Verb) { new Element Statement_Require_That_I; }
        else.if (contains ' return.if returnif ' Verb) { new Element Statement_Return_If; }
        else.if (contains ' sequence ' Verb) { new Element Statement_Sequence; }
        else.if (contains ' sort ' Verb) { new Element Statement_Sort; }
        else.if (contains ' protocol ' Verb) { new Element Statement_Old_Goal; }
        else.if (contains ' skiptoken skip.token ' Verb) { new Element Statement_Skip_Token; }
        else.if (contains ' statement ' Verb) { new Element Statement_Statement; }
        else.if (contains ' statements ' Verb) { new Element Statement_Statements; }
        else.if (contains ' string ' Verb) { new Element Statement_String; }
        else.if (contains ' strings ' Verb) { new Element Statement_Strings; }
        else.if (contains ' symbol ' Verb) { new Element Statement_Symbol; }
        else.if (contains ' syntax ' Verb) { new Element Statement_Syntax; }
        else.if (contains ' syntaxes ' Verb) { new Element Statement_Syntaxes; }
        else.if (contains ' test ' Verb) { new Element Statement_Test; }
        else.if (contains ' todo ' Verb) { new Element Statement_Todo; }
        else.if (contains ' token ' Verb) { new Element Statement_Token; }
        else.if (contains ' token.append ' Verb) { new Element Statement_Token_Append; }
        else.if (contains ' newtoken ' Verb) { new Element Statement_New_Token; }
        else.if (contains ' tokenmode ' Verb) { new Element Statement_Token_Mode; }
        else.if (contains ' tokens ' Verb) { new Element Statement_Tokens; }
        else.if (contains ' try ' Verb) { new Element Statement_Try; }
        else.if (contains ' undef undefined ' Verb) { new Element Statement_Undef; }
        else.if (contains ' unless ' Verb) { new Element Statement_Unless; }
        else.if (contains ' variant ' Verb) { new Element Statement_Variant; }
        else.if (contains ' verb polymorph ' Verb) { new Element Statement_Verb; }
        else.if (contains ' verbose ' Verb) { new Element Statement_Verbose; }
        else.if (contains ' verbosity ' Verb) { new Element Statement_Verbosity; }
        else.if (contains ' we us ' Verb) { new Element Statement_We; }
        else.if (contains ' myclass ' Verb) { new Element Statement_Myclass; }
        else.if (contains ' while ' Verb) { new Element Statement_While; }
        else.if (contains ' write ' Verb) { new Element Statement_Write; }
        else.if (contains ' writeline say write.line ' Verb) { new Element Statement_Write_Line; }
        else.if (contains ' raku ' Verb) { new Element Statement_Raku; }
        comment 'Book Dialect';
        else.if (contains ' book ' Verb) { new Element Statement_Book; }
        else.if (contains ' chapter chap ' Verb) { new Element Statement_Chapter; }
        else.if (contains ' section ' Verb) { new Element Statement_Section; }
        else.if (contains ' overview ' Verb) { new Element Statement_Overview; }
        else.if (contains ' expository exposition expo ' Verb) { new Element Statement_Expository; }
        else.if (contains ' paragraph p ' Verb) { new Element Statement_Paragraph; }
        else.if (contains ' linux shell ' Verb) { new Element Statement_Shell; }
        else.if (contains ' summary summ ' Verb) { new Element Statement_Summary; }
        else.if (contains ' title ' Verb) { new Element Statement_Title; }
        else.if (contains ' description desc ' Verb) { new Element Statement_Description; }
        else.if (contains ' codefile code ' Verb) { new Element Statement_Codefile; }
        else.if (contains ' book.gal ' Verb) { new Element Statement_Book_Gal; }
        else.if (contains ' book.raku ' Verb) { new Element Statement_Book_Raku; }
        else.if (contains ' book.fallback ' Verb) { new Element Statement_Book_Fallback; }
        else.if (contains ' book.python ' Verb) { new Element Statement_Book_Python; }
        else.if (contains ' book.javascript ' Verb) { new Element Statement_Book_Javascript; }

        else.if (contains ' feature ' Verb) { new Element Statement_Feature; }
        else.if (contains ' thing ' Verb) { new Element Statement_Thing; }
        else.if (contains ' resource ' Verb) { new Element Statement_Resource; }
        else.if (contains ' task ' Verb) { new Element Statement_Task; }
        else.if (contains ' subtask ' Verb) { new Element Statement_Subtask; }
        else.if (contains ' workaround ' Verb) { new Element Statement_Workaround; }
        else.if (contains ' status ' Verb) { new Element Statement_Status; }
        else.if (contains ' start ' Verb) { new Element Statement_Start; }
        else.if (contains ' end ' Verb) { new Element Statement_End; }
        else.if (contains ' scene ' Verb) { new Element Statement_Scene; }
        else.if (contains ' camera ' Verb) { new Element Statement_Camera; }
        else.if (contains ' box ' Verb) { new Element Statement_Box; }
        else.if (contains ' position ' Verb) { new Element Statement_Position; }
        else.if (contains ' animation ' Verb) { new Element Statement_Animation; }
        else.if (contains ' center ' Verb) { new Element Statement_Center; }
        else.if (contains ' color ' Verb) { new Element Statement_Color; }
        else.if (contains ' rotation ' Verb) { new Element Statement_Rotation; }
        else.if (contains ' size ' Verb) { new Element Statement_Size; }
        else.if (contains ' texture ' Verb) { new Element Statement_Texture; }
        else.if (contains ' x ' Verb) { new Element Statement_X; }
        else.if (contains ' y ' Verb) { new Element Statement_Y; }
        else.if (contains ' z ' Verb) { new Element Statement_Z; }

        else
        {
            error "Unknown Statement '" [. Input_Token Input] "'";
        }
        list.append [. Element Elements] Input_Token;
        .= Element Verb [. Next Input];
        .= Element Start_Position [. Input_Token Start_Position];
        .= Element End_Position [. Input_Token End_Position];
        .= Element Document Document;
        .= Element Parent Parent_Element;
        .= Element Block (new Block);
        . Element Ensure_Block;
        return Element;

    }

    class.method entity Create_Operation [entity Input_Token, entity Next, entity Document, entity Parent_Element]
    {
        string Verb ' ' (lowercase [. Next Input]) ' ';
        entity Element;
        comment 'Numeric Operations';
        if (contains ' + add ' Verb) { new Element Operation_Add; }
        else.if (contains ' greater gt ' Verb) { new Element Operation_Greater; }
        else.if (contains ' greater.equal ge ' Verb) { new Element Operation_Greater_Equal; }
        else.if (contains ' divide div / ' Verb) { new Element Operation_Divide; }
        else.if (contains ' less lt ' Verb) { new Element Operation_Less; }
        else.if (contains ' less.equal le ' Verb) { new Element Operation_Less_Equal; }
        else.if (contains ' multiply mult * ' Verb) { new Element Operation_Multiply; }
        else.if (contains ' round ' Verb) { new Element Operation_Round; }
        else.if (contains ' subtract - ' Verb) { new Element Operation_Subtract; }

        comment 'Logical Operations';
        else.if (contains ' & and ' Verb) { new Element Operation_And; }
        else.if (contains ' equal = ' Verb) { new Element Operation_Equal; }
        else.if (contains ' != ne not.= not.equal ' Verb) { new Element Operation_Not_Equal; }
        else.if (contains ' not ! ' Verb) { new Element Operation_Not; }
        else.if (contains ' or | ' Verb) { new Element Operation_Or; }

        comment 'Invocation Operations';
        else.if (contains ' . call ' Verb) { new Element Operation_Call; }
        else.if (contains ' : cm class.method ' Verb) { new Element Operation_Colon; }
        else.if (contains ' i self me this ' Verb) { new Element Operation_I; }
        else.if (contains ' we ' Verb) { new Element Operation_We; }

        comment 'Class Operations';
        else.if (contains ' classpropget ' Verb) { new Element Operation_Classpropget; }
        else.if (contains ' new ' Verb) { new Element Operation_New; }

        comment 'Variable Operations';
        else.if (contains ' defined ' Verb) { new Element Operation_Defined; }
        else.if (contains ' isnull is.null ' Verb) { new Element Operation_Is_Null; }
        else.if (contains ' notnull not.null ' Verb) { new Element Operation_Not_Null; }

        comment 'Dictionary/Hash Operations';
        else.if (contains ' key.get dict.get dictionary.get hash.get ' Verb) { new Element Operation_Key_Get; }
        else.if (contains ' key.exists dict.exists dictionary.exists hash.exists ' Verb) { new Element Operation_Key_Exists; }

        comment 'String Operations';
        else.if (contains ' firstchar ' Verb) { new Element Operation_Firstchar; }
        else.if (contains ' is.whitespace whitespace ' Verb) { new Element Operation_Whitespace; }
        else.if (contains ' lastchar ' Verb) { new Element Operation_Lastchar; }
        else.if (contains ' lowercase lower ' Verb) { new Element Operation_Lowercase; }
        else.if (contains ' startswith starts.with starts begins beginswith begins.with ' Verb) { new Element Operation_Begins; }
        else.if (contains ' string ' Verb) { new Element Operation_String; }
        else.if (contains ' string.append append s.append s+ ' Verb) { new Element Operation_Append; }
        else.if (contains ' string.contains contains s.contains ' Verb) { new Element Operation_Contains; }
        else.if (contains ' string.equal string.eq seq s= s.= ' Verb) { new Element Operation_String_Equal; }
        else.if (contains ' string.greater string.gt s.gt sgt ' Verb) { new Element Operation_String_Greater; }
        else.if (contains ' string.greater.equal string.ge s.ge sge ' Verb) { new Element Operation_String_Greater_Equal; }
        else.if (contains ' string.length length s.length s.len len ' Verb) { new Element Operation_String_Length; }
        else.if (contains ' string.less string.lt s.lt slt ' Verb) { new Element Operation_String_Less; }
        else.if (contains ' string.less.equal string.le s.le sle ' Verb) { new Element Operation_String_Less_Equal; }
        else.if (contains ' string.not.equal string.ne s.ne sne s!= ' Verb) { new Element Operation_String_Not_Equal; }
        else.if (contains ' substring ' Verb) { new Element Operation_Substring; }
        else.if (contains ' uppercase upper ' Verb) { new Element Operation_Uppercase; }
        else.if (contains ' is.lowercase is.lower islower ' Verb) { new Element Operation_Is_Lowercase; }
        else.if (contains ' is.uppercase is.upper isupper ' Verb) { new Element Operation_Is_Uppercase; }
        else.if (contains ' isalpha ' Verb) { new Element Operation_Is_Alpha; }
        else.if (contains ' isident ' Verb) { new Element Operation_Is_Ident; }
        else.if (contains ' titlecase ' Verb) { new Element Operation_Uppercase; }

        comment 'Communication Operations';
        else.if (contains ' http.fetch fetch ' Verb) { new Element Operation_Http_Fetch; }

        comment 'Instance Operations';
        else.if (contains ' isa is.a ' Verb) { new Element Operation_Isa; }

        comment 'List Operations';
        else.if (contains ' list.get ' Verb) { new Element Operation_List_Get; }
        else.if (contains ' list.last ' Verb) { new Element Operation_List_Last; }
        else.if (contains ' list.length ' Verb) { new Element Operation_List_Length; }
        else.if (contains ' list.pop pop ' Verb) { new Element Operation_List_Pop; }
        else.if (contains ' list.shift shift ' Verb) { new Element Operation_List_Shift; }
        else.if (contains ' list.split split ' Verb) { new Element Operation_List_Split; }

        comment 'Database Operations';
        else.if (contains ' sql.escape ' Verb) { new Element Operation_Sql_Escape; }
        else.if (contains ' sql.query query ' Verb) { new Element Operation_Sql_Query; }

        comment 'time operations';
        else.if (contains ' time.string ' Verb) { new Element Operation_Time_String; }

        comment 'oho compiler operations';
        else.if (contains ' tokenmode ' Verb) { new Element Operation_Token_Mode; }
        else.if (contains ' file.exists ' Verb) { new Element Operation_File_Exists; }

        else
        {
            error "Unknown Operation '" Verb "' '" [. Next Input] "'";
        }
        list.append [. Element Elements] Input_Token;
        .= Element Start_Position [. Input_Token Start_Position];
        .= Element End_Position [. Input_Token End_Position];
        .= Element Document Document;
        .= Element Parent Parent_Element;
        : Factory Add_Index Element;
        return Element;
    }

    class.method entity Create_Syntax [entity Input_Token, entity Next, entity Document, entity Parent_Element]
    {
        string Verb ' ' (lowercase [. Next Input]) ' ';
        entity Element;
        if (contains ' . property prop p ' Verb) { new Element Syntax_Dot; }
        else.if (contains ' ~ attribute att symbol ' Verb) { new Element Syntax_Symbol; }
        else.if (contains ' backslash ' Verb) { new Element Syntax_Backslash; }
        else.if (contains ' : ' Verb) { new Element Syntax_Colon; }
        else.if (contains ' class ' Verb) { new Element Syntax_Class; }
        else.if (contains ' class.attribute class.att classatt ' Verb) { new Element Syntax_Class_Symbol; }
        else.if (contains ' class.lookup lookup ' Verb) { new Element Syntax_Class_Lookup; }
        else.if (contains ' class.name classname ' Verb) { new Element Syntax_Class_Name; }
        else.if (contains ' class.property classprop cp our their ' Verb) { new Element Syntax_Class_Property; }
        else.if (contains ' dictionary dict hash ' Verb) { new Element Syntax_Dictionary; }
        else.if (contains ' entity ' Verb) { new Element Syntax_Entity; }
        else.if (contains ' exclude ' Verb) { new Element Syntax_Exclude; }
        else.if (contains ' false ' Verb) { new Element Syntax_False; }
        else.if (contains ' flag ' Verb) { new Element Syntax_Flag; }
        else.if (contains ' key ' Verb) { new Element Syntax_Key; }
        else.if (contains ' indent ' Verb) { new Element Syntax_Indent; }
        else.if (contains ' infinity ' Verb) { new Element Syntax_Infinity; }
        else.if (contains ' -infinity ' Verb) { new Element Syntax_Negative_Infinity; }
        else.if (contains ' integer ' Verb) { new Element Syntax_Integer; }
        else.if (contains ' is extends ' Verb) { new Element Syntax_Is; }
        else.if (contains ' italic ' Verb) { new Element Syntax_Italic; }
        else.if (contains ' line newline ' Verb) { new Element Syntax_Line; }
        else.if (contains ' list ' Verb) { new Element Syntax_List; }
        else.if (contains ' my self this me i ' Verb) { new Element Syntax_My; }
        else.if (contains ' my.attribute my.symbol ' Verb) { new Element Syntax_My_Symbol; }
        else.if (contains ' my.class self.class me.class us ' Verb) { new Element Syntax_My_Class; }
        else.if (contains ' node ' Verb) { new Element Syntax_Node; }
        else.if (contains ' null ' Verb) { new Element Syntax_Null; }
        else.if (contains ' number ' Verb) { new Element Syntax_Number; }
        else.if (contains ' optional ' Verb) { new Element Syntax_Optional; }
        else.if (contains ' optional.repeating optrep ' Verb) { new Element Syntax_Optrep; }
        else.if (contains ' repeating ' Verb) { new Element Syntax_Repeating; }
        else.if (contains ' string ' Verb) { new Element Syntax_String; }
        else.if (contains ' tab ' Verb) { new Element Syntax_Tab; }
        else.if (contains ' true ' Verb) { new Element Syntax_True; }
        else.if (contains ' variant ' Verb) { new Element Syntax_Variant; }

        else.if (contains ' red ' Verb) { new Element Syntax_Red; }

        else
        {
            error "Unknown Syntax '" [. Next Input] "'";
        }
        list.append [. Element Elements] Input_Token;
        .= Element Start_Position [. Input_Token Start_Position];
        .= Element End_Position [. Input_Token End_Position];
        .= Element Document Document;
        .= Element Parent Parent_Element;
        : Factory Add_Index Element;
        return Element;
    }

    class.method entity Create_Keyvalue [entity Input_Token, entity Next, entity Document, entity Parent_Element]
    {
        writeline 'Creating Keyvalue from input token: ' (. Input_Token To_String);
        entity.new Element Keyvalue;
        list.append [. Element Elements] Input_Token;
        .= Element Start_Position [. Input_Token Start_Position];
        .= Element End_Position [. Input_Token End_Position];
        .= Element Document Document;
        .= Element Parent Parent_Element;
        return Element;
    }

    class.method entity Create_Element [entity Input_Token, entity Next, entity Document, entity Parent_Element, string Comma_Mode]
    {
        entity Element;
        if (or (isa Input_Token Token_Operation_Start)
               (and (isa Input_Token Token_Comma) (string.eq Comma_Mode 'operation')))
        {
            = Element (: Factory Create_Operation Input_Token Next Document Parent_Element);
        }
        else.if (or (isa Input_Token Token_Syntax_Start)
                (and (isa Input_Token Token_Comma) (string.eq Comma_Mode 'syntax')))
        {
            = Element (: Factory Create_Syntax Input_Token Next Document Parent_Element);
        }
        else.if (or (isa Input_Token Token_Keyvalue_Start)
                (and (isa Input_Token Token_Comma) (string.eq Comma_Mode 'keyvalue')))
        {
            = Element (: Factory Create_Keyvalue Input_Token Next Document Parent_Element);
        }
        else
        {
            = Element (: Factory Create_Statement Input_Token Next Document Parent_Element);
        }
        comment string Elem_String (. Element To_String);
        comment string Parent_String (. Parent_Element To_String);
        comment writeline 'created ' Elem_String ' with parent ' Parent_String;
        return Element;
    }
}

comment 'Compiler.gal';

class Compiler
{
    class.property entity Instance;

    property flag Token_List [false];
    property flag Element_List [false];
    property flag Show_Output [false];
    property flag Verbose [false];
    property list Test_Errors;

    property flag Generate_Gal [false];
    property flag Generate_Fallback [false];

    property flag Sideways [false];
    property flag Class_Export [false];
    property flag Verb_Export [false];
    property flag Class_Keep_Verbs [true];
    property flag Verb_Keep_Handlers [true];

    property entity Language;

    property hash Verb_Index;
    property hash Class_Index;

    property list Statements;
    property list Operations;
    property list Syntaxes;

    property list Statement_Index;
    property list Operation_Index;
    property list Syntax_Index;

    method void Test
    {
        entity Element;
        integer Test_Count 0;
        list Errors;
        todo 'my.verbose statement';
        if [my Verbose] { writeline 'Testing Operations'; }
        foreach [my Operations] Element
        {
            . Element Test Errors [my Verbose];
            increment Test_Count;
        }
        if [my Verbose] { writeline 'Testing Statements'; }
        foreach [my Statements] Element
        {
            . Element Test Errors [my Verbose];
            increment Test_Count;
        }
        if [my Verbose] { writeline 'Testing Syntaxes'; }
        foreach [my Syntaxes] Element
        {
            . Element Test Errors [my Verbose];
            increment Test_Count;
        }
        if [my Verbose] 
        {
            writeline 'Tests: ' Test_Count;
            writeline 'Errors: ' (list.length Errors);
        }
        todo `our= Test_Errors Errors`;
    }

    method void Add_Verb [entity Statement]
    {
        string Signature [. Statement Method_Signature];
        dict.= [my Verb_Index] Signature Statement;
        comment `writeline 'Successfully added ' Signature ' to verb index.';`;
    }

    method entity Get_Verb [string Name]
    {
        try
        {
            return (dict.get [my Verb_Index] Name);
        }
        catch
        {
            return [null];
        }
    }

    method void Add_Class [entity Statement]
    {
        string Name [. Statement Name_Prefix] [. Statement Class_Name Input];
        if (dict.exists [my Class_Index] Name)
        {
            entity Existing (dict.get [my Class_Index] Name);
            returnif (. Existing Am_Earlier [self]);
        }
        dict.= [my Class_Index] Name Statement;
        comment writeline 'Successfully added ' Name ' to class index.';
    }

    method entity Get_Class [string Name]
    {
        try
        {
            return (dict.get [my Class_Index] Name);
        }
        catch
        {
            return [null];
        }
    }

    method void Add_Definition [entity Element]
    {
        if (isa Element Statement_Statement) 
        {
            list.append [my Statements] Element;
        }
        else.if (isa Element Statement_Operation)
        {
            list.append [my Operations] Element;
        }
        else.if (isa Element Statement_Syntax)
        {
            list.append [my Syntaxes] Element;
        }
    }

    method string Generate_Factory
    {
        string Definition_Methods 'todo "Tokens";' [line];
        append Definition_Methods (we Generate_Factory_Method 'Statement' [my Statements]);
        append Definition_Methods (we Generate_Factory_Method 'Operation' [my Operations]);
        append Definition_Methods (we Generate_Factory_Method 'Syntax' [my Syntaxes]);
        todo 'Indent Definition Methods';
        string Factory_Code 'class Factory' [line] '{' [line] Definition_Methods '}' [line];
        return Factory_Code;
    }
    method string Generate_Factory_Method [string Type, list Definition_List]
    {
        string Header 'method entity Create_' Type ` [entity Input_Token, entity Next, entity Document, entity Parent_Element]
{
    string Verb ' ' (lowercase [. Input_Token Input]) ' ';
    entity Element;
`;
        string Tail `    else
    {
        error "Unknown ` Type ` '" [. Input_Token Input] "'";
    }
    list.append [. Element Elements] Input_Token;
    .= Element Verb [. Next Input];
    .= Element Start_Position [. Input_Token Start_Position];
    .= Element End_Position [. Input_Token End_Position];
    .= Element Document Document;
    .= Element Parent Parent_Element;
    : Factory Add_Index Element;
    return Element;
}`;
        string Else '';
        entity Definition;
        string Class_Name;
        string Declaration '';
        foreach Definition_List Definition
        {
            = Class_Name [. Definition Class_Name Input];
            string Aliases [. Definition Aliases];
            string Options ' ' Class_Name ' ' Aliases ' ';
            append Declaration '    ' Else;
            append Declaration 'if (contains "' Options '" Verb) { new Element ' Class_Name '; }' [line]; 
            = Else 'else.';
        }
        string Code Header Declaration Tail;
        return Code;
    }

    method void Error_Check [entity This_Document, entity Context]
    {
        string Error_Report '';
        integer Element_Number 0;
        entity This_Element;
        foreach [. This_Document Document_Body] This_Element
        {
            increment Element_Number;
            if (defined [. This_Element Error])
            {
                if (string.gt [. This_Element Error] '')
                {
                    append Error_Report Element_Number ' ' (. This_Element To_String) [line];
                }
            }
        }
        if (string.gt Error_Report '')
        {
            writeline "ERROR REPORT in " Context;
            writeline Error_Report;
            error "EXITING due to error in " Context;
        }
    }

    method void Show_Tokens [entity Parser]
    {
        writeline 'Tokens:';
        entity Item;
        integer Item_Number 0;
        foreach [. Parser Tokens] Item
        {
            increment Item_Number;
            if (isa Item Token)
            {
                writeline Item_Number ' ' (. Item To_String);
            }
            else
            {
                writeline Item_Number ': "' Item '"';
            }
        }

    }

    method void Show_Elements [entity Parser]
    {
        integer Element_Number 0;
        writeline 'Elements:';
        foreach [. Parser Document_Body] This_Element
        {
            increment Element_Number;
            if (or (isa This_Element Token) (isa This_Element Element))
            {
                writeline Element_Number ' ' (. This_Element To_String);
            }
            else
            {
                writeline Element_Number ': "' This_Element '"';
            }
        }
        writeline '';
    }

    method void Translate [string Translation, string Source, string Target]
    {
        if [my Verbose] { writeline 'translating ' Translation ' file ' Source ' to ' Target; }
        entity Parser;
        entity Generator;
        if (string.eq Translation 'gal')
        {
            new Parser Gal_Input;
            new Generator Gal_Output;
            my= Class_Export [true];
        }
        else.if (string.eq Translation 'fallback')
        {
            new Parser Gal_Input;
            new Generator Fallback_Output;
        }
        else.if (string.eq Translation 'python')
        {
            new Parser Gal_Input;
            new Generator Python_Output;
        }
        else.if (string.eq Translation 'javascript')
        {
            new Parser Gal_Input;
            new Generator Javascript_Output;
        }
        else
        {
            error "Unsupported translation '" Translation "'.";
        }
        .= Parser File_Name Source;
        .= Generator File_Name Target;
        oho;
        if [my Verbose] { writeline '    reading ' Source; }
        . Parser Read;
        if [my Verbose] { writeline '    read complete'; }
        i Error_Check Parser 'reading';
        if [my Verbose] { writeline '    tokenizing ' Source; }
        . Parser Tokenize;
        if [my Token_List]
        {
            i Show_Tokens Parser;
        }
        i Error_Check Parser 'tokenizing';
        if [my Verbose] { writeline '    parsing ' Source; }
        . Parser Parse;
        i Error_Check Parser 'parsing';
        if [my Verbose] { writeline '    attributes ' Source; }
        . Parser Child_Attributes;
        i Error_Check Parser 'attributes';
        if [my Verbose] { writeline '    structure ' Source; }
        . Parser Structure;
        i Error_Check Parser 'structure';
        if [my Verbose] { writeline '    model ' Source; }
        . Parser Base_Model;
        i Error_Check Parser 'model';
        if [my Verbose] { writeline '    generating ' Target; }
        . Generator Generate Parser;
        i Error_Check Parser 'generate';
        if [my Element_List] { i Show_Elements Parser; }
        string Output_Code (. Generator Get Parser);
        if [my Show_Output] { writeline Output_Code; }
        .= Generator Input Output_Code;
        .= Generator File_Name Target;
        if [my Verbose] { writeline '    write ' Target; }
        . Generator Write;
    }
}

class Dialect
{
    todo `Operations, Syntaxes and Elements are lists, not dictionaries.`;

    property string Name_Prefix;
    property list Statements;
    property list Operations;
    property list Syntaxes;

    method void Import
    {
        entity Element;
        string Name;
        foreach [my Statements] Element
        {
            foreach [. Element Names] Name
            {
                dict.assign [my Statements] Name Element;
            }
        }
        foreach [my Operations] Element
        {
            foreach [. Element Names] Name
            {
                dict.assign [my Operations] Name Element;
            }
        }
        foreach [my Operations] Element
        {
            foreach [. Element Names] Name
            {
                dict.assign [my Operations] Name Element;
            }
        }
    }

    method void Know
    {
        entity Element;
        string Prefix [my Name_Prefix] '.';
        string Name;
        string Full_Name;
        foreach [my Statements] Element
        {
            foreach [. Element Names] Name
            {
                = Full_Name (append Prefix Name);
                dict.assign [my Statement_Index] Full_Name Element;
            }
        }
        foreach [my Operations] Element
        {
            foreach [. Element Names] Name
            {
                = Full_Name (append Prefix Name);
                dict.assign [my Operation_Index] Full_Name Element;
            }
        }
        foreach [my Syntaxes] Element
        {
            foreach [. Element Names] Name
            {
                = Full_Name (append Prefix Name);
                dict.assign [my Syntax_Index] Full_Name Element;
            }
        }
    }
}

main [string Translation, string Source, string Target]
{
    entity Comp_Instance;
    new Comp_Instance Compiler;
    := Compiler Instance Comp_Instance;
    . Comp_Instance Translate Translation Source Target;
}
