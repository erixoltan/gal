
class Goal;
class Spell;

goal.spell License
    `The goalspell compiler is dedicated to altruism.`
{
    class License
    {
        class.property string License_Text `
Closed Source goalspell License

goalspell programming language
Copyright (c) 2022 Erik Zoltán. All Rights Reserved.

goalspell contains a licensing spell. Over time, the text that appears here will be changed by the goalspell compiler. Initially, this programming languge is closed source, all rights reserved. 

The goalspell compiler is dedicated to altruism. It tries to select the goalspell code that best serves human outcome. This license is defined in goalspell code. Future versions of goalspell are likely to be released under different license terms. 

If you download, execute or examine the source code of the goalspell compiler, it means that you have purchased a licensed copy of goalspell. If that is not the case, it means that you are in violation of this license. 
`;
        class.method flag Publish
        {
            string License_Text [: License License_Text];
            file.dump License_Text 'LICENSE';
            return [true];
        }
        class.method entity Get
        {
            returnif (defined [: License Instance]) [: License Instance];
            entity.new Lic License;
            = [: License Instance] Lic;
            return Lic;
        }
    }

    comment `mildbeard
    {
        name 'Erik Zoltán';
        email 'mildbeard@pm.me';
        outcome 0.5;
    }`;
}
flowerbox 'Knowledge.gal';

goal.spell Knowledge `represent abstract knowledge using symbols, entities and attributes, things and features`
{
    class Symbol
    {
        property entity Symbol_Object;
        property variant Symbol_Value;
    }
    class Thing;
    class Entity;

    symbol flag Flag;
    symbol integer Integer;
    symbol number Number;
    symbol string String;
    symbol list List
    {
        method void Clear
        {
            list.clear [my Symbol_Value];
        }
    }
    symbol dictionary Dictionary;
    symbol entity Object;
    symbol number Amount;
    symbol entity Argument;
    symbol string Keyword;

    symbol string File_Like
    {
        method flag See;
        method flag Say;
    }

    symbol string File
    {
        property string File_Name;

        method flag See
        {
            comment debug;
            verbosity;
            returnif (not [my File_Name]) [true];
            try
            {
                file.readall [my Symbol_Value, my File_Name];
                verbose 'read ' [my Symbol_Value];
                return [true];
            }
            catch Error
            {
                writeline "Error " Error;
                return [false];
            }
        }

        method flag Say
        {
            flag Verbose [false];
            returnif (not [my File_Name]) [true];
            try
            {
                verbose 'write ' [my Symbol_Value];
                file.dump [my Symbol_Value, my File_Name];
                return [true];
            }
            catch Error
            {
                writeline "Error " Error;
                return [false];
            }
        }
    }

    class Class_Symbol [is Symbol];

    class Class_List [is Class_Symbol]
    {
        property list Symbol_Value;
    }
}
flowerbox "Intelligence.gal";

goal Intelligence 
    "intelligence is the ability to identify the 'best' way to achieve a set of goals";

spell Intelligence
{
    symbol string Context;

    class Inference
    {
        property entity Owner;
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            return [my Status];
        }
        method flag Infer
        {
            return [my Status];
        }
    }

    class Thinker
    {
        property flag Status [true];
        attribute list Inferences;
        attribute entity Contest;
        method flag Initialize
        {
            return [my Status];
        }
        method flag Infer
        {
            entity Inference;
            my= Status [true];
            verbosity;
            verbose '   ' [class.name [self]] ' iterate ' (list.length [my.attribute Inferences]) ' inferences.';
            foreach [my.attribute Inferences] Inference
            {
                verbose '      Inference: ' [class.name Inference];
                &= [my Status] (. Inference Infer);
                breakif (not [my Status]);
            }
            return [my Status];
        }
        method flag Choose
        {
            debug;
            return [my Status];
        }
    }

    class Talker [is Thinker]
    {
        method flag See
        {
            return [my Status];
        }
        method flag Say
        {
            return [my Status];
        }
    }

    class Translator [is Talker]
    {
        attribute entity Input File;
        attribute entity Output File;
        property entity Parser;
        property entity Generator;
        method flag Initialize
        {
            my= Status (. [my Parser] Initialize);
            and [my Status] (. [my Generator] Initialize);
            return [my Status];
        }
        method flag See
        {
            return (. [my Input] See);
        }
        method flag Say
        {
            return (. [my Output] Say);
        }

        method flag Infer_Input
        {
            verbosity;
            if (not (. [my Parser] Infer))
            {
                verbose (. [my Parser] Error_Report);
                my= Status [false];
                return [my Status];
            }
            return [my Status];
        }

        method flag Infer_Output
        {
            verbosity;
            if (not (. [my Generator] Infer))
            {
                verbose(. [my Generator] Error_Report);
                my= Status [false];
                return [my Status];
            }
            my= Status [my Generator Status];
            string Code [my Generator Code];
            = [my.attribute Output] Code;
            return [my Status];
        }

        method flag Choose
        {
            todo 'Implementors not Classifications';
            = [my.attribute Generator Elements] [my.attribute Parser Elements];
            entity Element; entity Choice;
            foreach [my.attribute Generator Elements] Element
            {
                foreach [. Element Classifications] Choice
                {
                    if (lt [. Element Classification Gratitude] [. Choice Gratitude])
                    {
                        .= Element Classification Choice;
                    }
                }
            }
            return [my Status];
        }

        method flag Run
        {
            verbosity;
            verbose 'See';
            require.that.i See;
            verbose 'infer input';
            require.that.i Infer_Input;
            verbose 'choose';
            require.that.i Choose;
            verbose 'infer output';
            require.that.i Infer_Output;
            verbose 'Say';
            require.that.i Say;
            verbose 'Success';
            return [my Status];
        }
    }

    class Language_Intelligence [is Thinker]
    {
        property string Language_Name;
        property entity Owner;
        property flag Status [true];

        method string Error_Report
        {
            flag Status [true];
            string Report '';
            entity Element;
            variant Error;
            string Text;
            integer N 0;
            integer Errors 0;
            append Report [classname [self]] ' Error Report' [line];
            foreach [my.attribute Elements] Element
            {
                if (and (defined [. Element Classification]) (defined [. Element Classification Error]))
                {
                    = Status [false];
                    append Report N '+ ' [classname [. Element Classification]] ': <' [. Element Classification Error] '>' [line];
                    = Text (. Element Get_Input);
                    if (gt (length Text) 70)
                    {
                        = Text (append (substring Text 0 70) '...');
                    }
                    append Report [indent] Text [line];
                    increment Errors;
                }
                else.if (defined [. Element Error])
                {
                    string Class_Name  [classname Element];
                    if (defined [. Element Classification])
                    {
                        = Class_Name [classname [. Element Classification]];
                    }
                    forgive
                    {
                        append Class_Name '/' [. Element Verb];
                    }
                    forgive
                    {
                        append Class_Name '/' [. Element Classification Verb];
                    }
                    = Status [false];
                    append Report N ') ' [classname Element] ': <' [. Element Error] '>' [line];
                    = Text (. Element Get_Input);
                    if (gt (length Text) 70)
                    {
                        = Text (append (substring Text 0 70) '...');
                    }
                    append Report [indent] Text [line];
                    increment Errors;
                }
                increment N;
            }
            append Report [classname [self]] ' logged ' Errors ' Errors';
            return Report;
        }
        method flag Infer
        {
            entity Inference;
            my= Status [true];
            verbosity [true];
            comment verbose '   ' [class.name [self]] ' iterate ' (list.length [my.attribute Inferences]) ' inferences.';
            foreach [my.attribute Inferences] Inference
            {
                comment verbose '      Inference: ' [class.name Inference];
                &= [my Status] (. Inference Infer);
                if (not [my Status])
                {
                    verbose [indent] 'ERROR in ' [class.name Inference] '.';
                }
            }
            if (not [my Status])
            {
                string Report (i Error_Report);
                my= Code Report;
            }
            return [my Status];
        }
    }

    class Parser [is Language_Intelligence]
    {
        method void Dump
        {
            entity Element;
            integer Offset 0;
            foreach [my.attribute Elements] Element
            {
                writeline '   ' Offset ' ' (. Element To_String);
                ++ Offset;
            }
        }

        method flag Initialize
        {
            debug;
            comment 'THIS DOES NOT INHERIT.';
        }

        method entity Top_Token
        {
            if (ge [my Position] 
                (list.length [my.attribute Tokens]))
            {
                return [false];
            }
            entity Top (list.get [my.attribute Tokens] [my Position]);
            return Top;
        }

        method void Add_Element [entity New_Element]
        {
            if (defined [. New_Element Error])
            {
                debug;
            }
            list.append [my.attribute Elements] New_Element;
        }
        
        method flag Parse_Token [list Parent_Elements, string Token_Input]
        {
            entity Top_Token (i Top_Token);
            returnif (not (isa Top_Token Token)) [false];
            string Input [. Top_Token Input];
            returnif (sne Input Token_Input) [false];
            list.append Parent_Elements Top_Token;
            i Consume_Token;
            return [true];
        }

        method void Rollback [integer Start, string Message]
        {
            entity Element (i Top_Token);
            if Element
            {
                .= Element Error Message;
            }
            while (gt [my Position] Start)
            {
                = Element (pop [my.attribute Elements]);
                = [my Position] (- [my Position] 1);
            }
        }
    }


    class Generator [is Language_Intelligence]
    {
        property string Code '';
        method void Compiled_Inheritance
        {
            verbosity [false];
            entity Elem;
            entity Classification;
            foreach [my.attribute Elements] Elem
            {
                contif (not (defined [. Elem Classification]));
                = Classification [. Elem Classification];
                if (isa Classification Class_Statement)
                {
                    verbose 'inherit ' [. Classification Name Input];
                    . Classification Inherit;
                }
            }
        }
    }

    inference list Elements
    {
        classify Parser
        {
            verbosity;
            comment debug;
            flag Parse_Result (i Parse_Program [my.attribute Elements]);
            integer Length (list.length [my.attribute Tokens]);
            if (lt [my Position] Length)
            {
                string Error_Message 'Parsed ' [my Position] ' tokens out of ' Length '. Unexpected text at end:';
                integer T;
                string S;
                string At_End '';
                for.range T [my Position] Length
                {
                    breakif (ge T Length);
                    = S [. (list.get [my.attribute Tokens] T) Input];
                    append At_End ' ' S;
                }
                integer Length (length At_End);
                if (gt Length 200)
                {
                    = At_End (append (substring At_End 0 100)
                                     '...'
                                     (substring At_End (- Length 100)));
                }
                append Error_Message At_End;
                verbose Error_Message;
                = Parse_Result [false];
                comment error Error_Message;
            }
            return Parse_Result;
        }
    }

    class Elements [is List];
}
flowerbox 'Language.gal';

goal Language
    `classification of language elements`;

spell Language
{
    class Registry;
    class Element
    {
        property entity Location;
        property entity Parent;
        property entity Classification;
        property entity Implementer;
        property entity Owner;
        property string Reference;
        property string Error;
        property string Property_Name;
        property string Language_Name;
        property string Class_Context;
        property string Usage 'value';
        property string Inner_Type;
        property string Outer_Type;
        method entity Method_Context
        {
            if (defined [my Parent])
            {
                return (. [my Parent] Method_Context);
            }
            return [null];
        }

        method string To_String
        {
            string String [class.name [self]] ' '
                [my Location Start_Position] '-' [my Location End_Position];
            return String;
        }
        method string Get_Input
        {
            return (. [my Location] Get_Input);
        }
        method string Unquoted
        {
            return (i Get_Input);
        }
        method string Enquote [string Text]
        {
            returnif (not (contains Text "'")) (append "'" Text "'");
            returnif (not (contains Text '"')) (append '"' Text '"');
            returnif (not (contains Text "`")) (append "`" Text "`");
            returnif (and (not (contains Text '“')) (not (contains Text '”'))) (append '“' Text '”');
            returnif (and (not (contains Text '‘')) (not (contains Text '’'))) (append '‘' Text '’');
            returnif (and (not (contains Text '«')) (not (contains Text '»'))) (append '«' Text '»');
            returnif (and (not (contains Text '‹')) (not (contains Text '›'))) (append '‹' Text '›');
            return "'ERROR goalspell compiler DEEPLY ENQUOTED STRING FAILED HERE'";
        }
        method string Get_Language_Name
        {
            returnif (defined [my Language_Name]) [my Language_Name];
            string Name;
            if (defined [my Parent])
            {
                = Name (. [my Parent] Get_Language_Name);
                returnif (notnull Name) Name;
            }
            if (defined [my Owner])
            {
                = Name (. [my Owner] Get_Language_Name);
                returnif (notnull Name) Name;
            }
            return '';
        }
        method string Get_Property_Name
        {
            returnif (defined [my Property_Name]) [my Property_Name];
            string Name;
            if (defined [my Parent])
            {
                = Name (. [my Parent] Get_Property_Name);
                returnif (notnull Name) Name;
            }
            if (defined [my Owner])
            {
                = Name (. [my Owner] Get_Property_Name);
                returnif (notnull Name) Name;
            }
            return '';
        }
        method entity Get_Class_Context
        {
            returnif (defined [my Class_Context]) [my Class_Context];
            string Name;
            if (defined [my Parent])
            {
                = Name (. [my Parent] Get_Class_Context);
                returnif (notnull Name) Name;
            }
            if (defined [my Owner])
            {
                = Name (. [my Owner] Get_Class_Context);
                returnif (notnull Name) Name;
            }
            return [null];
        }
        method string Get_Module_Name
        {
            returnif (defined [my Parent]) (. [my Parent] Get_Module_Name);
            error 'Module not known';
        }
    }

    class Token [is Element]
    {
        property string Input;
        constructor [entity Document, string Character, integer Start, integer End]
        {
            my= Input Character;
            my= Location (new Location Document Start End);
        }
        method string To_String
        {
            string String [class.name [self]] ' '
                [my Location Start_Position] '-' [my Location End_Position]
                ' input ' [my Input];
            return String;
        }
        method string Get_Input
        {
            return [my Input];
        }
    }

    class Literal [is Element]
    {
        constructor [string Text]
        {
            my= Input Text;
            my= Gs Text;
            my= Fallback Text;
        }
        method string Get_Input
        {
            return [my Input];
        }
    }

    class Location
    {
        property entity Document;
        property integer Start_Position;
        property integer End_Position;
        constructor [entity Doc, integer Start, integer End]
        {
            my= Document Doc;
            my= Start_Position Start;
            my= End_Position End;
        }
        method string Get_Input
        {
            verbosity [true];
            try
            {
                integer X (+ (- [my End_Position] [my Start_Position]) 1);
            }
            catch Error {
                verbose Error;
            }
            comment integer Length (+ (- [my End_Position] [my Start_Position]) 1);
            string Input '<unknown input>';
            forgive
            {
                integer End [my End_Position];
                integer Start [my Start_Position];
                integer Diff (- End Start);
                integer Length (+ Diff 1);
                = Input (substring [my.attribute Document Owner Input] Start Length);
            }
            return Input;
        }
    }


    class Dialect
    {
        property dictionary Statements;
        property dictionary Operations;
        property dictionary Syntaxes;
    }

}


    class Token
    {
        method flag Is_Value
        {
            return [false];
        }
    }
    class Syntax_Token [is Token];
    class Boundary_Token [is Syntax_Token];
    class Non_Boundary_Token [is Token]
    {
        method flag Is_Value
        {
            return [true];
        }
    }
    class Atomic_Token [is Non_Boundary_Token];
    class Name_Token [is Non_Boundary_Token];
    class Keyword_Token [is Name_Token];
    class Token_Keyword [is Keyword_Token];
    class Token_Name [is Name_Token];
    class Token_Whitespace [is Non_Boundary_Token];
    class Token_Number [is Atomic_Token];
    class Token_Quote [is Atomic_Token]
    {
        method string Unquoted
        {
            string Input (i Get_Input);
            integer End (- (length Input) 2);
            string Unquoted (substring Input 1 End);
            return Unquoted;
        }
    }
    class Token_Syntax_Start [is Boundary_Token];
    class Token_Syntax_End [is Boundary_Token];
    class Token_Operation_Start [is Boundary_Token];
    class Token_Operation_End [is Boundary_Token];
    class Token_Statement_Start [is Syntax_Token];
    class Token_Statement_End [is Syntax_Token];
    class Token_Block_Start [is Boundary_Token];
    class Token_Block_End [is Boundary_Token];
    class Token_Comma [is Syntax_Token];
    class Token_Tilde [is Keyword_Token]
    {
        method flag Is_Value
        {
            return [true];
        }
    }
    class Token_Semi [is Boundary_Token];
    class Token_Comment [is Non_Boundary_Token];
    class Token_Token [is Token];
    class Token_Name_Special [is Token_Name];

    class Named_Element [is Element]
    {
        property list Arguments;
        property list Listargs;

        method entity Factory [entity Parsed_Element]
        {
            entity.new New_Element [my.class];
            .= New_Element Owner Parsed_Element;
            .= New_Element Location [. Parsed_Element Location];
            return New_Element;
        }

        method string To_String
        {
            string String [class.name [self]] ' '
                [my Location Start_Position] '-' [my Location End_Position];
            entity Imp [my Classification];
            entity Arg;
            string Args '';
            string Between '';
            foreach [. Imp Arguments] Arg
            {
                append Args Between [class.name Arg];
                = Between ', ';
            }
            if (sgt Args '')
            {
                = Args (s+ ' (' Args ')');
            }
            append String Args;
            return String;
        }
    }

    class Tail [is Named_Element];
    class Statements [is Element];
    class Expressions [is Element];
    class Operation [is Named_Element]
    {
        method string Then [list Predecessor]
        {
            string Keyword [my Gs_Keyword];
            string Arguments "";
            object Pred;
            foreach Predecessor Pred
            {
                append Arguments " " [. Predecessor Gs];
            }
            string Code "(" Keyword Arguments ")";
            return Code;
        }
        method flag Can [list Predecessor]
        {
            return [false];
        }
    }
    class Operation_Tail [is Tail];
    class Syntax [is Named_Element]
    {
        method string Then [list Predecessor]
        {
            string Keyword [my Gs_Keyword];
            string Arguments "";
            object Pred;
            foreach Predecessor Pred
            {
                append Arguments " " [. Predecessor Gs];
            }
            string Code "[" Keyword Arguments "]";
            return Code;
        }
        method flag Can [list Predecessor]
        {
            return [false];
        }
    }
    class Syntax_Tail [is Tail];
    class Statement [is Named_Element]
    {
        property entity Block;
        method string Then [list Predecessor]
        {
            todo "Block? Right now we only do line statements.";
            string Keyword [my Gs_Keyword];
            string Arguments "";
            object Pred;
            foreach Predecessor Pred
            {
                append Arguments " " [. Predecessor Gs];
            }
            string Code Keyword Arguments ";";
            return Code;
        }
        method flag Can [list Predecessor]
        {
            return [false];
        }
    }
    class Statement_Tail [is Tail];
    class Block [is Element]
    {
        property list Statements;

        method string To_String
        {
            string String [class.name [self]] ' '
                [my Location Start_Position] '-' [my Location End_Position];
            entity Imp [my Classification];
            entity Stmt;
            string Code '';
            foreach [. Imp Statements] Stmt
            {
                append Code ' ' [class.name Stmt] ';';
            }
            append String ' {' Code '}';
            return String;
        }
    }

    flowerbox 'Language Element Superclasses';

    class Line_Statement [is Statement];
    class Scoped_Statement [is Statement];
    class Append_Args_Statement [is Line_Statement];

    class Argument_Statement [is Line_Statement];
    class Assignment_Statement [is Line_Statement];
    class Declaration_Statement [is Line_Statement];
    class Output_Statement [is Line_Statement];
    class Iterative_Statement [is Scoped_Statement];
    class Class_Statement [is Scoped_Statement]
    {
        property list Ancestors;
        property flag Generate_Constructor [false];
        property flag Has_Constructor [false];
        property string Infer_Inits '';
        property list Inferences;
        property flag Is_Compiled [false];
        property dictionary Compiled_Methods;
        property dictionary Compiled_Properties;
        property dictionary Compiled_Class_Methods;
        property dictionary Compiled_Class_Properties;
        property dictionary Compiled_Ancestors;

        property list Appended_Statements;
        property entity Constructor;
        property entity Main;
        property list Class_Property_Statements;
        property list Property_Statements;
        property list Class_Methods;
        property list Methods;
        property list Main_Body;

        method entity Factory [entity Parsed_Element]
        {
            verbosity;
            string Class_Name "";
            string Between "";
            entity Argument;
            foreach [. Parsed_Element Elements] Argument
            {
                if (isa Argument Token_Name)
                {
                    append Class_Name Between (. Argument Get_Input);
                    = Between '_';
                }
            }
            verbose "Class.Factory got name '" Class_Name "'.";
            entity.new New_Element [my.class];
            .= New_Element Owner Parsed_Element;
            .= New_Element Location [. Parsed_Element Location];
            entity Existing New_Element;
            if (dict.exists [: Statement_Class Names] Class_Name)
            {
                verbose [indent] 'Class.Factory returns existing class object ' [class.name Existing] ' ' Existing;
                = Existing (dict.get [: Statement_Class Names] Class_Name);
            }
            else
            {
                verbose [indent] 'Class.Factory method registers the new class ' Class_Name ' as ' [class.name New_Element];
                dict.assign [: Statement_Class Names] Class_Name New_Element;
            }
            .= New_Element Implementer Existing;
            return New_Element;
        }
        method void Append_Statement [entity Statement]
        {
            if (isa Statement Statement_Class_Property)
            {
                todo;
            }
            else.if (isa Statement Statement_Constructor)
            {
                my= Constructor Statement;
            }
            else.if (isa Statement Statement_Property)
            {
                todo;
            }
            else.if (isa Statement Statement_Main)
            {
                debug;
                my= Main Statement;
                list.append [my Main_Body] Statement;
            }
            else
            {
                list.append [my Main_Body] Statement;
            }
        }
        method entity Get_Class_Context
        {
            return [self];
        }
        method void Inherit
        {
            verbosity [true];
            returnif [my Is_Compiled];
            entity Stmt;
            entity S2;
            string Name;
            string My_Name [my Name Input];
            foreach [my Ancestors] Name
            {
                verbose [indent] 'class ' My_Name ' looks up ancestor ' Name;
                = S2 (dict.get [: Statement_Class Names] Name);
                dict.assign [my Compiled_Ancestors] Name S2;
                . S2 Inherit;
                iterate [. S2 Compiled_Ancestors] Name Stmt
                {
                    dict.assign [my Compiled_Ancestors] Name S2;
                }
                iterate [. S2 Compiled_Class_Properties] Name Stmt
                {
                    dict.assign [my Compiled_Class_Properties] Name Stmt;
                }
                iterate [. S2 Compiled_Class_Methods] Name Stmt
                {
                    dict.assign [my Compiled_Class_Methods] Name Stmt;
                }
                iterate [. S2 Compiled_Properties] Name Stmt
                {
                    dict.assign [my Compiled_Properties] Name Stmt;
                }
                iterate [. S2 Compiled_Methods] Name Stmt
                {
                    dict.assign [my Compiled_Methods] Name Stmt;
                }

            }
            foreach [my Class_Property_Statements] Stmt
            {
                = Name [. Stmt Name Input];
                dict.assign [my Compiled_Class_Properties] Name Stmt;
            }
            foreach [my Class_Methods] Stmt
            {
                = Name [. Stmt Name Input];
                dict.assign [my Compiled_Class_Methods] Name Stmt;
            }
            foreach [my Property_Statements] Stmt
            {
                = Name [. Stmt Name Input];
                dict.assign [my Compiled_Properties] Name Stmt;
            }
            foreach [my Methods] Stmt
            {
                = Name [. Stmt Name Input];
                dict.assign [my Compiled_Methods] Name Stmt;
            }
            my= Is_Compiled [true];
        }
    }
    class Behavior_Statement [is Scoped_Statement]
    {
        property dictionary Variables;
        method entity Method_Context
        {
            return [self];
        }
    }
    class Conditional_Statement [is Scoped_Statement]
    {
        property entity If_Statement;
        property flag Last_If [false];
        property flag Is_Last [false];
        property string End_Label;
    }
    class Error_Handling_Statement [is Scoped_Statement]
    {
        property entity Try_Statement;
        property string End_Label;
    }
    class Iffy_Statement [is Conditional_Statement];
    class Comment_Statement [is Append_Args_Statement];
    class Method_Statement [is Scoped_Statement]
    {
        property dictionary Variables;
        method entity Method_Context
        {
            return [self];
        }
        method string Get_Property_Name
        {
            forgive
            {
                string Method_Name (. [my Name] Get_Input);
                if (contains Method_Name 'Infer_')
                {
                    replace Method_Name 'Infer_' '';
                    return Method_Name;
                }
            }
            return (. [my Parent] Get_Property_Name);
        }
    }
    class Class_Method_Statement [is Method_Statement];
    class Symbol_Statement [is Class_Statement];
    class Attribute_Value_Statement [is Line_Statement]
    {
    }
    class Feature_Assignment_Statement [is Line_Statement]
    {
    }
    class Object_Definition_Statement [is Scoped_Statement]
    {
    }
    class Definition_Statement [is Scoped_Statement]
    {
        class.property string Base_Class;
        property entity Name_Arg;
        property entity Keyword; 
        property entity Root_Type;
        method entity Get_Class_Context
        {
            return [self];
        }
    }
    class Feature_Statement [is Attribute_Value_Statement];
    class Thing_Statement [is Scoped_Statement];
    class Amount_Statement [is Scoped_Statement];
    class Append_Names_Statement [is Scoped_Statement];
    class Dialect_Statement [is Line_Statement];

    class Unary_Operation [is Operation];
    class Binary_Operation [is Operation];
    class Repeating_Operation [is Binary_Operation];

    class Argument_Syntax [is Syntax];

    flowerbox 'Statement Classes';

    statement Article article Append_Names
    {
        property string Name;
        optional Description;
    }
    statement Article_Reference article.reference Append_Names
    {
        property string Name;
        optional Description;
    }
    statement Article_Plan article.plan Append_Names
    {
        property string Name;
        optional Description;
    }

    statement Atomic atomic
    {
        comment 'atomic Gs_Code Atomic_Code;';
        argument Source;
        argument Target;
    }

    statement Defined defined Scoped
    {
        argument Value_Reference;
    }

    statement Gal_Statement statement Definition
    {
        class.property string Gal_Keyword 'statement';
        class.property string Base_Class 'Statement';

        argument Name;
        keyword Keyword;
        optional Ancestor;
    }
    statement Gs_Statement statement Definition
    {
        class.property string Gal_Keyword 'statement';
        class.property string Base_Class 'Statement';

        argument Name;
        argument Keyword;
        optional Ancestor;
    }
    statement Gal_Operation operation Definition
    {
        class.property string Gal_Keyword 'operation';
        class.property string Base_Class 'Operation';

        argument Name;
        keyword Keyword;
        optional Ancestor;
    }
    statement Gs_Operation operation Definition
    {
        class.property string Gal_Keyword 'operation';
        class.property string Base_Class 'Operation';

        argument Name;
        argument Keyword;
        optional Ancestor;
    }
    statement Gal_Syntax syntax Definition
    {
        class.property string Gal_Keyword 'syntax';
        class.property string Base_Class 'Syntax';

        argument Name;
        keyword Keyword;
        optional Ancestor;
    }
    statement Gs_Syntax syntax Definition
    {
        class.property string Gal_Keyword 'syntax';
        class.property string Base_Class 'Syntax';

        argument Name;
        argument Keyword;
        optional Ancestor;
    }

    statement Module module Scoped
    {
        argument Name;
        property dictionary Variables;
        method string Get_Module_Name
        {
            return (. [my Name] Get_Input);
        }
        method entity Method_Context
        {
            return [self];
        }
    }
    statement Function function Method
    {
        keyword Return_Type;
        argument Name;
        property dictionary Variables;
        method entity Method_Context
        {
            return [self];
        }
    }
    statement Redirect redirect Method
    {
        keyword Return_Type;
        argument Name;
    }
    statement Redirect_To redirect.to Line
    {
        argument Url;
    }
    statement Function_Pointer function.pointer Scoped
    {
        argument Name;
    }
    statement Include include Line
    {
        argument File_Name;
    }
    statement Constant constant Line
    {
        keyword Type;
        argument Name;
        argument Value;
    }
    statement Global global Line
    {
        keyword Type;
        argument Name;
        argument Value;
    }
    statement Exit exit Line
    {
        optional Return_Value;
    }

    statement Speaking speaking Line;
    statement Author author Line;
    statement Document document Scoped;
    statement Title title Line;
    statement Subtitle subtitle Line;
    statement Author author Line;
    statement Chapter chapter Scoped;
    statement Section section Scoped;
    statement Paragraph paragraph Scoped;
    statement Codebox codebox Scoped
    {
        argument Name;
    }
    statement Example example Scoped;
    statement Pane pane Line
    {
        argument Selection;
    }
    statement Diagram diagram Line
    {
        argument File_Name;
        optional Width;
        optional Height;
    }
    statement Numbered_List numbered.list Scoped;
    statement List_Item list.item Line;
    statement Terminology terminology Scoped;
    statement Term term Line
    {
        argument Word;
        argument Definition;
    }
    statement Note note Line;
    statement Ingredients ingredients Scoped;
    statement Steps steps Scoped;
    statement Recipe recipe Scoped;
    statement Menu_Bar menu_bar Scoped
    {
        argument Title;
        optional Name;
    }
    statement Menu_Dropdown menu_dropdown Scoped
    {
        argument Title;
        optional Document;
    }
    statement Menu_Item menu_item Line
    {
        argument Title;
        optional Document;
        optional Url;
    }
    statement Document_Reference document_reference Scoped
    {
        argument Document;
        argument Title;
        optional Url;
    }
    statement Site site Scoped
    {
        argument Document;
        argument Title;
    }

    statement Action action Scoped
    {
        keyword Type;
        argument Class_Name;
        optional Parent_Class;
    }

    statement Add add Line
    {
        argument Variable;
    }
    statement Alert alert Line;
    statement Alpha alpha Scoped
    {
        argument Identifier;
        optional Performance;
    }

    statement Amount amount Scoped
    {
        argument Name;
        argument Keyword;
    }
    statement Analysis analysis Scoped;
    statement Analyze analyze Scoped
    {
        argument Behavior;
        argument Test;
        argument Map;
    }
    statement And and Line
    {
        argument Variable;
    }
    statement Append append Append_Args
    {
        argument Variable;
    }
    statement Append_Token append.token Line
    {
        argument Mode;
    }
    statement Argument argument Argument
    {
        argument Argument_Name;
        optional Type_Value;
    }
    statement Array array
    {
        argument Name;
    }
    statement Array_Of array.of
    {
        argument Name;
        argument Class;
    }
    statement Array_Number array.number
    {
        argument Name;
        argument Size;
    }
    statement Assign = Line
    {
        argument Variable;
        argument Value;
    }
    statement Async_Method async.method Method
    {
        keyword Type;
        argument Name;
    }
    statement Attribute attribute Line
    {
        keyword Type;
        argument Property_Name;
        optional Value;
    }
    statement Behavior behavior Behavior
    {
        keyword Type;
        argument Behavior_Name;
    }
    statement Bias bias Line
    {
        argument Bias;
    }
    statement Bind bind Declaration
    {
        argument Class;
        argument Variable;
        optional Value;
    }
    statement Bless bless Line
    {
        argument Object;
        argument Class;
    }
    statement Break break Line;
    statement Break_If breakif Line
    {
        argument Condition;
    }
    statement Build build Line
    {
        argument Variable;
    }
    statement C c Scoped;
    statement Call . Line
    {
        argument Target;
        argument Method;
    }
    statement Catch catch Error_Handling
    {
        optional Variable;
    }
    statement Cd cd Line
    {
        argument Directory;
    }
    statement Class_Append class.append Scoped
    {
        property entity Primary_Class;
        property flag Generate_Constructor [false];

        argument Name;
    }
    statement Class_Set class.set Scoped
    {
        property entity Primary_Class;
        property flag Generate_Constructor [false];

        argument Name;
    }
    statement Class_Attribute class.attribute Scoped
    {
        keyword Data_Type;
        argument Property_Name;
        optional Class;
    }
    statement Class class Class
    {
        class.property dictionary Names;

        argument Name;
    }
    statement Class_Is class.is Class
    {
        argument Name;
        argument Ancestor_Class;
    }
    statement Copy_From copy.from Line
    {
        optional Target;
        argument Source;
    }
    statement Copy_To copy.to Line
    {
        argument Source;
        optional Target;
    }
    statement Egg egg Class
    {
        argument Name;
    }
    statement Class_Module class.module Class
    {
        argument Name;
    }
    statement Classify classify Method;
    statement Class_Method class.method Class_Method
    {
        keyword Return_Type;
        argument Name;
    }
    statement Class_Property class.property Line
    {
        keyword Type;
        argument Name;
        optional Value;
    }
    statement Classpropset := Assignment
    {
        argument Target;
        argument Property;
        argument Expression;
    }
    statement Click click Method
    {
        argument Element_Name;
    }
    statement Close close Line
    {
        argument Device;
    }
    statement Collates collates Line
    {
        argument Property_Name;
    }
    statement Colon : Line
    {
        argument Class;
        argument Method;
    }
    statement Comment # Comment;
    statement Compile compile Line
    {
        argument From;
        argument Source;
        argument To;
        argument Target;
    }
    statement Confirm_Exit_If confirm.exit.if Line
    {
        argument Condition;
    }
    statement Constructor constructor Method;
    statement Contest contest Scoped;
    statement Continue continue Line;
    statement Continue_If contif Line
    {
        argument Condition;
    }
    statement Create create Line
    {
        argument Device;
    }
    statement Crown crown Scoped
    {
        argument Owner_Class;
        argument Behavior_Name;
    }
    statement Currency currency Scoped
    {
        argument Name;
    }
    statement Date date Line;
    statement Debug debug Line;
    statement Debug_If debugif Line
    {
        argument Condition;
    }
    statement Decrement -- Line
    {
        argument Op1;
    }
    statement Default default Line
    {
        argument Variable;
        argument Value;
    }
    statement Dialect dialect Scoped
    {
        argument Name;
        optional Ancestor;
    }
    statement Dial dial Scoped
    {
        argument Name;
    }
    statement Dictionaries dictionaries Line;
    statement Dictionary dictionary Declaration
    {
        argument Variable;
        property string Value '';
    }
    statement Dictionary_Assign dict.assign Line
    {
        argument Dict;
        argument Key;
        argument Value;
    }
    statement Diff diff Line
    {
        argument Object;
        argument Name;
        argument From;
        argument To;
    }
    statement Dispatcher dispatcher Line
    {
        argument Name;
        argument Method;
    }
    statement Dispatchers dispatchers Line
    {
        argument Name;
    }
    statement Distribute distribute Line
    {
        argument List;
        argument Function;
    }
    statement Divide /= Line
    {
        argument Variable;
    }
    Statement Do do Line
    {
        argument Doarg;
    }
    statement Either either Line
    {
        argument Rule_Name;
    }
    statement Element element Line
    {
        argument Id;
        argument Class_Name;
    }
    statement Else else Conditional;
    statement Else_If else.if Conditional
    {
        argument Condition;
    }
    statement English english Scoped;
    statement Entity entity Class
    {
        argument Name;
        optional Parent_Class;
    }
    statement Entities entities Line
    {
        argument Variable;
        optional Value;
    }
    statement Entity_New entity.new Line
    {
        argument Variable;
        argument Class;
    }
    statement Error error Line;

    statement Execute execute Line
    {
        argument Target;
    }
    statement Expect_String expect.string Line
    {
        argument Expected;
        argument Actual;
        argument Name;
    }
    statement Expect_Equal expect.= Line
    {
        argument Expected;
        argument Actual;
        argument Name;
    }
    statement Expected_Output expected.output Line;
    statement Experience experience Line
    {
        argument Class_Name;
        argument Code;
        argument Performance;
    }
    statement Export_Memory export.memory Line;
    statement Fallback fallback Method
    {
        method string Get_Language_Name
        {
            return 'Fallback';
        }
    }
    statement Fallback_Equal fallback= Line
    {
        method string Get_Language_Name
        {
            return 'Fallback';
        }
    }
    statement Feature feature Feature
    {
        keyword Type;
        argument Name;
        argument Keyword;
        argument Symbol_Class;
    }
    statement File_Append file.append Line
    {
        argument File_Text;
        argument File_Name;
    }
    statement File_Delete file.delete Line
    {
        argument File_Name;
    }
    statement File_Dump file.dump Line
    {
        argument File_Text;
        argument File_Name;
    }
    statement File_Readall file.readall Line
    {
        argument Variable;
        argument File_Name;
    }
    statement File_Read_Line file.readline Line
    {
        argument File_Name;
        argument Variable;
    }
    statement File_Read_List file.readlist Line
    {
        argument File;
        argument Text;
        argument List;
    }
    statement Flag flag Declaration
    {
        argument Variable;
        optional Value;
    }
    statement Flags flags Line;
    statement Flowerbox flowerbox Comment;
    statement For_Down for.down Iterative
    {
        argument Variable;
        argument Start;
        argument End;
        optional Decrement;
    }
    statement Foreach foreach Iterative
    {
        argument List;
        argument Variable;
    }
    statement For_Each_Key foreachkey Iterative
    {
        argument List;
        argument Variable;
    }
    statement For_Each_In for.each.in Iterative
    {
        argument Variable;
        argument List;
    }
    statement For_Prev_Key forprevkey Iterative
    {
        argument List;
        argument Variable;
    }
    statement Forever forever Iterative;
    statement Forgive forgive Scoped;
    statement For_Range for.range Iterative
    {
        argument Variable;
        argument Start;
        argument End;
        optional Increment;
    }
    statement Function_Invoke invoke Line
    {
        argument Function;
    }
    statement Gal gal Method;

    statement Gal_Equal gal= Line;

    statement Generate generate
    {
        argument Class_Name;
        property dictionary Variables;
        method entity Method_Context
        {
            return [self];
        }
    }
    statement Generate_Gal generate.gal
    {
        method entity Method_Context
        {
            return [self];
        }
    }
    statement Generator generator Scoped
    {
        argument Language;
        method string Get_Language_Name
        {
            return (. [my Language] Get_Input);
        }
        method string Get_Property_Name
        {
            return (. [my Language] Get_Input);
        }
    }
    statement Given_An_In given.an.in Iterative
    {
        argument Variable;
        argument List;
    }
    statement Global_List glist Line
    {
        argument Variable;
    }
    statement Glvn glvn Line
    {
        argument Root;
        optional Value;
    }
    statement Glvn_Global glvn^ Line
    {
        argument Root;
    }
    statement Gpu_Function gf Scoped
    {
        argument Name;
    }
    statement Gpu_Invoke gi Scoped
    {
        argument Name;
        argument Blocks;
        argument Threads;
    }
    statement Gpu_Invoke_Method gim Scoped
    {
        argument Class;
        argument Name;
        argument Blocks;
        argument Threads;
    }
    statement Gpu_Method gm Scoped
    {
        argument Name;
    }
    statement Gpu_Property gp Line
    {
        keyword Type;
        argument Name;
        optional Value;
    }
    statement Goal goal Scoped
    {
        argument Name;
        optional Description;
    }
    statement Goal_Spell goal.spell Scoped
    {
        argument Name;
        optional Description;
    }
    Statement Gs gs Scoped
    {
        argument Class_Name;
        method string Get_Language_Name
        {
            return 'Gs';
        }
    }
    Statement Gs_Equal gs= Scoped
    {
        argument Class_Name;
        method string Get_Language_Name
        {
            return 'Gs';
        }
    }
    statement Hope hope Scoped;
    statement Html html Method
    {
        method string Get_Language_Name
        {
            return 'Html';
        }
    }
    statement Dom_Object dom.object Class
    {
        argument Class_Name;
    }
    statement Human_Being human.being Class
    {
    }
    statement I_Equal i= Line
    {
        argument Value;
    }
    statement If if Iffy
    {
        argument Condition;
    }
    statement Ifdef ifdef Scoped;
    statement I i Line
    {
        argument Method;
    }
    statement I_Generate i.generate Line;

    statement Imagine_Statement imagine.statement Scoped
    {
        argument Data_Type;
        argument Name;
        argument Keyword;
    }
    statement Imagine_Operation imagine.operation Scoped
    {
        argument Data_Type;
        argument Name;
        argument Keyword;
    }
    statement Implement implement Line;
    statement Implementer implementer Line
    {
        argument Function;
    }
    statement Implementers implementers Scoped;
    statement Implements_Class implements: Line
    {
        argument Implementer;
        argument Class;
        argument Method;
    }
    statement Implements_Instance implements. Line
    {
        argument Implementer;
        argument Object;
        argument Method;
    }
    statement Import import Line
    {
        argument Name;
        argument Alias;
    }
    statement Improve improve Line;
    statement Include_Implementers include.implementers Line;
    statement Increment ++ Line
    {
        argument Op1;
    }
    statement In_Goalspell in.goalspell Line;
    statement In in Line
    {
        argument Language;
        argument Language_Code;
        optional Dialect_Code;
    }
    statement Infer infer Line
    {
        optional Object;
        keyword Inference;
    }
    statement Inference inference Scoped
    {
        argument Name;
    }
    statement Infer_Inits infer.inits Line;
    statement Inferences inferences Line;
    statement Infers infers Line
    {
        argument Inference;
    }
    statement Initialize initialize Line
    {
        argument Variable;
    }
    statement Integer integer Declaration
    {
        argument Variable;
        optional Value;
    }
    statement Integers integers Line;
    statement Interface interface Line
    {
        keyword Return_Type;
    }
    statement Is_A isa Method
    {
        argument Class;
    }
    statement It_Equals it= Line;
    statement Iterate iterate Iterative
    {
        argument Dictionary;
        argument Key_Variable;
        argument Value_Variable;
    }
    statement Reverse_Iterate reverse.iterate Iterative
    {
        argument Dictionary;
        argument Key_Variable;
        argument Value_Variable;
    }
    statement Javascript javascript Method
    {
        method string Get_Language_Name
        {
            return 'Javascript';
        }
    }
    statement Javascript_Equal javascript= Line
    {
        method string Get_Language_Name
        {
            return 'Javascript';
        }
    }
    statement Job job Line
    {
        argument Method;
        argument Class;
    }
    statement Join join Line
    {
        argument Variable;
        argument List;
        argument Delimiter;
    }
    statement Kill kill Line
    {
        argument Root;
    }
    statement Kill_Global kill^ Line
    {
        argument Root;
    }
    statement Keyword keyword Line
    {
        argument Argument_Name;
        optional Type_Value;
    }
    statement Know know Line
    {
        argument Name;
        argument Directory;
    }
    statement Language language Scoped
    {
        optional Name;
        method string Get_Language_Name
        {
            return (. [my Name] Get_Input);
        }
        method string Get_Property_Name
        {
            return (. [my Name] Get_Input);
        }
    }
    statement Language_Behavior language.behavior Behavior
    {
        keyword Type;
        argument Behavior_Name;
    }
    statement Language_Machine_Architecture language.machine.architecture Scoped;
    statement Lexical lexical
    {
        argument Name;
        argument Literal;
    }
    statement Lock lock Line
    {
        argument Reference;
    }
    statement Global_Lock lock^ Line
    {
        argument Root;
    }
    statement List_Append list.append
    {
        argument List;
    }
    statement List_Assign list.assign Line
    {
        argument Variable;
        argument Index;
        argument Value;
    }
    statement List_Clear list.clear Line
    {
        argument List;
    }
    statement List_Copy list.copy Line
    {
        argument Variable;
        argument Value;
    }
    statement List_Insert list.insert Line
    {
        argument Variable;
        argument Index;
        argument Value;
    }
    statement List_Split list.split Line
    {
        argument List;
        argument String;
        argument Delimiter;
    }
    statement List list Line
    {
        argument Variable;
    }
    statement Lists lists Line;
    statement List_Property_Insert list.property.insert Line
    {
        argument List;
        argument Property_Name;
        argument Inserted_Value;
    }
    statement Main main Scoped
    {
        property dictionary Variables;
        method entity Method_Context
        {
            return [self];
        }
    }
    statement Maximize maximize Scoped;
    statement Member member Scoped
    {
        argument Identifier;
        argument Performance;
    }
    statement Merge_From merge.from Line
    {
        optional Target;
        argument Source;
    }
    statement Merge_To merge.to Line
    {
        argument Source;
        optional Target;
    }
    statement Method method Method
    {
        keyword Type;
        argument Name;
    }
    statement Migrate migrate Line
    {
        argument Name;
        argument Map;
        argument Deferral;
        argument Code;
    }
    statement Minimize minimize Scoped;
    statement Multiply *= Line
    {
        argument Variable;
    }
    statement Mumps mumps Method
    {
        method string Get_Language_Name
        {
            return 'Mumps';
        }
    }
    statement Mumps_Equal mumps= Line
    {
        method string Get_Language_Name
        {
            return 'Mumps';
        }
    }
    statement My_Equal my= Line
    {
        argument Property;
        argument Value;
    }
    statement My_Attribute_Equal my~= Line
    {
        argument Attribute;
        argument Value;
    }
    statement No no Line;
    statement New_Token new.token Line
    {
        argument Token_Entity;
        argument Class;
        argument Mode;
        argument Character;
        argument Start;
        argument End;
    }
    statement Not not Line
    {
        argument Op1;
    }
    statement Nsl_Module nsl.module Scoped
    {
        argument Name;
        method string Get_Module_Name
        {
            return (. [my Name] Get_Input);
        }
    }
    statement Number number Declaration
    {
        argument Variable;
        optional Value;
    }
    statement Numbers numbers Line;
    statement Obj obj Line;
    statement Object object Declaration
    {
        argument Variable;
        optional Value;
    }
    statement Objects objects Line;
    statement Object_New entity.new Line
    {
        argument Variable;
        argument Class;
    }
    statement Ohlc ohlc Line
    {
        argument Trading_Pair;
        argument Epoch;
        argument Open;
        argument High;
        argument Low;
        argument Close;
        argument Vwap;
        argument Volume;
        argument Count;
    }
    statement Open open Line
    {
        argument Device;
        optional Timeout;
    }
    statement Operations operations Dialect;
    statement Optimize optimize Scoped;
    statement Optimize_Equal optimize= Line;
    statement Optional optional Argument
    {
        argument Argument_Name;
        optional Type_Value;
    }
    statement Outcome outcome Line
    {
        argument Result;
        argument Implementer;
        argument Behavior;
    }
    statement Parser parser Class
    {
        argument Class_Name;
    }
    statement Pay_Gratitude pay.gratitude Line
    {
        argument Supporter;
        argument Amount;
    }
    statement Person person Line;
    statement Plist plist Line
    {
        argument Class;
        argument Name;
        argument Count;
    }
    statement Pobj pobj Line
    {
        argument Class;
        argument Name;
        optional Initializer;
    }
    statement Process process Class;
    statement Prompt prompt Scoped;
    statement Prompt_Context prompt.context Line;
    statement Prop_Obj prop.obj Line
    {
        argument Type;
        argument Name;
        optional Value;
    }
    statement Property property Line
    {
        keyword Type;
        argument Name;
        optional Value;
    }
    statement Propset .= Assignment
    {
        argument Object;
        argument Property;
        argument Value;
    }
    statement Python python Method
    {
        method string Get_Language_Name
        {
            return 'Python';
        }
    }
    statement Python_Equal python= Line
    {
        method string Get_Language_Name
        {
            return 'Python';
        }
    }
    statement Queue queue Line
    {
        argument Method;
    }
    statement Quest quest Class
    {
        argument Name;
    }
    statement Quit_Colon quit: Line
    {
        argument Condition;
        optional Return_Value;
    }
    statement Raku raku Line
    {
        method string Get_Language_Name
        {
            return 'Raku';
        }
    }
    statement Raku_Equal raku= Line
    {
        method string Get_Language_Name
        {
            return 'Raku';
        }
    }

    statement Read_Character read.char Line;
    statement Reaadline reaadline Line
    {
        argument Variable;
    }
    statement Readline readline Line
    {
        argument Variable;
    }
    statement Remember remember Scoped
    {
        argument Name;
    }
    statement Rename rename Line
    {
        argument From;
        argument To;
    }
    statement Replace replace Line
    {
        argument Variable;
        argument Search_Text;
        argument Replace_Text;
    }
    statement Report_Outcome report.outcome Line
    {
        argument Result;
        argument Implementer;
    }
    statement Require_That_I require.that.i Line
    {
        argument Self_Method;
    }
    statement Require_That require.that Line;
    statement Retain retain Line
    {
        argument Element;
    }
    statement Return return Line
    {
        optional Value;
    }
    statement Return_If returnif Line
    {
        argument Return_Value;
        optional Condition;
    }
    statement Return_If_Gs return.if.gs Line
    {
        argument Arg1;
        optional Arg2;
    }
    statement Result result Line
    {
        argument Name;
        argument Value;
    }
    statement Roster roster
    {
        argument Capacity;
        argument Floor;
    }
    statement Roster_Floor roster.floor
    {
        argument Floor;
    }
    statement Run_Queue run.queue;
    statement Send_File send.file Line
    {
        argument File_Text;
        argument File_Name;
    }
    statement Sequence sequence Line
    {
        argument Rule_Name;
    }
    statement Saay say Line;
    statement Shell shell Line;
    statement Skip_Token skiptoken Line
    {
        argument Class;
        argument Mode;
    }

    statement Spell spell Scoped
    {
        argument Name;
    }
    statement Statements statements Dialect;
    statement Strings strings Line;
    statement String string Declaration
    {
        argument Variable;
    }
    statement Subtract *= Line
    {
        argument Variable;
    }
    statement Supporter supporter Line
    {
        argument Person;
        argument Supporter;
        argument Weight;
    }
    statement Symbol symbol Class
    {
        keyword Type;
        argument Name;
        optional Parent_Class;
    }
    statement Syntaxes syntaxes Dialect;
    statement Synthesis synthesis Scoped;
    statement Synthesize synthesize Scoped
    {
        argument Predecessor;
        argument Dialect;
    }
    statement Target_Includes target.includes Line;
    statement Test test Scoped
    {
        argument Name;
        property dictionary Variables;
        method entity Method_Context
        {
            return [self];
        }
    }
    statement Test_Case testcase Scoped
    {
        argument Class_Name;
    }
    statement Tests tests Scoped
    {
        argument Name;
    }
    statement Tests_Append tests.append Scoped
    {
        argument Name;
    }
    statement Thing thing Thing
    {
        argument Name;
        argument Keyword;
    }
    statement Tilda tilda;
    statement To_Analyze to.analyze Scoped
    {
        argument Goal_Name;
        argument Test;
    }
    statement Tokenization tokenization Scoped
    {
        argument Language_Name;
    }
    statement Token_Handler token.handler Scoped
    {
        argument Mode;
    }
    statement Token_Initial token.initial Scoped;
    statement Token_Test token.test Line
    {
        argument Code_Text;
    }
    statement Todo todo Comment;
    statement Token_Append token.append Line
    {
        argument Token_Entity;
        argument Character;
        argument Position;
    }
    statement Token_Mode token.mode Line
    {
        argument Mode_Name;
    }
    statement Tokens tokens Line;
    statement Token token Line
    {
        argument Class_Name;
    }
    statement Token_New token.new Line
    {
        argument Class;
        argument Mode;
    }
    statement Translation_Tests translation.tests Scoped
    {
        argument Name;
    }
    statement Try try Error_Handling;
    statement Try_At_Of try.at.of Line
    {
        argument Implementer;
        argument Test;
        argument Goal_Name;
    }
    statement Undefined undefined Scoped;
    statement Unlock unlock Line
    {
        argument Reference;
    }
    statement Global_Unlock unlock^ Line
    {
        argument Root;
    }
    statement Unless unless Iffy
    {
        argument Condition;
    }
    statement Uuid uuid Line
    {
        argument Variable;
    }
    statement Values values Scoped;
    statement Variants variants Line;
    statement Variant variant Declaration
    {
        argument Variable;
        optional Value;
    }
    statement Variations variations Scoped;
    statement Vernacular vernacular Scoped;
    statement Verbose verbose Append_Args;
    statement Verbosity line
    {
        optional Condition;
    }
    statement We we Line
    {
        argument Method;
    }
    statement Web_App web.app Method
    {
        argument Name;
    }
    statement While while Iterative
    {
        argument Condition;
    }
    statement Wriite write Line;
    statement Write write Append_Args;
    statement Write_Line writeline Append_Args;
    statement Yes yes Line;

    operation Absolute absolute
    {
        argument Op1;
    }
    operation Add + Repeating
    {
        argument Op1;
        argument Op2;
    }
    operation And & Repeating
    {
        argument Op1;
        argument Op2;
    }
    operation Begins begins
    {
        argument String_Value;
        argument Begin_Value;
    }
    operation Call .
    {
        argument Object;
        argument Method;
    }
    operation Can can
    {
        argument Predecessor;
        argument Successor;
    }
    operation Char2int char2int
    {
        argument Character;
    }
    operation Classpropget classproget;
    operation Colon :
    {
        argument Class;
        argument Method;
    }
    operation Contains contains Binary
    {
        argument String;
        argument Search;
    }
    operation Create_Element create.element
    {
        argument Tag;
    }
    operation Csv_String csv.string
    {
        argument Columns;
        argument Rows;
    }
    operation Default default
    {
        argument Value;
        argument Root;
    }
    operation Default_Global default^
    {
        argument Value;
        argument Root;
    }
    operation Exists exists
    {
        argument Root;
    }
    operation Defined defined
    {
        argument First;
    }
    operation Dict_Exists dict.exists
    {
        argument Dictionary;
        argument Key;
    }
    operation Dict_Get dict.get
    {
        argument Dictionary;
        argument Key;
    }
    operation Dispatch dispatch
    {
        argument Name;
    }
    operation Distribute distribute
    {
        argument List;
        argument Function;
    }
    operation Divide / Repeating
    {
        argument Op1;
        argument Op2;
    }
    operation Dequote dequote
    {
        argument Op1;
    }
    operation Enquote enquote
    {
        argument Op1;
    }
    operation Equal = Binary
    {
        argument Op1;
        argument Op2;
    }
    operation Environment env
    {
        argument Variable;
    }
    operation Evaluate evaluate
    {
        argument Target;
    }
    operation Not_Equal != Binary
    {
        argument Op1;
        argument Op2;
    }
    operation Exists exists
    {
        argument Root;
    }
    operation Exists_Global exists^
    {
        argument Root;
    }
    operation File_Exists file.exists
    {
        argument Path;
    }
    operation Files files
    {
        todo 'return a list of matching fully-qualified file names.';
        argument Filespec;
    }
    operation First_Char firstchar
    {
        argument String_Value;
    }
    operation Flowerbox flowerbox
    {
    }
    operation From_Json from.json
    {
        argument Object;
    }
    operation Get get
    {
        argument Root;
    }
    operation Get_Element_By_Id get.element.by.id
    {
        argument Id;
    }
    operation Get_Global get^
    {
        argument Root;
    }
    operation Glvn glvn
    {
        argument Variable;
    }
    operation Greater_Equal ge Binary
    {
        argument Op1;
        argument Op2;
    }
    operation Greater_Than gt Binary
    {
        argument Op1;
        argument Op2;
    }
    operation Http_Fetch http.fetch
    {
        argument Url;
    }
    operation I i
    {
        argument Method;
    }
    operation If if
    {
        argument Condition;
        argument If_Value;
        argument Else_Value;
    }
    operation Implement implement;
    operation Int2char int2char
    {
        argument Integer;
    }
    operation Integer integer Unary
    {
        argument Op1;
    }
    operation Flag flag Unary
    {
        argument Op1;
    }
    operation Number number Unary
    {
        argument Op1;
    }
    operation String string Unary
    {
        argument Op1;
    }
    operation Invoke invoke
    {
        argument Function;
    }
    operation Integer_Divide intdiv
    {
        argument Op1;
        argument Op2;
    }
    operation Is_A isa
    {
        argument Variable;
        argument Class_Name;
    }
    operation Is_Ident is.ident
    {
        argument Character;
    }
    operation Is_Lowercase is.lowercase
    {
        argument First;
    }
    operation Is_Uppercase is.uppercase
    {
        argument First;
    }
    operation Is_Whitespace is.whitespace
    {
        argument Character;
    }
    operation Is_Digit is.digit
    {
        argument Character;
    }
    operation Is_Punct is.punct
    {
        argument Character;
    }
    operation Is_Number is.number
    {
        argument Value;
    }
    operation Is_String is.string
    {
        argument Value;
    }
    operation Last_Char last.char
    {
        argument First;
    }
    operation Length length
    {
        argument First;
    }
    operation Less_Equal le Binary
    {
        argument Op1;
        argument Op2;
    }
    operation Less_Than lt Binary
    {
        argument Op1;
        argument Op2;
    }
    operation List_Get list.get
    {
        argument List;
        argument Offset;
    }
    operation List_Last list.last
    {
        argument List;
    }
    operation List_Length list.length
    {
        argument First;
    }
    operation Lowercase lowercase
    {
        argument First;
    }
    operation Module_Class_Name_New module.class.name.new
    {
        argument Module;
        argument Name;
    }
    operation Modulo mod Binary
    {
        argument Op1;
        argument Op2;
    }
    operation Multiply * Repeating
    {
        argument Op1;
        argument Op2;
    }
    operation Name name
    {
    	argument Glvn;
    }
    operation New new
    {
        argument Class_Name;
    }
    operation New_My_Class new.my.class;
    operation New_Our_Class new.our.class;
    operation Not not Unary
    {
        argument Op1;
    }
    operation Is_Null isnull Unary
    {
        argument Op1;
    }
    operation Next next
    {
        argument Root;
    }
    operation Next_Global next^
    {
        argument Root;
    }
    operation Not_Null notnull Unary
    {
        argument Op1;
    }
    operation Or or Repeating
    {
        argument Op1;
        argument Op2;
    }
    operation Outcome outcome
    {
        argument Amount;
    }
    operation Power power Binary
    {
        argument Op1;
        argument Op2;
    }
    operation List_Pop pop
    {
        argument First;
    }
    operation Prev prev
    {
        argument Root;
    }
    operation Prev_Global prev^
    {
        argument Root;
    }
    operation Processes processes;

    operation QLength qlength
    {
        argument Glvn;
    }
    operation QSubscript qsubscript
    {
        argument Glvn;
        argument Subscript;
    }

    operation Random_Integer randint
    {
        argument Values;
    }
    operation Random_Percent random.percent;
    operation Round round
    {
        argument Number;
        optional Decimals;
    }
    operation Shift shift
    {
        argument First;
    }
    operation Split split
    {
        argument String;
        argument Delimiter;
    }
    operation Sql_Array sql.array
    {
        argument Query;
    }
    operation Sql_Object sql.object
    {
        argument Query;
    }
    operation Square_Root sqrt
    {
        argument Op1;
    }
    operation String_Append s+ Repeating
    {
        argument Op1;
        argument Op2;
    }
    operation String_Equal s= Binary
    {
        argument Op1;
        argument Op2;
    }
    operation String_Not_Equal sne Binary
    {
        argument Op1;
        argument Op2;
    }
    operation String_Greater_Equal sge Binary
    {
        argument Op1;
        argument Op2;
    }
    operation String_Greater sgt Binary
    {
        argument Op1;
        argument Op2;
    }
    operation String_Less_Equal sle Binary
    {
        argument Op1;
        argument Op2;
    }
    operation String_Less slt Binary
    {
        argument Op1;
        argument Op2;
    }
    operation Substring substring
    {
        argument String_Value;
        argument Start_Index;
        optional Length;
    }
    operation Subtract - Repeating
    {
        argument Op1;
        optional Op2;
    }
    operation Ternary ?
    {
        argument Condition;
        argument If;
        argument Else;
    }
    operation Test test
    {
    }
    operation Then then
    {
        argument Predecessor;
        argument Successor;
    }
    operation Tilda tilda;
    operation Time_String now.string;
    operation Titlecase titlecase
    {
        argument String;
    }
    operation To_Json to.json
    {
        argument Object;
    }
    operation Token_Mode token.mode
    {
        argument Mode_Name;
    }
    operation Uppercase uppercase
    {
        argument First;
    }
    operation Uuid uuid;
    operation We we
    {
        argument Method;
    }
    
    syntax Array array;
    syntax Attribute attribute
    {
        argument Object;
        argument Attribute;
    }
    syntax Await await
    {
        argument Invocation;
    }
    syntax Behavior behavior;
    syntax Bold bold;
    syntax Class class
    {
        argument Object;
    }
    syntax Class_Attribute class.attribute
    {
        argument Class;
        argument Attribute;
    }
    syntax Class_Name class.name
    {
        optional Object;
    }
    syntax Class_Property :
    {
        argument First;
        optional Second;
    }
    syntax Classes classes;
    syntax Code code;
    syntax Count count
    {
        argument Minimum;
        argument Maximum;
    }
    syntax Dictionary dict Argument
    {
        argument Variable;
    }
    syntax Dictionary_Key dict.key;
    syntax Object entity Argument
    {
        argument Variable;
        optional Default_Value;
    }
    syntax Either either
    {
        todo;
    }
    syntax Exclude exclude
    {
        argument Rule_Name;
    }
    syntax False false;
    syntax Flag flag Argument
    {
        argument Variable;
        optional Default_Value;
    }
    syntax Function_Pointer fptr
    {
        argument Name;
    }
    syntax Future future;
    syntax Generator generator;
    syntax Glvn glvn
    {
        argument Root;
    }
    syntax Italic italic;
    syntax Implementers_Of implementers.of
    {
        argument Goal_Name;
    }
    syntax Indent indent
    {
        optional Count;
    }
    syntax Init init;
    syntax Input input
    {
        argument Name;
    }
    syntax Integer integer Argument
    {
        argument Variable;
        optional Default_Value;
    }
    syntax Is is
    {
        argument Superclass;
    }
    syntax Is_Main ismain;
    syntax Job job;
    syntax Language_Elements language.elements
    {
        argument Dialect;
    }
    syntax Line line
    {
        optional Count;
    }
    syntax List list Argument
    {
        argument Variable;
    }
    syntax Method method;
    syntax Mildbeard mildbeard;
    syntax Module_Class module.class
    {
        argument Module_Expression;
        argument Class_Name;
    }
    syntax My_Attribute my.attribute;
    syntax My_Class my.class;
    syntax My my
    {
        argument Property;
    }
    syntax New_List new.list;
    syntax Node node
    {
        argument Root;
    }
    syntax Null null;
    syntax Number number Argument
    {
        argument Variable;
        optional Default_Value;
    }
    syntax Optrep optrep
    {
        argument Rule_Name;
    }
    syntax Our our
    {
        optional Class_Property;
    }
    syntax Outcomes outcomes;
    syntax Output output;
    syntax Optional optional
    {
        argument Rule_Name;
    }
    syntax Property .
    {
        argument Object;
        argument Property_Name;
    }
    syntax Property_Lookup property.lookup
    {
        argument Object;
        argument Name_String;
    }
    syntax Repeating repeating
    {
        argument Rule_Name;
    }
    syntax Request request
    {
        argument Key;
    }
    syntax Roster_Floor roster.floor;
    syntax Session session
    {
        argument Key;
    }
    syntax String string Argument
    {
        argument Variable;
        optional Default_Value;
    }
    syntax Self self;
    syntax Sequence sequence
    {
        argument Rule_Name;
    }
    syntax Sql_Connection sql.connection
    {
        argument Database;
        optional Server;
    }
    syntax Remember remember
    {
        argument Name;
        argument Expression;
    }
    syntax Tab tab
    {
        optional Count;
    }
    syntax Tilda tilda;
    syntax True true;
    syntax Us us;
    syntax Variant variant Argument
    {
        argument Variable;
        optional Default_Value;
    }

class Gal_Parser [is Parser];
class Gs_Parser [is Parser];


flowerbox "Tasks";

statement Title title Feature
{
    property string Property_Name 'Title';
    argument Value;
}

statement Created created Feature
{
    property string Property_Name 'Created';
    argument Value;
}

statement Comments comments Feature
{
    property string Property_Name 'Comments';
    argument Value;
}

statement Assignee assignee Feature
{
    property string Property_Name 'Assignee';
    argument Value;
}

statement Completed completed Feature
{
    property string Property_Name 'Completed';
    argument Value;
}
statement Expires expires Feature
{
    property string Property_Name 'Expires';
    argument Value;
}

statement Status status Feature
{
    property string Property_Name 'Status';
    argument Value;
}

statement Task task Thing
{
    property string Thing_Type 'Thing_Task';
    argument Name;
    optional Text;
}

statement Task_List task.list Thing
{
    property string Thing_Type 'Thing_Task_List';
    argument Name;
    optional Text;
}

statement Person person Thing
{
    property string Thing_Type 'Thing_Person';
    argument Name;
    optional Text;
}

class Thing_Food [is Thing]
{
    property object Portion (new Portion [self]);
    property object Fat (new Fat [self]);
    property object Saturated_Fat (new Saturated_Fat [self]);
    property object Cholesterol (new Cholesterol [self]);
    property object Sodium (new Sodium [self]);
    property object Carbohydrate (new Carbohydrate [self]);
    property object Fiber (new Fiber [self]);
    property object Sugar (new Sugar [self]);
    property object Protein (new Protein [self]);
    property object Calcium (new Calcium [self]);
    property object Iron (new Iron [self]);
    property object Potassium (new Potassium [self]);
}
class Statement_Food [is Thing_Statement]
{
    class.property string Gal_Keyword 'food';
    class.property string Gs_Keyword 'food';
    property string Thing_Type 'Thing_Food';
    attribute object Name Argument;
    property object Text;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Name';
        }
        my= Name (shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Text (shift [my Listargs]);
        }
        return [true];
    }
}
class Thing_Meal [is Thing]
{
    property object Name (new String [self]);
    property object Foods (new List [self]);
}
class Statement_Meal [is Thing_Statement]
{
    class.property string Gal_Keyword 'meal';
    class.property string Gs_Keyword 'meal';
    property string Thing_Type 'Thing_Meal';
    attribute object Name Argument;
    property object Text;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Name';
        }
        my= Name (shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Text (shift [my Listargs]);
        }
        return [true];
    }
}
class Thing_Recipe [is Thing]
{
    property object Name (new String [self]);
    property object Ingredients (new List [self]);
    property object Steps (new List [self]);
}
class Statement_Recipe [is Thing_Statement]
{
    class.property string Gal_Keyword 'recipe';
    class.property string Gs_Keyword 'recipe';
    property string Thing_Type 'Thing_Recipe';
    attribute object Name Argument;
    property object Text;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Name';
        }
        my= Name (shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Text (shift [my Listargs]);
        }
        return [true];
    }
}
class Statement_Ingredients [is Statement]
{
    class.property string Gal_Keyword 'ingredients';
    class.property string Gs_Keyword 'ingredients';
    fallback 'hello';
    method flag Attributes
    {
        return [true];
    }
}
class Thing_Nutrition [is Thing];
class Statement_Nutrition [is Thing_Statement]
{
    class.property string Gal_Keyword 'nutrition';
    class.property string Gs_Keyword 'nutrition';
    property string Thing_Type 'Thing_Nutrition';
    attribute object Name Argument;
    property object Text;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Name';
        }
        my= Name (shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Text (shift [my Listargs]);
        }
        return [true];
    }
}
class Statement_Grams [is Statement]
{
    class.property string Gal_Keyword 'g';
    class.property string Gs_Keyword 'g';
    property object Food (new Argument [self]);
    property object Amount (new Argument [self]);
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Food';
        }
        my= Food (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        return [true];
    }
}
class Source [is String]
{
    property object Symbol_Object;
    property string Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Source [is Feature_Statement]
{
    class.property string Gal_Keyword "'source'";
    class.property string Gs_Keyword "'source'";
    property string Property_Name 'Source';
    attribute object Value Argument;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Value';
        }
        my= Value (shift [my Listargs]);
        return [true];
    }
}
class Calories [is String]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Calories [is Feature_Statement]
{
    class.property string Gal_Keyword "'calories'";
    class.property string Gs_Keyword "'calories'";
    property string Property_Name 'Calories';
    attribute object Value Argument;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Value';
        }
        my= Value (shift [my Listargs]);
        return [true];
    }
}
class Portion [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Portion [is Amount_Statement]
{
    class.property string Gal_Keyword 'portion';
    class.property string Gs_Keyword 'portion';
    property string Property_Name 'Portion';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Fat [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Fat [is Amount_Statement]
{
    class.property string Gal_Keyword 'fat';
    class.property string Gs_Keyword 'fat';
    property string Property_Name 'Fat';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Saturated_Fat [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Saturated_Fat [is Amount_Statement]
{
    class.property string Gal_Keyword 'saturated';
    class.property string Gs_Keyword 'saturated';
    property string Property_Name 'Saturated_Fat';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Cholesterol [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Cholesterol [is Amount_Statement]
{
    class.property string Gal_Keyword 'cholesterol';
    class.property string Gs_Keyword 'cholesterol';
    property string Property_Name 'Cholesterol';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Sodium [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Sodium [is Amount_Statement]
{
    class.property string Gal_Keyword 'sodium';
    class.property string Gs_Keyword 'sodium';
    property string Property_Name 'Sodium';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Carbohydrate [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Carbohydrate [is Amount_Statement]
{
    class.property string Gal_Keyword 'carbohydrate';
    class.property string Gs_Keyword 'carbohydrate';
    property string Property_Name 'Carbohydrate';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Fiber [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Fiber [is Amount_Statement]
{
    class.property string Gal_Keyword 'fiber';
    class.property string Gs_Keyword 'fiber';
    property string Property_Name 'Fiber';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Sugar [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Sugar [is Amount_Statement]
{
    class.property string Gal_Keyword 'sugar';
    class.property string Gs_Keyword 'sugar';
    property string Property_Name 'Sugar';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Protein [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Protein [is Amount_Statement]
{
    class.property string Gal_Keyword 'protein';
    class.property string Gs_Keyword 'protein';
    property string Property_Name 'Protein';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Vitamin [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Vitamin [is Amount_Statement]
{
    class.property string Gal_Keyword 'vitamin';
    class.property string Gs_Keyword 'vitamin';
    property string Property_Name 'Vitamin';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Calcium [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Calcium [is Amount_Statement]
{
    class.property string Gal_Keyword 'calcium';
    class.property string Gs_Keyword 'calcium';
    property string Property_Name 'Calcium';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Iron [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Iron [is Amount_Statement]
{
    class.property string Gal_Keyword 'iron';
    class.property string Gs_Keyword 'iron';
    property string Property_Name 'Iron';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Potassium [is Amount]
{
    property object Symbol_Object;
    property number Symbol_Value;
    constructor [entity Object]
    {
        my= Symbol_Object Object;
    }
}
class Statement_Potassium [is Amount_Statement]
{
    class.property string Gal_Keyword 'potassium';
    class.property string Gs_Keyword 'potassium';
    property string Property_Name 'Potassium';
    attribute object Amount Argument;
    attribute object Unit Keyword;
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Amount';
        }
        my= Amount (shift [my Listargs]);
        if (= (list.length [my Keywords]) 0)
        {
            error 'missing required keyword Unit';
        }
        = [my Unit Symbol_Value] (shift [my Keywords]);
        return [true];
    }
}
class Statement_For_Each_Human_Being [is Scoped_Statement]
{
    class.property string Gal_Keyword 'for.each.human.being';
    class.property string Gs_Keyword 'for each human being';
    property entity Human_Entity (new Argument [self]);
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Human_Entity';
        }
        my= Human_Entity (shift [my Listargs]);
        return [true];
    }
}
class Statement_For_Each_Human_Outcome [is Scoped_Statement]
{
    class.property string Gal_Keyword 'for.each.human.outcome';
    class.property string Gs_Keyword 'for each human outcome';
    property entity Human_Entity (new Argument [self]);
    property entity Outcome_Entity (new Argument [self]);
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Human_Entity';
        }
        my= Human_Entity (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Outcome_Entity';
        }
        my= Outcome_Entity (shift [my Listargs]);
        return [true];
    }
}
class Statement_For_Each_Outcome_Support [is Scoped_Statement]
{
    class.property string Gal_Keyword 'for.each.outcome.support';
    class.property string Gs_Keyword 'for each outcome support';
    property entity Outcome_Entity (new Argument [self]);
    property entity Support_Entity (new Argument [self]);
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Outcome_Entity';
        }
        my= Outcome_Entity (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Support_Entity';
        }
        my= Support_Entity (shift [my Listargs]);
        return [true];
    }
}
class Statement_For_Each_Supporter [is Scoped_Statement]
{
    class.property string Gal_Keyword 'for.each.supporter';
    class.property string Gs_Keyword 'for each supporter';
    property entity Support_Entity (new Argument [self]);
    property entity Supporter_Entity (new Argument [self]);
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Support_Entity';
        }
        my= Support_Entity (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Supporter_Entity';
        }
        my= Supporter_Entity (shift [my Listargs]);
        return [true];
    }
}
class Operation_Human_Outcome_Gratitude [is Operation]
{
    class.property string Gal_Keyword 'human.outcome.gratitude';
    class.property string Gs_Keyword 'human outcome gratitude';
    property entity Supporter_Entity (new Argument [self]);
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Supporter_Entity';
        }
        my= Supporter_Entity (shift [my Listargs]);
        return [true];
    }
}
class Statement_Pay [is Line_Statement]
{
    class.property string Gal_Keyword 'pay';
    class.property string Gs_Keyword 'pay';
    property entity Transaction_Entity (new Argument [self]);
    method flag Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Transaction_Entity';
        }
        my= Transaction_Entity (shift [my Listargs]);
        return [true];
    }
}
class Statement_Cycle [is Scoped_Statement]
{
    class.property string Gal_Keyword 'cycle';
    class.property string Gs_Keyword 'cycle';
    method flag Attributes
    {
        return [true];
    }
}
flowerbox 'Gal.gal';

goal.spell Gal 'general abstract language'
{
    dialect Gal
    {
        statements,
            Statement_Add 'add' '+' '+=',
            Statement_And 'and' '&' 'and=' '&=',
            Statement_Append 'append' 'string.append' 's+',
            Statement_Argument 'argument',
            Statement_Assign 'assign' '=',
            Statement_Atomic 'atomic',
            Statement_Attribute 'attribute',
            Statement_Author 'author',
            Statement_Behavior 'behavior',
            Statement_Break 'break',
            Statement_Break_If 'breakif' 'break.if',
            Statement_Call '.' 'call',
            Statement_Catch 'catch',
            Statement_Class 'class',
            Statement_Class_Append 'class.append',
            Statement_Class_Attribute 'class.attribute',
            Statement_Class_Method 'class.method' 'classmethod',
            Statement_Class_Property 'class.property' 'classprop',
            Statement_Classpropset ':=' 'classpropset' 'cp.=',
            Statement_Classify 'classify',
            Statement_Comment 'comment',
            Statement_Compile 'compile',
            Statement_Constructor 'constructor',
            Statement_Contest 'contest',
            Statement_Continue 'continue',
            Statement_Continue_If 'contif' 'continue.if',
            Statement_Currency 'currency',
            Statement_Debug 'debug' 'debugger',
            Statement_Debug_If 'debugif' 'debug.if',
            Statement_Decrement 'decrement' '--',
            Statement_Dialect 'dialect',
            Statement_Dictionary 'dict' 'dictionary' 'hash',
            Statement_Dictionary_Assign 'dict.assign',
            Statement_Dictionaries 'dicts' 'dictionaries' 'hashes',
            Statement_Do 'do' 'do @',
            Statement_Document_Reference 'document_reference',
            Statement_Else 'else',
            Statement_Either 'either',
            Statement_Expect_String 'expect.string',
            Statement_Fallback 'fallback',
            Statement_Forgive 'forgive',
            Statement_Generate 'generate',
            Statement_I_Equal 'i=' 'i =' 'i equal',
            Statement_Iterate 'iterate',
            Statement_List_Copy 'list.copy',
            Statement_Parser 'parser',
            Statement_Sequence 'sequence',
            Statement_Else_If 'else.if',
            Statement_English 'english',
            Statement_Objects 'entities' 'objects',
            Statement_Object 'entity' 'object',
            Statement_Object_New 'entity.new' 'object.new',
            Statement_Error 'error' 'throw' 'raise' 'whoops' 'oops',
            Statement_Execute 'execute',
            Statement_Feature 'feature',
            Statement_File_Dump 'file.dump',
            Statement_File_Readall 'file.readall' 'readall',
            Statement_Flag 'flag' 'boolean' 'bool',
            Statement_Flags 'flags' 'booleans' 'bools',
            Statement_Flowerbox 'flowerbox',
            Statement_For_Range 'for.range',
            Statement_Forever 'forever',
            Statement_Foreach 'foreach',
            Statement_Generator 'generator',
            Statement_Goal 'goal',
            Statement_Goal_Spell 'goalspell' 'goal.spell',
            Statement_Gs 'gs' 'goalspell',
            Statement_Gs_Equal 'gs=' 'goalspell=''gs.=' 'goalspell.=',
            Statement_I 'i',
            Statement_Improve 'improve',
            Statement_Increment 'increment' '++',
            Statement_If 'if',
            Statement_Ifdef 'ifdef', 'ifdefined', 'if def', 'if defined',
            Statement_Infer_Inits 'infer.inits',
            Statement_Inference 'inference',
            Statement_Infers 'infers',
            Statement_Integer 'integer' 'int',
            Statement_Integers 'integers' 'ints',
            Statement_Is_A 'isa' 'is a' 'is.a',
            Statement_It_Equals 'it=',
            Statement_Join 'join' 'list.join',
            Statement_Keyword 'keyword',
            Statement_List 'list' 'list.items',
            Statement_Lists 'lists',
            Statement_List_Append 'list.append' 'list+' 'push',
            Statement_List_Clear 'list clear' 'lclear' 'list.clear',
            Statement_Main 'main',
            Statement_Menu_Item 'menu_item',
            Statement_Menu_Dropdown 'menu_dropdown',
            Statement_Menu_Bar 'menu_bar',
            Statement_Method 'method',
            Statement_My_Equal 'my=',
            Statement_New_Token 'newtoken' 'new.token',
            Statement_Number 'number',
            Statement_Numbers 'numbers',
            Statement_Gal_Operation 'operation',
            Statement_Operations 'operations',
            Statement_Optimize_Equal 'optimize=',
            Statement_Optional 'optional',
            Statement_Prompt_Context 'prompt.context',
            Statement_Property 'property',
            Statement_Propset '.=' 'propset',
            Statement_Read_Character 'read.char',
            Statement_Readline 'readline' 'read.line',
            Statement_Replace 'replace',
            Statement_Return 'return',
            Statement_Return_If 'returnif' 'return.if',
            Statement_Require_That 'require.that',
            Statement_Require_That_I 'require.that.i',
            Statement_Site 'site',
            Statement_Skip_Token 'skiptoken' 'skip.token',
            Statement_Spell 'spell',
            Statement_Gal_Statement 'statement',
            Statement_Statements 'statements',
            Statement_String 'string',
            Statement_Strings 'strings',
            Statement_Supporter 'supporter',
            Statement_Symbol 'symbol',
            Statement_Gal_Syntax 'syntax',
            Statement_Syntaxes 'syntaxes',
            Statement_Thing 'thing',
            Statement_Todo 'todo',
            Statement_Token 'token',
            Statement_Tokens 'tokens',
            Statement_Token_Append 'token.append' 'tokenappend',
            Statement_Token_Mode 'token.mode' 'tokenmode',
            Statement_Try 'try',
            Statement_Undefined 'undef' 'undefined',
            Statement_Variant 'var' 'variant',
            Statement_Variants 'vars' 'variants',
            Statement_Vernacular 'vernacular',
            Statement_Verbose 'verbose',
            Statement_Verbosity 'verbosity',
            Statement_We 'we',
            Statement_While 'while',
            Statement_Write 'write',
            Statement_Write_Line 'writeline' 'write.line' 'say'
        ;
        operations,
            Operation_Add 'add' '+' 'plus',
            Operation_And 'and' '&' '&&',
            Operation_Begins 'startswith' 'starts.with' 'starts' 'begins' 'beginswith' 'begins.with',
            Operation_Classpropget 'classpropget',
            Operation_Call 'call' '.',
            Operation_Char2int 'chartoint' 'char to int' 'charint' 'char int' 'char2int' 'char2num',
            Operation_Colon ':',
            Operation_Contains 'contains',
            Operation_Defined 'defined',
            Operation_List_Last 'list.last',
            Operation_Split 'split',
            Operation_Dict_Exists 'dict.exists' 'key.exists',
            Operation_Dict_Get 'dict.get' 'key.get',
            Operation_Divide 'divide' '/' 'div',
            Operation_Environment 'env' 'environment',
            Operation_Equal '=' '==' 'eq' 'equals' 'equal',
            Operation_First_Char 'firstchar' 'first.char',
            Operation_Greater_Equal '>=' 'ge',
            Operation_Greater_Than '>' 'gt' 'greater',
            Operation_I 'i' 'self',
            Operation_Int2char 'int char' 'intchar' 'int2char' 'num2char',
            Operation_Is_A 'isa' 'is.a',
            Operation_Is_Ident 'isident' 'is.ident',
            Operation_Is_Lowercase 'islowercase' 'is.lowercase' 'islower',
            Operation_Is_Uppercase 'isuppercase' 'is.uppercase' 'isupper',
            Operation_Is_Whitespace 'isws' 'is.ws' 'iswhitespace' 'is.whitespace' 'whitespace',
            Operation_Is_Null 'isnull' 'is.null',
            Operation_Last_Char 'lastchar' 'last.char',
            Operation_Length 'length' 'len' 'string.length',
            Operation_Less_Equal '<=' 'le',
            Operation_Less_Than '<' 'lt' 'less',
            Operation_List_Get 'list.get',
            Operation_List_Length 'list.length',
            Operation_List_Pop 'pop' 'list.pop' 'lpop',
            Operation_Lowercase 'lowercase' 'lower',
            Operation_Multiply '*' 'multiply' 'mult' 'times',
            Operation_New 'new',
            Operation_Not 'not' '!',
            Operation_Not_Equal 'ne' '!=' '<>',
            Operation_Not_Null 'notnull',
            Operation_Or 'or' '|' '||',
            Operation_Titlecase 'title' 'titlecase' 'title.case',
            Operation_Token_Mode 'tokenmode' 'token.mode',
            Operation_Shift 'shift' 'list.shift',
            Operation_String 'string',
            Operation_Subtract 'subtract' '-' 'minus',
            Operation_Substring 'substring',
            Operation_String_Append 'append' 's+',
            Operation_String_Equal 's=' 'seq' 'string.eq',
            Operation_String_Not_Equal 's!=' 'sne',
            Operation_String_Greater 'string.gt' 'sgt' 's.gt' 's>',
            Operation_String_Less 's<' 'slt' 's.lt' 'string.lt' ,
            Operation_String_Greater_Equal 's.ge' 'sge',
            Operation_String_Less_Equal 'sle' 'string.le'
            's<=',
            Operation_Uppercase 'uppercase' 'upper',
            Operation_We 'we'
        ;
        syntaxes,
            Syntax_Attribute 'attribute' 'att' '~',
            Syntax_Class_Attribute 'class.attribute' 'class.att' 'classatt',
            Syntax_Class_Name 'class.name' 'classname',
            Syntax_Class_Property ':',
            Syntax_Generator 'generator',
            Syntax_Indent 'indent',
            Syntax_Line 'line',
            Syntax_List 'list',
            Syntax_Optrep 'optrep',
            Syntax_Repeating 'repeating',
            Syntax_Object 'entity' 'object',
            Syntax_False 'false',
            Syntax_Integer 'integer',
            Syntax_Is 'is',
            Syntax_My 'my',
            Syntax_My_Attribute 'my.attribute' 'my.att',
            Syntax_My_Class 'my.class' 'my.class' 'self.class',
            Syntax_Null 'null',
            Syntax_Property '.' 'property' 'propchain',
            Syntax_Self 'self' 'me',
            Syntax_String 'string',
            Syntax_True 'true'
        ;
    }

    class Gal_Parser
    {
        infers Tokens;
        infers Elements;
        infers Location;
        infers Verb;
        infers Classification;
        infers Components;
        infers Attributes;
        infers Structure;

        property entity Dialect Dialect_Gal;

        attribute list Inferences;
        attribute list Tokens;
        attribute list Elements;

        property integer Position 0;
        constructor [entity Owner]
        {
            my= Owner Owner;
            my= Dialect (new Dialect_Gal);
        }
        method flag Initialize
        {
            flag Verbose [false];
            verbose [class.name [self]] ' Inits';
            . [my Dialect] Initialize;
            infer.inits;
            return [true];
        }
    }

    parser Gal
    {
        tokens Token_Name Token_Number Token_Quote Token_Keyword Token_Semi Token_Comma;
        token Token_Operation_Start;
        token Token_Operation_End;
        token Token_Syntax_Start;
        token Token_Syntax_End;
        token Token_Block_Start;
        token Token_Block_End;
        token Name_Token;

        sequence Operation
            Token_Operation_Start
            [repeating Expression]
            [optrep Operation_Tail]
            Token_Operation_End;

        sequence Operation_Tail
            Token_Comma
            [repeating Expression];

        sequence Syntax
            Token_Syntax_Start
            [repeating Expression]
            [optrep Syntax_Tail]
            Token_Syntax_End;

        sequence Syntax_Tail
            Token_Comma
            [repeating Expression];

        either Expression
            Operation
            Syntax
            Name_Token
            Token_Number
            Token_Quote;

        either Statement_End 
            Token_Semi 
            Block;

        sequence Statement_Tail
            Token_Comma
            [repeating Expression];

        sequence Statement
            [repeating Expression]
            [optrep Statement_Tail]
            Statement_End;

        sequence Block
            Token_Block_Start
            [optrep Statement]
            Token_Block_End;

        sequence Statements
            [repeating Statement];

        sequence Expressions
            [repeating Expression];

        either Program 
            Statements 
            Expression;
    }

    class.append Named_Element
    {
        property list Gal_Keywords;
        property string Gal_Keyword '';
        property string Gal_Key_Suffix '';
        method string Gal_Arguments
        {
            string Code '';
            string Arg_Code;
            entity Arg;
            foreach [my Arguments] Arg
            {
                = Arg_Code [. Arg Gal];
                if (begins Arg_Code ',')
                {
                    append Code Arg_Code;
                }
                else
                {
                    append Code ' ' Arg_Code;
                }
            }
            return Code;
        }
        method string Gal_Key
        {
            string Code '';
            string Between '';
            string Key;
            foreach [my Gal_Keywords] Key
            {
                append Code Between Key;
                = Between ' ';
            }
            return Code;
        }
        method string Gal_Listargs
        {
            string Code '';
            entity Arg;
            foreach [my Listargs] Arg
            {
                append Code ' ' [. Arg Gal];
            }
            return Code;
        }
        method string Gal_Tails
        {
            string Code '';
            entity Tail;
            foreach [my Tails] Tail
            {
                append Code (. Tail Gal_Tail);
            }
            return Code;
        }
    }

    class.append Syntax
    {
        property list Tails;
        method string Syntax_Gal [string Code]
        {
            return (append '[' Code ']');
        }
        method string Old_Syntax_Gal [string Code]
        {
            string Ret '';
            if (isa [my Owner] Syntax_Tail)
            {
                if (sne (firstchar Code) ',')
                {
                    append Ret ', ';
                }
                append Ret Code;
            }
            else
            {
                append Ret '[' Code ']';
            }
            return Ret;
        }
        method string Gal_Tail
        {
            string Gal [my Gal];
            integer Length (- (length Gal) 2);
            string Middle (substring Gal 1 Length);
            string Code ', ' Middle;
            return Code;
        }
    }

    class.append Operation
    {
        property list Tails;
        method string Gal_Tail
        {
            string Gal [my Gal];
            integer Length (- (length Gal) 2);
            string Middle (substring Gal 1 Length);
            string Code ', ' Middle;
            return Code;
        }
    }

    class.append Statement
    {
        property list Tails;
        method string Gal_Block
        {
            string Code ';';
            if (defined [my Block])
            {
                = Code [my Block Gal];
            }
            return Code;
        }
    }

    class.append Block
    {
        property string Gal_Statements '';
    }

    class Gal_Generator [is Generator]
    {
        infers Gal;
        attribute list Elements;
        attribute list Inferences;
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            flag Verbose [false];
            verbose [class.name] ' Inits';
            infer.inits;
            return [true];
        }
    }

    inference string Gal
    {
        generate Element '';
        generate Token [my Input];
        generate Statement (i Gal_Key) (i Gal_Arguments) (i Gal_Block);
        generate Operation '(' (i Gal_Key) (i Gal_Arguments) ')';
        generate Syntax
        {
             string Code (i Gal_Key) (i Gal_Arguments);
             i= (i Syntax_Gal Code);
        }
        generate Statement_Tail
        {
            string Code (i Gal_Arguments);
            i= Code;
        }
        generate Operation_Tail
        {
            string Code (i Gal_Arguments);
            i= Code;
        }
        generate Syntax_Tail
        {
            debug;
            todo 'translate object syntax tail to entity for gal output.';
            string Code (i Gal_Arguments);
            i= Code;
        }

        generate Syntax_My_Attribute
        {
            string Code 'my.attribute' (i Gal_Arguments);
            i= (i Syntax_Gal Code);
        }

        generate Block
        {
            entity Line;
            string Statements '';
            foreach [my Statements] Line
            {
                append Statements [. Line Gal] [line];
            }
            = Statements (i Indent Statements);
            string Code [line] 
                '{' [line]
                    Statements 
                '}';
            my= Gal_Statements Statements;
            i= Code;
        }
        generate Gal_Generator
        {
            verbosity;
            flag Error_Fail [true];
            entity Elem;
            entity I;
            integer Number 0;
            variant Error;
            foreach [my.attribute Elements] Elem
            {
                if Error_Fail
                {
                    = I [. Elem Classification];
                    . I Infer_Gal;
                    .= Elem Gal [. I Gal];
                    increment Number;
                }
                else
                {
                    try
                    {
                        = I [. Elem Classification];
                        . I Infer_Gal;
                        .= Elem Gal [. I Gal];
                        increment Number;
                    }
                    catch Error
                    {
                        my= Status [false];
                        .= Elem Error Error;
                        comment debug;
                        verbose 'Error gal element ' Number
                            ': ' [classname I]
                            ', <' Error '>'
                            ', source ' (. I Get_Input);
                    }
                }
            }
            returnif (not [my Status]) [false];
            entity Top (list.last [my.attribute Elements]);
            comment debug;
            string Code [. Top Gal];
            i= Code;
            my= Code Code;
            return [true];
        }

        generate Statements
        {
            comment debug;
            string Code '';
            entity Statement;
            foreach [my Elements] Statement
            {
                append Code [. Statement Gal] [line];
            }
            i= Code;
        }

        generate Statement_Write_Line 'writeline' (i Gal_Arguments) ';';

        generate Statement_Gal_Statement
        {
            string Name [my Name Gal];
            string Keyword [my Keyword Gal];
            string Gal_Name Name;
            string Gs_Name Name;
            if (isa Token_Quote [my Keyword])
            {
                = Gal_Name (. [my Keyword] Unquoted);
            }
            else
            {
                = Gs_Name (i Enquote Gs_Name);
            }
            replace Gal_Name ' ' '.';

            string Code 'statement ' Name ' ' Keyword;
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gal];
            }
            append Code [line] '{' [line, indent]
                'property string Gal_Keyword ' Gal_Name ';' [line, indent]
                'property string Gs_Keyword ' Gs_Name ';' [line];
            if (defined [my Block])
            {
                append Code [my Block Gal_Statements];
            }
            append Code '}';
            i= Code;
        }
        generate Statement_Gal_Operation
        {
            string Code 'operation ' [my Name Gal] ' ' [my Keyword Gal];
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gal];
            }
            append Code (i Gal_Block);
            i= Code;
        }
        generate Statement_Gal_Syntax
        {
            string Code 'syntax ' [my Name Gal] ' ' [my Keyword Gal];
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gal];
            }
            append Code (i Gal_Block);
            i= Code;
        }
        generate Statement_Goalspell 
            'goal.spell' (i Gal_Arguments) (i Gal_Block);
        generate Statement_File_Readall
            'file.readall' (i Gal_Arguments) ';';
        generate Statement_File_Dump
            'file.dump' (i Gal_Arguments) ';';
        generate Statement_Flowerbox
            'flowerbox' (i Gal_Arguments) (i Gal_Block);
        generate Statement_My_Equal
            'my=' (i Gal_Arguments) ';';
        generate Operation_List_Length
            '(list.length' (i Gal_Arguments) ')';
        generate Operation_List_Last
            '(list.last' (i Gal_Arguments) ')';
        generate Statement_Break_If
            'break.if' (i Gal_Arguments) ';';
        generate Statement_Continue_If
            'contif' (i Gal_Arguments) ';';
        generate Statement_Require_That
            'require.that' (i Gal_Arguments) ';';
        generate Statement_Require_That_I
            'require.that.i' (i Gal_Arguments) ';';
        generate Operation_List_Get
            '(list.get' (i Gal_Arguments) ')';
        generate Operation_Shift
            '(shift' (i Gal_Arguments) ')';
        generate Statement_List_Append
            'push' (i Gal_Arguments) ';';
        generate Statement_List_Copy
            'list.copy' (i Gal_Arguments) ';';
        generate Attribute_Value_Statement
            'my' [. [my.class] Property_Name] ' attribute = ' Value ';';
        generate Statement_Propset
            '.=' (i Gal_Arguments) ';';
        generate Operation_String_Append
            '(append' (i Gal_Arguments) ')';
        generate Operation_Greater_Equal
            '(ge' (i Gal_Arguments) ')';
        generate Operation_Greater_Than
            '(gt' (i Gal_Arguments) ')';
        generate Operation_Less_Equal
            '(le' (i Gal_Arguments) ')';
        generate Operation_Less_Than
            '(lt' (i Gal_Arguments) ')';
        generate Operation_Or
            '(or' (i Gal_Arguments) ')';
        generate Operation_And
            '(and' (i Gal_Arguments) ')';
        generate Statement_Increment
            'increment' (i Gal_Arguments) ';';
        generate Operation_Is_Whitespace
            '(is.whitespace' (i Gal_Arguments) ')';
        generate Operation_Not
            '(not' (i Gal_Arguments) ')';
        generate Statement_And
            'and' (i Gal_Arguments) ';';
        generate Operation_Length
            '(length' (i Gal_Arguments) ')';
        generate Statement_Feature
            'feature ' Type ' ' Name ' ' Keyword ' ' Symbol_Class (i Gal_Block);
        generate Statement_Thing
            'thing ' Name ' ' Keyword (i Gal_Block);
        generate Statement_Class_Property 
        {
            string Type (list.last [my Gal_Keywords]);
            string Name [my Name Gal];
            string Value '';
            if (defined [my Value])
            {
                append Value ' ' [my Value Gal];
            }
            string Code
                'class.property ' Type ' ' Name Value ';';
            i= Code;
        }
        generate Statement_Object_New
            'entity.new' (i Gal_Arguments) ';';
        generate Syntax_Property
            (i Syntax_Gal (append '.' (i Gal_Arguments)));
        generate Statement_Return_If
            'returnif' (i Gal_Arguments) ';';
        generate Statement_Class_Append
            'class.append' (i Gal_Arguments) (i Gal_Block);
        generate Statement_Else_If
            'else.if' (i Gal_Arguments) (i Gal_Block);
        generate Statement_Method
            'method ' 
            (list.last [my Gal_Keywords])
            (i Gal_Arguments)
            (i Gal_Block);
        generate Statement_Class_Method
            'class.method ' 
            (list.last [my Gal_Keywords]) 
            (i Gal_Arguments)
            (i Gal_Block);
        generate Statement_Dictionary_Assign
            'dict.assign' (i Gal_Arguments) ';';
        generate Statement_Foreach
            'foreach' (i Gal_Arguments)
            (i Gal_Block);
        generate Statement_String
            'string' (i Gal_Arguments) ';';
        generate Statement_Number
            'number' (i Gal_Arguments) ';';
        generate Statement_Integer
            'integer' (i Gal_Arguments) ';';
        generate Statement_Flag
            'flag' (i Gal_Arguments) ';';
        generate Statement_Object
            'entity' (i Gal_Arguments) ';';
        generate Statement_List
            'list' (i Gal_Arguments) ';';
        generate Statement_Dictionary
            'dictionary' (i Gal_Arguments) ';';
        generate Statement_I_Equal
            'i=' (i Gal_Arguments) ';';
        generate Syntax_Object
            '[entity' (i Gal_Arguments) ']';
        generate Statement_For_Range
            'for.range' (i Gal_Arguments) (i Gal_Block);
        generate Operation_String_Greater
            '(sgt ' Op1 ' ' Op2 ')';
        generate Operation_String_Greater_Equal
            '(sge ' Op1 ' ' Op2 ')';
        generate Operation_String_Less
            '(slt ' Op1 ' ' Op2 ')';
        generate Operation_String_Less_Equal
            '(sle ' Op1 ' ' Op2 ')';
        generate Operation_Is_A
            '(isa ' Variable ' ' Class_Name ')';
    }
}
flowerbox 'Goalspell.gal';

goal.spell Gs `goalspell programming language`
{
    dialect Gs
    {
        statements,
            Statement_Abstract 'abstract' 'abstract entity',
            Statement_Action 'action',
            Statement_Add 'add' '+=',
            Statement_Alert 'alert',
            Statement_Alpha 'alpha',
            Statement_Amount 'amount',
            Statement_Analysis 'analysis',
            Statement_Analyze 'analyze',
            Statement_And 'and' '&' 'and=' 'and =' '&=',
            Statement_Append 'append' 'string.append' 's+' 's +' '+',
            Statement_Append_Token 'append token' 'append.token',
            Statement_Argument 'argument',
            Statement_Array 'array',
            Statement_Array_Number 'array number',
            Statement_Array_Of 'array of',
            Statement_Article 'article',
            Statement_Article_Reference 'article reference',
            Statement_Article_Plan 'article plan',
            Statement_Assign 'assign' '=',
            Statement_Async_Method 'async.method' 'async method' 'asynchronous method',
            Statement_Atomic 'atomic',
            Statement_Attribute 'attribute',
            Statement_Author 'author',
            Statement_Behavior 'behavior',
            Statement_Bias 'bias',
            Statement_Bind 'bind' 'bind =',
            Statement_Bless 'bless',
            Statement_Break 'break',
            Statement_Break_If 'breakif' 'break if' 'break.if',
            Statement_Build 'build',
            Statement_C 'c',
            Statement_Calcium 'calcium',
            Statement_Call '.' 'call',
            Statement_Calories 'calories' 'cal',
            Statement_Carbohydrate 'carb' 'carbs' 'carbohydrate' 'carbohydrates',
            Statement_Catch 'catch',
            Statement_Cd 'cd',
            Statement_Chapter 'chapter',
            Statement_Cholesterol 'cholesterol',
            Statement_Class 'class',
            Statement_Class_Is 'class.is' 'class is' 'class extends' 'class is a' 'class is an',
            Statement_Class_Append 'class.append' 'class append' 'class . append',
            Statement_Class_Set 'class.set' 'class set' 'class . set',
            Statement_Class_Attribute 'class.attribute' 'class attribute',
            Statement_Class_Module 'class module' 'classmodule' 'module class' 'moduleclass',
            Statement_Classify 'disabled clas sify',
            Statement_Class_Method 'class.method' 'class method',
            Statement_Class_Property 'class.property' 'class property',
            Statement_Click 'click',
            Statement_Close 'close',
            Statement_Codebox 'codebox' 'code box',
            Statement_Collates 'collates' 'collate',
            Statement_Colon ':',
            Statement_Comment 'comment' '#' '/.' '/ /',
            Statement_Compile 'compile',
            Statement_Compile 'compile',
            Statement_Copy_From 'copy from' 'copy < -',
            Statement_Copy_To 'copy to' 'copy - >' 'copy =',
            Statement_Confirm_Exit_If 'confirm exit if',
            Statement_Constant 'constant',
            Statement_Constructor 'constructor',
            Statement_Contest 'contest',
            Statement_Continue 'continue',
            Statement_Continue_If 'contif' 'continue if' 'continue.if',
            Statement_Create 'create',
            Statement_Crown 'crown',
            Statement_Currency 'currency',
            Statement_Cycle 'cycle',
            Statement_Date 'date',
            Statement_Debug 'debug' 'debugger',
            Statement_Debug_If 'debugif' 'debug if',
            Statement_Decrement 'decrement' '--',
            Statement_Default 'default',
            Statement_Defined 'defined',
            Statement_Diagram 'diagram',
            Statement_Dial 'dial',
            Statement_Dialect 'dialect',
            Statement_Dictionaries 'dicts' 'dictionaries' 'hashes',
            Statement_Dictionary_Assign 'dict.assign' 'dict assign' 'dictionary assign' 'dict assign' 'dict =' 'dictionary =' 'dict insert' 'dictionary insert' 'd =' 'd=',
            Statement_Dictionary 'dict' 'dictionary' 'hash',
            Statement_Dispatcher 'dispatcher',
            Statement_Dispatchers 'dispatchers',
            Statement_Distribute 'distribute',
            Statement_Divide 'divide' '/=',
            Statement_Do 'do' 'do @',
            Statement_Document_Reference 'document_reference' 'document reference',
            Statement_Dom_Object 'html object' 'dom object',
            Statement_Egg 'egg',
            Statement_Either 'either',
            Statement_Element 'element',
            Statement_Else 'else',
            Statement_Else_If 'else.if' 'else if',
            Statement_English 'english',
            Statement_Entities 'entities',
            Statement_Entity 'entity',
            Statement_Entity_New 'entity new',
            Statement_Error 'error' 'throw' 'raise' 'whoops' 'oops',
            Statement_Example 'example',
            Statement_Execute 'execute',
            Statement_Exit 'exit',
            Statement_Expect_Equal 'expect =' 'expect',
            Statement_Expect_String 'expect.string' 'expect string',
            Statement_Expected_Output 'expected output',
            Statement_Experience 'experience',
            Statement_Export_Memory 'export memory',
            Statement_Fallback 'fallback' 'fb',
            Statement_Fallback_Equal 'fallback =' 'fb =',
            Statement_Fat 'fat',
            Statement_Feature 'feature',
            Statement_Fiber 'fiber',
            Statement_File_Append 'file append',
            Statement_File_Delete 'file delete',
            Statement_File_Dump 'file.dump' 'file dump' 'fwrite' 'file write' 'write file' 'dump file' 'dump to file' 'write to file' 'save as' 'save as file',
            Statement_File_Readall 'file.readall' 'file readall' 'file read all' 'file text' 'readall' 'fread',
            Statement_File_Read_Line 'file.readline' 'file readline' 'file read line',
            Statement_File_Read_List 'file.readlist' 'file readlist' 'file read list',
            Statement_Flag 'flag' 'boolean' 'bool',
            Statement_Flags 'flags' 'booleans' 'bools',
            Statement_Flowerbox 'flowerbox' 'flower box',
            Statement_Food 'food',
            Statement_Foreach 'foreach' 'for each',
            Statement_For_Each_Key 'foreachkey' 'for each key',
            Statement_For_Prev_Key 'forprevkey' 'for prev key',
            Statement_For_Each_Human_Being 'for each human being',
            Statement_For_Each_Human_Outcome 'for each human outcome',
            Statement_For_Each_In 'for each in' 'for.each.in',
            Statement_For_Each_Outcome_Support 'for each outcome support',
            Statement_For_Each_Supporter 'for each supporter',
            Statement_Forever 'forever',
            Statement_Forgive 'forgive',
            Statement_For_Down 'for.down' 'for down' 'for down to',
            Statement_For_Range 'for.range' 'for range',
            Statement_Function 'function',
            Statement_Function_Pointer 'function pointer' 'fptr',
            Statement_Function_Invoke 'invoke',
            Statement_Gal 'gal',
            Statement_Gal_Equal 'gal =',
            Statement_Generate 'generate',
            Statement_Generate_Gal 'generate gal',
            Statement_Generator 'generator',
            Statement_Given_An_In 'given an in' 'given a in',
            Statement_Global 'global',
            Statement_Global_List 'global list' 'glist',
            Statement_Global_Lock 'lock ^',
            Statement_Global_Unlock 'unlock ^',
            Statement_Glvn 'glvn' 'key',
            Statement_Glvn_Global 'glvn ^' 'key ',
            Statement_Goal 'goal',
            Statement_Goal_Spell 'goal.spell' 'goal spell',
            Statement_Gpu_Function 'gpu function' 'gf',
            Statement_Gpu_Invoke 'gpu invoke' 'gi',
            Statement_Gpu_Invoke_Method 'gpu invoke method' 'gim',
            Statement_Gpu_Method 'gpu method' 'gm',
            Statement_Gpu_Property 'gpu property' 'gp',
            Statement_Grams 'g' 'gram' 'grams',
            Statement_Gs_Operation 'operation',
            Statement_Gs_Statement 'statement',
            Statement_Gs_Syntax 'syntax',
            Statement_Gs 'gs' 'goalspell',
            Statement_Gs_Equal 'gs =' 'goalspell =' 'gs=' 'goalspell=',
            Statement_Hope 'hope',
            Statement_Human_Being 'human being',
            Statement_Html 'html',
            Statement_I_Equal 'i=' 'i =' 'i equal',
            Statement_If 'if',
            Statement_Ifdef 'ifdef', 'ifdefined', 'if def', 'if defined',
            Statement_I 'i',
            Statement_I_Generate 'i generate',
            Statement_Improve 'improve',
            Statement_Imagine_Operation 'imagine operation',
            Statement_Imagine_Statement 'imagine statement',
            Statement_Implement 'implement',
            Statement_Implementer 'implementer' 'implementor',
            Statement_Implementers 'implementers' 'implementors',
            Statement_Implements_Instance 'implements .',
            Statement_Implements_Class 'implements :',
            Statement_Import 'import',
            Statement_In 'in',
            Statement_In_Goalspell 'in goalspell',
            Statement_Include 'include',
            Statement_Include_Implementers 'include implementers',
            Statement_Increment 'increment' '++',
            Statement_Infer 'infer',
            Statement_Inference 'inference',
            Statement_Inferences 'inferences',
            Statement_Infer_Inits 'infer.inits' 'infer inits',
            Statement_Infers 'infers',
            Statement_Ingredients 'ingredients',
            Statement_Initialize 'initialize',
            Statement_Interface 'interface',
            Statement_Iterate 'iterate',
            Statement_Integer 'integer' 'int',
            Statement_Integers 'integers' 'ints',
            Statement_Iron 'iron',
            Statement_Is_A 'isa' 'is a' 'is.a' 'classify',
            Statement_It_Equals 'it=' 'it =' 'it equals',
            Statement_Javascript 'javascript' 'js',
            Statement_Javascript_Equal 'javascript =' 'js =',
            Statement_Job 'job',
            Statement_Join 'join' 'list.join' 'list join',
            Statement_Keyword 'keyword',
            Statement_Kill 'kill',
            Statement_Kill_Global 'kill ^',
            Statement_Know 'know',
            Statement_Language 'language',
            Statement_Language_Behavior 'language behavior',
            Statement_Language_Machine_Architecture 'language machine architecture',
            Statement_Lexical 'lexical',
            Statement_List_Append 'list.append' 'list append' 'list+' 'list +' 'push' 'list push' 'lpush',
            Statement_List_Assign 'list assign' 'list =' 'l=' 'l =' 'lassign',
            Statement_List_Clear 'list clear' 'lclear' 'list . clear',
            Statement_List_Copy 'list.copy' 'list copy' 'lcopy',
            Statement_List_Insert 'list insert' 'insert' 'linsert',
            Statement_List_Item 'list item' 'li',
            Statement_List_Split 'list split' 'lsplit' 'split',
            Statement_List 'list',
            Statement_List_Property_Insert 'list property insert',
            Statement_Lists 'lists',
            Statement_Lock 'lock',
            Statement_Main 'main',
            Statement_Maximize 'maximize',
            Statement_Meal 'meal',
            Statement_Member 'member',
            Statement_Menu_Bar 'menu_bar' 'menu bar',
            Statement_Menu_Dropdown 'menu_dropdown' 'menu dropdown',
            Statement_Menu_Item 'menu_item' 'menu item',
            Statement_Merge_From 'merge from' 'merge < -',
            Statement_Merge_To 'merge to' 'merge - >' 'merge =',
            Statement_Method 'method',
            Statement_Migrate 'migrate',
            Statement_Minimize 'minimize',
            Statement_Module 'module',
            Statement_Multiply 'multiply' '*=',
            Statement_Mumps 'mumps',
            Statement_My_Attribute_Equal 'my~=' 'my ~ =' 'my attribute =',
            Statement_My_Equal 'my=' 'my =',
            Statement_New_Token 'new token' 'newtoken' 'new.token',
            Statement_No 'no',
            Statement_Not 'not' '!',
            Statement_Note 'note',
            Statement_Nsl_Module 'nsl module',
            Statement_Numbered_List 'numbered list' 'numbered.list' 'numlist' 'ol',
            Statement_Number 'number' 'certainty' 'percent',
            Statement_Numbers 'numbers' 'certainties' 'percents',
            Statement_Nutrition 'nutrition',
            Statement_Obj 'obj',
            Statement_Object 'object',
            Statement_Object_New 'object new',
            Statement_Objects 'objects',
            Statement_Ohlc 'ohlc',
            Statement_Open 'open',
            Statement_Operations 'operations',
            Statement_Optimize 'optimize',
            Statement_Optimize_Equal 'optimize=' 'optimize =',
            Statement_Optional 'optional',
            Statement_Outcome 'outcome',
            Statement_Pane 'pane',
            Statement_Paragraph 'paragraph' 'para' 'p',
            Statement_Parser 'parser',
            Statement_Pay_Gratitude 'pay gratitude' 'pay',
            Statement_Person 'person' 'human',
            Statement_Plist 'plist' 'prop list' 'p list',
            Statement_Pobj 'pobj' 'prop object' 'p obj',
            Statement_Portion 'portion' 'portion size',
            Statement_Potassium 'potassium',
            Statement_Process 'process',
            Statement_Prompt 'prompt',
            Statement_Prompt_Context 'prompt context' 'prompt.context',
            Statement_Prop_Obj 'prop obj',
            Statement_Property 'property',
            Statement_Propset '.=' 'propset' '. =',
            Statement_Protein 'protein' 'prot',
            Statement_Python 'python' 'py',
            Statement_Python_Equal 'python =' 'py =',
            Statement_Queue 'queue',
            Statement_Quest 'quest',
            Statement_Quit_Colon 'quit:' 'quit :' 'returnif',
            Statement_Raku 'raku',
            Statement_Raku_Equal 'raku =',
            Statement_Read_Character 'read.char' 'read char' 'read character',
            Statement_Reaadline 'reaadline' 'reaad line',
            Statement_Readline 'readline' 'read line',
            Statement_Recipe 'recipe',
            Statement_Redirect 'redirect',
            Statement_Redirect_To 'redirect to',
            Statement_Remember 'remember',
            Statement_Rename 'rename' 'move',
            Statement_Replace 'replace',
            Statement_Report_Outcome 'report outcome',
            Statement_Require_That_I 'require.that.i' 'require that i',
            Statement_Require_That 'require.that' 'require that',
            Statement_Retain 'retain',
            Statement_Return_If_Gs 'return if',
            Statement_Return 'return',
            Statement_Reverse_Iterate 'reverse iterate' 'iterate reverse',
            Statement_Roster 'roster',
            Statement_Roster_Floor 'roster floor',
            Statement_Run_Queue 'run queue',
            Statement_Saay 'saay' 'wriiteline',
            Statement_Saturated_Fat 'sat' 'sat fat' 'saturated' 'saturated fat',
            Statement_Section 'section',
            Statement_Send_File 'send file',
            Statement_Sequence 'sequence',
            Statement_Shell 'shell',
            Statement_Site 'site',
            Statement_Skip_Token 'skiptoken' 'skip token' 'skip.token',
            Statement_Sodium 'sodium',
            Statement_Source 'source' 'source site',
            Statement_Speaking 'speaking',
            Statement_Spell 'spell',
            Statement_Statements 'statements',
            Statement_Steps 'steps',
            Statement_Strings 'strings',
            Statement_String 'string',
            Statement_Subtitle 'subtitle',
            Statement_Subtract 'subtract' '-=',
            Statement_Sugar 'sugar',
            Statement_Supporter 'supporter',
            Statement_Symbol 'symbol',
            Statement_Syntaxes 'syntaxes',
            Statement_Synthesis 'synthesis',
            Statement_Synthesize 'synthesize',
            Statement_Target_Includes 'target includes',
            Statement_Terminology 'terminology',
            Statement_Term 'term',
            Statement_Test 'test',
            Statement_Test_Case 'test case' 'testcase',
            Statement_Tests 'tests',
            Statement_Tests_Append 'tests append',
            Statement_Thing 'thing',
            Statement_Tilda 'tilde' 'tilda' '~',
            Statement_Title 'title',
            Statement_To_Analyze 'to analyze',
            Statement_Todo 'todo',
            Statement_Token_Append 'token.append' 'token append' 'tokenappend',
            Statement_Token_Handler 'token.handler' 'token handler',
            Statement_Token_Initial 'token.initial' 'token initial',
            Statement_Tokenization 'tokenization',
            Statement_Token_Mode 'token.mode' 'token mode' 'tokenmode',
            Statement_Token_New 'token.new' 'token new',
            Statement_Token_Test 'token test',
            Statement_Tokens 'tokens',
            Statement_Token 'token',
            Statement_Translation_Tests 'translation tests' 'trans test',
            Statement_Try 'try',
            Statement_Try_At_Of 'try at of',
            Statement_Undefined 'undef' 'undefined',
            Statement_Unless 'unless',
            Statement_Unlock 'unlock',
            Statement_Values 'values',
            
            Statement_Variable_Begins 'flag begins',
            Statement_Variable_Contains 'flag contains',
            Statement_Variable_Dot 'flag .' 'integer .' 'percent .' 'number .' 'list .' 'dict .' 'dictionary .' 'object .' 'string .',
            Statement_Variable_Is_Null 'flag isnull',
            Statement_Variable_Is_Number 'flag isnumber',
            Statement_Variable_Is_Punct 'flag ispunct',
            Statement_Variable_Is_String 'flag isstring',
            Statement_Variable_Is_Uppercase 'flag isupper',
            Statement_Variable_Is_Whitespace 'flag iswhitespace' 'flag is whitespace',
            Statement_Variable_Not_Null 'flag notnull',
            Statement_Variable_String_Equal 'flag s=',
            Statement_Variable_String_Greater 'flag sgt',
            Statement_Variable_String_Not_Equal 'flag sne',
            Statement_Variable_Char2int 'integer char2int',
            Statement_Variable_String_Length 'integer length',
            Statement_Variable_Equal 'flag ==',
            Statement_Variable_Greater 'flag gt',
            Statement_Variable_Less 'flag lt',
            Statement_Variable_List_Split 'list split',
            Statement_Variable_List_Get 'variant list get',
            Statement_Variable_List_Last 'variant list last'
            Statement_Variable_List_Length 'integer list length',
            Statement_Variable_Isa 'flag isa',
            Statement_Variable_Int2char 'string int2char' 'string num2char',
            
            Statement_Variations 'variations',
            Statement_Variants 'vars' 'variants',
            Statement_Variant 'var' 'variant',
            Statement_Verbose 'verbose',
            Statement_Verbosity 'verbosity',
            Statement_Vernacular 'vernacular',
            Statement_Vitamin 'vitamin' 'vit',
            Statement_We 'we',
            Statement_Web_App 'web app' 'webapp' 'web application',
            Statement_While 'while',
            Statement_Wriite 'wriite',
            Statement_Write_Line 'say' 'writeline' 'write line' 'write.line',
            Statement_Write 'write',
            Statement_Yes 'yes',

            Statement_Title 'title',
            Statement_Created 'created',
            Statement_Completed 'completed',
            Statement_Expires 'expires',
            Statement_Comments 'comments',
            Statement_Assignee 'assignee',
            Statement_Status 'status',
            Statement_Task 'task',
            Statement_Task_List 'task list',
        ;
        operations,
            Operation_Absolute 'absolute' 'abs',
            Operation_Add 'add' '+' 'plus',
            Operation_And 'and' '&' '&&',
            Operation_Begins 'startswith' 'starts.with' 'starts' 'begins' 'beginswith' 'begins.with',
            Operation_Call 'call' '.',
            Operation_Can 'can',
            Operation_Char2int 'chartoint' 'char to int' 'charint' 'char int' 'char2int' 'char2num',
            Operation_Classpropget 'classpropget',
            Operation_Colon ':',
            Operation_Contains 'contains' 'string contains',
            Operation_Create_Element 'create element',
            Operation_Csv_String 'csv string',
            Operation_Defined 'defined' 'exists',
            Operation_Default 'default',
            Operation_Default_Global 'default ^',
            Operation_Dict_Exists 'dict.exists' 'dict exists' 'key.exists' 'key exists' 'dictionary exists' 'dexists',
            Operation_Dict_Get 'dict.get' 'dict get' 'key.get' 'key get' 'dictionary get',
            Operation_Dispatch 'dispatch',
            Operation_Distribute 'distribute',
            Operation_Divide 'divide' '/' 'div',
            Operation_Dequote 'dequote',
            Operation_Enquote 'enquote' 'quote',
            Operation_Environment 'env' 'environment',
            Operation_Equal '=' '==' 'eq' 'equals' 'equal',
            Operation_Evaluate 'evaluate' 'eval',
            Operation_File_Exists 'file exists',
            Operation_Files 'files',
            Operation_First_Char 'firstchar' 'first.char' 'first char',
            Operation_Flag 'flag' 'boolean' 'bool',
            Operation_Flowerbox 'flowerbox' 'flower' 'blossom' 'lotus',
            Operation_From_Json 'from json',
            Operation_Get 'get' 'dget',
            Operation_Get_Element_By_Id 'get element by id',
            Operation_Get_Global 'get ^' 'dget ^',
            Operation_Glvn 'glvn' 'key',
            Operation_Greater_Equal '>=' 'ge',
            Operation_Greater_Than '>' 'gt',
            Operation_Human_Outcome_Gratitude 'human outcome gratitude',
            Operation_Http_Fetch 'http fetch',
            Operation_I 'i' 'self',
            Operation_If 'if',
            Operation_Implement 'implement',
            Operation_Int2char 'int char' 'intchar' 'int2char' 'num2char',
            Operation_Integer 'integer',
            Operation_Integer_Divide 'intdiv',
            Operation_Invoke 'invoke',
            Operation_Is_A 'isa' 'is a' 'is.a' 'is an' 'isan' 'is.an',
            Operation_Is_Digit 'is digit',
            Operation_Is_Ident 'isident' 'is.ident' 'is ident',
            Operation_Is_Lowercase 'islowercase' 'is.lowercase' 'is lowercase' 'islower',
            Operation_Is_Null 'isnull' 'is null',
            Operation_Is_Number 'is_number' 'isnumber' 'is number' 'is numeric',
            Operation_Is_Punct 'is punct' 'is punctuation' 'ispunct',
            Operation_Is_String 'is_string' 'isstring' 'is string',
            Operation_Is_Uppercase 'isuppercase' 'is.uppercase' 'is uppercase' 'isupper',
            Operation_Is_Whitespace 'isws' 'is.ws' 'is ws' 'iswhitespace' 'is.whitespace' 'is whitespace' 'whitespace',
            Operation_Last_Char 'lastchar' 'last.char' 'last char',
            Operation_Length 'length' 'len' 'string.length' 'string length',
            Operation_Less_Equal '<=' 'le',
            Operation_Less_Than '<' 'lt',
            Operation_List_Get 'list.get' 'list get' 'lget',
            Operation_List_Last 'list.last' 'list last' 'llast',
            Operation_List_Length 'list.length' 'list length' 'llen' 'llength',
            Operation_List_Pop 'pop' 'list pop' 'list.pop' 'lpop',
            Operation_Lowercase 'lowercase' 'lower',
            Operation_Module_Class_Name_New 'module class name new',
            Operation_Modulo 'mod',
            Operation_Multiply '*' 'multiply' 'mult' 'times',
            Operation_Name 'name',
            Operation_New 'new',
            Operation_New_My_Class 'new my class',
            Operation_New_Our_Class 'new our class',
            Operation_Next 'next',
            Operation_Next_Global 'next ^',
            Operation_Not 'not' '!',
            Operation_Not_Equal 'ne' '!=' '<>',
            Operation_Not_Null 'not null' 'notnull' 'not.null',
            Operation_Ternary '? :' 'ternary',
            Operation_Test 'test',
            Operation_Time_String 'now string',
            Operation_Number 'number',
            Operation_Or 'or' '|' '||',
            Operation_Outcome 'outcome',
            Operation_Power 'power' 'pow' '**',
            Operation_Prev 'prev' 'previous',
            Operation_Prev_Global 'prev ^' 'previous ^',
            Operation_QLength 'qlength' 'ql',
            Operation_QSubscript 'qsubscript' 'qs',
            Operation_Random_Integer 'randint' 'rand_int' 'random integer' 'rand int',
            Operation_Random_Percent 'random percent' 'rand',
            Operation_Round 'round',
            Operation_Shift 'shift' 'list.shift' 'list shift' 'lshift',
            Operation_Split 'split',
            Operation_Sql_Array 'sql array',
            Operation_Sql_Object 'sql object',
            Operation_Square_Root 'sqrt' 'square root',
            Operation_String_Append 'append' 's+',
            Operation_String_Equal 's=' 'seq' 'string =' 's =',
            Operation_String_Greater_Equal 's>=' 'sge' 'string >=' 's >=' 'string ge' 's ge',
            Operation_String_Greater 'string.gt' 'sgt' 's>' 'string greater' 's >' 's gt',
            Operation_String_Less_Equal 'string.le' 's<=' 'sle' 'string <=' 's <=' 's le' 'string le',
            Operation_String_Less 's<' 'slt' 'string <' 's <',
            Operation_String_Not_Equal 's!=' 'sne' 'string !=' 's !=',
            Operation_String 'string',
            Operation_Substring 'substring',
            Operation_Subtract 'subtract' '-' 'minus',
            Operation_Then 'then',
            Operation_Titlecase 'titlecase' 'title case',
            Operation_Tilda 'tilde' 'tilda' '~',
            Operation_To_Json 'to json',
            Operation_Token_Mode 'tokenmode' 'token.mode' 'token mode',
            Operation_Uppercase 'uppercase' 'upper',
            Operation_Uuid 'uuid' 'guid',
            Operation_We 'we'
        ;
        syntaxes,
            Syntax_Array 'array' 'arr',
            Syntax_Attribute 'attribute' 'att' '~',
            Syntax_Await 'await',
            Syntax_Behavior 'behavior',
            Syntax_Class_Attribute 'class.attribute' 'class.att' 'classatt' 'class attribute' 'class att' 'class ~',
            Syntax_Class 'class' 'class of',
            Syntax_Classes 'classes',
            Syntax_Class_Name 'class.name' 'class name' 'classname',
            Syntax_Class_Property ':',
            Syntax_Count 'count',
            Syntax_Dictionary 'dict' 'dictionary' 'hash',
            Syntax_Remember 'remember',
            Syntax_Exclude 'exclude',
            Syntax_False 'false',
            Syntax_Flag 'flag' 'bool' 'boolean',
            Syntax_Function_Pointer 'fptr' 'function pointer',
            Syntax_Future 'future',
            Syntax_Generator 'generator',
            Syntax_Glvn 'glvn' 'key',
            Syntax_Implementers_Of 'implementers of',
            Syntax_Indent 'indent',
            Syntax_Init 'init',
            Syntax_Integer 'integer' 'int',
            Syntax_Is 'is',
            Syntax_Is_Main 'ismain' 'is main',
            Syntax_Job 'job',
            Syntax_Language_Elements 'language elements',
            Syntax_Line 'line',
            Syntax_List 'list',
            Syntax_Method 'method',
            Syntax_Mildbeard 'mildbeard',
            Syntax_Module_Class 'module class',
            Syntax_My_Attribute 'my.attribute' 'my attribute' 'my att' 'my.att' 'my ~' 'my~',
            Syntax_My_Class 'my.class' 'my class' 'my.class' 'self.class' 'self class',
            Syntax_My 'my' 'i',
            Syntax_New_List 'new list',
            Syntax_Node 'node',
            Syntax_Number 'number',
            Syntax_Null 'null',
            Syntax_Object 'entity' 'object',
            Syntax_Optional 'optional',
            Syntax_Optrep 'optrep' 'optional repeating',
            Syntax_Our 'our' 'we',
            Syntax_Outcomes 'outcomes',
            Syntax_Output 'output',
            Syntax_Property '.' 'property' 'propchain',
            Syntax_Property_Lookup 'property lookup',
            Syntax_Repeating 'repeating',
            Syntax_Request 'request',
            Syntax_Roster_Floor 'roster floor',
            Syntax_Self 'self' 'me',
            Syntax_Sequence 'sequence' 'seq',
            Syntax_Session 'session',
            Syntax_Sql_Connection 'sql connection',
            Syntax_String 'string',
            Syntax_Tab 'tab',
            Syntax_Tilda 'tilde' 'tilda' '~',
            Syntax_True 'true',
            Syntax_Us 'us' 'our class',
            Syntax_Variant 'variant'
        ;
    }

    class Gs_Parser
    {
        infers Tokens;
        infers Elements;
        infers Location;
        infers Verb;
        infers Classification;
        infers Components;
        infers Attributes;
        infers Structure;
        infers Data_Types;

        property entity Dialect Dialect_Gs;

        attribute list Inferences;
        attribute list Tokens;
        attribute list Elements;

        property integer Position 0;
        constructor [entity Owner]
        {
            my= Owner Owner;
            my= Dialect (new Dialect_Gs);
        }
        method flag Initialize
        {
            verbosity;
            verbose [class.name] ' Inits';
            . [my Dialect] Initialize;
            infer.inits;
            return [true];
        }
    }

    parser Gs
    {
        tokens Token_Name Token_Number Token_Quote Token_Keyword Token_Semi Token_Comma;
        token Token_Operation_Start;
        token Token_Operation_End;
        token Token_Syntax_Start;
        token Token_Syntax_End;
        token Token_Block_Start;
        token Token_Block_End;
        token Name_Token;

        sequence Operation
            Token_Operation_Start
            [repeating Expression]
            [optrep Operation_Tail]
            Token_Operation_End;

        sequence Operation_Tail
            Token_Comma
            [optrep Expression];

        sequence Syntax
            Token_Syntax_Start
            [repeating Expression]
            [optrep Syntax_Tail]
            Token_Syntax_End;

        sequence Syntax_Tail
            Token_Comma
            [optrep Expression];

        either Expression
            Operation
            Syntax
            Name_Token
            Token_Number
            Token_Quote;

        either Statement_End 
            Token_Semi 
            Block;

        sequence Statement_Tail
            Token_Comma
            [optrep Expression];

        sequence Statement
            [repeating Expression]
            [optrep Statement_Tail]
            Statement_End;

        sequence Block
            Token_Block_Start
            [optrep Statement]
            Token_Block_End;

        sequence Statements
            [repeating Statement];

        sequence Expressions
            [repeating Expression];

        either Program 
            Statements 
            Expression;
    }
            
    class.append Element
    {
        method string Indent [string Text]
        {
            returnif (isnull Text) '';
            string Qchars '"' "'" "`" '“' '‘' '«' '‹';
            dictionary Qend;
            dict.assign Qend '"' '"';
            dict.assign Qend "'" "'";
            dict.assign Qend '`' '`';
            dict.assign Qend '“' '”';
            dict.assign Qend '‘' '’';
            dict.assign Qend '«' '»';
            dict.assign Qend '‹' '›';
            integer P;
            string C;
            string I '';
            flag Quote [false];
            string Q '';
            string Between '';
            integer E (- (length Text) 1);
            if (not (contains Qchars (substring Text 0 1)))
            {
                = Between [indent];
            }
            for.range P 0 E
            {
                = C (substring Text P 1);
                append I Between C;
                = Between '';
                if Quote
                {
                    if (s= C Q)
                    {
                        = Quote [false];
                        = Q '';
                    }
                }
                else.if (= C [line])
                {
                    = Between [indent];
                }
                else.if (contains Qchars C)
                {
                    = Quote [true];
                    = Q (dict.get Qend C);
                }
            }
            return I;
        }
        method string Minify [string Text]
        {
            replace Text [line] ' ';
            while (contains Text '  ')
            {
                replace Text '  ' ' ';
            }
            return Text;
        }
    }

    class.append Named_Element
    {
        property string Gs_Statements '';
        property list Gs_Keywords;
        property string Gs_Keyword;
        property string Gs_Suffix '';
        method string Gs_Arguments
        {
            string Code '';
            string Arg_Code;
            entity Arg;
            foreach [my Arguments] Arg
            {
                contif (isa Arg Syntax_Token);
                = Arg_Code [. Arg Gs];
                if (begins Arg_Code ',')
                {
                    append Code Arg_Code;
                }
                else
                {
                    append Code ' ' Arg_Code;
                }
            }
            return Code;
        }
        method string Gs_Key
        {
            string Code '';
            string Between '';
            string Key;
            foreach [my Gs_Keywords] Key
            {
                append Code Between Key;
                = Between ' ';
            }
            return Code;
        }
        method string Gs_Listargs
        {
            string Code '';
            entity Arg;
            foreach [my Listargs] Arg
            {
                contif (isa Arg Syntax_Token);
                append Code ' ' [. Arg Gs];
            }
            return Code;
        }
        method string Gs_Tails
        {
            string Code '';
            entity Tail;
            foreach [my Tails] Tail
            {
                append Code (. Tail Gs_Tail);
            }
            return Code;
        }
    }

    class.append Syntax_Tail
    {
        method string Syntax_Gs [string Code]
        {
            string Text (append '[' Code ']');
            return Text;
        }
    }

    class.append Syntax
    {
        property list Tails;
        method string Syntax_Gs [string Code]
        {
            string Text (append '[' Code ']');
            return Text;
        }
        method string Old_Syntax_Gs [string Code]
        {
            string Ret '';
            if (isa [my Owner] Syntax_Tail)
            {
                if (sne (firstchar Code) ',')
                {
                    append Ret ', ';
                }
                append Ret Code;
            }
            else
            {
                append Ret '[' Code ']';
            }
            return Ret;
        }
        method string Gs_Tail
        {
            string Gs [my Gs];
            integer Length (- (length Gs) 2);
            string Middle (substring Gs 1 Length);
            string Code ', ' Middle;
            return Code;
        }
    }

    class.append Operation
    {
        property list Tails;
        method string Gs_Tail
        {
            string Gs [my Gs];
            integer Length (- (length Gs) 2);
            string Middle (substring Gs 1 Length);
            string Code ', ' Middle;
            return Code;
        }
    }

    class.append Statement
    {
        property list Tails;
        method string Gs_Block
        {
            string Code ';';
            forgive
            {
                = Code [my Block Gs];
            }
            return Code;
        }
    }

    class.append Block
    {
        property string Gs_Statements '';
    }

    class Gs_Generator [is Generator]
    {
        infers Gs;
        attribute list Elements;
        attribute list Inferences;
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            verbosity;
            verbose [class.name] ' Inits';
            infer.inits;
            return [true];
        }
    }

    inference string Gs
    {
        generate Element '';
        generate Token [my Input];
        generate Statement (i Gs_Key) (i Gs_Arguments) (i Gs_Block);
        generate Operation '(' (i Gs_Key) (i Gs_Arguments) ')';

        generate Syntax
        {
            string Code 
                (i Gs_Key) (i Gs_Arguments);
            i= (i Syntax_Gs Code);
        }
        generate Syntax_Property
        {
            string Code
                [my Object Gs] '.' [my Property_Name Gs];
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Code '.' [. Argument Gs];
            }
            if (contains [my Gal_Key_Suffix] '~')
            {
                append Code ' ~';
            }
            i= (i Syntax_Gs Code);
        }
        generate Syntax_Tail
        {
            string Code 
                [my Verb] ' ' 
                (i Gs_Arguments);
            i= (i Syntax_Gs Code);
        }
        generate Syntax_Attribute
        {
            string Code 
                (i Gs_Arguments) ' ~';
            i= (i Syntax_Gs Code);
        }
        generate Syntax_My_Attribute
        {
            string Code
                'my' (i Gs_Arguments) ' ~';
            i= (i Syntax_Gs Code);
        }

        generate Statement_Tail
        {
            string Code ',' [line, indent];
            flag First [true];
            string Between '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                if First
                {
                    = First [false];
                    continue;
                }
                append Code Between [. Argument Gs];
                = Between ' ';
            }
            i= Code;
        }

        generate Operation_Tail
        {
            string Code (i Gs_Arguments);
            i= Code;
        }
        generate Block
        {
            entity Line;
            string Statements '';
            forgive
            {
                foreach [my Statements] Line
                {
                    append Statements [. Line Gs] [line];
                }
                = Statements (i Indent Statements);
            }
            string Code [line] 
                '{' [line]
                    Statements 
                '}';
            i= Code;
            my= Gs_Statements Statements;
        }
        generate Gs_Generator
        {
            verbosity [true];
            flag Error_Fail [true];
            entity Elem;
            entity I;
            integer Number 0;
            variant Error;
            string Mumps_Append '';
            foreach [my.attribute Elements] Elem
            {
                forgive
                {
                    = I [. Elem Classification];
                    . I Infer_Gs;
                    .= Elem Gs [. I Gs];
                    increment Number;
                }
            }
            foreach [my.attribute Elements] Elem
            {
                if Error_Fail
                {
                    = I [. Elem Classification];
                    . I Infer_Gs;
                    .= Elem Gs [. I Gs];
                    increment Number;
                }
                else
                {
                    try
                    {
                        = I [. Elem Classification];
                        . I Infer_Gs;
                        .= Elem Gs [. I Gs];
                        increment Number;
                    }
                    catch Error
                    {
                        my= Status [false];
                        comment 'debug;';
                        .= Elem Error Error;
                        verbose 'Error fallback element ' Number
                            ': ' [classname I]
                            ', <' Error '>'
                            ', source ' (. I Get_Input);
                    }
                }
                forgive
                {
                    . I Infer_Mumps;
                    if (sgt [. I Mumps_Outer_Declaration] "")
                    {
                        append Mumps_Append [. I Mumps_Outer_Declaration];
                        comment verbose 'mumps: ' Mumps_Append;
                    }
                }
            }
            returnif (not [my Status]) [false];
            entity Top (list.last [my.attribute Elements]);
            undef [. Top Gs]
            {
                . Top Infer_Gs;
            }
            string Code
                [. Top Gs]
                Mumps_Append;
            i= Code;
            my= Code Code;
            return [true];
        }

        generate Statements
        {
            string Code '';
            entity Statement;
            string Between '';
            foreach [my Elements] Statement
            {
                s+ Code Between [. Statement Gs];
                = Between [line];
            }
            i= Code;
        }

        generate Expressions
        {
            string Code '';
            entity Statement;
            string Between '';
            foreach [my Elements] Statement
            {
                s+ Code Between [. Statement Gs];
                = Between [line];
            }
            i= Code;
        }


        generate Statement_Write_Line 
            'say' (i Gs_Arguments) ';';
        generate Statement_Readline 
            'read' (i Gs_Arguments) ' line;';
        generate Statement_Propset 
            Object '.' Property ' = ' Value ';';
        generate Statement_Goalspell 
            'goal spell' (i Gs_Arguments) (i Gs_Block);
        generate Statement_File_Readall 
            'file read all' (i Gs_Arguments) ';';
        generate Statement_File_Dump 
            'file dump' (i Gs_Arguments) ';';
        generate Statement_Flowerbox 
            'flower box' (i Gs_Arguments) (i Gs_Block);
        generate Statement_And
            Variable ' &=' (i Gs_Listargs) ';';
        generate Statement_Add
            Variable ' +=' (i Gs_Listargs) ';';
        generate Operation_Call
            '(' Object '.' Method (i Gs_Listargs) ')';
        generate Statement_My_Equal
            'my ' Property ' = ' Value ';';
        generate Operation_Not
            '(!' (i Gs_Arguments) ')';
        generate Statement_Assign
            Variable ' = ' Value ';';
        generate Statement_List_Append
            'push ' List (i Gs_Listargs) ';';
        generate Operation_List_Get
            '(list ' List ' get ' Offset ')';
        generate Operation_Equal
            '(' Op1 ' = ' Op2 ')';
        generate Operation_Less_Than
            '(' Op1 ' lt ' Op2 ')';
        generate Operation_Greater_Than
            '(' Op1 ' gt ' Op2 ')';
        generate Operation_Less_Equal
            '(' Op1 ' le ' Op2 ')';
        generate Operation_Greater_Equal
            '(' Op1 ' ge ' Op2 ')';
        generate Operation_Add
            '(' Op1 ' + ' Op2 ')';
        generate Operation_Subtract
        {
            string Code '';
            if (defined [my Op2])
            {
                append Code '(' [my Op1 Gs] ' - ' [my Op2 Gs] (i Gs_Listargs) ')';
            }
            else
            {
                append Code '(- ' [my Op1 Gs] ')';
            }
            i= Code;
        }
        generate Operation_Multiply
            '(' Op1 ' * ' Op2 ')';
        generate Operation_Divide
            '(' Op1 ' / ' Op2 ')';
        generate Operation_And
            '(' Op1 ' and ' Op2 (i Gs_Listargs) ')';
        generate Operation_Or
            '(' Op1 ' or ' Op2 (i Gs_Listargs) ')';
        generate Statement_Increment
            Op1 '++;';
        generate Statement_Decrement
            Op1 '--;';
        generate Statement_Require_That_I
            'require that i' (i Gs_Arguments) (i Gs_Block);
        generate Statement_Require_That
            'require that' (i Gs_Arguments) (i Gs_Block);
        generate Statement_Symbol 
            'symbol ' Type ' ' Name (i Gs_Listargs) (i Gs_Block);
        generate Statement_Property 
        {
            string Type [my Type Gs];
            string Name [my Name Gs];
            string Code 'property ' Type ' ' Name;
            if (defined [my Value])
            {
                append Code ' ' [my Value Gs];
            }
            entity Arg;
            foreach [my Listargs] Arg
            {
                append Code ' ' [. Arg Gs];
            }
            append Code ';';
            i= Code;
        }
        generate Statement_Class_Property 
        {
            string Type (list.last [my Gs_Keywords]);
            string Name [my Name Gs];
            string Value '';
            if (defined [my Value])
            {
                append Value ' ' [my Value Gs];
            }
            string Code
                'class property ' Type ' ' Name Value ';';
            i= Code;
        }
        generate Statement_Break_If
            'break if' (i Gs_Arguments) ';';
        generate Operation_List_Length
            '(list' (i Gs_Arguments) ' length)';
        generate Statement_Statement
        {
            debug;
            string Code 'statement ' [my Name Gs] [my Gal_Key_Suffix];
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gs];
            }
            append Code (i Gs_Block);
            i= Code;
        }
        generate Statement_Gs_Operation
        {
            string Code 'operation ' [my Name Gs] ' ' [my Keyword Gs];
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gs];
            }
            append Code (i Gs_Block);
            i= Code;
        }
        generate Statement_Gs_Syntax
        {
            string Code 'syntax ' [my Name Gs] ' ' [my Keyword Gs];
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gs];
            }
            append Code (i Gs_Block);
            i= Code;
        }
        generate Operation_String_Append
            '(s+' (i Gs_Arguments) ')';

        generate Statement_Feature
            'feature ' Type ' ' Name ' ' Keyword ' ' Symbol_Class (i Gs_Block);
        generate Statement_Thing
            'thing ' Name ' ' Keyword (i Gs_Block);
        generate Statement_Return_If
            'quit :' (i Gs_Arguments) ';';
        generate Statement_Class_Method
        {
            string Return_Type (list.last [my Gs_Keywords]);
            if (not (contains ' void flag integer percent number string object entity list dictionary variant glvn ' Return_Type))
            {
                error 'Invalid return type "' Return_Type '".';
            }
            string Code `class method ` Return_Type (i Gs_Arguments) (i Gs_Block);
            i= Code;
        }
        generate Statement_For_Range
            `for range` (i Gs_Arguments) (i Gs_Block);
        generate Statement_Grams
            Thing ' ' Amount ' g;';

        generate Amount_Statement
        {
            string Gsk [my Gs_Keyword];
            string Amount [my Amount Gs];
            string Unit [. [my.attribute Unit] Gs];
            string Code Gsk ' ' Amount ' ' Unit ';';
            i= Code;
        }
        generate Statement_Class_Append
        {
            verbosity;
            string Code '';
            if (not (defined [my Primary_Class]))
            {
                append Code 'class append' (i Gs_Arguments) (i Gs_Block);
            }
            verbose 'goalspell class append: ' Code;
            i= Code;
        }
        generate Statement_Class_Set
            'class set' (i Gs_Arguments) (i Gs_Block);
        generate Statement_Else_If
            'else if' (i Gs_Arguments) (i Gs_Block);
        generate Statement_Object
        {
            string Variable [my Variable Gs];
            string Code 'object ' Variable;
            if (defined [my Value])
            {
                append Code ' = ' [my Value Gs];
            }
            append Code ';';
            i= Code;
        }
        generate Statement_Object_New
            'object ' Variable ' new ' Class (i Gs_Listargs) ';';
        generate Operation_List_Last
            '(list ' List ' last )';
        generate Operation_Shift
            '(shift ' (i Gs_Arguments) ')';
        generate Syntax_Object
        {
            string Interior 'object' (i Gs_Arguments);
            string Code (i Syntax_Gs Interior);
            i= Code;
        }
        generate Statement_Call 
            Target '.' Method (i Gs_Listargs) ';';
        generate Syntax_Remember
            '[' Name ' ' Expression ' remember' (i Gs_Listargs) ']';
        generate Operation_String_Equal
            '(' Op1 ' s= ' Op2 ')';
        generate Operation_String_Not_Equal
            '(' Op1 ' s!= ' Op2 ')';
        generate Operation_String_Greater
            '(' Op1 ' sgt ' Op2 ')';
        generate Operation_String_Greater_Equal
            '(' Op1 ' sge ' Op2 ')';
        generate Operation_String_Less
            '(' Op1 ' sgt ' Op2 ')';
        generate Operation_String_Less_Equal
            '(' Op1 ' sle ' Op2 ')';
        generate Statement_Infer_Inits
            'infer inits';
        generate Statement_Element
        {
            string Code 
                'element' (i Gs_Arguments) ';';
            i= Code;
        }
        generate Statement_Tail
        {
            verbosity;
            string Code "";
            string Between "";
            entity Arg;
            foreach [my Elements] Arg
            {
                append Code Between [. Arg Gs];
                = Between " ";
            }
            i= Code;
            verbose "Hello Statement_Tail.Gs";
        }
        generate Statement_Crown
            '';
        generate Literal [my Input];
        generate Statement_Behavior
        {
            string Code (i Gs_Key) (i Gs_Arguments) (i Gs_Block);
            i= Code;
        }
        generate Statement_Include
        {
            string File_Name (. [my File_Name] Unquoted);
            if (not (contains File_Name "."))
            {
                append File_Name ".gs";
            }
            string File_Text;
            readall File_Text File_Name;
            string Code
                File_Text;

            i= Code;
        }
        generate Statement_Gal_Operation
        {
            string Code 'operation ' [my Name Gs] ' ' (i Enquote [my Keyword Gs]);
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gs];
            }
            append Code (i Gs_Block);
            i= Code;
        }
        generate Statement_Gal_Syntax
        {
            string Code 'syntax ' [my Name Gs] ' ' (i Enquote [my Keyword Gs]);
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gs];
            }
            append Code (i Gs_Block);
            i= Code;
        }
        generate Operation_Is_A
        {
            verbosity;
            comment string Variable [my Variable Mumps];
            comment string Class_Name [my Class_Name Mumps];
            string Variable [my Variable Gs];
            string Class_Name [my Class_Name Gs];
            string Isa_Name 'Isa_' Class_Name;
            string Declaration
                'class set Element { property flag ' Isa_Name ' [false]; }' [line]
                'class set ' Class_Name ' { property flag ' Isa_Name ' [true]; }' [line];
            comment my= Mumps_Outer_Declaration Declaration;
            comment verbose 'Is_A outer declaration created: ' [line] Declaration;
            string Code '(isa ' [my Variable Gs] ' ' [my Class_Name Gs] ')';
            i= Code;
        }
        generate Statement_Gal_Statement
        {
            string Name [my Name Gs];
            string Keyword [my Keyword Gs];
            string Code 'statement ' Name ' ' (i Enquote Keyword);
            if (defined [my Ancestor])
            {
                append Code ' ' [my Ancestor Gs];
            }
            append Code (i Gs_Block);
            i= Code;
        }

        generate Statement_Class_Is
        {
            verbosity;
            string Name [my Name Gs];
            comment debugif (s= Name 'Document');
            string Ancestor_Class [my Ancestor_Class Gs];
            verbose 'gs: class ' Name ' is ' Ancestor_Class;
            my= Error [null];
            string Statements '';
            entity Statement;
            string Between '';
            string SGS;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    append Statements Between [. Statement Gs];
                    = Between [line];
                }
            }
            entity Canonical (dict.get [: Statement_Class Names] Name);
            foreach [. Canonical Appended_Statements] Statement
            {
                = SGS [. Statement Gs];
                append Statements Between SGS;
                verbose [indent] 'class ' Name ' appending ' SGS;
                = Between [line];
            }
            if (sgt Statements '')
            {
                = Statements (i Indent Statements);
                if (sne (lastchar Statements) [line])
                {
                    append Statements [line];
                }
            }
            string Code
                'class ' Name ' [is ' Ancestor_Class ']' [line]
                '{' [line]
                    Statements
                '}' [line];
            i= Code;
        }
        generate Statement_For_Each_In
        {
            string Variable [my Variable Gs];
            string List [my List Gs];
            string Code 'for each ' Variable ' in ' List (i Gs_Block);
            i= Code;
        }
        generate Statement_Colon
        {
            string Class [my Class Gs];
            string Method [my Method Gs];
            string Code
                Class ':' Method (i Gs_Listargs)
                (i Gs_Block);
            i= Code;
        }
        generate Operation_Dict_Exists
        {
            string Dictionary [my Dictionary Gs];
            string Key [my Key Gs];
            string Code '(dict ' Dictionary ' exists ' Key ')';
            i= Code;
        }
        generate Operation_Dict_Get
        {
            string Dictionary [my Dictionary Gs];
            string Key [my Key Gs];
            string Code '(dict ' Dictionary ' get ' Key ')';
            i= Code;
        }
        generate Statement_Flag
        {
            string Variable [my Variable Gs];
            string Code 'flag ' Variable;
            if (defined [my Value])
            {
                append Code ' = ' [my Value Gs];
            }
            append Code ';';
            i= Code;
        }
        generate Statement_Integer
        {
            string Variable [my Variable Gs];
            string Code 'integer ' Variable;
            if (defined [my Value])
            {
                append Code ' = ' [my Value Gs];
            }
            append Code ';';
            i= Code;
        }
        generate Statement_Number
        {
            string Variable [my Variable Gs];
            string Code 'number ' Variable;
            if (defined [my Value])
            {
                append Code ' = ' [my Value Gs];
            }
            append Code ';';
            i= Code;
        }
        generate Statement_Dictionary_Assign
        {
            string Dict [my Dict Gs];
            string Key [my Key Gs];
            string Value [my Value Gs];
            string Code 'dict ' Dict ' ' Key ' = ' Value ';';
            i= Code;
        }
        generate Statement_Class
        {
            verbosity [true];
            my= Error [null];
            string Arguments (i Gs_Arguments);
            entity Argument;
            string Name [my Name Gs];
            string Search ' ' Name ' ';
            string Statements '';
            entity Statement;
            string Between '';
            string SGS;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    append Statements Between [. Statement Gs];
                    = Between [line];
                }
            }
            foreach [my Appended_Statements] Statement
            {
                = SGS [. Statement Gs];
                append Statements Between SGS;
                verbose 'class ' Name ' appending ' SGS;
                = Between [line];
            }
            if (sgt Statements '')
            {
                = Statements (i Indent Statements);
                if (sne (lastchar Statements) [line])
                {
                    append Statements [line];
                }
            }
            string Code
                'class' Arguments [line]
                '{' [line]
                    Statements
                '}' [line];
            i= Code;
        }
    }
}

flowerbox 'Javascript.gal';

comment 'author Tara Zoltan;';

goal.spell Javascript `Javascript programming language`
{
    class.append Element
    {
        property number Javascript_Precedence 999;
    }
    class.append Token_Quote
    {
        method string Js_Enquote [string Text]
        {
            if (contains Text [line])
            {
                replace Text [line] '\n';
            }
            returnif (not (contains Text "'")) (append "'" Text "'");
            returnif (not (contains Text '"')) (append '"' Text '"');
            returnif (not (contains Text "`")) (append "`" Text "`");
            return "'ERROR js_enquote goalspell DEEPLY ENQUOTED STRING FAILURE'";
        }
    }
    class.append Named_Element
    {
        method string Javascript_Arguments [string Separator]
        {
            entity Argument;
            string Args_Js '';
            string Between '';
            foreach [my Arguments] Argument
            {
                if (not (defined [. Argument Javascript]))
                {
                    error 'Argument Javascript not defined: ' [. Argument Gal];
                }
                string Arg_Js [. Argument Javascript];
                append Args_Js Between Arg_Js;
                = Between Separator;
            }
            return Args_Js;
        }
        method string Javascript_Args [string Separator]
        {
            entity Argument;
            string Args_Js '';
            string Between '';
            foreach [my Listargs] Argument
            {
                if (not (defined [. Argument Javascript]))
                {
                    error 'Argument Javascript not defined: ' [. Argument Gal];
                }
                string Arg_Js [. Argument Javascript];
                append Args_Js Between Arg_Js;
                = Between Separator;
            }
            return Args_Js;
        }
        method string Javascript_Repeating
        {
            string Operator ' ' [my Javascript_Operator] ' ';
            integer Precedence [my Javascript_Precedence];
            entity Argument;
            string Args_Js '';
            string Between '';
            foreach [my Arguments] Argument
            {
                if (not (defined [. Argument Javascript]))
                {
                    error 'Argument Javascript not defined: ' [. Argument Gal];
                }
                string Arg_Js [. Argument Javascript];
                if (ge Precedence [. Argument Javascript_Precedence])
                {
                    = Arg_Js (append '(' Arg_Js ')');
                }
                append Args_Js Between Arg_Js;
                = Between Operator;
            }
            return Args_Js;
        }
        method string Javascript_Unary
        {
            string Operator ' ' [my Javascript_Operator] ' ';
            integer Precedence [my Javascript_Precedence];
            entity Argument (list.get [my Arguments] 0);
            if (not (defined [. Argument Javascript]))
            {
                error 'Argument Javascript not defined: ' [. Argument Gal];
            }
            string Arg_Js [. Argument Javascript];
            if (ge Precedence [. Argument Javascript_Precedence])
            {
                = Arg_Js (append '(' Arg_Js ')');
            }
            string Code Operator Arg_Js;
            return Code;
        }
    }

    class.append Block
    {
        property string Javascript_Statements '';
    }
    class.append Statement
    {
        method string Javascript_Block
        {
            returnif (defined [my Block]) [my Block Javascript];
            return ' { }' [line];
        }
        method string Javascript_Statements
        {
            if (not (defined [my Block])) {
                return '';
            }
            return [my Block Javascript_Statements];
        }
    }

    class.append Operation_Add
    {
        property string Javascript_Operator '+';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Subtract
    {
        property string Javascript_Operator '-';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Multiply
    {
        property string Javascript_Operator '*';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Modulo
    {
        property string Javascript_Operator '%';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Power
    {
        property string Javascript_Operator '**';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Divide
    {
        property string Javascript_Operator '/';
        property number Javascript_Precedence 6;
    }
    class.append Operation_String_Append
    {
        property string Javascript_Operator '+';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Not
    {
        property string Javascript_Operator '!';
        property number Javascript_Precedence 6;
    }
    class.append Operation_And
    {
        property string Javascript_Operator '&&';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Or
    {
        property string Javascript_Operator '||';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Less_Than
    {
        property string Javascript_Operator '<';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Greater_Than
    {
        property string Javascript_Operator '<';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Equal
    {
        property string Javascript_Operator '==';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Less_Equal
    {
        property string Javascript_Operator '<=';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Greater_Equal
    {
        property string Javascript_Operator '<=';
        property number Javascript_Precedence 6;
    }
    class.append Operation_Not_Equal
    {
        property string Javascript_Operator '!=';
        property number Javascript_Precedence 6;
    }

   class Javascript_Generator [is Generator]
    {
        infers Javascript;
        attribute list Elements;
        attribute list Inferences;
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            verbosity;
            verbose [class.name] ' Inits';
            infer.inits;
            return [true];
        }
    }

    inference string Javascript
    {
        generate Token [my Input];

        generate Token_Quote
        {
            string U (i Unquoted);
            string Code (i Js_Enquote U);
            i= Code;
        }

        generate Block
        {
            entity Line;
            string Statements '';
            foreach [my Statements] Line
            {
                append Statements [. Line Javascript] [line];
            }
            = Statements (i Indent Statements);
            string Code [line] 
                '{' [line]
                    Statements 
                '}';
            i= Code;
            my= Javascript_Statements Statements;
        }
    
        generate Javascript_Generator
        {
            verbosity;
            entity Elem;
            entity I;
            integer Number 0;
            variant Error;
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    = I [. Elem Classification];
                    . I Infer_Javascript;
                    .= Elem Javascript [. I Javascript];
                    increment Number;
                }
                catch Error
                {
                    my= Status [false];
                    .= Elem Error Error;
                    comment debug;
                    verbose 'Error javascript element ' Number
                        ': ' [classname I] 
                        ', <' Error '>'
                        ', source ' (. I Get_Input);
                }
            }
            returnif (not [my Status]);
            entity Top (list.last [my.attribute Elements]);
            comment debug;
            string Code [. Top Javascript];
            i= Code;
            my= Code Code;
        }

        generate Statements
        {
            comment debug;
            string Code '';
            entity Statement;
            string Between '';
            foreach [my Elements] Statement
            {
                append Code Between [. Statement Javascript];
                = Between [line];
            }
            i= Code;
        }

        generate Expressions
        {
            comment debug;
            string Code '';
            entity Expression;
            string Between '';
            foreach [my Elements] Expression
            {
                append Code Between [. Expression Javascript];
                = Between ', ';
            }
            i= Code;
        }

        generate Statement_Add 
            Variable ' += ' (i Javascript_Args ' + ') ';';
        generate Statement_And 
            Variable ' &= ' (i Javascript_Args ' && ') ';';
        generate Statement_Append
            Variable ' += ' (i Javascript_Args ' + ') ';';
        generate Statement_Assign
            Variable ' = ' Value ';';
        generate Statement_Break
            'break;';
        generate Statement_Break_If
            'if (' Condition ') { break; }';
        generate Statement_Call 
            Target '.' Method '(' (i Javascript_Args ', ') ');';
        generate Statement_Catch
        {
            string Code 'catch';
            if (defined [my Variable])
            {
                append Code ' (' [my Variable Javascript] ')';
            }
            append Code (i Javascript_Block);
            my= Javascript Code;
        }
        generate Statement_Forgive
            'try' (i Javascript_Block) [line]
            'catch' [line]
            '{' [line]
            '}';
        generate Statement_Continue
            'continue;';
        generate Statement_Class_Method
            'static ' Name '(' (i Javascript_Args ', ') ')'
            (i Javascript_Block);
        todo "statement class property";
        generate Statement_Comment
        {
            string Code [my Gal_Key_Suffix];
            entity Argument;
            foreach [my Arguments] Argument
            {
                if (isa Argument Syntax_Line)
                {
                    append Code [line];
                }
                else.if (isa Argument Syntax_Indent) 
                {
                    append Code [indent];
                }
                else.if (isa Argument Token_Quote) 
                {
                    append Code ' ' (. Argument Unquoted);
                }
                else
                {
                    append Code ' ' [. Argument Javascript];
                }
            }
            if (contains Code [line])
            {
                = Code (append '/*' [line] Code [line] '*/' [line]);
            }
            else
            {
                = Code (append '//' Code [line]);
            }
            i= Code;
        }
        generate Statement_Constructor
        {
            string Code 'constructor(';
            string Args (i Javascript_Args ', ');
            if (string.gt Args '')
            {
                append Code Args;
            }
            entity Class_Object (i Get_Class_Context);
            string Name [. Class_Object Name Javascript];
            string Super [indent] 'super(...arguments);' [line];
            if (s= Name 'Goal')
            {
                = Super '';
            }
            append Code ') {' [line]
                Super;
            if [my Parent Generate_Constructor]
            {
                comment debug;
                append Code [indent] 'this.propinit();' [line];
            }
            append Code (i Javascript_Statements) '}' [line];
            i= Code;
        }
        generate Statement_Debug
            'debugger;';
        generate Statement_Dictionary
        {
            string Variable_Code [my Variable Javascript];
            string Value_Code "";
            string Between '';
            entity Argument;
            foreach [my Listargs] Argument
            {
                comment debug;
                todo 'dictionary arguments come in pairs';
                append Value_Code Between [. Argument Javascript];
                = Between ', ';
            }
            string Code 'var ' Variable_Code '= {' Value_Code '};';
            i= Code;
        }
        generate Statement_Else
            'else' (i Javascript_Block);
        generate Statement_Error
            'throw ' (i Javascript_Args ' + ') ';';
        generate Statement_File_Readall
        {
            string Varname [my Variable Javascript];
            string File_Name [my File_Name Javascript];
            string Code Varname ' = gal.file_reader.readFileSync(' File_Name ",'utf8');";
            i= Code;
        }
        generate Statement_File_Dump
            'gal.file_reader.writeFileSync(' [my File_Name Javascript] ', ' [my File_Text Javascript] ');';
        generate Statement_Foreach
            'for (' [my Variable Javascript] ' of ' [my List Javascript] ')' (i Javascript_Block);
        generate Statement_Forever
            'while (true)' (i Javascript_Block);
        generate Statement_Increment
            Op1 "++;";
        generate Statement_Decrement
            Op1 "--;";
        generate Statement_If
            'if (' [my Condition Javascript] ')' (i Javascript_Block);
        generate Statement_Else_If
            'else if (' [my Condition Javascript] ')' (i Javascript_Block);
        generate Statement_Join
            Variable ' = ' List '.join(' Delimiter ');';
        generate Statement_Colon
            [my Class Javascript] '.' [my Method Javascript] '(' (i Javascript_Args ', ') ')';

        generate Statement_Generate
        {
            string Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Class_Name [my First Javascript];
                = Property_Name [my Second Javascript];
            }
            else
            {
                = Class_Name 'this.constructor';
                entity Context (i Method_Context);
                if (and Context (isa Context Class_Method_Statement))
                {
                    = Class_Name 'this';
                }
                = Property_Name [my First Javascript];
            }
            string Code Class_Name '.' Property_Name;
            i= Code;
        }

        generate Statement_Classpropget
        {
            string Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Class_Name [my First Javascript];
                = Property_Name [my Second Javascript];
            }
            else
            {
                = Class_Name 'this.constructor';
                entity Context (i Method_Context);
                if (and Context (isa Context Class_Method_Statement))
                {
                    = Class_Name 'this';
                }
                = Property_Name [my First Javascript];
            }
            string Code Class_Name '.' Property_Name;
            i= Code;
        }
        generate Statement_Contains_binary
            [my String Javascript] '.includes(' [my Search Javascript] ')';
        generate Statement_Defined
        {
            string Value_Js [my Value_Reference Javascript];
            string Block_Js [my Block Javascript];
            debug;
        }
        generate Statement_Key_exists
            [my Key Javascript] ' in ' [my Dictionary Javascript];
        generate Statement_Is_a_binary
            [my Variable Javascript] ' instanceof ' [my Class_Name Javascript];
        generate Statement_Is_null
            '(' [my Variable Javascript] ' == null || ' [my Variable Javascript] ' == "")';
        generate Statement_List_Get
        {
            if (not (defined [my List Javascript]))
            {
                error (i Failure_Message 'List Javascript missing');
            }
            if (not (defined [my Node Javascript]))
            {
                error (i Failure_Message 'Node Javascript missing');
            }
            string Code [my List Javascript] '[' [my Node Javascript] ']';
            i= Code;
        }
        generate Statement_List_Last
        {
            if (not (defined [my First Javascript]))
            {
                error (i Failure_Message 'List Javascript missing');
            }
            string Code [my First Javascript] '[' [my First Javascript] '.length-1]';
            i= Code;
        }
        generate Statement_List_Length
            [my First Javascript] '.length';
        generate Statement_List_Pop
            [my First Javascript] '.pop()';
        generate Statement_List_Shift
            [my First Javascript] '.shift()';
        generate Statement_List_Split
            [my String Javascript] '.split(' [my Delimiter Javascript] ')';
        generate Statement_Lowercase
            [my First Javascript] '.toLowerCase()';
        generate Statement_Islowercase
            [my First Javascript] '.match(/[a-z]/)';
        generate Statement_Isalpha
            [my First Javascript] '.match(/[a-zA-Z]/)';
        generate Statement_New
            'new ' [my Class_Name Javascript] '(' (i Javascript_Args ', ') ')';
        generate Statement_Not_Null
            '(' [my Variable Javascript] ' != null && ' [my Variable Javascript] ' > "")';
        generate Statement_Round
            [my Number Javascript] '.toFixed(' [my Decimals Javascript] ')';
        generate Statement_String_Length
            [my First Javascript] '.length';
        generate Statement_Substring
        {
            string Code [my String_Value Javascript] '.substr(' [my Start_Index Javascript];
            if (defined [my Length])
            {
                append Code ', ' [my Length Javascript];
            }
            append Code ')';
            i= Code;
        }
        generate Statement_Time_String
            '(new Date().toISOString())';
        generate Statement_Uppercase
            [my First Javascript] '.toUpperCase()';
        generate Statement_Isuppercase
            [my First Javascript] '.match(/[A-Z]/)';
        generate Statement_We
        {
            string Class_Name 'this.constructor';
            entity Context (i Method_Context);
            if (and Context (isa Context Class_Method_Statement))
            {
                = Class_Name 'this';
            }
            string Code Class_Name '.' [my Method Javascript] '(' (i Javascript_Args ', ') ')';
            i= Code;
        }
        generate Statement_Whitespace
            '!' [my First Javascript] '.match(/\S/)';
        generate Statement_List
        {
            string Variable [my Variable Javascript];
            string Args (i Javascript_Args ', ');
            string Code 'var ' Variable ' = [' Args '];';
            i= Code;
        }
        generate Statement_List_Copy
        {
            string Variable [my Variable Javascript];
            string Value '[]';
            if (defined [my Value])
            {
                = Value [my Value Javascript];
            }
            string Code 'var ' Variable ' = ' Value ';';
            i= Code;
        }
        generate Statement_List_Append
        {
            string Code '';
            entity Arg;
            string Between '';
            foreach [my Listargs] Arg
            {
                append Code
                    Between
                    [my List Javascript] '.push(' [. Arg Javascript] ');';
                = Between [line];
            }
            i= Code;
        }
        generate Statement_List_Delete
            [my List Javascript] '.splice(' [my Index Javascript] ', ' [my Count Javascript] ');';
        generate Statement_Main
        {
            string Jargs '';
            entity Jarg;
            strings Jname Jvalue;
            string Jcode;
            number Sub 1;
            foreach [my Arguments] Jarg
            {
                increment Sub;
                = Jname [. Jarg Variable Javascript];
                = Jcode (append 'let ' Jname ' = process.argv[' (string Sub) ']');
                if (defined [. Jarg Default_Value])
                {
                    = Jvalue [. Jarg Default_Value];
                    append Jcode ' || ' Jvalue;
                }
                append Jargs Jcode ';' [line];
            }
            entity Statement;
            string Statements_Code '';
            foreach [my Block Statements] Statement
            {
                append Statements_Code [. Statement Javascript] [line];
            }
            string Code '/* Main Program Body */' [line]
                Jargs
                Statements_Code;
            i= Code;
        }
        generate Statement_Method
            Name '(' (i Javascript_Args ', ') ')'
            (i Javascript_Block);
        generate Statement_Property
        {
            string Name_Code [my Name Javascript];
            string Value_Code '';
            string DT [my Type Input];
            = DT (append ' ' DT ' ');
            if (contains ' dict dictionary hash ' DT)
            {
                = Value_Code '{}';
            }
            else.if (contains ' list array ' DT)
            {
                = Value_Code '[]';
            }
            comment writeline "property before defined";
            if (defined [my Value])
            {
                = Value_Code [my Value Javascript];
            }
            string Code 'this.' Name_Code ' = ' Value_Code ';';
            if (s= Value_Code '')
            {
                = Code (append '// this.' Name_Code ' = null;');
            }
            i= Code;
        }
        generate Statement_Propset
            Object '.' Property ' = ' Value ';';
        generate Statement_Classpropset
            [my Target Javascript] '.' [my Property Javascript] ' = ' [my Expression Javascript] ';';
        generate Statement_Our_Equal
            'this.' [my Property Javascript] ' = ' [my Expression Javascript] ';';
        generate Statement_Read_Line
        {
            entity Argument;
            string Argument_Javascript;
            string Code '';
            string Between '';
            foreach [my Arguments] Argument
            {
                = Argument_Javascript [. Argument Javascript];
                if (isa Argument Quote)
                {
                }
                if (isa Argument Token_Name)
                {
                    append Code Between Argument_Javascript ' = console.input();';
                    = Between [line];
                }
                else
                {
                    append Code Between 'console.log(' Argument_Javascript ');';
                    = Between [line];
                }
            }
            i= Code;
	    }
        generate Statement_Replace
            [my Variable Javascript] ' = ' [my Variable Javascript] '.replaceAll(' [my Search_Text Javascript] ', ' [my Replace_Text Javascript] ');';
        generate Statement_Return
        {
            string Value_Javascript '';
            if (defined [my Value])
            {
                append Value_Javascript ' ' [my Value Javascript];
            }
            string Code 'return' Value_Javascript ';';
            i= Code;
        }
        generate Statement_String
        {
            string Var_Code [my Variable Javascript];
            string Val_Code; 
            if (gt (list.length [my Listargs]) 0)
            {
                = Val_Code (append ' = ' (i Javascript_Args ' + '));
            }
            else
            {
                = Val_Code "";
            }
            string Code 'var ' Var_Code Val_Code ';';
            i= Code;
        }
        generate Statement_Try
            'try' (i Javascript_Block);
        generate Statement_While
            'while (' [my Condition Javascript] ')' (i Javascript_Block);
        generate Statement_Class
        {
            verbosity;
            comment debug;
            string Name [my Name Javascript];
            flag Null_Block [true];
            string Arguments (i Javascript_Arguments ' ');
            string Class_Properties '';
            string Properties '';
            string Class_Methods '';
            string Statements '';
            entity Statement;
            string Line_Code;
            flag Null_Block [true];
            string Constructor '';
            string Block '';

            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    = Line_Code (append [. Statement Javascript] [line]);
                    if (not (isa Statement Comment_Statement))
                    {
                        = Null_Block [false];
                    }
                    if (isa Statement Statement_Property)
                    {
                        append Properties Line_Code;
                    }
                    else.if (isa Statement Statement_Class_Property)
                    {
                        append Class_Properties Line_Code;
                    }
                    else.if (isa Statement Statement_Class_Method)
                    {
                        append Class_Methods Line_Code;
                    }
                    else
                    {
                        append Statements Line_Code;
                    }
                }
            }
            if (sgt Class_Properties '')
            {
                append Block (i Indent Class_Properties);
            }
            if (sgt Class_Methods '')
            {
                append Block (i Indent Class_Methods);
            }
            if [my Generate_Constructor]
            {
                = Null_Block [false];
                string Function 'constructor';
                string Super [indent] 'super(...arguments);' [line];
                if [my Has_Constructor]
                {
                    = Function 'propinit';
                    = Super '';
                }
                if (s= Name 'Goal')
                {
                    = Super '';
                }
                string Constructor Function '()' [line] '{' [line];
                append Constructor Super;
                append Constructor (i Indent Properties);
                append Constructor '}' [line];
            }
            if (sgt Constructor '')
            {
                append Block (i Indent Constructor);
            }
            if (sgt Statements '')
            {
                append Block (i Indent Statements);
            }
            string Code 'class ' Arguments [line] '{' [line]
                Block
                '}' [line];
            i= Code;
        }
        generate Statement_Write_Line
            'console.log(' (i Javascript_Args ', ') ');';
        generate Statement_Uuid 
            'var ' Variable ' = self.crypto.randomUUID();';
        
        generate Operation_Begins
            [my String_Value Javascript] '.substr(0,' [my Begin_Value Javascript] '.length) == ' [my Begin_Value Javascript];
        generate Operation_Firstchar
            [my String_Value Javascript] '.charAt(0)';
        generate Operation_Lastchar
            [my String_Value Javascript] '.charAt(' [my String_Value Javascript] '.length-1)';
        generate Operation_I
            'this.' [my Method Javascript] '(' (i Javascript_Args ',') ')';

        generate Statement_My_Equal
            'this.' [my Property Javascript] ' = ' [my Value Javascript] ';';

        generate Statement_Ifdef
            {
                string Ifargs "";
                string Between "";
                entity Argument;
                foreach [my Listargs] Argument
                {
                    append Ifargs Between [. Argument Javascript] "!= null";
                    = Between " && ";
                }
                string Block (i Javascript_Block);
                string Code "if (" Ifargs ")" Block;
                my= Javascript Code;
            }
        generate Statement_Undef
        {
            string Ifargs "";
            string Between "";
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Ifargs Between [. Argument Javascript] " == null";
                = Between " || ";
            }
            string Block (i Javascript_Block);
            string Code "if (" Ifargs ")" Block;
            my= Javascript Code;
        }
        generate Statement_New_Line
            [my Variable Javascript] ' = new ' [my Class Javascript] '(' (i Javascript_Args ', ') ');';

        generate Statement_Write
            'process.stdout.write(' (i Javascript_Args ', ') ');';
        

        generate Operation_Call
            Object '.' Method '(' (i Javascript_Args ', ') ')';
        generate Operation_Colon
            Class '.' Method '(' (i Javascript_Args ', ') ')';
        generate Operation_Classpropget
        {
            string Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Class_Name [my First Javascript];
                = Property_Name [my Second Javascript];
            }
            else
            {
                = Class_Name 'this.constructor';
                entity Context (i Method_Context);
                if (and Context (isa Context Class_Method_Statement))
                {
                    = Class_Name 'this';
                }
                = Property_Name [my First Javascript];
            }
            string Code Class_Name '.' Property_Name;
            i= Code;
        }
        generate Operation_Contains
            [my String Javascript] '.includes(' [my Search Javascript] ')';
        generate Operation_Defined
            [my First Javascript] ' != null';
        generate Operation_Dictionary_Get
            [my Dictionary Javascript] '[' [my Key Javascript] ']';
        generate Operation_Key_Exists
            [my Key Javascript] ' in ' [my Dictionary Javascript];
        generate Operation_Is_A
            [my Variable Javascript] ' instanceof ' [my Class_Name Javascript];
        generate Operation_Is_Null
            '(' [my Variable Javascript] ' == null || ' [my Variable Javascript] ' == "")';
        generate Operation_List_Get
        {
            if (not (defined [my List Javascript]))
            {
                error (i Failure_Message 'List Javascript missing');
            }
            if (not (defined [my Offset Javascript]))
            {
                error (i Failure_Message 'Offset Javascript missing');
            }
            string Code [my List Javascript] '[' [my Offset Javascript] ']';
            i= Code;
        }
        generate Operation_List_Last
        {
            string Code [my List Javascript] '.slice(-1)';
            i= Code;
        }
        generate Operation_List_Length
            [my First Javascript] '.length';
        generate Operation_List_Pop
            First '.pop()';
        generate Operation_List_Shift
            [my First Javascript] '.shift()';
        generate Operation_List_Split
            [my String Javascript] '.split(' [my Delimiter Javascript] ')';
        generate Operation_Lowercase
            [my First Javascript] '.toLowerCase()';
        generate Operation_Is_Lowercase
            [my First Javascript] '.match(/[a-z]/)';
        generate Operation_Is_Alpha
            [my First Javascript] '.match(/[a-zA-Z]/)';
        generate Operation_New
            'new ' [my Class_Name Javascript] '(' (i Javascript_Args ', ') ')';
        generate Operation_Not_Null
            '(' Op1 ' != null && ' Op1 '.toString() > "")';
        generate Operation_Round
            [my Number Javascript] '.toFixed(' [my Decimals Javascript] ')';
        generate Operation_String_Length
            [my First Javascript] '.length';
        generate Operation_Substring
        {
            string Code [my String_Value Javascript] '.substr(' [my Start_Index Javascript];
            if (defined [my Length])
            {
                append Code ', ' [my Length Javascript];
            }
            append Code ')';
            i= Code;
        }
        generate Operation_Time_String
            '(new Date().toISOString())';
        generate Operation_Uppercase
            [my First Javascript] '.toUpperCase()';
        generate Operation_Is_Uppercase
            [my First Javascript] '.match(/[A-Z]/)';
        generate Operation_We
        {
            string Class_Name 'this';
            forgive
            {
                entity Context (i Method_Context);
                if (and Context (isa Context Method_Statement))
                {
                    = Class_Name 'this.constructor';
                }
            }
            string Code Class_Name '.' [my Method Javascript] '(' (i Javascript_Args ', ') ')';
            i= Code;
        }
        comment `generate Operation_Whitespace
            '!' [my First Javascript] '.match(/\S/)';`;

        generate Operation_Whitespace
            '/\s/.test(' First ')';

        generate Syntax_Is
            'extends ' [my Superclass Javascript];
        generate Syntax_Property
            (i Javascript_Arguments '.');
        generate Syntax_My
            'this.' (i Javascript_Arguments '.');
        generate Syntax_Colon
            (i Javascript_Arguments '.');
        generate Operation_Classpropget
            (i Javascript_Arguments '.');
        generate Syntax_Key
            [my Dictionary Javascript] '[' [my Key Javascript] ']';
        generate Syntax_Node
            [my List Javascript] '[' [my Node Javascript] ']';
        generate Syntax_Line
        {
            string Code '"\n"';
            if (defined [my Count])
            {
                append Code '.repeat(' [my Count Javascript] ')';
            }
            i= Code;
        }
        generate Syntax_Tab
        {
            string Code '"\t"';
            if (defined [my Count])
            {
                append Code '.repeat(' [my Count Javascript] ')';
            }
            i= Code;
        }
        generate Syntax_Tab
        {
            string Code '"\t"';
            if (defined [my Count])
            {
                append Code '.repeat(' [my Count Javascript] ')';
            }
            i= Code;
        }
        generate Syntax_Backslash
        {
            string Code "gal.backslash(";
            if (defined [my Count])
            {
                append Code [my Count Javascript];
            }
            append Code ')';
            i= Code;
        }
        generate Syntax_Indent
        {
            string Code '"    "';
            if (defined [my Count])
            {
                append Code '.repeat(' [my Count Javascript] ')';
            }
            i= Code;
        }
        generate Syntax_Class
        {
            string Object 'this';
            if (defined [my Expression])
            {
                = Object [my Expression Javascript];
            }
            string Code Object '.constructor';
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Code '.' [. Argument Javascript];
            }
            i= Code;
        }
        generate Syntax_My_Class
            'this.constructor';
        generate Syntax_Class_Name
        {
            string Object_Code 'this';
            if (defined [my Object])
            {
                = Object_Code [my Object Javascript];
            }
            string Code Object_Code '.constructor.name';
            i= Code;
        }
        generate Syntax_Class_Property
        {
            string Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Class_Name [my First Javascript];
                = Property_Name [my Second Javascript];
            }
            else
            {
                = Class_Name 'this.constructor';
                entity Context (i Method_Context);
                if (and Context (isa Context Class_Method_Statement))
                {
                    = Class_Name 'this';
                }
                = Property_Name [my First Javascript];
            }
            string Code Class_Name '.' Property_Name;
            i= Code;
        }
        generate Syntax_True
            'true';
        generate Syntax_False
            'false';
        generate Syntax_Null
            'null';
        generate Syntax_Infinity
            'Infinity';
        generate Syntax_Negative_Infinity
            'Number.NEGATIVE_INFINITY';

        generate Declaration_Statement
        {
            if (not (defined [my Variable Javascript]))
            {
                error (i Failure_Message 'Variable Javascript is undefined');
            }
            string Variable_Javascript [my Variable Javascript];
            string Value_Javascript '';
            if (defined [my Value])
            {
                = Value_Javascript (append ' = ' [my Value Javascript]);
            }
            string Code 'var ' Variable_Javascript Value_Javascript ';';
            i= Code;
        }
        generate Statement_Readline
            Variable ' = prompt();';
        generate Operation_Random_Integer
            'Math.floor(Math.random() * ' Values ')';
        generate Operation_Random_Percent
            'Math.random()';

        generate Unary_Operation
        {
            string Code (i Javascript_Unary);
            i= Code;
        }
        generate Binary_Operation
        {
            string Code (i Javascript_Repeating);
            i= Code;
        }
        generate Repeating_Operation
        {
            string Code (i Javascript_Repeating);
            i= Code;
        }
        generate Statement_Module
        {
            string Preamble `
class gal 
{ 
    constructor() { } 
    static backslash(Count=1) 
    {
        return "\\".repeat(Count);
    }
    static file_append(filename, addtext)
    {
        gal.fs.appendFileSync(filename, addtext);
    }
    static file_exists(filename)
    {
        return gal.fs.existSync(filename);
    }
}
gal.fs = require("fs");
gal.file_reader = require("fs");
gal.read_file = function(File_Name) 
{
    gal.file_reader.readFileSync(File_Name, 'utf8');
};
gal.write_file = function(File_Name, File_Text) 
{
    gal.file_reader.writeFileSunc(File_Name, File_Text);
}
`;
            string Code '';
            entity Statement;
            foreach [my Block Statements] Statement
            {
                append Code [. Statement Javascript];
            }
            i= Code;
        }
        generate Syntax_Generator
            'Javascript_Generator';
        generate Operation_Round
        {
            string Number [my Number Javascript];
            string Code Number '.toFixed(';
            if (defined [my Decimals])
            {
                append Code ', ' [my Decimals Javascript];
            }
            append Code ')';
            i= Code;
        }
        generate Operation_Enquote
            'gal.enquote(' Op1 ')';
        generate Operation_Int2char
            'String.fromCharCode(' (i Javascript_Arguments ',') ')';
        generate Operation_Char2int
            Integer '.charCodeAt()';
        generate Statement_Execute
            'eval(' Target ');';
        generate Statement_File_Dump
            'gal.file_reader.writeFileSync(' [my File_Name Javascript] ', ' [my File_Text Javascript] ');';
        generate Statement_File_Append
            'gal.file_reader.writeFileSync(' [my File_Name Javascript] ', ' [my File_Text Javascript] ', "a");';
        generate Operation_Files
            'fs.readDirSync(' Filespec ')';
        generate Statement_Rename
            'fs.renameSync(' From ', ' To ');';
        generate Statement_File_Delete
            'fs.unlinkSync(' File_Name ')';
        generate Operation_Int2char
            'String.fromCharCode(' Integer ')';
        generate Operation_Char2int
            Character '.charCodeAt(0)';
        generate Statement_Iterate
            'for ([' Key_Variable ', ' Value_Variable '] of Object.entries(' Dictionary '))' (i Javascript_Block);
        generate Operation_Is_Null
            '!(' Op1 ')';
        generate Operation_Length
            First '.length';
        generate Operation_First_Char
            String_Value '.substring(0,1)';
        generate Operation_Last_Char
            First '.slice(-1)';
        generate Operation_Shift
            First '.shift()';
        generate Operation_Dict_Exists
            '(' Dictionary '[' Key '] != null)';
        generate Operation_Dict_Get
            Dictionary '[' Key ']';
        generate Operation_String_Not_Equal
        {
            string Op1 [my Op1 Javascript];
            string Op2 [my Op2 Javascript];
            if (not (isa [my Op1] Token_Quote))
            {
                append Op1 '.toString()';
            }
            if (not (isa [my Op2] Token_Quote))
            {
                append Op2 '.toString()';
            }
            string Code Op1 ' != ' Op2;
            i= Code;
        }
        generate Operation_String_Equal
        {
            string Op1 [my Op1 Javascript];
            string Op2 [my Op2 Javascript];
            if (not (isa [my Op1] Token_Quote))
            {
                append Op1 '.toString()';
            }
            if (not (isa [my Op2] Token_Quote))
            {
                append Op2 '.toString()';
            }
            string Code Op1 ' == ' Op2;
            i= Code;
        }
        generate Operation_String_Greater
        {
            string Op1 [my Op1 Javascript];
            string Op2 [my Op2 Javascript];
            if (not (isa [my Op1] Token_Quote))
            {
                append Op1 '.toString()';
            }
            if (not (isa [my Op2] Token_Quote))
            {
                append Op2 '.toString()';
            }
            string Code Op1 ' > ' Op2;
            i= Code;
        }
        generate Operation_String_Greater_Equal
        {
            string Op1 [my Op1 Javascript];
            string Op2 [my Op2 Javascript];
            if (not (isa [my Op1] Token_Quote))
            {
                append Op1 '.toString()';
            }
            if (not (isa [my Op2] Token_Quote))
            {
                append Op2 '.toString()';
            }
            string Code Op1 ' >= ' Op2;
            i= Code;
        }
        generate Operation_String_Less
        {
            string Op1 [my Op1 Javascript];
            string Op2 [my Op2 Javascript];
            if (not (isa [my Op1] Token_Quote))
            {
                append Op1 '.toString()';
            }
            if (not (isa [my Op2] Token_Quote))
            {
                append Op2 '.toString()';
            }
            string Code Op1 ' < ' Op2;
            i= Code;
        }
        generate Operation_String_Less_Equal
        {
            string Op1 [my Op1 Javascript];
            string Op2 [my Op2 Javascript];
            if (not (isa [my Op1] Token_Quote))
            {
                append Op1 '.toString()';
            }
            if (not (isa [my Op2] Token_Quote))
            {
                append Op2 '.toString()';
            }
            string Code Op1 ' <= ' Op2;
            i= Code;
        }
        generate Operation_Split
            String '.split(' Delimiter ')';
        generate Argument_Syntax
        {
            string Code [my Variable Javascript];
            if (defined [my Default_Value])
            {
                append Code '=' [my Default_Value Javascript];
            }
            i= Code;
        }
        generate Operation_Is_Ident
            '"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789".includes(' Character ')';
        generate Operation_Is_Whitespace
            '" \t\n\r".includes(' Character ')';
        generate Syntax_Self
            'this';
        generate Syntax_List
            Variable;
        generate Syntax_Dictionary
            Variable;
        generate Syntax_Our
        {
            string Code 'this';
            if (defined [my Class_Property])
            {
                append Code '.' (i Javascript_Arguments '.');
            }
            i= Code;
        }
        generate Statement_Class_Property
        {
            string Name_Code [my Name Javascript];
            string Value_Code '';
            string DT (list.last [my Gs_Keywords]);
            = DT (append ' ' DT ' ');
            if (contains ' dict dictionary hash ' DT)
            {
                = Value_Code '{}';
            }
            else.if (contains ' list array ' DT)
            {
                = Value_Code '[]';
            }
            if (defined [my Value])
            {
                = Value_Code [my Value Javascript];
            }
            string Code "static " Name_Code ' = ' Value_Code ';';
            if (s= Value_Code '')
            {
                = Code (append '// ' Name_Code ' = null;');
            }
            i= Code;
        }
        generate Statement_Dictionary_Assign
            Dict '[' Key '] = ' Value ';';
        generate Statement_For_Range
        {
            string Variable [my Variable Javascript];
            string Start [my Start Javascript];
            string End [my End Javascript];
            string Increment '';
            if (defined [my Increment])
            {
                append Increment ' += ' [my Increment Javascript];
            }
            else
            {
                append Increment '++';
            }
            string Code 'for (' Variable '=' Start '; ' Variable '<=' End '; ' Variable Increment ')' (i Javascript_Block);
            i= Code;
        }
        generate Statement_Undefined
        {
            string Ifargs "";
            string Between '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                append Ifargs Between [. Argument Javascript] ' == null';
                = Between ' && ';
            }
            string Block (i Javascript_Block);
            string Code "if (" Ifargs ')' Block;
            i= Code;
        }
        generate Syntax_Null 'null';
        generate Syntax_New_List
            '[' (i Javascript_Arguments ', ') ']';
        generate Operation_Is_String
            '(typeof ' Value " === 'string')";
        generate Operation_Is_Number
            '(typeof ' Value " === 'number')";
        generate Statement_Implement
            'eval(Implementer);';
        generate Operation_Absolute
            'Math.abs(' Op1 ')';
        generate Operation_Implement
            'eval(Implementer)';
        generate Statement_List_Clear
            List ' = [];';
        generate Statement_Nsl_Module
        {
            string Preamble `
var parallel = require('paralleljs');
var fs = require("fs");
var file_reader = require("fs");
var read_file = function(File_Name) 
{
    gal.file_reader.readFileSync(File_Name, 'utf8');
};
var write_file = function(File_Name, File_Text) 
{
    gal.file_reader.writeFileSunc(File_Name, File_Text);
}
`;
            string Code Preamble;
            entity Statement;
            foreach [my Block Statements] Statement
            {
                append Code [. Statement Javascript];
            }
            i= Code;
        }
        generate Statement_List_Property_Insert
        {
            string List [my  List Javascript];
            string Property_Name [my Property_Name Javascript];
            string Inserted_Value [my Inserted_Value Javascript];
            string Code
                'var idx,rec;' [line]
                List '.push(' Inserted_Value ');' [line]
                'for (idx=' List '.length-1; idx--; idx>=0)' [line] '{' [line, indent]
                    'if (' List '[idx].' Property_Name ' > ' List '[idx+1].' Property_Name ')' [line, indent] '{' [line, indent 2]
                        'rec=' List '[idx];' [line, indent 2]
                        List '[idx] = ' List '[idx+1];' [line, indent 2]
                        List '[idx+1] = rec;' [line, indent]
                    '}' [line]
                '}' [line];
            i= Code;
        }
        generate Statement_Collates
        {
            string Property_Name [my Property_Name Javascript];
            string Code
                '// Collates by property ' Property_Name [line];
            i= Code;
        }
        generate Statement_Distribute
        {
            string List [my List Javascript];
            string Function [my Function Javascript];
            string Code
                'var distribute = new parallel(' List ');' [line]
                'distribute.map(' Function ');';
            i= Code;
        }
        generate Statement_Function
            'function ' Name '(' (i Javascript_Args ', ') ')' 
            (i Javascript_Block);
        generate Operation_Titlecase
            'goalspell.titlecase(' String ')';
        generate Operation_Evaluate
            'evaluate(' (i Javascript_Arguments ' + ') ')';
        generate Operation_String
            Op1 '.toString()';
        generate Statement_List_Insert
            Variable '.splice(' Index ', 0, ' Value ')';
        generate Statement_List_Assign
            Variable '[' Index '] = ' Value ';';
        generate Operation_Square_Root
            'Math.sqrt(' Op1 ')';
        generate Operation_Integer
            'parseInt(' Op1 ')';
        generate Statement_Function_Invoke
            Function '(' (i Javascript_Args ', ') ')';

        generate Statement_Target_Includes
`
var parallel = require('paralleljs');
var fs = require("fs");
var file_reader = require("fs");
var read_file = function(File_Name)
{
    gal.file_reader.readFileSync(File_Name, 'utf8');
};
var write_file = function(File_Name, File_Text)
{
    gal.file_reader.writeFileSunc(File_Name, File_Text);
}
`;
        generate Statement_Import
        {
            verbosity;
            debug;
            verbose 'Statement_Import in Javascript';
        }
        generate Syntax_Class
            "(" Object '.constructor)';
        todo "Syntax_Module_Class Module_Expression has to be evaluated";
        generate Syntax_Module_Class
            Module_Expression '.' Class_Name;
        generate Operation_Last_Char
            First '.slice(-1)';
        generate Operation_Environment
            'process.env.' Variable;
        generate Statement_Cd
            'process.chdir(' Directory ');';
        generate Token_Name
        {
            string Input [my Input];
            if (contains Input '$')
            {
                replace Input '$' '';
            }
            i= Input;
        }
        generate Statement_Confirm_Exit_If
        {
            string Condition [my Condition Javascript];
            string Code 'window.onbeforeunload = e => (' Condition ') ? true : null;';
            i= Code;
        }
        generate Operation_Create_Element
        {
            string Tag [my Tag Javascript];
            string Code 'document.createElement(' Tag ')';
            i= Code;
        }
        generate Statement_Web_App
        {
            string Name [my Name Javascript];
            string Block '';
            entity Statement;
            forgive
            {
                foreach [my Block Statements] Statement
                {
                    append Block [. Statement Javascript] [line];
                }
            }
            string Code
                '// Web application: ' Name [line]
                Block;
            i= Code;
        }
        generate Syntax_Us
            'this';
        generate Operation_Get_Element_By_Id
            'document.getElementById(' Id ')';
        generate Statement_For_Each_In
            "for (" Variable " of " List ")"
            (i Javascript_Block);
        generate Syntax_Property_Lookup
            Object "[" Name_String "]";
        generate Statement_Redirect_To
            'window.location.replace(' Url ')';
        generate Operation_From_Json
            'JSON.parse(' Object ')';
        generate Operation_To_Json
            'JSON.stringify(' Object ')';
        generate Operation_Http_Fetch
            'await fetch(' (i Javascript_Arguments ", ") ')';
        generate Syntax_Await
            'await ' Invocation;
        generate Statement_Alert
            'alert(' (i Javascript_Arguments ", ") ')';
        generate Statement_Async_Method
            'async ' Name '(' (i Javascript_Args ', ') ')'
            (i Javascript_Block);
        generate Operation_File_Exists
            'gal.fs.readFileSync(' Path ')';
    }
}
flowerbox 'Python.gal';

comment author 'Tara Zoltan';

goal.spell Python `Python programming language`
{
    class.append Element
    {
        property number Python_Precedence 999;
        method string Py_Indent [string Text]
        {
            returnif (isnull Text) '';
            string C;
            string C3;
            string I '';
            flag Quote [false];
            string Q '';
            string Between '';
            integer E (- (length Text) 1);
            if (not (contains `'"` (substring Text 0 1)))
            {
                = Between [indent];
            }
            
            integer P -1;
            while (lt P E)
            {
                increment P;
                = C (substring Text P 1);
                = C3 (substring Text P 3);
                append I Between C;
                = Between '';
                if Quote
                {
                    if (s= C3 Q)
                    {
                        = Quote [false];
                        append I (substring Q 1 2);
                        += P 2;
                        = Q '';
                    }
                    else.if (s= C Q)
                    {
                        = Quote [false];
                        = Q '';
                    }
                    else.if (s= C '\')
                    {
                        increment P;
                        append I (substring Text P 1);
                    }
                }
                else.if (= C [line])
                {
                    = Between [indent];
                }
                else.if (or (s= C3 "'''") (s= C3 '"""'))
                {
                    = Quote [true];
                    = Q C3;
                    append I (substring Q 1 2);
                    += P 2;
                }
                else.if (or (s= C "'") (s= C '"'))
                {
                    = Quote [true];
                    = Q C;
                }

            }
            return I;
        }
        method string Py_Enquote [string Text]
        {
            if (contains Text '\')
            {
                replace Text '\' '\\';
            }
            if (contains Text [line])
            {
                replace Text [line] '\n';
            }
            returnif (not (contains Text "'")) (append "'" Text "'");
            returnif (not (contains Text '"')) (append '"' Text '"');

            if (not (contains Text "'''"))
            {
                replace Text "'" "\'";
                return (append "'''" Text "'''");
            }

            if (not (contains Text '"""'))
            {
                replace Text '"' '\"';
                return (append '"""' Text '"""');
            }

            return "'ERROR goalspell py_enquote DEEPLY QUOTED STRING'";
        }
    }
    class.append Named_Element
    {
        method string Python_Arguments [string Separator]
        {
            entity Argument;
            string Args_Py '';
            string Between '';
            foreach [my Arguments] Argument
            {
                if (not (defined [. Argument Python]))
                {
                    error 'Argument Python not defined: ' [. Argument Gal];
                }
                string Arg_Py [. Argument Python];
                append Args_Py Between Arg_Py;
                = Between Separator;
            }
            return Args_Py;
        }    
        method string Python_Args [string Separator]
        {
            entity Argument;
            string Args_Py '';
            string Between '';
            foreach [my Listargs] Argument
            {
                if (not (defined [. Argument Python]))
                {
                    error 'Argument Python not defined: ' [. Argument Gal];
                }
                string Arg_Py [. Argument Python];
                append Args_Py Between Arg_Py;
                = Between Separator;
            }
            return Args_Py;
        }    
        method string Python_Repeating
        {
            string Operator ' ' [my Python_Operator] ' ';
            integer Precedence [my Python_Precedence];
            entity Argument;
            string Args_Py '';
            string Between '';
            foreach [my Arguments] Argument
            {
                if (not (defined [. Argument Python]))
                {
                    error 'Argument Python not defined: ' [. Argument Gal];
                }
                string Arg_Py [. Argument Python];
                if (ge Precedence [. Argument Python_Precedence])
                {
                    = Arg_Py (append '(' Arg_Py ')');
                }
                append Args_Py Between Arg_Py;
                = Between Operator;
            }
            return Args_Py;
        }    
        method string Python_Unary
        {
            string Operator ' ' [my Python_Operator] ' ';
            integer Precedence [my Python_Precedence];
            entity Argument (list.get [my Arguments] 0);
            if (not (defined [. Argument Python]))
            {
                error 'Argument Python not defined: ' [. Argument Gal];
            }
            string Arg_Py [. Argument Python];
            if (ge Precedence [. Argument Python_Precedence])
            {
                = Arg_Py (append '(' Arg_Py ')');
            }
            string Code Operator Arg_Py;
            return Code;
        }
        method string Python_String_Args [string Separator]
        {
            entity Argument;
            string Args_Py '';
            string Between '';
            foreach [my Listargs] Argument
            {
                if (not (defined [. Argument Python]))
                {
                    error 'Argument Python not defined: ' [. Argument Gal];
                }
                string Arg_Py [. Argument Python];
                if (isa Argument Token_Quote)
                {
                    append Args_Py Between Arg_Py;
                }
                else
                {
                    append Args_Py Between 'str(' Arg_Py ')';
                }
                = Between Separator;
            }
            return Args_Py;
        }
    }
    class.append Block
    {
        property string Python_Statements '';
    }
    class.append Statement
    {
        method string Python_Block
        {
            if (defined [my Block])
            {
                return [my Block Python];
            }
            else
            {
                return (append ':' [line, indent] 'pass' [line]);
            }
        }
        method string Python_Statements
        {
            if (defined [my Block])
            {
                return [my Block Python_Statements];
            }
            else
            {
                return '';
            }
        }
    }

    class.append Operation_Add
    {
        property string Python_Operator '+';
        property number Python_Precedence 6;
    }
    class.append Operation_Subtract
    {
        property string Python_Operator '-';
        property number Python_Precedence 6;
    }
    class.append Operation_Multiply
    {
        property string Python_Operator '*';
        property number Python_Precedence 6;
    }
    class.append Operation_Modulo
    {
        property string Python_Operator '%';
        property number Python_Precedence 6;
    }
    class.append Operation_Divide
    {
        property string Python_Operator '/';
        property number Python_Precedence 6;
    }
    class.append Operation_String_Append
    {
        property string Python_Operator '+';
        property number Python_Precedence 6;
    }
    class.append Operation_Not
    {
        property string Python_Operator 'not';
        property number Python_Precedence 6;
    }
    class.append Operation_And
    {
        property string Python_Operator 'and';
        property number Python_Precedence 6;
    }
    class.append Operation_Or
    {
        property string Python_Operator 'or';
        property number Python_Precedence 6;
    }
    class.append Operation_Less_Than
    {
        property string Python_Operator '<';
        property number Python_Precedence 6;
    }
    class.append Operation_Greater_Than
    {
        property string Python_Operator '>';
        property number Python_Precedence 6;
    }
    class.append Operation_Equal
    {
        property string Python_Operator '==';
        property number Python_Precedence 6;
    }
    class.append Operation_Less_Equal
    {
        property string Python_Operator '<=';
        property number Python_Precedence 6;
    }
    class.append Operation_Greater_Equal
    {
        property string Python_Operator '>=';
        property number Python_Precedence 6;
    }
    class.append Operation_Not_Equal
    {
        property string Python_Operator '!=';
        property number Python_Precedence 6;
    }

   class Python_Generator [is Generator]
    {
        infers Python;
        attribute list Elements;
        attribute list Inferences;
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            verbosity;
            verbose [class.name] ' Inits';
            infer.inits;
            return [true];
        }
    }

    inference string Python
    {
        generate Element;
        generate Token [my Input];
        generate Token_Quote
        {
            verbosity;
            string U (i Unquoted);
            string Code (i Py_Enquote U);
            verbose "input: " [my Input] ", U: " U ", Code: " Code;
            i= Code;
        }
        generate Block
        {
            entity Line;
            string Statements '';
            string Between '';
            flag Found [false];
            foreach [my Statements] Line
            {
                if (not (isa Line Statement_Comment))
                {
                    = Found [true];
                }
                append Statements Between [. Line Python];
                = Between [line];
            }
            if (not Found)
            {
                if (sgt Statements '')
                {
                    append Statements [line];
                }
                append Statements 'pass';
            }
            = Statements (i Py_Indent Statements);
            string Code ':' [line]
                Statements;
            i= Code;
            my= Python_Statements Statements;
        }
    
        generate Python_Generator
        {
            verbosity;
            entity Elem;
            entity I;
            integer Number 0;
            variant Error;
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    = I [. Elem Classification];
                    . I Infer_Python;
                    .= Elem Python [. I Python];
                    increment Number;
                }
                catch Error
                {
                    my= Status [false];
                    comment debug;
                    .= Elem Error Error;
                    verbose 'Error python element ' Number
                        ': ' [classname I] 
                        ', <' Error '>'
                        ', source ' (. I Get_Input);
                }
            }
            returnif (not [my Status]) [false];
            entity Top (list.last [my.attribute Elements]);
            comment debug;
            string Code [. Top Python];
            i= Code;
            my= Code Code;
        }

        generate Statements
        {
            comment debug;
            string Code '';
            entity Statement;
            string Between '';
            foreach [my Elements] Statement
            {
                append Code Between [. Statement Python];
                = Between [line];
            }
            i= Code;
        }

        generate Expressions
        {
            comment debug;
            string Code '';
            entity Expression;
            string Between '';
            foreach [my Elements] Expression
            {
                append Code Between [. Expression Python];
                = Between ', ';
            }
            i= Code;
        }

        generate Statement_Add 
            Variable ' += ' (i Python_Args ' + ');
        generate Statement_And 
            Variable ' &= ' (i Python_Args ' && ');
        generate Statement_Append
            Variable ' += ' (i Python_Args ' + ');
        generate Statement_Assign
            Variable ' = ' Value;
        generate Statement_Break
            'break';
        generate Statement_Break_If
            'if ' Condition ':' [line, indent] 'break';
        generate Statement_Call 
            Target '.' Method '(' (i Python_Args ', ') ')';
        generate Statement_Catch
        {
            string Code 'except Exception';
            if (defined [my Variable])
            {
                append Code ' as ' [my Variable Python];
            }
            append Code (i Python_Block);
            i= Code;
        }
        generate Statement_Forgive
            'try' (i Python_Block) [line]
            'except Exception:' [line, indent]
                'pass';
        generate Statement_Continue
            'continue';
        generate Statement_Class_Method
        {
            string Code '@classmethod' [line] 'def ' [my Name Python] '(cls';
            string Args (i Python_Args ', ');
            if (string.gt Args '')
            {
                append Code ', ' Args;
            }
            append Code ')' (i Python_Block);
            i= Code;
        }
        todo "statement class property";
        generate Statement_Comment
        {
            string Code '#' [my Gal_Key_Suffix];
            entity Argument;
            foreach [my Arguments] Argument
            {
                if (isa Argument Syntax_Line)
                {
                    append Code [line] '#';
                }
                else.if (isa Argument Token_Quote) 
                {
                    string Text (. Argument Unquoted);
                    if (contains Text [line])
                    {
                        string Line;
                        string Between ' ';
                        list.copy Lines (split Text [line]);
                        foreach Lines Line
                        {
                            append Code Between Line;
                            = Between (append [line] '# ');
                        }
                    }
                    else
                    {
                        append Code ' ' Text;
                    }
                }
                else
                {
                    append Code ' ' [. Argument Python];
                }
            }
            i= Code;
        }
        generate Statement_Constructor
        {
            string Code 'def __init__(self';
            string Args (i Python_Args ', ');
            if (string.gt Args '')
            {
                append Code ', ' Args;
            }
            append Code '):' [line, indent]
                'super().__init__()' [line];
            if [my Parent Generate_Constructor]
            {
                append Code [indent] 'self.propinit()' [line];
            }
            append Code (i Python_Statements);
            i= Code;
        }
        generate Statement_Debug
            'import zdebug; zdebug.zbreak()';
        generate Statement_Dictionary
        {
            string Variable_Code [my Variable Python];
            string Value_Code "";
            string Between '';
            entity Argument;
            foreach [my Listargs] Argument
            {
                debug;
                todo 'dictionary arguments come in pairs.';
                append Value_Code Between [. Argument Python];
                = Between ', ';
            }
            string Code Variable_Code ' = {' Value_Code '}';
            i= Code;
        }
        generate Statement_Else
            'else' (i Python_Block);
        generate Statement_Error
            'raise Exception(' (i Python_String_Args ' + ') ')';
        generate Statement_File_Readall
            '_FH = open(' [my File_Name Python] ', "r", encoding="utf8")' [line]
            [my Variable Python] ' = _FH.read()' [line]
            '_FH.close()';
        generate Statement_File_Dump
            '_FH = open(' [my File_Name Python] ', "w")' [line]
            '_FH.write(' [my File_Text Python] ')' [line]
            '_FH.close()';
        generate Statement_Foreach
            'for ' [my Variable Python] ' in ' [my List Python] (i Python_Block);
        generate Statement_Forever
            'while True' (i Python_Block);
        generate Statement_Increment
            Op1 ' += 1';
        generate Statement_Decrement
            Op1 ' -= 1';
        generate Statement_If
            'if ' [my Condition Python] (i Python_Block);
        generate Statement_Else_If
            'elif ' [my Condition Python] (i Python_Block);
        generate Statement_Join
            Variable ' = ' Delimiter '.join(' List ')';
        generate Statement_Call
            [my Target Python] '.' [my Method Python] '(' (i Python_Args ', ') ')';
        generate Statement_Colon
            [my Class Python] '.' [my Method Python] '(' (i Python_Args ', ') ')';
        generate Statement_Generate
        {
            string Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Class_Name [my First Python];
                = Property_Name [my Second Python];
            }
            else
            {
                = Class_Name 'this.constructor';
                if (and (defined [my Method_Context])
                        (isa [my Method_Context] Class_Method_Statement))
                {
                    = Class_Name 'this';
                }
                = Property_Name [my First Python];
            }
            string Code Class_Name '.' Property_Name;
            i= Code;
        }
        generate Statement_Classpropget
        {
            string Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Class_Name [my First Python];
                = Property_Name [my Second Python];
            }
            else
            {
                = Class_Name 'this.constructor';
                entity Context (i Method_Context);
                if (and Context (isa Context Class_Method_Statement))
                {
                    = Class_Name 'this';
                }
                = Property_Name [my First Python];
            }
            string Code Class_Name '.' Property_Name;
            i= Code;
        }
        generate Statement_Contains_binary
            [my Search Python] ' in ' [my String Python];
        generate Statement_Defined
        {
            string Value_Python [my Value_Reference Python];
            string Block_Python (i Python_Block);
            debug;
        }
        generate Statement_We
            'self.__class__.' [my Method Python] '(' (i Python_Args ', ') ')';
        generate Statement_List
        {
            string Variable [my Variable Python];
            string Args (i Python_Args ', ');
            string Code Variable ' = [' Args ']';
            i= Code;
        }
        generate Statement_List_Copy
        {
            string Variable [my Variable Python];
            string Value '[]';
            if (defined [my Value])
            {
                = Value (append [my Value Python] '.copy()');
            }
            string Code Variable ' = ' Value;
            i= Code;
        }
        generate Statement_List_Append
            [my List Python] '.extend([' (i Python_Args ', ') '])';
        generate Statement_List_Delete
            'del ' [my List Python] '[' [my Index Python] ':' [my Index Python] '+' [my Count Python] ']';
        generate Statement_Main
        {
            string Code 'if __name__ == "__main__"';
            if (greater (list.length [my Arguments]) 0)
            {
                integer Sub 0;
                string Args '';
                entity Argument;
                foreach [my Arguments] Argument
                {
                    increment Sub;
                    string Arg_Name [. Argument Variable Python];
                    string Arg_Code [indent 2] Arg_Name ' = sys.argv[' Sub ']' [line];
                    if (defined [. Argument Default_Value])
                    {
                        = Arg_Code (append
                            [indent 2]'try:' [line, indent]
                                Arg_Code [indent 2]
                            'except:' [line, indent 3]
                                Arg_Name ' = ' [. Argument Default_Value Python] [line]
                            );
                    }
                    append Args Arg_Code;
                }
                append Code ':' [line, indent]
                    'try:' [line]
                        Args [indent]
                    'except:' [line, indent 2]
                        'print("Usage: ", sys.argv[0], "' (i Python_Args ' ') '")' [line, indent 2]
                        'sys.exit()' [line];
                append Code (i Python_Statements);
            }
            else
            {
                append Code (i Python_Block);
            }
            i= Code;
        }
        generate Statement_Method
        {
            string Code 'def ' [my Name Python] '(self';
            string Args (i Python_Args ', ');
            string Block (i Python_Block);
            if (string.gt Args '')
            {
                append Code ', ' Args;
            }
            append Code ')' Block;
            i= Code;
        }
        generate Statement_Property
        {
            string Name_Code [my Name Python];
            string Value_Code 'None';
            string DT [my Type Input];
            = DT (append ' ' DT ' ');
            if (contains ' dict dictionary hash ' DT)
            {
                = Value_Code '{}';
            }
            else.if (contains ' list array ' DT)
            {
                string List_Contents "";
                if (defined [my Value])
                {
                    append List_Contents [my Value Python];
                    entity Arg;
                    foreach [my Listargs] Arg
                    {
                        append List_Contents ', ' [. Arg Python];
                    }
                }
                = Value_Code (append '[' List_Contents ']');
            }
            else.if (defined [my Value])
            {
                = Value_Code [my Value Python];
            }
            comment writeline "property after defined";
            string Code 'self.' Name_Code ' = ' Value_Code;
            comment writeline "Property Code " Code;
            i= Code;
        }
        generate Statement_Propset
            Object '.' Property ' = ' Value;
        generate Statement_Classpropset
            Target '.' Property ' = ' Expression;
        generate Statement_Our_Equal
            'cls.' Property ' = ' Expression;
        generate Statement_Read_Line
	    {
		    entity Argument;
		    string Argument_Python;
		    string Code '';
		    foreach [my Arguments] Argument
		    {
			    = Argument_Python [. Argument Python];
                string Between '';
			    if (isa Argument Token_Name)
			    {
				    append Code Between Argument_Python ' = input()';
                    = Between [line];
			    }
			    else
			    {
				    append Code Between "print(" Argument_Python ",sep='',end='')";
                    = Between [line];
			    }
		    }
		    i= Code;
	    }
        generate Statement_Replace
            [my Variable Python] ' = ' [my Variable Python] '.replace(' [my Search_Text Python] ', ' [my Replace_Text Python] ')';
        generate Statement_Return
        {
            string Value_Python '';
            if (defined [my Value])
            {
                append Value_Python ' ' [my Value Python];
            }
            string Code 'return' Value_Python;
            i= Code;
        }
        generate Statement_String
        {
            string Var_Code [my Variable Python];
            string Val_Code; 
            if (gt (list.length [my Listargs]) 0)
            {
                = Val_Code (i Python_String_Args ' + ');
            }
            else
            {
                = Val_Code "None";
            }
            string Code Var_Code ' = ' Val_Code;
            i= Code;
        }
        generate Statement_Try
            'try' (i Python_Block);
        generate Statement_While
            'while ' [my Condition Python] (i Python_Block);
        generate Statement_Class 
        {
            verbosity;
            comment debug;
            flag Null_Block [true];
            string Arguments (i Python_Arguments ' ');
            string Class_Properties '';
            string Properties '';
            string Class_Methods '';
            string Statements '';
            entity Statement;
            string Line_Code;
            flag Null_Block [true];
            string Constructor '';
            string Block '';

            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    = Line_Code (append [. Statement Python] [line]);
                    if (not (isa Statement Comment_Statement))
                    {
                        = Null_Block [false];
                    }
                    if (isa Statement Statement_Property)
                    {
                        append Properties Line_Code;
                    }
                    else.if (isa Statement Statement_Class_Property)
                    {
                        append Class_Properties Line_Code;
                    }
                    else.if (isa Statement Statement_Class_Method)
                    {
                        append Class_Methods Line_Code;
                    }
                    else
                    {
                        append Statements Line_Code;
                    }
                }
            }
            if (sgt Class_Properties '')
            {
                append Block (i Py_Indent Class_Properties);
            }
            if (sgt Class_Methods '')
            {
                append Block (i Py_Indent Class_Methods);
            }
            if [my Generate_Constructor]
            {
                = Null_Block [false];
                string Function '__init__';
                string Super [indent] 'super().__init__()' [line];
                if [my Has_Constructor]
                {
                    = Function 'propinit';
                    = Super '';
                }
                string Constructor 'def ' Function '(self):' [line];
                append Constructor Super;
                append Constructor (i Py_Indent Properties);
            }
            if (sgt Constructor '')
            {
                append Block (i Py_Indent Constructor);
            }
            if (sgt Statements '')
            {
                append Block (i Py_Indent Statements);
            }
            if (or Null_Block (s= Block ''))
            {
                append Block [indent] 'pass' [line];
            }
            string Code 'class ' Arguments ':' [line]
                Block;
            i= Code;
        }
        generate Statement_Uuid 
            Variable ' = uuid.uuid4().hex';
        generate Operation_Uuid 
            'uuid.uuid4().hex';
        generate Statement_Undefined
        {
            string Ifargs "";
            entity Argument;
            foreach [my Arguments] Argument
            {
                append Ifargs "if " [. Argument Python] ' is None:' [line]
                    [indent] 'raise ValueError' [line];
            }
            = Ifargs (i Py_Indent Ifargs);
            string Block (i Python_Block);
            string Code "try:" [line] Ifargs;
            append Code "except (ValueError, AttributeError)" Block;
            i= Code;
        }
        generate Statement_Write_Line
        {
            string Code 'print(' (i Python_Args ', ');
            if (gt (list.length [my Listargs]) 1)
            {
                append Code ", sep=''";
            }
            append Code ")";
            i= Code;
        }
        generate Statement_Write
        {
            string Code 'print(' (i Python_Args ', ');
            if (gt (list.length [my Listargs]) 1)
            {
                append Code ", sep=''";
            }
            append Code ", end='')";
            i= Code;
        }
        generate Operation_Begins
            [my String_Value Python] '[:len(' [my Begin_Value Python] ')] == ' [my Begin_Value Python];
        generate Operation_First_Char
            [my String_Value Python] '[0]';
        generate Operation_Lastchar
            [my String_Value Python] '[-1]';
        generate Operation_I
            'self.' [my Method Python] '(' (i Python_Args ',') ')';

        generate Statement_My_Equal
            'self.' [my Property Python] ' = ' [my Value Python];

        generate Statement_Ifdef
        {
            string Ifargs "";
            entity Argument;
            foreach [my Arguments] Argument
            {
                append Ifargs "if " [. Argument Python] ' is None:' [line]
                    [indent] 'raise ValueError' [line];
            }
            = Ifargs (i Py_Indent Ifargs);
            string Block (i Python_Statements);
            string Code "try:" [line] Ifargs Block;
            append Code "except ValueError, AttributeError:" [line, indent] "pass";
            i= Code;
        }
        generate Statement_New
            [my Variable Python] ' = ' [my Class Python] '(' (i Python_Args ', ') ')';
        generate Operation_Call
            [my Object Python] '.' [my Method Python] '(' (i Python_Args ', ') ')';
        generate Operation_Colon
            [my Class Python] '.' [my Method Python] '(' (i Python_Args ', ') ')';
        generate Operation_Classpropget
        {
            string Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Class_Name [my First Python];
                = Property_Name [my Second Python];
            }
            else
            {
                = Class_Name 'self.__class__';
                = Property_Name [my First Python];
            }
            string Code Class_Name '.' Property_Name;
            i= Code;
        }
        generate Operation_Contains
            [my Search Python] ' in ' [my String Python];
        generate Operation_Defined
            [my First Python] ' is not None';
        generate Operation_Dict_Get
            [my Dictionary Python] '[' [my Key Python] ']';
        generate Operation_Dict_Exists
            [my Key Python] ' in ' [my Dictionary Python] '.keys()';
        generate Operation_Is_A
            'isinstance(' [my Variable Python] ', ' [my Class_Name Python] ')';
        generate Operation_Is_Null
            '(' [my Op1 Python] ' in (None, ""))';
        generate Operation_List_Get
        {
            if (not (defined [my List Python]))
            {
                error (i Failure_Message 'List Python missing');
            }
            if (not (defined [my Offset Python]))
            {
                error (i Failure_Message 'Offset Python missing');
            }
            string Code [my List Python] '[' [my Offset Python] ']';
            i= Code;
        }
        generate Operation_List_Last
        {
            if (not (defined [my List Python]))
            {
                error (i Failure_Message 'List Python missing');
            }
            string Code [my List Python] '[-1]';
            i= Code;
        }
        generate Operation_List_Length
            'len(' [my First Python] ')';
        generate Operation_List_Pop
            [my First Python] '.pop()';
        generate Operation_List_Shift
            [my First Python] '.pop(0)';
        generate Operation_Split
            [my String Python] '.split(' [my Delimiter Python] ')';
        generate Operation_Lowercase
            [my First Python] '.lower()';
        generate Operation_Is_Lowercase
            [my First Python] '.islower()';
        generate Operation_Is_Alpha
            [my First Python] '.isalpha()';
        generate Operation_New
            [my Class_Name Python] '(' (i Python_Args ', ') ')';
        generate Operation_Not_Null
            [my Op1 Python] ' > ""';
        generate Operation_Round
            'round(' [my Number Python] ', ' [my Decimals Python] ')';
        generate Operation_Length
            'len(' [my First Python] ')';
        generate Operation_Substring
        {
            string SVal [my String_Value Python];
            string Start [my Start_Index Python];
            string Code;
            if (defined [my Length])
            {
                string Len [my Length Python];
                if (string.eq Len '1')
                {
                    = Code (append SVal '[' Start ']');
                }
                else
                {
                    = Code (append SVal '[' Start ':(' Start ')+(' Len ')]');
                }
            }
            else
            {
                = Code (append SVal '[' Start ':]');
            }
            i= Code;
        }
        generate Operation_Time_String
            'datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")';
        generate Operation_Uppercase
            [my First Python] '.upper()';
        generate Operation_Is_Uppercase
            [my First Python] '.isupper()';
        generate Operation_We
            'cls.' [my Method Python] '(' (i Python_Args ', ') ')';
        generate Operation_Whitespace
            First '.isspace()';
        generate Syntax_Is
            '(' [my Superclass Python] ')';
        generate Syntax_Property
            (i Python_Arguments '.');
        generate Syntax_Colon
            (i Python_Arguments '.');
        generate Operation_Classpropget
            (i Python_Arguments '.');
        generate Syntax_Key
            [my Dictionary Python] '[' [my Key Python] ']';
        generate Syntax_Node
            [my List Python] '[' [my Node Python] ']';
        generate Syntax_Line
        {
            string Code "'\n'";
            if (defined [my Count])
            {
                append Code '*' [my Count Python];
            }
            i= Code;
        }
        generate Syntax_Tab
        {
            string Code "'\t'";
            if (defined [my Count])
            {
                append Code '*' [my Count Python];
            }
            i= Code;
        }
        generate Syntax_Indent
        {
            string Code '"    "';
            if (defined [my Count])
            {
                append Code '*' [my Count Python];
            }
            i= Code;
        }
        generate Syntax_Class
        {
            string Object 'self.__class__';
            entity Context (i Method_Context);
            if (and Context (isa Context Class_Method_Statement))
            {
                = Object 'cls';
            }
            if (defined [my Expression])
            {
                = Object (append [my Expression Python] '.__class__');
            }
            string Code Object;
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Code '.' [. Argument Python];
            }
            i= Code;
        }
        generate Syntax_My_Class
            'self.__class__';
        generate Syntax_My
            'self.' (i Python_Arguments '.');
        generate Syntax_Class_Name
        {
            string Object_Code 'self';
            if (defined [my Object])
            {
                = Object_Code [my Object Python];
            }
            string Code Object_Code '.__name__';
            i= Code;
        }
        generate Syntax_Class_Property
        {
            string Class_Name [my First Python];
            string Code Class_Name;
            string Property_Name;
            if (defined [my Second])
            {
                = Property_Name [my Second Python];
                append Code '.' Property_Name;
            }
            i= Code;
        }
        generate Syntax_True
            'True';
        generate Syntax_False
            'False';
        generate Syntax_Null
            'None';
        generate Syntax_Infinity
            "float('inf')";
        generate Syntax_Negative_Infinity
            "-float('inf')";
        generate Declaration_Statement
        {
            if (not (defined [my Variable Python]))
            {
                error (i Failure_Message 'Variable Python is undefined');
            }
            string Variable_Python [my Variable Python];
            string Value_Python 'None';
            if (defined [my Value])
            {
                if (not (defined [my Value Python]))
                {
                    error (i Failure_Message 'Value Python is undefined');
                }
                = Value_Python [my Value Python];
            }
            string Code Variable_Python ' = ' Value_Python;
            i= Code;
        }
        generate Statement_Readline
            Variable ' = input()';
        generate Operation_Random_Integer
            'random.randrange(' Values ')';
        generate Operation_Random_Percent
            'random.random()';
        generate Argument_Syntax
        {
            string Code [my Variable Python];
            if (defined [my Default_Value])
            {
                append Code '=' [my Default_Value Python];
            }
            i= Code;
        }
        generate Unary_Operation
        {
            string Code (i Python_Unary);
            i= Code;
        }
        generate Binary_Operation
        {
            string Code (i Python_Repeating);
            i= Code;
        }
        generate Repeating_Operation
        {
            string Code (i Python_Repeating);
            i= Code;
        }
        generate Statement_For_Range
        {
            string Variable [my Variable Python];
            string Start [my Start Python];
            string End [my End Python];
            string Increment '';
            if (defined [my Increment])
            {
                append Increment ', ' [my Increment Python];
            }
            string Code 'for ' Variable ' in range(' Start ',(' End ')+1' Increment ')' (i Python_Block);
            i= Code;
        }
        generate Statement_Module
        {
            string Preamble `#!/usr/bin/python

# module ` [my Name Python] `

import os
import sys
from Runtime import Runtime

#INPUT = []
#OUTPUT = ""

`;
            string Code Preamble;
            entity Statement;
            foreach [my Block Statements] Statement
            {
                append Code [. Statement Python, line];
            }
            i= Code;
        }
        generate Statement_Execute
            'exec(' Target ', globals())';
        generate Operation_String_Equal
            'str(' Op1 ') == str(' Op2 ')';
        generate Operation_String_Not_Equal
            'str(' Op1 ') != str(' Op2 ')';
        generate Operation_String_Less
            'str(' Op1 ') < str(' Op2 ')';
        generate Operation_String_Less_Equal
            'str(' Op1 ') <= str(' Op2 ')';
        generate Operation_String_Greater
            'str(' Op1 ') > str(' Op2 ')';
        generate Operation_String_Greater_Equal
            'str(' Op1 ') >= str(' Op2 ')';
        generate Operation_Flag
            'bool(' Op1 ')';
        generate Operation_Integer
            'int(' Op1 ')';
        generate Operation_Number
            'float(' Op1 ')';
        generate Operation_String
            'str(' Op1 ')';
        generate Syntax_Generator
            'Python_Generator';
        generate Operation_Power
            'pow(' Op1 ',' Op2 ')';
        generate Operation_Square_Root
            'math.sqrt(' Op1 ')';
        generate Operation_Subtract
        {
            if (defined [my Op2])
            {
                i= (i Python_Arguments '-');
            }
            else
            {
                i= (append '-(' [my Op1 Python] ')');
            }
        }
        generate Statement_Dictionary_Assign
            Dict '[' Key '] = ' Value;
        generate Syntax_Object
            Variable;
        generate Syntax_Self
            'self';
        generate Operation_Round
        {
            string Number [my Number Python];
            string Code 'round(' Number;
            if (defined [my Decimals])
            {
                append Code ', ' [my Decimals Python];
            }
            append Code ')';
            i= Code;
        }
        generate Syntax_List
            Variable;
        generate Syntax_Dictionary
            Variable;
        generate Operation_Evaluate
        {
            string Code 'eval(' [my Target Python] ')';
            i= Code;
        }
        generate Operation_Enquote
            'Runtime.Enquote(' Op1 ')';
        generate Operation_Int2char
        {
            string Integer [my Integer Python];
            string Code 'chr(' Integer ')';
            i= Code;
        }
        generate Operation_Char2int
            'ord(' Character ')';
        generate Operation_Is_Digit
            Character ' in string.digits';
        generate Operation_Is_Punct
            Character ' in string.punctuation';
        generate Statement_File_Append
            '_FH = open(' [my File_Name Python] ', "a")' [line]
            '_FH.write(' [my File_Text Python] ')' [line]
            '_FH.close()';
        generate Operation_Files
            'os.listdir(' Filespec ')';
        generate Statement_Rename
            'os.rename(' From ', ' To ')';
        generate Statement_File_Delete
            'os.remove(' File_Name ')';
        generate Statement_Target_Includes
`import os
import datetime
import re
import sys
import os.path
import uuid
import random
import zdebug
`;
        generate Statement_Distribute
        {
            string List [my List Python];
            string Function [my Function Python];
            string Code
                'mp.Pool(mp.cpu_count()).map(' Function ', ' List ')';
            i= Code;
        }
        generate Operation_Distribute
        {
            string List [my List Python];
            string Function [my Function Python];
            string Code
                'mp.Pool(mp.cpu_count()).map(' Function ', ' List ')';
            i= Code;
        }
        generate Statement_Dispatcher
        {
            string Name [my Name Python];
            string Method [my Method Python];
            string Code Name ' = getattr(self, ' Method ')';
            i= Code;
        }
        generate Operation_Dispatch
            Name '(' (i Python_Args ', ') ')';
        generate Statement_Dispatchers
        {
            string Name [my Name Python];
            string Args '';
            string Between '';
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Args Between "'" [. Argument Python] "'";
                = Between ', ';
            }
            string Code Name ' = [' Args ']';
            i= Code;
        }
        generate Statement_We
            'cls.' Method '(' (i Python_Args ', ') ')';
        generate Statement_Iterate
            'for ' Key_Variable ', ' Value_Variable ' in ' Dictionary '.items()' (i Python_Block);
        generate Operation_Is_Ident
            '(' Character ' in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789")';
        generate Operation_Is_Whitespace
            '(' Character ' in " \n\r\t")';
        generate Syntax_Our
        {
            string Code 'cls';
            if (defined [my Class_Property])
            {
                append Code '.' (i Python_Arguments '.');
            }
            i= Code;
        }
        generate Statement_Class_Property
        {
            string Name_Code [my Name Python];
            string Value_Code 'None';
            string DT (list.last [my Gs_Keywords]);
            = DT (append ' ' DT ' ');
            if (contains ' dict dictionary hash ' DT)
            {
                = Value_Code '{}';
            }
            else.if (contains ' list array ' DT)
            {
                = Value_Code '[]';
            }
            comment writeline "property before defined";
            if (defined [my Value])
            {
                = Value_Code [my Value Python];
            }
            comment writeline "property after defined";
            string Code Name_Code ' = ' Value_Code;
            comment writeline "Property Code " Code;
            i= Code;
        }
        generate Syntax_Null 'None';
        generate Syntax_New_List
            '[' (i Python_Arguments ', ') ']';
        generate Operation_Is_String
            'isinstance(' Value ', str)';
        generate Operation_Is_Number
            'isinstance(' Value ', (int, float, complex))';
        generate Statement_Prompt_Context
            'global INPUT' [line]
            'global OUTPUT';
        generate Operation_Shift
            First '.pop(0)';
        generate Statement_Implement
        {
            string Assigns '';
            string Tests '';
            string Between '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                string Argpy [. Argument Python];
                string Qarg (. Argument Py_Enquote);
                append Assigns Between Qarg ':' Argpy;
                = Between ', ';
                append Tests [line] Argpy ' = loc[' Qarg ']';
            }
            string Code
                'exec(Implementer, {}, {' Assigns '})'
                Tests;
            i= Code;
        }
        generate Operation_Absolute
            'abs(' Op1 ')';
        generate Operation_Implement
        {
            string Assigns '';
            string Between '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                string Argpy [. Argument Python];
                string Qarg (. Argument Py_Enquote);
                append Assigns Between Qarg ':' Argpy;
                = Between ', ';
            }
            string Code
                'eval(Implementer, {}, {' Assigns '})';
            i= Code;
        }
        generate Statement_List_Clear
            List '.clear()';
        generate Statement_Nsl_Module
        {
            string Preamble '#!/usr/bin/python' [line]
                '# nsl module ' [my Name Python] [line]
                'import zdebug' [line]
                'import bisect' [line]
                'from gsruntime import *' [line, line]
                'INPUT = []' [line]
                'OUTPUT = ""' [line, line];
            string Code Preamble;
            entity Statement;
            foreach [my Block Statements] Statement
            {
                append Code [. Statement Python, line];
            }
            i= Code;
        }
        generate Statement_Collates
        {
            string Property_Name [my Property_Name Python];
            string Code
                'def __lt__(self, other):' [line, indent]
                    'return self.' Property_Name ' < other.' Property_Name [line]
                'def __gt__(self, other):' [line, indent]
                    'return self.' Property_Name ' > other.' Property_Name ;
            i= Code;
        }
        generate Statement_List_Property_Insert
        {
            string List [my List Python];
            string Property_Name [my Property_Name Python];
            string Inserted_Value [my Inserted_Value Python];
            string Code List ' += [' Inserted_Value ']';
            i= Code;
        }
        generate Statement_Function
            'def ' Name '(' (i Python_Args ",") ')' (i Python_Block);
        generate Operation_Titlecase
            String '.title()';
        generate Operation_String
            'str(' Op1 ')';
        generate Statement_List_Insert
            Variable '.insert(' Index ', ' Value ')';
        generate Statement_List_Assign
            Variable '[' Index '] = ' Value;
        generate Statement_Function_Invoke
            Function '(' (i Python_Args ', ') ')';
        generate Statement_Import
            'sys.modules["' Alias '"] = importlib.import_module(' Name ')' [line]
            'import ' Alias;
        generate Operation_Module_Class_Name_New
            'getattr(sys.modules["' Module '"], ' Name ')()';
        generate Operation_File_Exists
            'Runtime.File_Exists(' Path ')';
        generate Syntax_Class
            '(' Object '.__class__)';
        generate Syntax_Module_Class
            'eval("sys.modules[' Module_Expression ']." + ' Class_Name ")";
        generate Operation_Last_Char
            First '[-1]';
        generate Statement_Shell
        {
            string Args
                (i Python_Arguments ' + ');
            string Pyargs
                '(' Args ').split()';
            string Code
                'import subprocess; '
                '_shell = subprocess.run(' Pyargs ')';
            i= Code;
        }
        generate Statement_Subtract
            Variable ' -= ' (i Python_Args ' - ');
        generate Statement_Multiply
            Variable ' *= ' (i Python_Args ' * ');
        generate Statement_Divide
            Variable ' /= ' (i Python_Args ' / ');
        generate Operation_Environment
            'os.environ[' Variable ']';
        generate Statement_Cd
            'os.chdir(' Directory ')';
        generate Operation_Get
        {
            string Root [my Root Python];
            string Code Root;
            object Arg;
            foreach [my Listargs] Arg
            {
                debug;
                todo "figure out how this works in python";
            }
            i= Code;
        }
        generate Token_Name
        {
            string Input [my Input];
            if (contains Input '$')
            {
                replace Input '$' '';
            }
            i= Input;
        }
    }
}

flowerbox 'Html.gal';

goal.spell Html 'Hypertext Markup Language'
{
    class.append Element
    {
        property string Html_Text;
        method string Js_Enquote [string Text]
        {
            if (contains Text [line])
            {
                replace Text [line] '\n';
            }
            returnif (not (contains Text "'")) (append "'" Text "'");
            returnif (not (contains Text '"')) (append '"' Text '"');
            returnif (not (contains Text "`")) (append "`" Text "`");
            if (not (contains Text "\'"))
            {
                replace Text "'" "\'";
                return (append "'" Text "'");
            }
            if (not (contains Text '\"'))
            {
                replace Text '"' '\"';
                return (append '"' Text '"');
            }
            if (not (contains Text '\`'))
            {
                replace Text '`' '\`';
                return (append '`' Text '`');
            }
            debug;
            comment replace Text '"' '\x22';
            comment replace Text "'" '\x72';
            comment replace Text '`' '\x60';
            return (append "'" Text "'");
        }
        method string Html_Enquote [string Text]
        {
            if (contains Text '&')
            {
                replace Text '&' '&#38;';
            }
            if (contains Text '>')
            {
                replace Text '>' '&#62;';
            }
            if (contains Text '<')
            {
                replace Text '<' '&#60;';
            }
            if (contains Text '"')
            {
                replace Text '"' '&#34;';
            }
            if (contains Text "'")
            {
                replace Text "'" '&#39;';
            }
            if (contains Text "?")
            {
                replace Text "?" '&#63;';
            }
            if (contains Text "\")
            {
                replace Text "\" '&#92;';
            }
            return (append "'" Text "'");
        }
        method string Html_Url [entity Document]
        {
            string Text [. Document Html_Text] '.html';
            return Text;
        }
    }
    class.append Named_Element
    {
        method string Html_Arguments
        {
            string Code '';
            string Arg_Code;
            entity Arg;
            foreach [my Arguments] Arg
            {
                = Arg_Code [. Arg Html];
                if (begins Arg_Code ',')
                {
                    append Code Arg_Code;
                }
                else
                {
                    append Code ' ' Arg_Code;
                }
            }
            return Code;
        }
        method string Html_Arguments_Text
        {
            string Code '';
            string Between '';
            string Arg_Code;
            entity Arg;
            foreach [my Arguments] Arg
            {
                = Arg_Code [. Arg Html_Text];
                if (begins Arg_Code ',')
                {
                    append Code Arg_Code;
                }
                else
                {
                    append Code Between Arg_Code;
                }
                = Between ' ';
            }
            return Code;
        }
    }
    class.append Statement
    {
        property string Parent_Name '';
        method string Html_Block
        {
            string Code ';';
            if (defined [my Block])
            {
                = Code [my Block Html];
            }
            return Code;
        }
        method string Html_Block_Text
        {
            string Code '';
            if (defined [my Block])
            {
                = Code [my Block Html_Text];
            }
            return Code;
        }
    }

    class Html_Generator [is Generator]
    {
        infers Html;
        attribute list Elements;
        attribute list Inferences;
        property integer Entity_Number 0;
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            verbosity;
            verbose [class.name] ' Inits';
            infer.inits;
            return [true];
        }
    }
    inference string Html
    {
        generate Element
        {
            string Code (i Get_Input);
            my= Html_Text Code;
            i= Code;
        }
        generate Syntax_Token
        {
            string Code (i Get_Input);
            my= Html_Text '';
            i= Code;
        }
        generate Token_Quote
        {
            my= Html_Text (i Unquoted);
            i= (i Get_Input);
        }
        generate Block
        {
            entity Line;
            string Statements [line];
            string Text [line];
            foreach [my Statements] Line
            {
                append Statements [. Line Html] [line];
                append Text [. Line Html_Text] [line];
            }
            comment = Text (i Indent Text);
            my= Html_Text Text;
            comment string Code (i Indent Statements);
            string Code Statements;
            i= Code;
        }

        generate Html_Generator
        {
            verbosity;
            entity Elem;
            entity I;
            integer Number 0;
            variant Error;
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    = I [. Elem Classification];
                    . I Infer_Html;
                    .= Elem Html [. I Html];
                    increment Number;
                }
                catch Error
                {
                    my= Status [false];
                    .= Elem Error Error;
                    comment debug;
                    verbose 'Error html element ' Number
                        ': ' [classname I] 
                        ', <' Error '>'
                        ', source ' (. I Get_Input);
                }
            }
            returnif (not [my Status]);
            entity Top (list.last [my.attribute Elements]);
            
            string Preamble `<!DOCTYPE html>
<html><head><title>goalspell</title>
<style>
    .codebox 
    {
        display: block;
        unicode-bidi: embed;
        font-family: monospace;
        white-space: pre-wrap;
        border-width: 1px;
        border-style: solid;
    }
    .note
    {
        font-style: italic;
    }
    th
    {
        vertical-align: top;
    }

    .dropbtn 
    {
        background-color: purple;
        color: white;
        padding: 8px;
        border: none;
    }

    .dropdown 
    {
        position: relative;
        display: inline-block;
    }
    .dropdown a 
    {
        color: white;
        padding: 8px;
        text-decoration: none;
        display: block;
    }

    .dropdown-content 
    {
        display: none;
        position: absolute;
        background-color: pink;
        color: black;
        min-width: 160px;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
    }
    .dropdown:hover
    {
        color: black;
    }

    .dropdown-content a 
    {
        color: black;
        padding: 8px;
        text-decoration: none;
        display: block;
    }

    .dropdown-content a:hover 
    {
        background-color: #ddd;
        color: black;
    }
    .dropdown:hover .dropdown-content 
    {
        color: black;
        display: block;
    }
    .dropdown:hover .dropbtn 
    {
        color: black;
        background-color: violet;
    }

    h1 
    {
        font-size: 60px;
    }

    h2 
    {
        font-size: 30px;
        color: purple;
        font-family: helvetica;
    }

    h3
    {
        padding-top: 30px;
    }

</style>
<script>
    function code_box(Name, Text)
    {
        //debugger;
        //console.log('codebox', Name, Text);
        var Element = document.getElementById(Name);
        Element.innerText = Text;
    }
</script></head><body>
`;

            string Body [. Top Html];
            string Code Preamble Body `
</body></html>`;
            i= Code;
            my= Code Code;
        }

        generate Statements
        {
            comment debug;
            string Code '';
            entity Statement;
            foreach [my Elements] Statement
            {
                append Code [. Statement Html] [line];
            }
            i= Code;
        }

        generate Statement_Title
        {
            string Code '<h1>' (i Html_Arguments_Text) (i Html_Block_Text) '</h1>';
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Subtitle
        {
            string Code '<h3>' (i Html_Arguments_Text) (i Html_Block_Text) '</h3>';
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Author
        {
            string Code '<h4>by ' (i Html_Arguments_Text) (i Html_Block_Text) '</h4>';
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Chapter
        {
            string Code '<h2>' (i Html_Arguments_Text) '</h2>' (i Html_Block_Text);
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Paragraph
        {
            string Code '<p>' (i Html_Arguments_Text) [line] (i Html_Block_Text) '</p>';
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Section
        {
            string Code '<h3>' (i Html_Arguments_Text) '</h3>' (i Html_Block_Text);
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Diagram
        {
            string File [my File_Name Html_Text];
            string Height [my Height Html_Text];
            string Width [my Width Html_Text];
            string Code `<img src=` File ` height=` Height ` width=` Width `>`;
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Codebox
        {
            string Name [my Name Html_Text];
            string Block [my Block Html];
            string Starting_Code '';
            if (gt (list.length [my Block Statements]) 0)
            {
                entity First (list.get [my Block Statements] 0);
                = Starting_Code [. First Html_Text];
            }
            string Code 
                `<div>`
                Block 
                `<div class="codebox" id="` Name '">' Starting_Code '</div>'
                '</div>';
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Pane
        {
            string Inner_Text '';
            entity Arg;
            foreach [my Listargs] Arg
            {
                append Inner_Text [. Arg Html_Text];
            }
            comment = Inner_Text (i Js_Enquote Inner_Text);
            string Inner_Quoted (i Js_Enquote Inner_Text);
            string Parent_Name (i Js_Enquote [my Parent_Name]);
            string Handler 'code_box(' Parent_Name ',' Inner_Quoted ');';
            comment = Handler (i Js_Enquote Handler);
            increment [: Html_Generator Entity_Number];
            string Button_Name 'Button_' [: Html_Generator Entity_Number];
            string Code `<button id=` (i Html_Enquote Button_Name) `>` [my Selection Html_Text] '</button>';
            append Code '<script>document.getElementById(' (i Js_Enquote Button_Name) ').addEventListener("click", function() { ' Handler ' });</script>';
            my= Html_Text Inner_Text;
            i= Code;
        }
        generate Statement_Term
        {
            string Word [my Word Html_Text];
            string Definition [my Definition Html_Text];
            string Code '<tr><th>' Word '</th><td>' Definition '</td></tr>';
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Terminology
        {
            string Code '<table>' (i Html_Block_Text) '</table>';
            my= Html_Text Code;
            i= Code;
        }

        generate Statement_Note 
        {
            string Code '<div class="note">' (i Html_Arguments_Text) '</div>';
            my= Html_Text Code;
            i= Code;
        }

        generate Statement_Numbered_List
        {
            string Code '<ol>' (i Html_Arguments_Text) (i Html_Block_Text) '</ol>';
            my= Html_Text Code;
            i= Code;
        }

        generate Statement_List_Item
        {
            string Items (i Html_Arguments_Text) (i Html_Block_Text);
            string Code '<li>' Items '</li>';
            my= Html_Text Code;
            i= Code;
        }

        generate Statement_Menu_Bar
        {
            comment debug;
            string Code [line]
                '<!-- Menu Bar: ' [my Title Html_Text] '-->' [line]
                 (i Html_Block_Text)
                '<!-- End of menu bar: ' [my Title Html_Text] '-->' [line];
            my= Html_Text Code;
            i= Code;
        }

        generate Statement_Menu_Dropdown
        {
            string Block_Code (i Html_Block_Text);
            string Menu_Text [my Title Html_Text];
            if (defined [my Document])
            {
                string Url (i Html_Url [my Document]);
                = Menu_Text (append '<a href="' Url '">' Menu_Text '</a>');
            }
            string Inner_Code
                '<div class="dropbtn">' Menu_Text '</div>' [line]
                '<div class="dropdown-content">' [line]
                (i Indent Block_Code)
                '</div>' [line];
            string Code 
                '<div class="dropdown">' [line, indent]
                (i Indent Inner_Code)
                '</div>' [line];
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Menu_Item
        {
            comment debug;
            string Title [my Title Html_Text];
            string Url '#';
            if (defined [my Url])
            {
                = Url (i Html_Url [my Url]);
            }
            else.if (defined [my Document])
            {
                = Url (i Html_Url [my Document]);
            }
            string Code 
                '<a href="' Url '">'
                Title
                '</a>' [line];
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Document_Reference
        {
            string Code '<!-- reference document ' [my Document Html_Text] ', ' [my Title Html_Text] ' -->';
            my= Html_Text Code;
            i= Code;
        }
        generate Statement_Article_Reference
        {
            string Name [my Name];
            string Title Name;
            replace Title '_' ' ';
            string Code '<p><a href="articles/' Name '.html">' Title '</a>';
            if (defined [my Description])
            {
                append Code ': ' [my Description Html_Text];
            }
            append Code '</p>';
            i= Code;
        }
        generate Statement_Article_Plan
        {
            string Name [my Name];
            string Title Name;
            replace Title '_' ' ';
            string Code '<p>' Title;
            if (defined [my Description])
            {
                append Code ': ' [my Description Html_Text];
            }
            append Code ' (future)</p>';
            i= Code;
        }
    }
}

class C
{
    class.property integer Variable_Number 0;
    class.property string Behavior '<<<UNKNOWN BEHAVIOR in C.gal>>>';
    class.property string Test '<<<UNKNOWN TEST in C.gal>>>';
    class.property string Map '<<<UNKNOWN MAP in C.gal>>>';
    class.property string Floor '<<<UNKNOWN Floor in C.gal>>>';
    class.property list Inits;
    class.method string Get_Variable
    {
        increment [: C Variable_Number];
        string Variable '_v' [: C Variable_Number];
        return Variable;
    }
}


class.append Element
{
    property string C;
    property integer C_Precedence 999;
    property string C_Declaration '';
    method string C_Type [string Type]
    {
        returnif (s= Type 'number') 'float';
        returnif (s= Type 'integer') 'int';
        returnif (s= Type 'time') 'int';
        returnif (s= Type 'flag') 'bool';
        returnif (s= Type 'outcome') 'float';
        returnif (s= Type 'certainty') 'float';
        return Type;
    }
    method string C_Format_Code [string Type]
    {
        returnif (s= Type 'number') '%0.5f';
        returnif (s= Type 'integer') '%d';
        returnif (s= Type 'time') '%d';
        returnif (s= Type 'flag') '%d';
        returnif (s= Type 'outcome') '%0.5f';
        returnif (s= Type 'certainty') '%0.5f';
        return '%s';
    }

    method string C_Copyright
    {
        string Text
            [line] `/*
******************************************
*   Copyright (c) 2024 by Erik Zoltan.   *
*   All rights reserved.                 *
******************************************
*/` [line];
        return Text;
    }
}
class.append Token_Quote
{
    method string C_Enquote [string Text]
    {
        if (contains Text '\')
        {
            replace Text '\' '\\';
        }
        if (contains Text '"')
        {
            replace Text '"' '\"';
        }
        if (contains Text [line])
        {
            replace Text [line] '\n';
        }
        if (contains Text (int2char 9))
        {
            replace Text (int2char 9) '\t';
        }
        if (contains Text (int2char 13))
        {
            replace Text (int2char 13) '\r';
        }
        return (append '"' Text '"');
    }
}

class.append Named_Element
{
    method string C_Arguments [string Separator]
    {
        entity Argument;
        string Args_C '';
        string Between '';
        foreach [my Arguments] Argument
        {
            if (not (defined [. Argument C]))
            {
                error 'Argument C not defined: ' (. Argument Get_Input);
            }
            string Arg_C [. Argument C];
            append Args_C Between Arg_C;
            = Between Separator;
        }
        return Args_C;
    }
    method string C_Args [string Separator]
    {
        entity Argument;
        string Args_C '';
        string Between '';
        foreach [my Listargs] Argument
        {
            if (not (defined [. Argument C]))
            {
                error 'Argument C not defined: ' (. Argument Get_Input);
            }
            string Arg_C [. Argument C];
            append Args_C Between Arg_C;
            = Between Separator;
        }
        return Args_C;
    }
    method string C_Repeating
    {
        string Operator ' ' [my C_Operator] ' ';
        integer Precedence [my C_Precedence];
        entity Argument;
        string Args_C '';
        string Between '';
        foreach [my Arguments] Argument
        {
            if (not (defined [. Argument C]))
            {
                error 'Argument C not defined: ' (. Argument Get_Input);
            }
            string Arg_C [. Argument C];
            if (ge Precedence [. Argument C_Precedence])
            {
                = Arg_C (append '(' Arg_C ')');
            }
            append Args_C Between Arg_C;
            = Between Operator;
        }
        return Args_C;
    }
    method string C_Unary
    {
        string Operator ' ' [my C_Operator] ' ';
        integer Precedence [my C_Precedence];
        entity Argument (list.get [my Arguments] 0);
        if (not (defined [. Argument C]))
        {
            error 'Argument C not defined: ' (. Argument Get_Input);
        }
        string Arg_C [. Argument C];
        if (ge Precedence [. Argument C_Precedence])
        {
            = Arg_C (append '(' Arg_C ')');
        }
        string Code Operator Arg_C;
        return Code;
    }
}

class.append Block
{
    property string C_Statements '';
    property string C_Lines '';
}
class.append Statement
{
    method string C_Block
    {
        returnif (defined [my Block]) [my Block C];
        return ' { }';
    }
    method string C_Statements
    {
        if (not (defined [my Block])) {
            return '';
        }
        return [my Block C_Statements];
    }
}

class.append Operation_Add
{
    property string C_Operator '+';
    property number C_Precedence 6;
}
class.append Operation_Subtract
{
    property string C_Operator '-';
    property number C_Precedence 6;
}
class.append Operation_Multiply
{
    property string C_Operator '*';
    property number C_Precedence 6;
}
class.append Operation_Modulo
{
    property string C_Operator '%';
    property number C_Precedence 6;
}
class.append Operation_Power
{
    property string C_Operator '**';
    property number C_Precedence 6;
}
class.append Operation_Divide
{
    property string C_Operator '/';
    property number C_Precedence 6;
    method flag Infer_C
    {
        string Op1 [my Op1 C];
        string Op2 [my Op2 C];
        string Code '(' Op2 ' == 0 ? 0 : ' Op1 ' / ' Op2 ')';
        my= C Code;
    }
}
class.append Operation_String_Append
{
    property string C_Operator '+';
    property number C_Precedence 6;
}
class.append Operation_Not
{
    property string C_Operator '!';
    property number C_Precedence 6;
}
class.append Operation_And
{
    property string C_Operator '&&';
    property number C_Precedence 6;
}
class.append Operation_Or
{
    property string C_Operator '||';
    property number C_Precedence 6;
}
class.append Operation_Less_Than
{
    property string C_Operator '<';
    property number C_Precedence 6;
}
class.append Operation_Greater_Than
{
    property string C_Operator '>';
    property number C_Precedence 6;
}
class.append Operation_Equal
{
    property string C_Operator '==';
    property number C_Precedence 6;
}
class.append Operation_Less_Equal
{
    property string C_Operator '<=';
    property number C_Precedence 6;
}
class.append Operation_Greater_Equal
{
    property string C_Operator '>=';
    property number C_Precedence 6;
}
class.append Operation_Not_Equal
{
    property string C_Operator '!=';
    property number C_Precedence 6;
}

class C_Generator [is Generator]
{
    infers C;
    attribute list Elements;
    attribute list Inferences;
    constructor [entity Owner]
    {
        my= Owner Owner;
    }
    method flag Initialize
    {
        verbosity;
        verbose [class.name] ' Inits';
        infer.inits;
        return [true];
    }
}

inference string C
{
    generate Token [my Input];

    generate Token_Quote
    {
        string U (i Unquoted);
        string Code (i C_Enquote U);
        i= Code;
    }

    generate Block
    {
        entity Line;
        string Statements '';
        foreach [my Statements] Line
        {
            append Statements [. Line C] [line];
        }
        my= C_Lines Statements;
        = Statements (i Indent Statements);
        string Code [line]
            '{' [line]
                Statements
            '}';
        i= Code;
        my= C_Statements Statements;
    }

    generate C_Generator
    {
        verbosity [true];
        i Compiled_Inheritance;
        entity Elem;
        entity I;
        integer Number 0;
        variant Error;
        foreach [my.attribute Elements] Elem
        {
            try
            {
                = I [. Elem Classification];
                . I Infer_C;
                .= Elem C [. I C];
                increment Number;
            }
            catch Error
            {
                my= Status [false];
                .= Elem Error Error;
                comment debug;
                verbose 'Error C element ' Number
                    ': ' [classname I]
                    ', <' Error '>'
                    ', source ' (. I Get_Input);
            }
        }
        returnif (not [my Status]);
        entity Top (list.last [my.attribute Elements]);
        comment debug;
        string Code [. Top C];
        i= Code;
        my= Code Code;
    }

    generate Statements
    {
        comment debug;
        string Code '';
        entity Statement;
        string Between '';
        foreach [my Elements] Statement
        {
            append Code Between [. Statement C];
            = Between [line];
        }
        i= Code;
    }

    generate Expressions
    {
        comment debug;
        string Code '';
        entity Expression;
        string Between '';
        foreach [my Elements] Expression
        {
            append Code Between [. Expression C];
            = Between ', ';
        }
        i= Code;
    }

    generate Statement_Add
        Variable ' += ' (i C_Args ' + ') ';';
    generate Statement_And
        Variable ' &= ' (i C_Args ' && ') ';';
    generate Statement_Append
        Variable ' += ' (i C_Args ' + ') ';';
    generate Statement_Assign
        Variable ' = ' Value ';';
    generate Statement_Break
        'break;';
    generate Statement_Break_If
        'if (' Condition ') { break; }';
            generate Statement_Continue
        'continue;';
    generate Statement_Comment
    {
        string Code [my Gal_Key_Suffix];
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Syntax_Line)
            {
                append Code [line];
            }
            else.if (isa Argument Syntax_Indent)
            {
                append Code [indent];
            }
            else.if (isa Argument Token_Quote)
            {
                append Code ' ' (. Argument Unquoted);
            }
            else
            {
                append Code ' ' [. Argument C];
            }
        }
        if (contains Code [line])
        {
            = Code (append '/*' [line] Code [line] '*/');
        }
        else
        {
            = Code (append '//' Code);
        }
        i= Code;
    }
    generate Statement_Todo
    {
        string Code [my Gal_Key_Suffix];
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Syntax_Line)
            {
                append Code [line];
            }
            else.if (isa Argument Syntax_Indent)
            {
                append Code [indent];
            }
            else.if (isa Argument Token_Quote)
            {
                append Code ' ' (. Argument Unquoted);
            }
            else
            {
                append Code ' ' [. Argument C];
            }
        }
        if (contains Code [line])
        {
            = Code (append '/* TODO:' [line] Code [line] '*/');
        }
        else
        {
            = Code (append '// TODO: ' Code);
        }
        i= Code;
    }
    generate Statement_Else
        'else' (i C_Block);
    generate Statement_Forever
        'while (true)' (i C_Block);
    generate Statement_Increment
        Op1 "++;";
    generate Statement_Decrement
        Op1 "--;";
    generate Statement_If
        'if (' [my Condition C] ')' (i C_Block);
    generate Statement_Else_If
        'else if (' [my Condition C] ')' (i C_Block);
    generate Statement_Return
    {
        string Value_C '';
        if (defined [my Value])
        {
            append Value_C ' ' [my Value C];
        }
        string Code 'return' Value_C ';';
        i= Code;
    }
    generate Statement_While
        'while (' [my Condition C] ')' (i C_Block);
    generate Syntax_Tail
    {
        error "Reduce to fallback before compiling into C.";
    }
    generate Statement_Tail
    {
        string Code '';
        entity Elem;
        entity Arg;
        foreach [my Elements] Elem
        {
            contif (isa Elem Token_Comma);
            append Code [. Elem C];
        }
        foreach [my Arguments] Arg
        {
            debug;
        }
        i= Code;
    }
    generate Syntax_Array
    {
        string Args '';
        string Between '';
        entity Arg;
        foreach [my Arguments] Arg
        {
            append Args Between [. Arg C];
            = Between ', ';
        }
        string Code '{ ' Args ' }';
        i= Code;
    }
    generate Syntax_Number
    {
        string Code 'float ' [my Variable C];
        if (defined [my Default_Value])
        {
            append Code '=' [my Default_Value C];
        }
        i= Code;
    }
    generate Syntax_Flag
    {
        string Code 'bool ' [my Variable C];
        if (defined [my Default_Value])
        {
            append Code '=' [my Default_Value C];
        }
        i= Code;
    }
    generate Syntax_Integer
    {
        string Code 'int ' [my Variable C];
        if (defined [my Default_Value])
        {
            append Code '=' [my Default_Value C];
        }
        i= Code;
    }
    generate Unary_Operation
    {
        string Code (i C_Unary);
        i= Code;
    }
    generate Binary_Operation
    {
        string Code (i C_Repeating);
        i= Code;
    }
    generate Repeating_Operation
    {
        string Code (i C_Repeating);
        i= Code;
    }

    generate Statement_Integer
    {
        string Code 'int ' [my Variable C];
        if (defined [my Value])
        {
            append Code ' = ' [my Value C];
        }
        append Code ';';
        i= Code;
    }
    generate Statement_Flag
    {
        string Code 'bool ' [my Variable C];
        if (defined [my Value])
        {
            append Code ' = ' [my Value C];
        }
        append Code ';';
        i= Code;
    }
    generate Statement_Number
    {
        string Code 'float ' [my Variable C];
        if (defined [my Value])
        {
            append Code ' = ' [my Value C];
        }
        append Code ';';
        i= Code;
    }
    generate Statement_Function
    {
        string Return (i C_Type [my Return_Type C]);
        string Name [my Name C];
        string Args (i C_Args ', ');
        string Block (i C_Block);
        string Code
            Return ' ' Name '(' Args ')'
            Block;
        i= Code;
    }
    generate Statement_Constant
        '#define ' (i C_Arguments ' ');
    generate Statement_Obj
    {
        entity Arg;
        string Arg_Code '';
        string Between '.';
        flag Odd [true];
        foreach [my Arguments] Arg
        {
            if (isa Arg Statement_Tail)
            {
                append Arg_Code ', .' [. Arg C];
            }
            else
            {
                append Arg_Code Between [. Arg C];
                = Odd (not Odd);
                if Odd
                {
                    = Between ', .';
                }
                else
                {
                    = Between ' = ';
                }
            }
        }
        string Code '{' Arg_Code '}';
        i= Code;
    }
    generate Statement_Array
    {
        string Type "float";
        string Name [my Name C];
        string Indexes '';
        string Index_Between '';
        string Inits '';
        string I '';
        string Inits_Between '';
        entity Arg;
        foreach [my Listargs] Arg
        {
            append Indexes Index_Between [. Arg C];
            = Index_Between '][';
        }
        string Code Type ' ' Name '[' Indexes ']';
        append Code ';';
        i= Code;
    }
    generate Statement_Array_Number
    {
        string Type 'float';
        string Name [my Name C];
        string Size [my Size C];
        string Inits '';
        string I '';
        string Inits_Between '';
        entity Arg;
        foreach [my Listargs] Arg
        {
            if (isa Arg Syntax_Array)
            {
                append I Inits_Between [. Arg C];
                append Inits Inits_Between [. Arg C];
                if (gt (length I) 80)
                {
                    append Inits [line];
                    = I "";
                }
                = Inits_Between ', ';
            }
            else.if (isa Arg Token)
            {
                append I Inits_Between [. Arg C];
                append Inits Inits_Between [. Arg C];
                if (gt (length I) 80)
                {
                    append Inits [line, indent];
                    = I "";
                }
                = Inits_Between ', ';
            }
            else
            {
                debug;
                todo 'what kind of argument got passed to statement_array, and how do we handle it?';
            }
        }
        string Code
            '#define top_' Name ' ' Size [line]
            Type ' ' Name '[top_' Name ']';
        if (notnull Inits)
        {
            append Code ' = {' [line, indent] '  ' Inits '}';
        }
        append Code ';';
        i= Code;
    }
    generate Statement_Array_Of
    {
        string Class [my Class C];
        string Name [my Name C];
        string Code (i C_Type Class) ' ' Name '[';
        if (gt (list.length [my Listargs]) 0)
        {
            append Code (i C_Args '][');
        }
        append Code ']';
        if (defined [my Block])
        {
            append Code ' = {';
            entity Stmt;
            string Between '';
            foreach [my Block Statements] Statement
            {
                append Code Between [line, indent] [. Statement C];
                = Between ',';
            }
            append Code [line] '}';
        }
        append Code ';';
        i= Code;
    }
    generate Syntax
    {
        comment "Syntax.Infer_C: Override at subclass";
        comment debug;
        say "Syntax: " [class.name [self]] ' ' (i Get_Input);
    }
    generate Statement_Prop_Obj
    {
        string Type (i C_Type [my Type C]);
        string Name [my Name C];
        debugif (defined [my Value]);
        string Code Type ' ' Name ';';
        i= Code;
    }
    generate Statement_Object
    {
        comment "The property names don't make much sense in C.";
        string Class [my Variable C];
        string Variable [my Value C];
        string Code Class ' ' Variable ';';
        i= Code;
    }
    generate Statement_Main
    {
        string Inits '';
        string Init;
        foreach [: C Inits] Init
        {
            append Inits Init [line];
        }
        if (notnull Inits)
        {
            = Inits (i Indent Inits);
        }
        string Code
            'int main(int argc, char *argv[])' [line] '{' [line]
            [indent] 'srand(time(NULL)); // random seed' [line]
            Inits
            (i C_Statements)
            '}';
        i= Code;
    }
    generate Operation_Call
    {
        string Object [my Object C];
        string Method [my Method C];
        string Arguments (i C_Args ', ');
        string Code '(' Object '->' Method ')(' Arguments ')';
        i= Code;
    }
    generate Statement_Call
    {
        string Object [my Object C];
        string Method [my Method C];
        string Arguments (i C_Args ', ');
        string Code '(' Object '->' Method ')(' Arguments ');';
        i= Code;
    }
    generate Statement_Foreach
    {
        string List [my List C];
        string Variable [my Variable C];
        string Loop_Var (: C Get_Variable);
        string Statements (i C_Statements);
        string Code
            'for (int ' Loop_Var '=0; ' Loop_Var ' < top_' List '; ' Loop_Var '++)' [line]
            '{' [line, indent]
                Variable ' = ' List '[' Loop_Var '];' [line]
                Statements
            '}';
        i= Code;
    }
    generate Statement_Function_Invoke
    {
        string Function [my Function C];
        string Arguments (i C_Args ', ');
        string Code Function '(' Arguments ');';
        i= Code;
    }
    generate Syntax_Is
        "";
    generate Syntax_Object
    {
        string Code "void *" [my Variable C];
        if (defined [my Default_Value])
        {
            append Code "=" [my Default_Value C];
        }
        i= Code;
    }
    generate Syntax_True
        "1";
    generate Syntax_False
        "0";
    generate Statement_Multiply
        Variable " *= "  (i C_Args ' * ') ';';
    generate Statement_Subtract
        Variable " -= "  (i C_Args ' - ') ';';
    generate Operation_List_Get
        List '[' Offset ']';
    generate Operation_Invoke
        Function '(' (i C_Args ', ') ')';
    generate Operation_List_Length
        'top_' First;
    generate Statement_For_Range
    {
        string Variable [my Variable C];
        string Start [my Start C];
        string End [my End C];
        string Increment Variable '++';
        if (defined [my Increment])
        {
            = Increment (append Variable '+=' [my Increment C]);
        }
        string Block (i C_Statements);
        string Code
            'for (' Variable '=' Start '; ' Variable '<=' End '; ' Increment ')'
            [line] '{' [line]
            Block
            '}';
        i= Code;
    }
    generate Statement_For_Down
    {
        string Variable [my Variable C];
        string Start [my Start C];
        string End [my End C];
        string Increment Variable '--';
        if (defined [my Decrement])
        {
            = Increment (append Variable '-=' [my Decrement C]);
        }
        string Block (i C_Statements);
        string Code
            'for (' Variable '=' Start '; ' Variable '>=' End '; ' Increment ')'
            [line] '{' [line]
            Block
            '}';
        i= Code;
    }
    generate Statement_Module
    {
        string Name [my Name C];
        string Includes `
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
`;

        comment debug;
        todo 'first get the declarations.';
        todo 'then get the executables.';

        string Code
            (i C_Copyright)
            Includes
            [my Block C_Lines];
        i= Code;
    }
    generate Syntax_Line '\n';
    generate Statement_Redirect
    {
        verbosity;
        string Return (i C_Type [my Return_Type C]);
        string Name [my Name C];
        string Args (i C_Args ', ');
        string Statements [my Block C_Statements];
        string Types '';
        string Call_Args '';
        object Arg;
        object Arg_Arg;
        strings A T;
        string Between '';
        foreach [my Listargs] Arg
        {
            = A [. Arg Gs_Keyword];
            = T (i C_Type A);
            append Types Between T;
            = Arg_Arg (list.get [. Arg Arguments] 0);
            append Call_Args Between [. Arg_Arg C];
            = Between ', ';
        }
        verbose "Redirect " Name " GSType " [my Return_Type C] " Ctype " Return;
        string Declaration Return ' (*' Name '_Implementer)(' Types ') = NULL;' [line];
        string Invocation '(*' Name '_Implementer)(' Call_Args ')';
        string Redirection
                'if (' Name '_Implementer != NULL && ' Name '_Implementer != ' Name ')' [line, indent]
                '{' [line, indent 2]
                    'return ' Invocation ';' [line, indent]
                '}' [line];
        if (sne Name [: C Behavior])
        {
            = Declaration '';
            = Redirection '';
        }

        string Code [line]
            Declaration
            Return ' ' Name '(' Args ')' [line]
            '{' [line]
                Redirection
                Statements
            '}';
        i= Code;
    }
    generate Statement_Return_If_Gs
    {
        verbosity [true];
        string Code '';
        string Arg1 [my Arg1 C];
        if (defined [my Arg2])
        {
            append Code 'if (' [my Arg2 C] ') return ' Arg1 ';';
        }
        else
        {
            append Code 'if (' Arg1 ') return;';
        }
        i= Code;
    }
    generate Statement_Implementers
    {
        verbosity;
        entity Arg;
        string Args '';
        string Names '';
        string Between;
        string Word;
        string Arglist '';
        string Rtype '';
        string Argc;
        foreach [my Gs_Keywords] Word
        {
            contif (contains ' implementers fptr ' (append ' ' Word ' '));
            = Word (i C_Type Word);
            if (isnull Rtype)
            {
                = Rtype Word;
            }
            else
            {
                append Arglist Between Word;
                = Between ', ';
            }
        }
        integer Arg_Count 0;
        = Between '';
        integer Count 0;
        foreach [my Arguments] Arg
        {
            = Argc [. Arg C];
            increment Arg_Count;
            append Args Between Argc;
            append Names Between '"' Argc '"';
            = Between ', ';
            increment Count;
            if (gt Count 8)
            {
                append Between [line, indent];
                = Count 0;
            }
        }
        string Code
            '#define top_Implementers ' Arg_Count [line]
            Rtype '(*Implementers[top_Implementers])(' Arglist ') = {' [line] Args '};' [line]
            'char *Implementer_Names[top_Implementers] = {' [line] Names '};' [line]
            ;
        verbose Code;
        i= Code;
    }
    generate Statement_Function_Pointer
    {
        verbosity [true];
        string Between '';
        string Word;
        string Arglist '';
        string Rtype '';
        foreach [my Gs_Keywords] Word
        {
            contif (contains ' implementers fptr ' (append ' ' Word ' '));
            = Word (i C_Type Word);
            if (isnull Rtype)
            {
                = Rtype Word;
            }
            else
            {
                append Arglist Between Word;
                = Between ', ';
            }
        }
        string Name [my Name C];
        string Code
            Rtype '(*' Name ')(' Arglist ') = NULL;';
        i= Code;
    }
    generate Syntax_Function_Pointer
    {
        verbosity [true];
        string Between '';
        string Word;
        string Arglist '';
        string Rtype '';
        foreach [my Gs_Keywords] Word
        {
            contif (contains ' implementers fptr ' (append ' ' Word ' '));
            = Word (i C_Type Word);
            if (isnull Rtype)
            {
                = Rtype Word;
            }
            else
            {
                append Arglist Between Word;
                = Between ', ';
            }
        }
        string Name [my Name C];
        string Code
            Rtype '(*' Name ')(' Arglist ')';
        i= Code;
    }
    generate Operation_Absolute
    {
        string Op1 [my Op1 C];
        string Code 'fabs(' Op1 ')';
        i= Code;
    }

    generate Statement_Implementer
    {
        string Function [my Function C];
        string Redirect [: C Behavior];
        string Code
            Redirect '_Implementer = Implementers[' Function '];' [line]
            'Implementer_Name = Implementer_Names[' Function '];' [line];
        i= Code;
    }

    generate Statement_Analyze
    {
        string Beh [my Behavior C];
        string Tst [my Test C];
        string Map [my Map C];
        = [: C Behavior] Beh;
        = [: C Test] Tst;
        = [: C Map] Map;
        string Code '// ANALYZE ' Map ' redirect ' Beh ' with ' Tst [line];
        i= Code;
    }

    generate Syntax_Behavior
    {
        string Code [: C Behavior];
        i= Code;
    }

    generate Operation_Test
    {
        string Test [: C Test];
        if (not (contains Test 'Test'))
        {
            = Test (append 'Test_' Test);
        }
        string Code Test '()';
        i= Code;
    }
    generate Statement_Write_Line
    {
        verbosity [true];
        string Format_String '';
        string Args '';
        entity Arg;
        foreach [my Arguments] Arg
        {
            if (isa Arg Token_Quote)
            {
                append Format_String (. Arg Unquoted);
            }
            else.if (isa Arg Syntax_Node)
            {
                append Format_String '%f';
                append Args ', ' [. Arg C];
            }
            else.if (isa Arg Syntax)
            {
                append Format_String '%s';
                append Args ', ' [. Arg C];
            }
            else
            {
                entity Context (i Method_Context);
                string Variable [. Arg C];
                string FT '%f';
                if (dict.exists [. Context Variables] Variable)
                {
                    string Type (dict.get [. Context Variables] Variable);
                    = FT (i C_Format_Code Type);
                }
                append Format_String FT;
                append Args ', ' Variable;
            }
        }
        string Code 'printf("' Format_String '\n"' Args ');';
        i= Code;
    }
    generate Statement_Bias
        '';
    generate Statement_Report_Outcome
    {
        string Result [my Result C];
        string Name [my Implementer C];
        string Fstring 'outcome %f %s ' [: C Behavior];
        string Vars '';
        entity Arg;
        integer Var (list.length [my Listargs]);
        list Names 'Zz' 'Yy' 'Xx' 'Ww' 'Vv' 'Uu';
        string N;
        foreach [my Listargs] Arg
        {
            add Var -1;
            append Fstring ' %f';
            = N (list.get Names Var);
            append Vars ', ' N;
        }
        string Code
            `printf("` Fstring `;\n", ` Result `, ` Name Vars `);` [line];
        i= Code;
    }

    generate Statement_Roster_Floor
    {
        string Floor [my Floor C];
        = [: C Floor] Floor;
        string Code
            '// roster floor ' Floor [line] ;
        i= Code;
    }
    generate Syntax_Roster_Floor
    {
        i= [: C Floor];
    }
    generate Statement_String
    {
        string Var [my Variable C];
        string Code "char* " Var ";";
        i= Code;
    }
    generate Statement_Include_Implementers
    {
        string Map [: C Map];
        replace Map '"' '';
        string Code '#include "Implementers_' Map '.c"';
        i= Code;
    }
    generate Operation_Contains
    {
        string String [my String C];
        string Search [my Search C];
        string Code 'strstr(' String ', ' Search ') != NULL';
        i= Code;
    }
    generate Operation_Ternary
    {
        string Condition [my Condition C];
        string If [my If C];
        string Else [my Else C];
        string Code Condition ' ? ' If ' : ' Else;
        i= Code;
    }

    generate Syntax_Node
    {
        string Code [my Root C];
        entity Arg;
        foreach [my Listargs] Arg
        {
            append Code '[' [. Arg C] ']';
        }
        i= Code;
    }
    generate Operation_Random_Percent
    {
        string Code "(rand()/(float)RAND_MAX)";
        i= Code;
    }
    generate Operation_Power
    {
        string Op1 [my Op1 C];
        string Op2 [my Op2 C];
        string Code "pow(" Op1 ", " Op2 ")";
        i= Code;
    }
    generate Syntax_Indent
    {
        string Text '    ';
        if (defined [my Count])
        {
            = Text '';
            string Count [my Count C];
            integer End (- (char2int Count) 48);
            integer This;
            for.range This 1 End
            {
                append Text '    ';
            }
        }
        string Code '"' Text '"';
        i= Code;
    }
    generate Statement_Write
    {
        verbosity [true];
        string Format_String '';
        string Args '';
        entity Arg;
        foreach [my Arguments] Arg
        {
            if (isa Arg Token_Quote)
            {
                append Format_String (. Arg Unquoted);
            }
            else.if (isa Arg Syntax_Node)
            {
                append Format_String '%f';
                append Args ', ' [. Arg C];
            }
            else.if (isa Arg Syntax)
            {
                append Format_String '%s';
                append Args ', ' [. Arg C];
            }
            else
            {
                entity Context (i Method_Context);
                string Variable [. Arg C];
                string FT '%f';
                if (dict.exists [. Context Variables] Variable)
                {
                    string Type (dict.get [. Context Variables] Variable);
                    = FT (i C_Format_Code Type);
                }
                append Format_String FT;
                append Args ', ' Variable;
            }
        }
        string Code 'printf("' Format_String '"' Args ');';
        i= Code;
    }

    generate Statement_Plist
    {
        verbosity;
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C];
        string Class [my Class C];
        string Name [my Name C];
        string Count [my Count C];
        string List Class_Name '_prop_' Name;
        string Top 'top_' List;
        verbose 'plist class ' Class ' name ' Name ' count ' Count ' class name ' Class_Name;
        string Code
            'int ' Top '[' Class_Name '_Capacity];' [line]
            'int ' List '[' Class_Name '_Capacity][' Count ']; // pointer to ' Class;
        string Declaration
            'memset(' Top ", '\0', sizeof(" Top '));' [line]
            'memset(' List ", '\0', sizeof(" List '));';
        push [: C Inits] Declaration;
        i= Code;
    }
    generate Statement_Pobj
    {
        string Object_Class [my Class C];
        string Name [my Name C];
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C];
        string Index '[' Object_Class '_Capacity]';
        string Prop_Name Class_Name '_prop_' Name;
        string Code
            'int ' Prop_Name Index '; // pointer to ' Object_Class;
        i= Code;
        if (defined [my Initializer])
        {
            string Declaration
                Prop_Name '[self] = ' [my Initializer C] ';';
            my= C_Declaration Declaration;
        }
        string Initializer
            'memset(' Prop_Name ", '\0', sizeof(" Prop_Name '));';
        push [: C Inits] Initializer;
    }
    generate Syntax_Property
    {
        verbosity;
        string Object [my Object C];
        string Property_Name [my Property_Name C];
        entity Class_Context (i Get_Class_Context);
        string Class_Name [. Class_Context Name C];

        entity Meth_Context (i Method_Context);
        if (dict.exists [. Meth_Context Variables] Object)
        {
            verbose 'NOT ' Class_Name;
            = Class_Name (dict.get [. Meth_Context Variables] Object);
        }
        verbose Object ' is a ' Class_Name;

        string Code Class_Name '_prop_' Property_Name '[' Object ']';
        object Arg;
        foreach [my Listargs] Arg
        {
            append Code '[' [. Arg C] ']';
        }
        i= Code;
    }
    generate Syntax_My
    {
        string Property_Name [my Property C];
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C];
        string Code Class_Name '_prop_' Property_Name '[self]';
        object Arg;
        foreach [my Listargs] Arg
        {
            append Code '[' [. Arg C] ']';
        }
        i= Code;
    }
    generate Statement_Object
    {
        string Code 'unsigned int ' [my Variable C];
        if (defined [my Value])
        {
            append Code ' = ' [my Value C];
        }
        append Code ';';
        i= Code;
    }
    generate Statement_My_Equal
    {
        string Property [my Property C];
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C];
        string Value [my Value C];
        string Code Class_Name '_prop_' Property '[self] = ' Value ';';
        i= Code;
    }
    generate Statement_Class
    {
        string Capacity '1';
        todo 'this still needs a rewrite';
        string Name [my Name C];
        debug;
        todo 'first get the declarations.';
        todo 'then get the executables.';
        string Block (i C_Statements);
        comment string Old_Code 'typedef ' Name [line] '{' [line] Block '} ' Name ';';
        entity Stmt;
        string Inits "unsigned int self = last_" Name '++;' [line];
        foreach [my Block Statements] Stmt
        {
            if (isa Stmt Statement_Property)
            {
                if (defined [. Stmt Value])
                {
                    append Inits [. Stmt C_Declaration] [line];
                }
            }
            else.if (isa Stmt Statement_Pobj)
            {
                if (defined [. Stmt Initializer])
                {
                    append Inits [. Stmt C_Declaration] [line];
                }
            }
        }
        append Inits
            'return self;' [line];
        string Constructor
            'unsigned int ' Name '_constructor()' [line]
            '{' [line]
                (i Indent Inits)
            '}' [line];
        string Code [line]
            '// class ' Name ' begins' [line]
            'int last_' Name ' = -1;' [line]
            '#ifndef ' Name '_Capacity' [line]
            '#define ' Name '_Capacity ' Capacity [line]
            '#endif' [line]
            Block
            Constructor
            '// class ' Name ' ends' [line]
            ;

        i= Code;
    }
    generate Statement_Method
    {
        string Type [my Type C];
        string Return (i C_Type Type);
        string Name [my Name C];
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C] '_meth_' Name;
        string Args '';
        entity Arg;
        foreach [my Listargs] Arg
        {
            append Args ', ' [. Arg C];
        }
        string Block (i C_Block);
        string Code
            Return ' ' Class_Name '(int self' Args ')'
            Block;
        i= Code;
    }
    generate Statement_Property
    {
        string Type (i C_Type [my Type C]);
        string Name [my Name C];
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C];
        string Index '[' Class_Name '_Capacity]';
        string Prop_Name Class_Name '_prop_' Name;
        if (defined [my Value])
        {
            string Declaration
                Class_Name '_prop_' Name '[self]' ' = ' [my Value C] ';';
            my= C_Declaration Declaration;
        }
        string Code Type ' ' Prop_Name Index ';';
        string Initializer
            'memset(' Prop_Name ", '\0', sizeof(" Prop_Name '));';
        push [: C Inits] Initializer;
        i= Code;
    }
    generate Statement_Bind
    {
        verbosity [true];
        string Class [my Class C];
        string Variable [my Variable C];
        string Code
            'int ' Variable;
        if (defined [my Value])
        {
            string Value [my Value C];
            append Code ' = ' Value;
        }
        append Code '; // bound to class ' Class;
        verbose ' ~ bind: ' Code;
        i= Code;
        verbose 'bind ' Variable ' to ' Class;
        entity Meth_Context (i Method_Context);
        dict.assign [. Meth_Context Variables] Variable Class;
    }

    generate Operation_New
    {
        string Class_Name [my Class_Name C];
        string Args (i C_Args ', ');
        string Code Class_Name '_constructor(' Args ')';
        i= Code;
    }

    generate Statement_Call
    {
        string Target [my Target C];
        string Method [my Method C];
        string Args (i C_Args ', ');
        if (sne Args '')
        {
            = Args (append ', ' Args);
        }
        entity Context (i Method_Context);
        string Type '<UNKNOWN TYPE>';
        if (dict.exists [. Context Variables] Target)
        {
            = Type (dict.get [. Context Variables] Target);
        }
        string Code Type '_meth_' Method '(' Target Args ');';
        i= Code;
    }

    generate Statement_List_Append
    {
        string List [my List C];
        string List_Top 'top_' List;
        string Code '// ' (i Get_Input);
        entity Arg;
        foreach [my Listargs] Arg
        {
            append Code [line]
                List '[' List_Top '] = ' [. Arg C] ';' [line]
                List_Top '++;';
        }
        i= Code;
    }

    generate Statement_Propset
    {
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C];
        string Object [my Object C];
        string Property [my Property C];
        string Value [my Value C];
        string Code Class_Name '_prop_' Property '[' Object '] = ' Value ';';
        i= Code;
    }
    generate Statement_Gpu_Function
    {
        todo 'the gpu function needs to accept array pointers as arguments';
        string Name [my Name C];
        string Args (i C_Args ', ');
        string Code
            '__global__ void ' Name '(' Args ')'
            (i C_Block);
        i= Code;
    }
    generate Statement_Gpu_Invoke
    {
        todo 'the gpu function needs to accept array pointers as arguments';
        string Name [my Name C];
        string Blocks [my Blocks C];
        string Threads [my Threads C];
        string Args (i C_Args ', ');
        string Code
            Name '<<<' Blocks ', ' Threads '>>>(' Args ');';
        i= Code;
    }
    generate Statement_Gpu_Invoke_Method
    {
        todo 'the gpu method needs to accept property array pointers as arguments';
        string Name [my Name C];
        string Class_Name [my Class C];
        string Blocks [my Blocks C];
        string Threads [my Threads C];
        string Args (i C_Args ', ');
        string Code
            Class_Name '<<<' Blocks ', ' Threads '>>>(' Args ');';
        i= Code;
    }
    generate Statement_Gpu_Method
    {
        todo 'the gpu method needs to accept property array pointers as arguments';
        string Name [my Name C];
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C] '_gm_' Name;
        string Args (i C_Args ', ');
        string Statements (i C_Statements);
        string Code
            '__global__ void ' Class_Name '(' Args ')' [line]
            '{' [line]
            [indent] 'int self = blockIdx.x * blockDim.x + threadIdx.x;' [line]
            Statements
            '}';
        i= Code;
    }
    generate Statement_Gpu_Property
    {
        todo 'the gpu property requires cuda malloc and cuda free and cuda memcpy';
        string Type (i C_Type [my Type C]);
        string Name [my Name C];
        entity Context (i Get_Class_Context);
        string Class_Name [. Context Name C];
        string Index '[' Class_Name '_Capacity]';
        string Initializer '';
        if (defined [my Value])
        {
            string Declaration
                Class_Name '_prop_' Name '[self]' ' = ' [my Value C] ';';
            push [: C Inits] Declaration;
        }
        string Code Type ' ' Class_Name '_prop_' Name Index ';';
        i= Code;
    }
}
flowerbox 'Fallback.gal';

    class.append Element
    {
        property string Fallback_Declaration '';
        method string Line_String [string Input_String]
        {
            todo `resolve line breaks here.`;
            string Return_String (i Enquote Input_String);
            return Return_String;
        }
    }

    class Fallback_Generator [is Generator]
    {
        class.property integer Example_Number 0;
        infers Fallback;
        comment infers Parse;
        comment infers Generate;
        infers Fallback;
        attribute list Elements;
        attribute list Inferences;
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            verbosity;
            verbose [class.name] ' Inits';
            infer.inits;
            return [true];
        }
        classmethod string Next_Example
        {
            increment [: Fallback_Generator Example_Number];
            string Name "Example" [: Fallback_Generator Example_Number];
            return Name;
        }
    }

    class.append Named_Element
    {
        method string Fallback_Arguments
        {
            string Code '';
            string Arg_Code;
            entity Arg;
            foreach [my Arguments] Arg
            {
				if (isa Arg Token_Comma)
				{
					continue;
				}
                = Arg_Code [. Arg Fallback];
				append Code ' ' Arg_Code;
            }
            return Code;
        }
        method string Fallback_Args
        {
            string Code '';
            string Arg_Code;
            entity Arg;
            foreach [my Listargs] Arg
            {
                = Arg_Code [. Arg Fallback];
                if (begins Arg_Code ',')
                {
                    append Code Arg_Code;
                }
                else
                {
                    append Code ' ' Arg_Code;
                }
            }
            return Code;
        }
        method string Fallback_Tails
        {
            string Code '';
            entity Tail;
            foreach [my Tails] Tail
            {
                debug;
                append Code (. Tail Fallback_Tail);
            }
            return Code;
        }
    }

    class.append Statement
    {
        method string Fallback_Block
        {
            string Code ';';
            if (defined [my Block])
            {
                = Code [my Block Fallback];
            }
            return Code;
        }
        method string Fallback_Statements
        {
            string Return '';
            if (defined [my Block])
            {
                if (defined [my Block Fallback_Statements])
                {
                    = Return [my Block Fallback_Statements];
                }
            }
            return Return;
        }
    }

    inference string Fallback
    {
        generate Element
        {
            string Code [my Gs];
            i= Code;
            my= Reference Code;
        }
        generate Token_Quote
        {
            string U (i Unquoted);
            string Q (i Enquote U);
            i= Q;
        }

        generate Statement
        {
            string Keywords [my Gs_Keyword];
            string Name (title.case Keywords);
            replace Name ' ' '_';
            = Keywords (i Enquote Keywords);
            string Declaration
                'statement ' Name ' ' Keywords ';' [line]
                'symbol ' Name ';' [line]
                'spell ' Name ';' [line]
                ;
            if (not (or (contains Keywords '~') (contains Keyword 'tilda')))
            {
                append Declaration
                    '~ ' Keywords ';' [line];
            }
            comment `my= Fallback_Declaration Declaration;`;

            string Code  (i Gs_Key) (i Fallback_Arguments) (i Fallback_Block);
            i= Code;
        }
        generate Operation
        {
            comment 'This is necessary, to ensure that most statements use the fallback of their elements.';
            string Code '(' (i Gs_Key) (i Fallback_Arguments) ')';
            i= Code;
        }

        generate Syntax
        {
            comment 'This is necessary, to ensure that most syntaxes use the fallback of their elements.';
            string Code '[' (i Gs_Key) (i Fallback_Arguments) ']';
            i= Code;
        }

        generate Syntax_Tail
        {
            comment 'This is necessary, to ensure that most syntaxes use the fallback of their elements.';
            string Code '[' (i Gs_Key) (i Fallback_Arguments) ']';
            i= Code;
        }


        generate Fallback_Generator
        {
            verbosity;
            my= Status [true];
            entity Elem;
            entity I;
            variant Error;
            flag Status [true];
            string EF;
            foreach [my.attribute Elements] Elem
            {
                forgive
                {
                    = I [. Elem Classification];
                    . I Infer_Gs;
                    .= Elem Gs [. I Gs];
                    . I Infer_Fallback;
                }
            }
            integer Number 0;
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    = I [. Elem Classification];
                    verbose 'fallback generating ' [classname I];
                    . I Infer_Gs;
                    .= Elem Gs [. I Gs];
                    & Status (. I Infer_Fallback);
                    .= Elem Error [. I Error];
                    .= Elem Fallback [. I Fallback];
                    increment Number;
                    verbose Number ' ' [class.name I] ': ' [. Elem Fallback] [line];
                }
                catch Error
                {
                    = Status [false];
                    .= I Error Error;
                    .= Elem Error Error;
                    string Error_Message Error;
                    string EF 'error ' (. Elem Enquote Error_Message) ';';
                    .= I Fallback EF;
                    .= Elem Fallback EF;
                    verbose 'Error fallback element ' Number
                        ': ' [classname I]
                        ', <' Error '>'
                        ', source ' (. I Get_Input);
                }
            }
            my= Status Status;
            returnif (not Status) Status;
            entity Top (list.last [my.attribute Elements]);
            string Code [. Top Fallback];
            i= Code;
            my= Code Code;
            return [my Status];
        }

        generate Block
        {
            string Lines '';
            entity Statement;
            foreach [my Statements] Statement
            {
                append Lines [. Statement Fallback] [line];            integer Number 0;

            }
            if (s= Lines '')
            {
                i= ';';
                my= Fallback_Statements '';
            }
            else
            {
                my= Fallback_Statements (i Indent Lines);
                string Code [line] '{' [line] [my Fallback_Statements] '}';
                i= Code;
            }
        }

        generate Statements
        {
            string Code '';
            entity Statement;
            string Between '';
            foreach [my Elements] Statement
            {
                s+ Code Between [. Statement Fallback];
                = Between [line];
            }
            i= Code;
        }

        generate Statement_Argument
        {
            string Argument_Name [my Argument_Name Fallback];
            string Code 'property object ' Argument_Name ';';
            string Declaration
                "if ((llength [my Listargs]) = 0)" [line]
                "{" [line, indent]
                    "error 'missing required argument " Argument_Name "';" [line]
                "}" [line]
                'my ' Argument_Name ' = (shift [my Listargs]);' [line];
            if (defined [my Type_Value])
            {
                append Declaration '[my ' Argument_Name ' Usage] = ' [my Type_Value Fallback] ';' [line];
            }
            my= Fallback_Declaration Declaration;
            i= Code;
        }

        generate Statement_Expect_String
        {
            string Expected [my Expected Fallback];
            string Actual [my Actual Fallback];
            string Name [my Name Fallback];
            string Code
                'increment Test_Count;' [line]
                'if (' Expected ' s= ' Actual ')' [line] '{' [line, indent]
                    'increment Test_Success;' [line] '}' [line]
                'else' [line] '{' [line, indent]
                    `verbose "` Name ` expected {" ` Expected ` "} s= actual {" ` Actual ` "}";` [line]
                '}';
            i= Code;
        }

        generate Statement_Feature
        {
            string Type [my Type Fallback];
            string Name [my Name Fallback];
            string Keyword [my Keyword Fallback];
			string Symbol_Class "Symbol";
			if (defined [my Symbol_Class])
			{
				= Symbol_Class [my Symbol_Class Fallback];
			}
            string Declaration
                'symbol ' Type ' ' Name ' ' Symbol_Class
                    (i Fallback_Block) [line]
                'statement ' Name ' ' Keyword ' Feature' [line] '{' [line, indent]
                    'property string Property_Name ' (i Enquote Name) ';' [line, indent]
                    'argument Value;' [line]
                '}' [line];
            i= Declaration;
        }

        generate Statement_Thing
        {
            string Name [my Name Fallback];
            string Class_Name 'Thing_' Name;
            string Quote_Name (i Enquote Class_Name);
            string Keyword [my Keyword Fallback];
            string Class_Block '';
            string Statement_Block '';
            entity Statement;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    comment 'arguments to statement, all else to thing class.';
                    if (isa Statement Argument_Statement)
                    {
                        append Statement_Block [. Statement Fallback] [line];
                    }
                    else
                    {
                        append Class_Block [. Statement Fallback] [line];
                    }
                }
                if (sgt Statement_Block '')
                {
                    = Statement_Block (i Indent Statement_Block);
                }
                if (sgt Class_Block '')
                {
                    = Class_Block (i Indent Class_Block);
                }
            }
            string Code
                'class ' Class_Name ' [is Thing]' [line]
                '{' [line]
                    Class_Block
                '}'
                'statement ' Name " " Keyword " Thing" [line]
                '{' [line, indent]
                    'property string Thing_Type ' Quote_Name ';' [line]
                    Statement_Block
                '}';
            i= Code;
        }

        generate Statement_Require_That 'if (not ' (i Fallback_Arguments) ')' '{' 'return [false];' '}';

        generate Statement_Require_That_I 'if (not (i' (i Fallback_Arguments) '))' '{' 'return [false];' '}';

        generate Statement_Quit_Colon
        {
            string Condition [my Condition Fallback];
            string Return_Value "";
            if (defined [my Return_Value])
            {
                append Return_Value ' ' [my Return_Value Fallback];
            }
            string Code
                'if' Condition
                '{'
                    'return ' Return_Value ';'
                '}';
            i= Code;
        }

        generate Statement_Speaking
        {
            verbosity [true];
            debug;
            verbose 'speaking statement generation';
        }

        generate Statement_Parser
        {
            verbosity [true];
            string Declarations '';
            entity Statement;
            foreach [my Block Statements] Statement
            {
                if (defined [. Statement Fallback_Declaration])
                {
                    append Declarations [. Statement Fallback_Declaration];
                }
                if (isa Statement Statement_Infers)
                {
                    debug;
                    todo 'handle parser infers statement';
                }
                else.if (isa Statement Statement_Inferences)
                {
                    debug;
                    todo 'handle parser inferences statement';
                }
            }
            string Code
                'class ' [my Class_Name Fallback] '_Parser [is Parser]'
                (i Fallback_Args)
                (i Fallback_Block)
                Declarations;
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Statement_Sequence
        {
            verbosity;
            string Rule_Name [my Rule_Name Fallback];
            string Declarations '';
            flag First [false];
            string Block 'comment ' (i Enquote (i Get_Input)) ';' [line]
                'integer Start_Char [my Char_Pos];' [line]
                'integer Start_Token [my Token_Pos];' [line]
                'global list My_Elements;' [line];
            if Verbose
            {
                append Block 'verbosity [true];' [line];
                append Block 'verbose "Parsing sequence ' Rule_Name '.";' [line];
            }
            entity Argument;
            flag Excludes [false];
            foreach [my Listargs] Argument
            {
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                if (or (isa Argument Token_Quote) (isa Argument Syntax_Line))
                {
                    string Text [. Argument Fallback];
                    append Block
                        'if (not (i Parse_Token My_Elements ' Text ')) { iRollback Start_Char Start_Token (append "' [my Rule_Name Fallback] ' expected "' Text '"."); return [false]; }' [line];
                    if Verbose
                    {
                        append Block 'verbose [indent] "Sequence ' Rule_Name ' parsed literal: ' Text '";' [line];
                    }
                }
                else.if (isa Argument Token)
                {
                    string Name [. Argument Fallback];
                    append Block
                        'if (not (i Parse_' Name ' My_Elements)) { i Rollback Start_Char Start_Token "' [my Rule_Name Fallback] ' expected ' Name '."; return [false]; }' [line];
                    if Verbose
                    {
                        append Block 'verbose [indent] "Sequence ' Rule_Name ' parsed token ' Name '";' [line];
                    }
                }
                else.if (isa Argument Syntax_Exclude)
                {
                    = Excludes [true];
                    append Block [. Argument Fallback] [line];
                    if Verbose
                    {
                        append Block 'verbose [indent] "Sequence ' Rule_Name ' parsed exclude: ' [. Argument Rule_Name Input] '";' [line];
                    }
                }
                else
                {
                    append Block [. Argument Fallback] [line];
                    if Verbose
                    {
                        append Block 'verbose [indent] "Sequence ' Rule_Name ' parsed rule: ' [. Argument Rule_Name Fallback] '";' [line];
                    }
                }
            }
            if Verbose
            {
                append Block 'verbose "Sequence ' Rule_Name ' success, start " Start_Char;' [line];
            }
            append Block
                'integer End [my Char_Pos];' [line]
                'object Element (new ' Rule_Name ');' [line]
                'object First_Child (lget [my Tokens] Start_Token);' [line]
                'Start_Char = [First_Child.Start_Position];' [line]
                '.= Element Start_Position Start_Char;' [line]
                '.= Element End_Position End;' [line]
                '.= Element Document [self];' [line]
                'copy [Element.Elements] = My_Elements;' [line]
                'i Add_Element Element;' [line]
                'push Parent_Elements Element;' [line]
                'return [true];' [line];
            if Excludes
            {
                = Block (append 'list Excluded;' [line] Block);
            }

            = Block (i Indent Block);
            string Code 'method flag Parse_' Rule_Name
                ' [list Parent_Elements]' [line]
                '{' [line]
                Block
                '}';
            my= Fallback_Declarations Declarations;
            i= Code;
        }

        generate Syntax_Sequence
        {
            string Declarations '';
            todo 'the fallback is a reference to the named rule created by this syntax.';
            todo 'the fallback declaration is the sequence function generated by this code.';
            string My_Source (i Get_Input);
            string Rule_Name [my Rule_Name Fallback];
            string Block 'comment ' (i Enquote (i Get_Input)) ';' [line]
                'integer Start_Char [my Char_Pos];' [line]
                'integer Start_Token [my Token_Pos];' [line]
                'global list My_Elements;' [line];
            entity Argument;
            flag Excludes [false];
            foreach [my Listargs] Argument
            {
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                if (or (isa Argument Token_Quote) (isa Argument Syntax_Line))
                {
                    string Text [. Argument Fallback];
                    append Block
                        'if (not (i Parse_Token My_Elements ' Text ')) { i Rollback Start_Char Start_Token (append "' [my Rule_Name Fallback] ' expected "' Text '"."); return [false]; }' [line];
                }
                else.if (isa Argument Token)
                {
                    string Name [. Argument Fallback];
                    append Block
                        'if (not (i Parse_' Name ' My_Elements)) { i Rollback Start_Char Start_Token "' [my Rule_Name Fallback] ' expected ' Name '."; return [false]; }' [line];
                }
                else.if (isa Argument Syntax_Exclude)
                {
                    = Excludes [true];
                    append Block [. Argument Fallback] [line];
                }
                else
                {
                    append Block [. Argument Fallback] [line];
                }
            }
            append Block
                'integer End [my Char_Pos];' [line]
                'object Element (new ' [my Rule_Name Fallback] ');' [line]
                'object First_Child (lget [my Tokens] Start_Token);' [line]
                'Start_Char = [First_Child.Start_Position];' [line]
                '.= Element Start_Position Start_Char;' [line]
                '.= Element End_Position End;' [line]
                '.= Element Document [self];' [line]
                'copy [Element.Elements] = My_Elements;' [line]
                'i Add_Element Element;' [line]
                'push Parent_Elements Element;' [line]
                'return [true];' [line];
            if Excludes
            {
                = Block (append 'list Excluded;' [line] Block);
            }

            = Block (i Indent Block);
            string Code
                Declarations
                'method flag Parse_' Rule_Name
                ' [list Parent_Elements]' [line]
                '{' [line]
                Block
                '}';
            my= Fallback_Declaration Code;
            i= Rule_Name;
        }

        generate Statement_Either
        {
            verbosity;
            string Rule_Name [my Rule_Name Fallback];
            string Declarations '';
            string Quoted_Input (i Enquote (i Get_Input));
            string Block 'comment ' Quoted_Input ';' [line];
            if Verbose
            {
                append Block 'verbosity [true];' [line]
                    'verbose "Parse " ' Quoted_Input ';' [line];
            }
            entity Argument;
            foreach [my Listargs] Argument
            {
                if Verbose
                {
                    append Block
                        'verbose [indent] '
                        (i Enquote (append
                            'Either '
                            Rule_Name
                            ' trying '
                            (. Argument Get_Input)))
                        ';' [line];
                }
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                if (or (isa Argument Token_Quote) (isa Argument Syntax_Line))
                {
                    append Block 'quit : (i Parse_Token Parent_Elements ' [. Argument Fallback] ') [true];' [line];
                }
                else.if (isa Argument Token)
                {
                    append Block 'quit : (i Parse_' [. Argument Fallback] ' Parent_Elements) [true];' [line];
                }
                else
                {
                    append Block [. Argument Fallback];
                }
            }
            if Verbose
            {
                append Block
                    'verbose "FAILED " ' Quoted_Input ';' [line];
            }
            = Block (i Indent Block);
            string Code 'method flag Parse_' Rule_Name
                ' [list Parent_Elements]' [line]
                '{' [line]
                Block
                [indent] 'return [false];' [line]
                '}';
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Count
        {
            string Minimum [my Minimum Fallback];
            string Maximum [my Maximum Fallback];
            debug;
            verbosity [true];
        }

        generate Statement_Lexical
        {
            string Name [my Name Fallback];
            string Literal [my Literal Fallback];
            string Code
                'method flag Parse_' Name ' [list Parent_Elements]' [line]
                '{' [line, indent]
                    'integer Start_Char [my Char_Pos];' [line, indent]
                    'integer Start_Token [my Token_Pos];' [line, indent]
                    'if (not (i Parse_Token Parent_Elements ' Literal ')) { i Rollback Start_Char Start_Token ' (i Enquote (append 'Lexical ' Name ' expected ' Literal '.')) '; return [false]; }' [line,  indent]
                    'return [true];' [line]
                '}';
            i= Code;
        }
        generate Statement_Token
        {
            verbosity;
            string Name [my Class_Name Fallback];
            string Code
                'method flag Parse_' Name ' [list Parent_Elements]' [line]
                '{' [line]
                [indent] 'object Top_Token (i Top_Token);' [line]
                [indent] 'quit : (isnull Top_Token) [false];' [line]
                [indent] 'if (not (isa Top_Token ' Name ')) { '
                    'Top_Token.Error = "Expected ' Name '";' [line]
                    'return [false]; }' [line]
                [indent] 'push Parent_Elements Top_Token;' [line]
                [indent] 'Top_Token.Error = [null];' [line]
                [indent] 'i Consume_Token;' [line]
                [indent] 'return [true];' [line]
                '}';
            i= Code;
            string Declaration
                'class set ' Name ' { property flag Isa_' Name ' [true]; }' [line];
            verbose 'token declaration: ' Declaration;
            my= Fallback_Declaration Declaration;
        }
        generate Statement_Tokens
        {
            verbosity;
            string Code '';
            entity Argument;
            string Between '';
            string Declaration '';
            string D;
            foreach [my Arguments] Argument
            {
                string Name [. Argument Fallback];
                append Code Between
                    'method flag Parse_' Name ' [list Parent_Elements]' [line]
                    '{' [line]
                    [indent] 'object Top_Token (i Top_Token);' [line]
                    [indent] 'quit : (isnull Top_Token) [false];' [line]
                    [indent] 'if (not (isa Top_Token ' Name ')) { '
                    'Top_Token.Error = "Expected ' Name '";' [line]
                    'return [false]; }' [line]
                    [indent] 'push Parent_Elements Top_Token;' [line]
                    [indent] 'Top_Token.Error = [null];' [line]
                    [indent] 'i Consume_Token;' [line]
                    [indent] 'return [true];' [line]
                    '}';
                    = Between [line];
            }
            i= Code;
            comment `
            string Declaration
                'class set ' Name ' { property flag Isa_' Name ' [true]; }' [line];
            verbose 'token declaration: ' Declaration;
            my= Fallback_Declaration Declaration;
            `;
        }

        generate Syntax_Repeating
        {
            string Declarations '';
            string Rule [my Rule_Name Fallback];
            string Self_Call '(i Parse_' Rule ' My_Elements)';
            if (or (isa [my Rule_Name] Token_Quote) (isa [my Rule_Name] Syntax_Line))
            {
                = Self_Call (append '(i Parse_Token My_Elements ' Rule ')');
            }
            if (defined [my Rule_Name Fallback_Declaration])
            {
                append Declarations [my Rule_Name Fallback_Declaration];
            }
            string Code
                'comment `repeating ' Rule '`;' [line]
                'if (not ' Self_Call ')' [line]
                '{' [line, indent]
                    'i Rollback Start_Char Start_Token `[repeating ' Rule '] expected at least one ' Rule '.`;' [line, indent]
                    'return [false];' [line]
                '}' [line]
                'forever' [line]
                '{' [line,
                indent] 'breakif (not ' Self_Call ');' [line]
                '}';
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Optional
        {
            string Declarations '';
            string Rule [my Rule_Name Fallback];
            string Self_Call 'i Parse_' Rule ' My_Elements;';
            if (or (isa [my Rule_Name] Token_Quote) (isa [my Rule_Name] Syntax_Line))
            {
                = Self_Call (append 'i Parse_Token My_Elements ' Rule ';');
                if (defined [my Rule_Name Fallback_Declaration])
                {
                    append Declarations [my Rule_Name Fallback_Declaration];
                }
            }
            string Code
                'comment `optional ' Rule '`;' [line]
                Self_Call;
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Optrep
        {
            string Declarations '';
            string Rule [my Rule_Name Fallback];
            string Defines '';
            string Self_Call '(i Parse_' Rule ' My_Elements)';
            if (or (isa [my Rule_Name] Token_Quote) (isa [my Rule_Name] Syntax_Line))
            {
                = Self_Call (append '(i Parse_Token My_Elements ' Rule ')');
                if (defined [my Rule_Name Fallback_Declaration])
                {
                    append Declarations [my Rule_Name Fallback_Declaration];
                }
            }
            string Code
                'comment ' (i Enquote (i Get_Input)) ';' [line]
                'forever' [line]
                '{' [line,
                indent] 'breakif (not ' Self_Call ');' [line]
                '}';
            if (defined [my Rule_Name Fallback_Declaration])
            {
                my= Fallback_Declaration [my Rule_Name Fallback_Declaration];
            }
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Exclude
        {
            string Declarations '';
            string Args (i Fallback_Args);
            string Code 'comment "[exclude ' Args ']";' [line];
            entity Argument;
            foreach [my Arguments] Argument
            {
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                comment "rule name tokens are required here, right?";
                append Code 'return if (i Parse_' [. Argument Fallback] ' Excluded) [false];' [line];
            }
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Statement_Property
        {
            string Code
                'property '
                [my Type Fallback]
                (i Fallback_Arguments)
                ';';
            i= Code;
        }

        generate Statement_Attribute
        {
            string Property_Fallback [my Property_Name Fallback];
            string Type_Fallback [my Type Fallback];
            string Ancestor_Fallback 'Symbol';
            string Class_Fallback (upper (firstchar Type_Fallback)) (substring Type_Fallback 1);
            string Value_Code '(new ' Class_Fallback " [self]";
            if (defined [my Value])
            {
                entity Value [my Value];
                if (isa Value Name_Token)
                {
                    = Value_Code (append '(new ' [. Value Fallback] " [self]");
                }
                else.if (isa Value Atomic_Token)
                {
                    append Value_Code ' ' [my Value Fallback];
                }
                else
                {
                    debug;
                }
            }
            append Value_Code ');';
            string Code 'property object ' Property_Fallback ' ' Value_Code;
            i= Code;
        }
        generate Statement_Entity
        {
            string Name 'Entity_' [my Name Fallback];
            string Parent_Class "Entity";
            if (defined [my Parent_Class])
            {
                = Parent_Class [my Parent_Class Fallback];
            }
            string Declaration '';
            entity Statement;
            forgive
            {
                foreach [my Block Statements] Statement
                {
                    if (defined [. Statement Fallback_Declaration])
                    {
                        append Declaration [. Statement Fallback_Declaration];
                    }
                }
            }
            string Code
                Declaration [line]
                'class ' Name ' [is ' Parent_Class ']'
                (i Fallback_Block);
            i= Code;
        }
        generate Statement_Optional
        {
            string Argument_Name [my Argument_Name Fallback];
            string Code 'property object ' Argument_Name ';';
            string Declaration 'if (gt (list [my Listargs] length) 0)' [line]
                '{' [line];
            append Declaration [indent]
                'my ' Argument_Name ' = (shift [my Listargs]);' [line];
            if (defined [my Type_Value])
            {
                append Declaration [indent]
                    '.= [my ' Argument_Name '] Usage ' [my Type_Value Fallback] ';' [line];
            }
            append Declaration '}' [line];
            my= Fallback_Declaration Declaration;
            i= Code;
        }
        generate Statement_Keyword
        {
            string Argument_Name [my Argument_Name Fallback];
            string Code 'property object ' Argument_Name ';';
            string Declaration
                "if (= (llength [my Keywords]) 0)" [line]
                "{" [line, indent]
                    "error 'missing required keyword " Argument_Name "';" [line]
                "}" [line];
            append Declaration '[my ' Argument_Name ' Symbol_Value] = (shift [my Keywords]);' [line];
            if (defined [my Type_Value])
            {
                append Declaration '[my ' Argument_Name ' Usage] = ' [my Type_Value Fallback] ';' [line];
            }
            my= Fallback_Declaration Declaration;
            i= Code;
        }
        generate Statement_Method
        {
            string Code
                'method '
                [my Type Fallback]
                (i Fallback_Arguments)
                (i Fallback_Block);
            i= Code;
        }

        generate Amount_Statement
        {
            string Parent [my Parent Name Fallback];
            string Amount (i Enquote [my Amount Fallback]);
            string Unit (i Enquote [. [my.attribute Unit] Fallback]);
            string Property_Name [my Property_Name];
            string Code
                '[' Parent '.' Property_Name '.Symbol_Value] = ' Amount ';' [line]
                '[' Parent '.' Property_Name '.Unit] = ' Unit ';';
            i= Code;
        }
        generate Thing_Statement
        {
            string Name [my Name Fallback];
            string Class_Name [my Thing_Type];
            string Code 'object ' Name ' new ' Class_Name ';';
            if (defined [my Text])
            {
                s+ Code [line]
                    Name '.Text = ' [my Text Fallback] ';';
            }
            s+ Code [line]
                (i Fallback_Statements);
            i= Code;
        }

        generate Statement_Amount
        {
            string Name [my Name Fallback];
            string Quote_Name (i Enquote Name);
            string Keyword [my Keyword Fallback];
            string Symbol_Code
                'symbol number ' Name ' Amount;';
            string Attribute_Code
                'property number ' Name ' ' Name ';';
            string Statement_Code
                'statement ' Name " " Keyword " Amount" [line] '{' [line, indent]
                    'property string Property_Name ' Quote_Name ';' [line, indent]
                    'argument Amount;' [line, indent]
                    'keyword Unit;' [line]
                '}';
            string Code
                Symbol_Code [line]
                Statement_Code;
            todo 'Attribute code is a property!';
            i= Code;
        }
        generate Statement_Symbol
        {
            string Type [my Type Fallback];
            string Name [my Name Fallback];
            string Parent_Class "Symbol";
            if (defined [my Parent_Class])
            {
                = Parent_Class [my Parent_Class Fallback];
            }
            string Block '';
            string Declaration "";
            if (defined [my Block])
            {
                = Block [my Block Fallback_Statements];
                foreach [my Block Statements] Statement
                {
                    if (defined [. Statement Fallback_Declaration])
                    {
                        append Declaration [. Statement Fallback_Declaration];
                    }
                }
            }
            string Default_Value ', ' Type ' Value [null]';
            string Initializer
                'if (defined Value) {' [line, indent 3]
                'my Symbol_Value = Value;' [line, indent 2]
                '}' [line, indent];
            if (contains " list dictionary object glvn dict " (append ' ' Type ' '))
            {
                = Default_Value "";
                = Initializer "";
            }
            string Code
                Declaration [line]
                'class ' Name ' [is ' Parent_Class ']' [line] '{' [line, indent]
                    'property object Symbol_Object;' [line, indent]
                    'property ' Type ' Symbol_Value;' [line, indent]
                    'constructor [object Object' Default_Value ']' [line, indent] '{' [line, indent 2]
                        'my Symbol_Object = Object;' [line, indent]
                        Initializer
                    '}' [line]
                    Block
                '}';
            i= Code;
        }
        generate Statement_Action
        {
            string Type [my Type Fallback];
            string Name [my Class_Name Fallback];
            string Parent_Class "Action";
            if (defined [my Parent_Class])
            {
                = Parent_Class [my Parent_Class Fallback];
            }
            string Block '';
            if (defined [my Block])
            {
                = Block [my Block Fallback_Statements];
            }
            string Code
                'class Action_' Name ' [is ' Parent_Class ']' [line] '{' [line, indent]
                    'property object Symbol_Object;' [line, indent]
                    'constructor [object Object]' [line, indent] '{' [line, indent 2]
                        'my Symbol_Object = Object;' [line, indent]
                    '}' [line]
                    Block
                '}';
            i= Code;
        }
        generate Definition_Statement
        {
            string Base_Class (classpropget Base_Class);
            string Class_Name Base_Class '_' [my Name Fallback];
            string Keyword [my Keyword Fallback];
            if (isa [my Keyword] Token_Quote)
            {
                = Keyword (. [my Keyword] Unquoted);
            }
            string Gal_Keyword Keyword;
            replace Gal_Keyword ' ' '.';
            string Code 'class ' Class_Name;
            if (defined [my Ancestor])
            {
                append Code ' [is ' [my Ancestor Fallback] '_' Base_Class ']';
            }
            else
            {
                append Code ' [is ' (classpropget Base_Class) ']';
            }
            append Code [line] '{' [line,
                indent] "class property string Gal_Keyword " (i Enquote Gal_Keyword) ";" [line,
                indent] "class property string Keyword " (i Enquote Keyword) ";" [line];
            string Attribute_Statements '';
            entity Statement;
            if (defined [my Block])
            {
                append Code (i Fallback_Statements);
                foreach [my Block Statements] Statement
                {
                    if (defined [. Statement Fallback_Declaration])
                    {
                        append Attribute_Statements [. Statement Fallback_Declaration];
                    }
                }
            }
            string Indented (i Indent Attribute_Statements);
            string Attribute_Method
                'method flag Attributes' [line]
                '{' [line]
                    Indented
                    [line, indent]
                    'return [true];' [line]
                '}' [line];
            append Code (i Indent Attribute_Method);
            append Code '}' [line];
            i= Code;
        }
        generate Statement_Todo
        {
            string Text 'TODO:' [my Gal_Key_Suffix] (i Fallback_Arguments);
            string Code 'comment ' (i Enquote Text) ';';
            i= Code;
        }
        generate Statement_Flowerbox
        {
            string Comment_Text '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                string Arg_Text [. Argument Fallback];
                if (isa Argument Token_Quote)
                {
                    = Arg_Text (. Argument Unquoted);
                }
                append Comment_Text Arg_Text;
            }
            list.copy Lines (split Comment_Text [line]);
            = Comment_Text '';
            strings Line Full;
            integer Width 0;
            foreach Lines Line
            {
                if (gt (length Line) Width)
                {
                    = Width (length Line);
                }
            }
            foreach Lines Line
            {
                = Full (append Line '                                                                                                          ');
                = Full (substring Full 0 Width);
                = Full (append '* ' Full ' *');
                append Comment_Text ' ' (i Enquote Full) ' [line]';
            }
            += Width 4;
            string Stars '"' (substring "****************************************************************************************************************" 0 Width) '"';
            = Comment_Text (append Stars ' [line] ' Comment_Text ' ' Stars);
            string Code 'comment ' Comment_Text ';';
            i= Code;
        }
        generate Operation_Flowerbox
        {
            string Comment_Text '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                string Arg_Text [. Argument Fallback];
                if (isa Argument Token_Quote)
                {
                    = Arg_Text (. Argument Unquoted);
                }
                append Comment_Text Arg_Text;
            }
            list.copy Lines (split Comment_Text [line]);
            = Comment_Text '';
            strings Line Full;
            integer Width 0;
            foreach Lines Line
            {
                if (gt (length Line) Width)
                {
                    = Width (length Line);
                }
            }
            foreach Lines Line
            {
                = Full (append Line '                                                                                                          ');
                = Full (substring Full 0 Width);
                = Full (append '* ' Full ' *');
                append Comment_Text (i Enquote Full) ' [line]';
            }
            += Width 4;
            string Stars '"' (substring "****************************************************************************************************************" 0 Width) '"';
            = Comment_Text (append Stars ' [line] ' Comment_Text ' ' Stars);
            string Code '(append' Comment_Text ')';
            i= Code;
        }
        generate Feature_Statement
        {
            string Property_Name [my Property_Name];
            string Parent [my Parent Name Fallback];
            string Value [my Value Fallback];
            string Code '[' Parent '.' Property_Name '.Symbol_Value] = ' Value ';';
            i= Code;
        }
        generate Statement_Class_Property
        {
            string Type (list.last [my Gs_Keywords]);
            string Name [my Name Fallback];
            string Value '';
            if (defined [my Value])
            {
                append Value ' ' [my Value Fallback];
            }
            string Code
                'class property ' Type ' ' Name Value ';';
            i= Code;
        }
        generate Syntax_Property
        {
            string Code
                [my Object Fallback] '.' [my Property_Name Fallback];
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Code '.' [. Argument Fallback];
            }
            if (contains [my Gal_Key_Suffix] '~')
            {
                append Code ' Symbol_Value';
            }
            i= (i Syntax_Gs Code);
        }
        generate Statement_Propset
            Object '.' Property ' = ' Value ';';
        generate Statement_Assign
            Variable ' = ' Value ';';
        generate Statement_Object_New
            'object ' Variable ' (new ' Class (i Fallback_Args) ');';
        generate Statement_Object
        {
            string Code
                'object' (i Fallback_Arguments) ';';
            i= Code;
        }
        generate Statement_Isa
        {
            debug;
            todo 'fall back to an appropriate class set statement';
        }
        generate Statement_Generate
        {
            if (isnull (i Get_Language_Name))
            {
                debug;
                comment "can't find the language name Class_Name";
            }
            string Language (i Get_Language_Name);
            string Class_Name [my Class_Name Fallback];
            string Method_Prefix '';
            string Method_Suffix '';
            if (gt (list.length [my Listargs]) 0)
            {
                append Method_Prefix [indent] 'string Code = ';
                entity Argument;
                foreach [my Listargs] Argument
                {
                    if (isa Argument Name_Token)
                    {
                        append Method_Prefix ' [my ' [. Argument Fallback] ' ' Language ']';
                    }
                    else
                    {
                        append Method_Prefix ' ' [. Argument Fallback];
                    }
                }
                append Method_Prefix ';' [line];
                append Method_Suffix [indent] 'my ' Language ' = Code;' [line];
            }
            string Method_Statements
                Method_Prefix
                (i Fallback_Statements)
                Method_Suffix;
            string Method_Code
                'method flag Infer_' Language [line] '{' [line]
                Method_Statements
                '}';
            string Code 'class set ' Class_Name [line] '{' [line] (i Indent Method_Code) [line]
            '}';
            i= Code;
        }

        generate Statement_Inferences
        {
            entity Argument;
            string Code '';
            string Between '';
            foreach [my Arguments] Argument
            {
                append Code Between 'infers ' [. Argument Fallback] ';';
                = Between [line];
            }
            i= '';
            my= Fallback_Declaration Code;
        }
        generate Statement_Tokenization
        {
            string Parser [my Language_Name Fallback] '_Parser';
            entity Statement;
            string Defs `object O [self];
verbosity [true];
string Ignore;
strings Mode C Next;
string Q '';
integer Position;
string Input [my.attribute Input];
verbose "Input: " Input;
integer Last ((length Input) - 1);
tokenmode Initial;
object T;
`;
            string Handlers `= Next (substring Input Position 2);
= C (firstchar Next);
verbose Mode ' [' C ']';
if (Position = Last)
{
    Next = '';
}
else
{
    Next = (lastchar Next);
}
if (Mode s= 'Initial')
{
    comment 'skip other handlers';
}
`;
            foreach [my Block Statements] Statement
            {
                string Statement_Fallback [. Statement Fallback];
                string Statement_Declaration [. Statement Fallback_Declaration];
                if (sgt Statement_Fallback '')
                {
                    append Defs Statement_Fallback [line];
                }
                if (sgt Statement_Declaration '')
                {
                    append Handlers Statement_Declaration [line];
                }
            }

            string Loop 'for range Position 0 Last 1' [line] '{' [line]
                (i Indent Handlers)
                '}' [line];

            string Display
                'integer Position 0;' [line]
                'foreach [my.attribute Tokens] T' [line] '{' [line, indent]
                    "verbose Position ' ' [class name T] ' ' [. T Input];" [line, indent]
                    'Position ++;' [line]
                '}' [line];
            = Display (append 'if Verbose' [line] '{' [line]
                (i Indent Display)
                '}' [line]);

            string Block
                (i Indent Defs)
                (i Indent Loop)
                (i Indent Display);

            string Method
                'method flag Infer_Tokens' [line] '{' [line]
                    Block
                '}' [line];
            string Code
                'class set ' Parser [line] '{' [line]
                    (i Indent Method)
                '}';
            i= Code;
        }
        generate Statement_Generator
        {
            string Fallback_Statements '';
            string Fallback_Declaration '';
            entity Statement;
            foreach [my Block Statements] Statement
            {
                string Statement_Fb [. Statement Fallback];
                string Statement_Dec [. Statement Fallback_Declaration];
                if (isa Statement Statement_Generate)
                {
                    if (notnull Statement_Dec)
                    {
                        append Fallback_Declaration Statement_Dec;
                    }
                    if (notnull Statement_Fb)
                    {
                        append Fallback_Declaration Statement_Fb;
                    }
                }
                else.if (isa Statement Statement_Infers)
                {
                    if (notnull Statement_Dec)
                    {
                        append Fallback_Declaration Statement_Dec;
                    }
                    if (notnull Statement_Fb)
                    {
                        append Fallback_Declaration Statement_Fb;
                    }
                }
                else.if (isa Statement Statement_Inferences)
                {
                    if (notnull Statement_Dec)
                    {
                        append Fallback_Declaration Statement_Dec;
                    }
                    if (notnull Statement_Fb)
                    {
                        append Fallback_Declaration Statement_Fb;
                    }
                }
                else
                {
                    if (notnull Statement_Dec)
                    {
                        append Fallback_Declaration Statement_Dec;
                    }
                    if (notnull Statement_Fb)
                    {
                        append Fallback_Declaration Statement_Fb;
                    }
                }
            }
            string Language [my Language Fallback];
            string Class Language '_Generator';
            string Class_Definition `class ` Class ` [is Generator]
{
    infers ` Language `;
    property string Language_Name ` (i Enquote Language) `;
    property string Property_Name ` (i Enquote Language) `;
    attribute list Elements;
    attribute list Inferences;
    constructor [entity Owner]
    {
        my= Owner Owner;
    }
    method flag Initialize
    {
        verbosity;
        verbose [class.name] ' Inits';
        infer.inits;
        return [true];
    }
    method flag Infer_` Language `
    {
        verbosity;
        object Elem;
        object I;
        integer Number 0;
        variant Error;
        foreach [my Elements ~] Elem
        {
            try
            {
                I = [Elem.Classification];
                I.Infer_` Language `;
                Elem.` Language ` = [I.` Language `];
                Number++;
            }
            catch Error
            {
                my Status = [false];
                Elem.Error = Error;
                verbose 'Error ` Language `element ' Number ': ' [classname I] ', <' Error '>, source ' (. I Get_Input);
            }
        }
        returnif (not [my Status]) [false];
        object Top = (list last [my Elements ~]);
        Top.Infer_` Language `;
        string Code [Top.` Language `];
        my ` Language ` = Code;
        my Code = Code;
        return [true];
    }
}
`;
            string Statements_Code `class set Statements
{
    method flag Infer_` Language `
    {
        string Code '';
        object Statement;
        foreach [my Elements] Statement
        {
            Code s+ [. Statement ` Language `] [line];
        }
        my ` Language ` = Code;
    }
}` [line];
            string Inference
            `inference string ` Language [line] `{` [line]
            '}' [line]
                Statements_Code
                Fallback_Statements
            ;
            string Code
                Fallback_Declaration
                Class_Definition
                Inference;
            i= Code;
        }
        generate Statement_Language
        {
            string Name 'Gal';
            if (defined [my Name])
            {
                = Name [my Name Fallback];
            }
            string Declarations '';
            entity Statement;
            if (and (defined [my Block]) (defined [my Block Statements]))
            {
                foreach [my Block Statements] Statement
                {
                    string Dec [. Statement Fallback_Declaration];
                    if (sgt Dec '')
                    {
                        append Declarations Dec [line];
                    }
                }
            }
            if (sgt Declarations '')
            {
                = Declarations (i Indent Declarations);
            }

            string Code
                Declarations
                'class Language_' Name ' [is Language]' (i Fallback_Block);
            i= Code;
        }

        generate Statement_Token_New
        {
            string Class [my Class Fallback];
            string Mode [my Mode Fallback];
            comment string Code 'new token T ' Class ' ' Mode ' Char Position Position;';
            string Code
                'T = (new Token_' Class ' [self] Char Position Position);' [line]
                'list append [my Tokens Symbol_Value] T;' [line]
                'Mode = ' (i Enquote Mode) ';';
            i= Code;
        }

        generate Statement_Skip_Token
        {
            string Class [my Class Fallback];
            string Mode [my Mode Fallback];
            comment string Code 'new token T ' Class ' ' Mode ' Char Position Position;';
            string Code
                'T = (new Token_' Class ' [self] Char Position Position);' [line]
                'comment `' Class ' tokens are not appended to the token list.`;' [line]
                'Mode = ' (i Enquote Mode) ';';
            i= Code;
        }

        generate Statement_Token_Initial
        {
            string Code
                'else' [line] '{' [line, indent]
                    'debug;' [line, indent]
                    "error 'Unknown Token Mode ' Mode;" [line]
                '}' [line]
                "comment 'this must go at the end to allow other handlers to delegate to Initial mode.';" [line]
                "if (Mode s= 'Initial')"
                    (i Fallback_Block);
            i= '';
            my= Fallback_Declaration Code;
        }
        generate Statement_Token_Handler
        {
            string Mode (i Enquote [my Mode Fallback]);
            string Code
                'else.if (Mode s= ' Mode ')'
                    (i Fallback_Block);
            i= '';
            my= Fallback_Declaration Code;
        }
        generate Statement_Append_Token
        {
            string Mode [my Mode Fallback];
            string Code 'token append T Char ' Mode ';';
            i= Code;
        }
        generate Statement_Currency
            'class Currency_' Name ' [is Currency]' (i Fallback_Args) (i Fallback_Block);
        generate Statement_Cycle
            'method flag Cycle' (i Fallback_Arguments) [line] '{' [line]
            (i Fallback_Statements)
            [indent] 'return [true];' [line]
            '}';
        generate Statement_For_Each_Human_Being
            'object ' Human_Entity ';' [line]
            'for each [: Human_Being Persons] ' Human_Entity
            (i Fallback_Block);
        generate Statement_For_Each_Human_Outcome
            'object ' Outcome_Entity ';' [line]
            'for each [' Human_Entity '.Outcomes] ' Outcome_Entity
            (i Fallback_Block);
        generate Statement_For_Each_Outcome_Support
            'object ' Support_Entity ';' [line]
            'for each [' Outcome_Entity '.Supports] ' Support_Entity
            (i Fallback_Block);
        generate Statement_For_Each_Supporter
            'object ' Supporter_Entity ';' [line]
            'for each [' Support_Entity '.Supporters] ' Supporter_Entity
            (i Fallback_Block);
        generate Operation_Human_Outcome_Gratitude
            '(' Supporter_Entity '.Human_Outcome_Gratitude' (i Fallback_Args) ')';
        generate Statement_Pay
            Transaction_Entity '.Pay' (i Fallback_Args) ';';
        generate Statement_For_Each_In
            'for each ' List ' ' Variable
            (i Fallback_Block);
        generate Statement_I_Equal
        {
            string Property_Name (i Get_Property_Name);
            if (isnull Property_Name)
            {
                = Property_Name (i Get_Language_Name);
            }
            if (isnull Property_Name)
            {
                debug;
            }
            string Code 'my ' Property_Name ' = ' [my Value Fallback] ';';
            i= Code;
        }
        generate Statement_Example
        {
            verbosity [true];
			flag Error_Status [true];
            string Text '';
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Text (. Argument Unquoted);
            }
            if (defined [my Block])
            {
                append Text [my Block Gs_Statements];
            }
            entity.new Trans Translator;
            = [attribute Trans Input] Text;
            .= Trans Parser (new Gs_Parser Trans);
            .= Trans Generator (new Gs_Generator Trans);
            flag Status (. Trans Initialize);
            if (not Status)
            {
                my= Error 'Error intiailizing Goalspell Translator';
                return [false];
            }
            = Status (. [. Trans Parser] Infer);
            if (not Status)
            {
                my= Error (. [. Trans Parser] Error_Report);
                verbose [my Error];
                return [false];
            }
            = [. Trans Generator Elements] [. Trans Parser Elements];
            = Status (. [. Trans Generator] Infer);
            string Gs [. Trans Generator Code];
            returnif (not Status) [true];
            verbose 'gs ' Gs;
            string Fallback Gs;
            entity.new Fb_Gen Fallback_Generator Trans;
            .= Fb_Gen Elements [. Trans Parser Elements];
            = Status (. Fb_Gen Initialize);
            = Status (. Fb_Gen Infer);
			if (not Status) {
				debug;
			}
            string Fallback [. Fb_Gen Code];
            verbose 'fallback ' Fallback;

            string Atomic Fallback;
            if (sne (i Minify Fallback) (i Minify Gs))
            {
                entity.new Atomic_Trans Translator;
                = [attribute Atomic_Trans Input] Fallback;
                .= Atomic_Trans Parser (new Gs_Parser Atomic_Trans);
                .= Atomic_Trans Generator (new Fallback_Generator Atomic_Trans);
                flag Status (. Atomic_Trans Initialize);
                if (not Status)
                {
                    error 'Error intiailizing Atomic Translator';
                }
				try
				{
	                = Status (. [. Atomic_Trans Parser] Infer);
				}
				catch Error
				{
					debug;
					writeline "Error '" Error "' parsing Fallback Code: " Fallback;
					= Status [false];
				}
                if (not Status)
                {
                    error (. [. Atomic_Trans Parser] Error_Report);
                }
                = [. Atomic_Trans Generator Elements] [. Atomic_Trans Parser Elements];
                = Status (. [. Atomic_Trans Generator] Infer);
                = Atomic [. Atomic_Trans Generator Code];
                verbose 'atomic ' Atomic;
            }
            string Python '';
            string Javascript '';
            string Mumps '';
            string PHP '';
            string Raku '';
            if Status
            {
                entity.new Py_Trans Translator;
                = [attribute Py_Trans Input] Atomic;
                .= Py_Trans Parser (new Gs_Parser Py_Trans);
                .= Py_Trans Generator (new Python_Generator Py_Trans);
                flag Status (. Py_Trans Initialize);
                if (not Status) { debug; }
                = Status (. [. Py_Trans Parser] Infer);
                if (or Status Error_Status)
				{
					= Python (. [. Py_Trans Parser] Error_Report);
				}
                else
                {
                    if (contains Python "\")
                    {
                        replace Python "\" '&#92;';
                    }
                }
			}
			if Status
			{
                = [. Py_Trans Generator Elements] [. Py_Trans Parser Elements];
                = Status (. [. Py_Trans Generator] Infer);
                comment if (not Status) { debug; }
                = Python [. Py_Trans Generator Code];
                verbose 'python ' Python;

                entity.new Js_Gen Javascript_Generator Py_Trans;
                .= Js_Gen Elements [. Py_Trans Parser Elements];
                = Status (. Js_Gen Initialize);
                if (not Status) { debug; }
                = Status (. Js_Gen Infer);
                comment if (not Status) { debug; }
				if (or Status Error_Status)
				{
 	               = Javascript [. Js_Gen Code];
				}
                else
                {
                    if (contains Javascript "\")
                    {
                        replace Javascript "\" '&#92;';
                    }
                }
                verbose 'javascript ' Javascript;

comment `
                entity.new PHP_Gen PHP_Generator Py_Trans;
                .= PHP_Gen Elements [. Py_Trans Parser Elements];
                = Status (. PHP_Gen Initialize);
                if (not Status) { debug; }
                = Status (. PHP_Gen Infer);
                comment if (not Status) { debug; }
				if (or Status Error_Status)
				{
	                = PHP [. PHP_Gen Code];
				}
                verbose 'php ' PHP;
`;
comment `
                entity.new Raku_Gen Raku_Generator Py_Trans;
                .= Raku_Gen Elements [. Py_Trans Parser Elements];
                = Status (. Raku_Gen Initialize);
                if (not Status) { debug; }
                = Status (. Raku_Gen Infer);
                comment if (not Status) { debug; }
				if (or Status Error_Status)
				{
   		            = Raku [. Raku_Gen Code];
				}
                verbose 'raku ' Raku;
`;
                entity.new M_Gen Mumps_Generator Py_Trans;
                .= M_Gen Elements [. Py_Trans Parser Elements];
                = Status (. M_Gen Initialize);
                if (not Status) { debug; }
                = Status (. M_Gen Infer);
                comment if (not Status) { debug; }
    	        if (or Status Error_Status)
				{
				    = Mumps [. M_Gen Code];
				}
                verbose 'mumps ' Mumps;
            }

            string Panes 'pane "goalspell" ' (i Line_String Gs) ';' [line];
            if (sne (i Minify Gs) (i Minify Fallback)) {
                append Panes 'pane "fallback" ' (i Line_String Fallback) ';' [line];
                if (sne (i Minify Fallback) (i Minify Atomic)) {
                    append Panes 'pane "atomic" ' (i Line_String Atomic) ';' [line];
                }
            }
            if (sgt Python '')
            {
                append Panes 'pane "Python" ' (i Line_String Python) ';' [line];
            }
            if (sgt Javascript '')
            {
                append Panes 'pane "Javascript" ' (i Line_String Javascript) ';' [line];
            }
            if (sgt PHP '')
            {
                append Panes 'pane "PHP" ' (i Line_String PHP) ';' [line];
            }
            if (sgt Raku '')
            {
                append Panes 'pane "Raku" ' (i Line_String Raku) ';' [line];
            }
            if (sgt Mumps '')
            {
                append Panes 'pane "MUMPS" ' (i Line_String Mumps) ';' [line];
            }
            string Example_Name (: Fallback_Generator Next_Example);
            string Code
                'code box ' Example_Name [line] '{' [line]
                    Panes
                '}';
            i= Code;
        }

        generate Statement_Compile_Runtime
            Target ' = (Runtime:Compile ' (i Enquote [my From Fallback]) ' ' (i Enquote [my To Fallback]) ' ' Source ');';
        generate Statement_Atomic_Runtime
            Gs_Variable ' = (Runtime:Atomic ' Atomic_Variable ');';

        generate Statement_Debug_If
            'if ' Condition ' { debug; }';
        generate Statement_Break_If
            'if ' Condition ' { break; }';
        generate Statement_Continue_If
            'if ' Condition ' { continue; }';
        generate Operation_Shift
            '(shift ' (i Fallback_Arguments) ')';
        generate Syntax_Mildbeard
        {
            i= '"Erik Zoltan"';
        }
        generate Statement_Write_Line
            'say' (i Fallback_Arguments) ';';
        generate Syntax_My_Attribute
            '[my' (i Fallback_Arguments) ' Symbol_Value]';
        generate Statement_Compile
        {
            string From [my From Fallback];
            string Source [my Source Fallback];
            string To [my To Fallback];
            string Target [my Target Fallback];
            increment [: Fallback_Generator Example_Number];
            integer VN [: Fallback_Generator Example_Number];
            string Code `comment 'compile ` From ` ` Source ` ` To ` ` Target `';
object Factory` VN ` new Translation_Factory;
object Trans` VN ` (Factory` VN `.Get_Translator ` From ` ` To `);
[Trans` VN `.Input Symbol_Value] = ` Source `;
[Trans` VN `.Output Symbol_Value] = '';
flag Status` VN ` = (Trans` VN `.Initialize);
and Status` VN ` (Trans` VN `.Run);
if (not Status` VN `) { error "Compile Failed"; }
` Target ` = [Trans` VN `.Output Symbol_Value];`;
            i= Code;
        }
        generate Statement_Atomic
        {
            string Source [my Source Fallback];
            string Target [my Target Fallback];
            increment [: Fallback_Generator Example_Number];
            integer VN [: Fallback_Generator Example_Number];
            string Code `comment 'atomic ` Source ` ` Target `';
object Factory` VN ` new Translation_Factory;
object Trans` VN ` (Factory` VN `.Get_Translator 'goalspell' 'goalspell');
dictionary Sources` VN `;
forever
{
    dict assign Sources` VN ` ` Source ` [true];
    [Trans` VN `.Input Symbol_Value] = ` Source `;
    [Trans` VN `.Output Symbol_Value] = '';
    flag Status` VN ` = (Trans` VN `.Initialize);
    and Status` VN ` (Trans` VN `.Run);
    if (not Status` VN `) { error "Atomic Failed"; }
    ` Target ` = [Trans` VN `.Output Symbol_Value];
    break if (dict exists Sources` VN ` ` Target `);
    ` Source ` = ` Target `;
}`;
            i= Code;
        }
        generate Statement_Integers
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'integer ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Strings
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'string ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Numbers
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'number ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Flags
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'flag ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Objects
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'object ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Lists
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'list ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Dictionaries
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'dictionary ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Variants
        {
            entity Argument;
            string Code '';
            foreach [my Arguments] Argument
            {
                string Variable [. Argument Fallback];
                append Code 'variant ' Variable ';' [line];
            }
            i= Code;
        }
        generate Statement_Readline
        {
            string Code "";
            string Writes "";
            string Between "";
            entity Argument;
            foreach [my Arguments] Argument
            {
                if (isa Argument Token_Name)
                {
                    if (sgt Writes "")
                    {
                        append Code Between "write " Writes ";";
                        = Between [line];
                        = Writes "";
                    }
                    append Code Between "read " [. Argument Fallback] " line;";
                    = Between [line];
                }
                else
                {
                    if (sgt Writes "")
                    {
                        append Writes " ";
                    }
                    append Writes [. Argument Fallback];
                }
            }
            if (sgt Writes "")
            {
                append Code Between "write " Writes ";";
            }
            i= Code;
        }

        generate Statement_Class
        {
            verbosity;
            my= Error [null];
            string Arguments (i Fallback_Arguments);
            entity Argument;
            string Ancestor ' [is Object]';
            string Name [my Name Fallback];
            string Post_Statements '';
            string Search ' ' Name ' ';
            if (contains ' Goal Symbol Egg Object ' Search)
            {
                = Ancestor '';
            }
            foreach [my Arguments] Argument
            {
                if (isa Argument Syntax_Is)
                {
                    = Ancestor '';
                }
            }
            append Arguments Ancestor;
            string Declarations '';
            string Statements '';
            entity Statement;
            string Between '';
            string SFB;
            string Dec;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    if (sgt [. Statement Fallback_Declaration] '')
                    {
                        append Declarations [. Statement Fallback_Declaration] [line];
                    }
                    append Statements Between [. Statement Fallback];
                    = Between [line];
                }
            }
            foreach [my Appended_Statements] Statement
            {
                if (sgt [. Statement Fallback_Declaration] '')
                {
                    = Dec [. Statement Fallback_Declaration];
                    verbose 'class ' Name ' declares ' Dec;
                    append Declarations Dec [line];
                }
                = SFB [. Statement Fallback];
                append Statements Between SFB;
                verbose 'class ' Name ' appending ' SFB;
                = Between [line];
            }
            if (sgt Statements '')
            {
                = Statements (i Indent Statements);
                if (sne (lastchar Statements) [line])
                {
                    append Statements [line];
                }
            }
            string Code
                Declarations
                'class' Arguments [line]
                '{' [line]
                    Statements
                '}' [line]
                Post_Statements;
            i= Code;
        }

        generate Statement_Article
        {
            verbosity;
            string Code "";
            entity Argument;
            string Title "";
            string Name "";
            string Between "";
            foreach [my Arguments] Argument
            {
                if (isa Argument Name_Token)
                {
                    append Name Between [. Argument Fallback];
                    = Between ' ';
                }
                else.if (isa Argument Token_Quote)
                {
                    = Title [. Argument Fallback];
                }
                else
                {
                    debug;
                    verbose 'Unexpected argument type?';
                }
            }
            if (sgt Name "")
            {
                append Code 'title' (i Enquote Name) ';' [line];
            }
            if (sgt Title "")
            {
                append Code 'subtitle ' Title ';' [line];
            }
            string Statements [my Block Fallback_Statements];
            append Code Statements;
            i= Code;
        }

        generate Statement_Class_Append
        {
            verbosity [true];
            string Code '';
            if (not (defined [my Primary_Class]))
            {
                Code = [my Gs];
            }
            verbose 'fallback class append: ' Code;
            i= Code;
        }

        generate Statement_Class_Set
        {
            i= '';
        }

        generate Statement_Gs_Statement
        {
            string Name [my Name Fallback];
            string Keyword;
            string Ancestor 'Statement';
            string Argument_Statements '';
            string Attribute_Method '';
            entity Statement;
            = Keyword [my Keyword Fallback];
            if (defined [my Ancestor])
            {
                = Ancestor (append [my Ancestor Fallback] '_Statement');
            }
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    if (defined [. Statement Fallback_Declaration])
                    {
                        append Argument_Statements [. Statement Fallback_Declaration];
                    }
                }
                if (sgt Argument_Statements "")
                {
                    = Argument_Statements (i Indent Argument_Statements);
                    append Attribute_Method
                        'method void Attributes' [line]
                        '{' [line]
                        Argument_Statements
                        '}' [line];
                    = Attribute_Method (i Indent Attribute_Method);
                }
            }
            string Code 'class Statement_' Name ' [is ' Ancestor ']' [line]
                '{' [line, indent]
                    'property string Keyword ' Keyword ';' [line]
                    Attribute_Method
                    (i Fallback_Statements)
                '}';
            i= Code;
        }

        generate Statement_Gs_Operation
        {
            string Name [my Name Fallback];
            string Keyword;
            string Ancestor 'Operation';
            = Keyword [my Keyword Fallback];
            string Argument_Statements '';
            string Attribute_Method '';
            entity Statement;
            if (defined [my Ancestor])
            {
                = Ancestor (append [my Ancestor Fallback] '_Operation');
            }
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    if (defined [. Statement Fallback_Declaration])
                    {
                        append Argument_Statements [. Statement Fallback_Declaration];
                    }
                }
                if (sgt Argument_Statements "")
                {
                    = Argument_Statements (i Indent Argument_Statements);
                    append Attribute_Method
                        'method void Attributes' [line]
                        '{' [line]
                        Argument_Statements
                        '}' [line];
                    = Attribute_Method (i Indent Attribute_Method);
                }
            }
            string Code 'class Operation_' Name ' [is ' Ancestor ']' [line]
                '{' [line, indent]
                    'property string Keyword ' Keyword ';' [line]
                    Attribute_Method
                    (i Fallback_Statements)
                '}';
            i= Code;
        }

        generate Statement_Gs_Syntax
        {
            string Name [my Name Fallback];
            string Keyword;
            string Ancestor 'Syntax';
            = Keyword [my Keyword Fallback];
            string Argument_Statements '';
            string Attribute_Method '';
            entity Statement;
            if (defined [my Ancestor])
            {
                = Ancestor (append [my Ancestor Fallback] '_Syntax');
            }
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    if (defined [. Statement Fallback_Declaration])
                    {
                        append Argument_Statements [. Statement Fallback_Declaration];
                    }
                }
                if (sgt Argument_Statements "")
                {
                    = Argument_Statements (i Indent Argument_Statements);
                    append Attribute_Method
                        'method void Attributes' [line]
                        '{' [line]
                        Argument_Statements
                        '}' [line];
                    = Attribute_Method (i Indent Attribute_Method);
                }
            }
            string Code 'class Syntax_' Name ' [is ' Ancestor ']' [line]
                '{' [line, indent]
                    'property string Keyword ' Keyword ';' [line]
                    Attribute_Method
                    (i Fallback_Statements)
                '}';
            i= Code;
        }

        generate Binary_Operation
        {
            string Code '(';
            string Append ' ' [my Gs_Keyword];
            string Between '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                append Code Between [. Argument Fallback] Append;
                = Append '';
                = Between ' ';
            }
            append Code ')';
            i= Code;
        }

        generate Repeating_Operation
        {
            string Code '(';
            string Append ' ' [my Gs_Keyword];
            string Between '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                append Code Between [. Argument Fallback] Append;
                = Append '';
                = Between ' ';
            }
            append Code ')';
            i= Code;
        }
        generate Operation_Call
            '(' Object '.' Method (i Fallback_Args) ')';
        generate Statement_I
            '[self].' Method (i Fallback_Args) ';';
        generate Statement_Goal
        {
            string Name [my Name Fallback];
            string Full_Name 'Goal_' Name;

            string Fallback_Lines '';
            string Fallback_Declarations '';

            entity Statement;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    append Fallback_Lines [. Statement Fallback] [line];
                    if (defined [. Statement Fallback_Declaration])
                    {
                        comment append Fallback_Declarations [. Statement Fallback_Declaration] [line];
                    }
                }
            }

            string Fallback_Block [line] '{' [line] (i Indent Fallback_Declarations) '}';

            string Code 'class ' Full_Name ' [is Goal]' Fallback_Block;
            append Code Fallback_Lines;
            i= Code;
        }
        generate Statement_Spell
        {
            string Name [my Name Fallback];
            string Full_Name Name;

            string Fallback_Lines '';
            string Fallback_Declarations '';

            if (defined [my Block])
            {
                entity Statement;
                foreach [my Block Statements] Statement
                {
                    append Fallback_Lines [. Statement Fallback] [line];
                    if (defined [. Statement Fallback_Declaration])
                    {
                        comment append Fallback_Declarations [. Statement Fallback_Declaration] [line];
                    }
                }
            }

            string Fallback_Block [line] '{' [line] (i Indent Fallback_Declarations) '}';

            string Code 'class ' Full_Name ' [is Spell]' Fallback_Block;
            append Code Fallback_Lines;
            i= Code;
        }
        generate Statement_Goal_Spell
        {
            string Name [my Name Fallback];
            string Goal_Code
                'goal ' Name;
            if (defined [my Description])
            {
                append Goal_Code ' ' [my Description Fallback];
            }
            append Goal_Code ';' [line];
            string Spell_Code
                'spell ' Name (i Fallback_Block);
            string Code
                Goal_Code
                Spell_Code;
            i= Code;
        }

        generate Statement_Verbosity
        {
            string Condition '[false]';
            if (defined [my Condition])
            {
                = Condition [my Condition Fallback];
            }
            string Code 'flag Verbose ' Condition ';';
            i= Code;
        }
        generate Statement_Verbose
            'if Verbose' [line] '{' [line, indent]
                'write' (i Fallback_Arguments) ' line;' [line]
            '}';
        generate Syntax_Exclude
        {
            string Declarations '';
            string Rule [my Rule Fallback];
            string Self_Call 'quit : (i Parse_' Rule ' My_Elements) [false];';
            if (or (isa [my Rule] Token_Quote) (isa [my Rule] Syntax_Line))
            {
                = Self_Call (append 'quit : (i Parse_Token My_Elements ' Rule ') [false];');
                if (defined [my Rule Fallback_Declaration])
                {
                    append Declarations [my Rule Fallback_Declaration];
                }
            }
            string Code
                'comment `exclude ' Rule '`;' [line]
                Self_Call;
            my= Fallback_Declaration Declarations;
            i= Code;
        }
        generate Statement_Tests
        {
            string Name [my Name Fallback];
            string Lines '';
            entity Statement;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    append Lines [. Statement Fallback] [line];
                }
                = Lines (i Indent Lines);
            }
            string Code 'method flag Test_' Name [line] '{' [line]
                Lines
                [indent] 'return [true];' [line]
            '}';
            i= Code;
        }
        generate Statement_No
        {
            string Arguments (i Fallback_Arguments);
            if (gt (list.length [my Arguments]) 1)
            {
                = Arguments (append '(append ' Arguments ')');
            }
            string Code
                'quit : (i Succeed ' Arguments ') [false];';
            i= Code;
        }
        generate Statement_Yes
        {
            string Arguments (i Fallback_Arguments);
            if (gt (list.length [my Arguments]) 1)
            {
                = Arguments (append '(append ' Arguments ')');
            }
            string Code
                'quit : (i Fail ' Arguments ') [false];';
            i= Code;
        }
        generate Statement_Translation_Test
            'comment `Translation Test ' Name '`;' [line]
            [my Block Fallback_Statements];
        generate Statement_In
        {
            debug;
            string Parent_Name [my Parent Name Fallback];
            string Code 'class set ' [my Language Fallback] '_Tests' [line]
            '{' [line,indent]
                'tests append ' Parent_Name [line, indent]
                '{' [line, indent 2]
                    'yes' (i Fallback_Args) ';' [line, indent]
                '}' [line]
            '}';
            i= Code;
        }
        generate Statement_In_Goalspell
        {
            debug;
            string Parent_Name [my Parent Name Fallback];
            string Code 'class set Goalspell_Tests' [line]
            '{' [line,indent]
                'tests append ' Parent_Name [line, indent]
                '{' [line, indent 2]
                    'yes' (i Fallback_Args) ';' [line, indent]
                '}' [line]
            '}';
            i= Code;
        }

        generate Statement_Tests_Append
        {
            debug;
            todo 'How to append these tests to any existing tests by that name??';
            i= '';
        }
        generate Statement_Entity_New
        {
            debug;
            string Variable [my Variable Fallback];
            string Class [my Class Fallback];
            string Code
            'object ' Variable ' (new ' Class (i Fallback_Args) ');';
            i= Code;

        }
        generate Operation_Enquote
            '(Runtime:Enquote ' Op1 ')';
comment `
        generate Statement_File_Readall
            Variable ' = (Runtime:File_Readall ' File_Name ');';
`;
        generate Statement_File_Dump
            'Runtime:File_Dump ' File_Text ' ' File_Name ';';
comment `
        generate Statement_File_Append
            'Runtime:File_Append ' File_Text ' ' File_Name ';';
`;
        generate Operation_Time_String
            '(Runtime:Time_String)';
        generate Statement_Readline
        {
            string Code '';
            string Between '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                if (isa Argument Token_Name)
                {
                    append Code Between [. Argument Fallback] ' = (Runtime:Readline);';
                }
                else
                {
                    append Code Between 'write ' [. Argument Fallback] ';';
                }
                = Between [line];
            }
            i= Code;
        }
        generate Operation_Random_Integer
            '(Runtime:Random_Integer ' Values ')';
        generate Operation_Files
            '(Runtime:Files ' Filespec ')';
        generate Statement_Rename
            'Runtime:Rename ' From ' ' To ';';
        generate Statement_File_Delete
            'Runtime:File_Delete ' File_Name ';';
        generate Operation_Token_Mode
            '(Mode s= ' (i Enquote [my Mode_Name Fallback]) ')';
        generate Statement_Token_Mode
            'Mode = ' (i Enquote [my Mode_Name Fallback]) ';';
        generate Syntax_Attribute
            '[' Object '.' Attribute (i Fallback_Args) ' Symbol_Value]';
        generate Syntax_Class_Attribute
            '[' Class ':' Attribute (i Fallback_Args) ' Symbol_Value]';
        generate Statement_Token_Append
            'append [' Token_Entity '.Input] ' Character ';' [line]
            '[' Token_Entity '.Location End_Position] = ' Position ';';
        generate Statement_Author
            'comment Author:' (i Fallback_Arguments) ';';
        generate Statement_Class_Attribute
        {
            string Property_Fallback [my Property_Name Fallback];
            string Type_Fallback [my Data_Type Fallback];
            string Ancestor_Fallback 'Attribute';
            string Class_Fallback;
            if (defined [my Class])
            {
                = Class_Fallback [my Class Fallback];
            }
            else
            {
                string Type_Name (upper (firstchar Type_Fallback)) (substring Type_Fallback 1);
                = Class_Fallback Type_Name;
            }
            comment `Class Property entities don't know their owner!`;
            string Code 'class.property object ' Property_Fallback ' (new Class_' Class_Fallback ');' [line];
            i= Code;
        }
        generate Statement_English
            'comment English' (i Fallback_Arguments) ';';
        generate Statement_Call
            Target '.' Method (i Fallback_Args) ';';
        generate Statement_It_Equals
            'i=' (i Fallback_Arguments) ';';
        generate Statement_My_Attribute_Equal
            '[my ' Attribute ' Symbol_Value] = ' Value ';';
        generate Statement_New_Token
            '= ' Token_Entity ' (new Token_' Class ' [self] ' Character ' ' Start ' ' End ');' [line]
            'push [my Tokens Symbol_Value] ' Token_Entity ';' [line]
            '= Mode ' (i Enquote [my Mode Fallback]) ';';


        generate Statement_Infer_Inits
        {
            entity Owner_Class (i Get_Class_Context);
            if (isnull Owner_Class)
            {
                i= 'infer inits;';
            }
            else
            {
                i= [. Owner_Class Infer_Inits];
            }
        }

        generate Statement_Remember
        {
            string Name (i Enquote [my Name Fallback]);
            string Variable;
            entity Argument;
            string Names "";
            foreach [my Listargs] Argument
            {
                = Variable [. Argument Fallback];
                append Names " " Variable;
            }
            if (sgt Names '')
            {
                = Names (append ' [new list' Names ']');
            }
            string Statements [my Block Fallback_Statements];
            increment [. Fallback_Generator Example_Number];
            integer Offset [. Fallback_Generator Example_Number];
            string Code 'Runtime:Remember_Before ' Name Names ';' [line]
                Statements
                'Runtime:Remember_After ' Name Names ';';
            i= Code;
        }
        generate Syntax_Remember
        {
            string Name (i Enquote [my Name Fallback]);
            string Expression [my Expression Fallback];
            string Variable;
            entity Argument;
            string Names "";
            foreach [my Listargs] Argument
            {
                = Variable [. Argument Fallback];
                append Names " " Variable;
            }
            if (sgt Names '')
            {
                = Names (append ' [new list' Names ']');
            }
            increment [. Fallback_Generator Example_Number];
            integer Offset [. Fallback_Generator Example_Number];
            string Code '(Runtime:Remember_Result ' Name ' ' Expression Names ')';
            i= Code;
        }
        generate Statement_Export_Memory
        {
            string Code 'comment "Export Memory";';
            entity Argument;
            foreach [my Listargs] Argument
            {
                append Code [line] "Runtime:Export_Memory " (i Enquote [. Argument Fallback]) ';';
            }
            i= Code;
        }
        generate Statement_Prompt
        {
            prompt.context;
            list Temp;
            = INPUT Temp;
            = OUTPUT '$ goalspell';
            entity Argument;
            string Unquoted;
            foreach [my Arguments] Argument
            {
                list.append INPUT (. Argument Unquoted);
            }
            verbosity;
            entity.new RT Runtime_Translator;
            string Input;
            entity Statement;
            foreach [my Block Statements] Statement
            {
                = Input (. Statement Get_Input);
                string Compiled (. RT Compile Input);
                replace Input 'saay' 'say';
                replace Input 'wriite' 'write';
                replace Input 'reaad' 'read';
                if (and (sgt OUTPUT '') (sne (lastchar OUTPUT) [line]))
                {
                    append OUTPUT [line];
                }
                append OUTPUT '~ ' Input [line];
                try
                {
                    execute Compiled;
                }
                catch Error
                {
                    append OUTPUT [line] "ERROR: " Error [line];
                }
            }
            append OUTPUT '~ ';
            string Code 'code box Prompt_' (: Fallback_Generator Next_Example) [line]
            '{' [line]
            'pane "prompt"' [line]
                (i Enquote OUTPUT) ';' [line]
            '}';
            i= Code;
        }
        generate Statement_Wriite
        {
            string Args '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                append Args ' (string ' [. Argument Fallback] ')';
            }
            string Code '';
            if (sgt Args '')
            {
                append Code 'append OUTPUT' Args ';';
            }
            i= Code;
        }
        generate Statement_Saay
        {
            string Args '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                append Args ' (string ' [. Argument Fallback] ')';
            }
            string Code 'append OUTPUT' Args ' [line];';
            i= Code;
        }
        generate Statement_Reaadline
        {
            string Code '';
            entity Argument;
            foreach [my Arguments] Argument
            {
                if (isa Argument Token_Name)
                {
                    append Code
                        'append OUTPUT (list INPUT get 0);' [line]
                        [. Argument Fallback] ' = (list INPUT shift);' [line];
                }
                else
                {
                    append Code 'append OUTPUT ' [. Argument Fallback] ';' [line];
                }
            }
            i= Code;
        }
        generate Statement_Class_Module
            'module ' Name ' { '
            'class '
                (i Fallback_Arguments)
                (i Fallback_Block)
            ' }' [line];
        generate Statement_Expect_Equal
        {
            string Expected [my Expected Fallback];
            string Actual [my Actual Fallback];
            string Name [my Name Fallback];
            string Code
                'increment Test_Count;' [line]
                'if (' Expected ' = ' Actual ')' [line] '{' [line, indent]
                    'increment Test_Success;' [line] '}' [line]
                'else' [line] '{' [line, indent]
                    `verbose "` Name ` expected {" ` Expected ` "} = actual {" ` Actual ` "}";` [line]
                '}';
            i= Code;
        }
        generate Statement_My_Equal
            'my ' Property ' = ' Value ';';
        generate Statement_Behavior
        {
            entity Class_Context (i Get_Class_Context);
            string Class_Name (. [. Class_Context Name] Get_Input);
            string Behavior_Name (. [my Behavior_Name] Get_Input);
            string Entity_Behavior_Class "Behavior_" Class_Name '_' Behavior_Name;
            string Type [my Type Fallback];
            string Ancestor 'Behavior';
            string Args (i Fallback_Args);
            string Call_Args '';
            entity Arg;
            entity ArgArg;
            foreach [my Listargs] Arg
            {
                = ArgArg (list.get [. Arg Arguments] 0);
                append Call_Args ' ' [. ArgArg Fallback];
            }
            string Entity_Return Entity_Behavior_Class ':Execute [self]' Call_Args;
            string Behavior_Return '[our Implementer].Execute [self]' Call_Args;
            if (s= Type 'void')
            {
                append Entity_Return ";";
                append Behavior_Return ";";
            }
            else
            {
                = Entity_Return (append 'return (' Entity_Return ');');
                = Behavior_Return (append 'return (' Behavior_Return ');');
            }
            string Behavior_Statements [indent]
                'if (defined [our Implementer])' [line, indent]
                '{' [line, indent 2]
                Behavior_Return [line, indent]
                '}' [line];
            if (and (defined [my Block]) (defined [my Block Fallback_Statements]))
            {
                append Behavior_Statements [my Block Fallback_Statements];
            }
            else
            {
                append Behavior_Statements [indent] 'error "' Behavior_Name ' implementer not defined.";' [line];
            }
            string Method
                'method ' Type ' ' Behavior_Name
                (i Fallback_Args)
                [line] '{' [line, indent]
                Entity_Return
                [line] '}';
            string Behavior_Code
                'class ' Entity_Behavior_Class ' [is Behavior]' [line]
                '{' [line, indent]
                    'class property object Implementer;' [line, indent]
                    'class property string Data_Type "' Type '";' [line, indent]
                    'class property object Roster (new Roster);' [line, indent]
                    'class method ' Type ' Execute [object Owner]' (i Fallback_Args) [line, indent]
                    '{' [line]
                        (i Indent Behavior_Statements)
                    [indent] '}' [line]
                '}' [line];
            string Code
                Method;
            i= Code;
            my= Fallback_Declaration Behavior_Code;
        }
        generate Statement_Language_Behavior
        {
            entity Class_Context (i Get_Class_Context);
            string Class_Name (. [. Class_Context Name] Get_Input);
            string Behavior_Name (. [my Behavior_Name] Get_Input);
            string Entity_Behavior_Class "Behavior_" Class_Name '_' Behavior_Name;
            string Type (list.last [my Gs_Keywords]);
            string Ancestor 'Behavior';
            string Args (i Fallback_Args);
            string Call_Args '';
            entity Arg;
            entity ArgArg;
            foreach [my Listargs] Arg
            {
                = ArgArg (list.get [. Arg Arguments] 0);
                append Call_Args ' ' [. ArgArg Fallback];
            }
            string Entity_Return Entity_Behavior_Class ':Execute [self]' Call_Args;
            string Behavior_Return '[our Implementer].Execute Owner' Call_Args;
            if (s= Type 'void')
            {
                append Entity_Return ";";
                append Behavior_Return ";";
            }
            else
            {
                = Entity_Return (append 'return (' Entity_Return ');');
                = Behavior_Return (append 'return (' Behavior_Return ');');
            }
            string Behavior_Statements [indent]
                'if (defined [our Implementer])' [line, indent]
                '{' [line, indent 2]
                Behavior_Return [line, indent]
                '}' [line];
            if (and (defined [my Block]) (defined [my Block Fallback_Statements]))
            {
                append Behavior_Statements [my Block Fallback_Statements];
            }
            else
            {
                append Behavior_Statements [indent] 'error "' Behavior_Name ' implementer not defined.";' [line];
            }
            string Method
                'method ' Type ' ' Behavior_Name
                (i Fallback_Args)
                [line] '{' [line, indent]
                Entity_Return
                [line] '}';
            string Behavior_Code
                'class ' Entity_Behavior_Class ' [is Language_Behavior]' [line]
                '{' [line, indent]
                    'class property object Implementer;' [line, indent]
                    'class method ' Type ' Execute [object Owner]' (i Fallback_Args) [line, indent]
                    '{' [line]
                        (i Indent Behavior_Statements)
                    [indent] '}' [line]
                '}' [line];
            string Code
                Method;
            i= Code;
            my= Fallback_Declaration Behavior_Code;
        }
        generate Statement_Egg
        {
            string Name [my Name Fallback];
            string Ancestor ' [is Egg]';
            if (s= Name 'Egg')
            {
                = Ancestor '';
            }
            string Code 'class ' Name Ancestor (i Fallback_Block);
            i= Code;
        }
        generate Statement_Dialect
        {
            string Name [my Name Fallback];
            string Ancestor 'Dialect';
            if (defined [my Ancestor])
            {
                = Ancestor (append [my Ancestor Fallback] '_Dialect');
            }
            string Body '';
            string Fback 'my Name = ' (i Enquote Name) ';' [line];
            entity Statement;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    if (or (isa Statement Method_Statement)
                           (isa Statement Statement_Main))
                    {
                        append Body [. Statement Fallback] [line];
                    }
                    else
                    {
                        if (defined [. Statement Fallback_Declaration])
                        {
                            append Body [. Statement Fallback_Declaration] [line];
                        }
                        if (defined [. Statement Fallback])
                        {
                            append Fback [. Statement Fallback] [line];
                        }
                    }
                }
            }
            string Method
                'method flag Initialize'  [line] '{' [line, indent]
                    'object Element;' [line]
                    (i Indent Fback) [line, indent]
                    'return [true];' [line]
                    '}';

            = Body (i Indent Body);
            = Method (i Indent Method);
            string Code 'class Dialect_' Name ' [is ' Ancestor ']' [line] '{' [line]
                    (i Indent Method)
                    (i Indent Body)
                '}' [line];
            i= Code;
        }
        generate Statement_Statements
        {
            entity Arg;
            entity Tail;
            string Statement 'ERROR_UNKNOWN_STATEMENT';
            string Keyword 'ERROR_UNKNOWN_KEYWORD';
            string Code '';
            foreach [my Arguments] Tail
            {
                foreach [. Tail Elements] Arg
                {
                    if (isa Arg Token_Comma)
                    {
                        = Statement 'ERROR_UNKNOWN_STATEMENT';
                        = Keyword 'ERROR_UNKNOWN_KEYWORD';
                        continue;
                    }
                    if (isa Arg Token_Quote) {
                        = Keyword [. Arg Fallback];
                        append Code
                            'dict [my Statements] ' Keyword ' = Element;' [line];
                    }
                    else.if (isa Arg Token_Name) {
                        = Statement [. Arg Fallback];
                        append Code
                            'Element =  (new ' Statement ');' [line]
                            'list [my Elements] append Element;' [line];
                    }
                    else
                    {
                        error 'unexpected statements argument ' (. Arg Enquote (. Arg Get_Input));
                    }
                }
            }
            i= Code;
        }
        generate Statement_Operations
        {
            entity Arg;
            entity Tail;
            string Operation 'ERROR_UNKNOWN_OPERATION';
            string Keyword 'ERROR_UNKNOWN_KEYWORD';
            string Code '';
            foreach [my Arguments] Tail
            {
                foreach [. Tail Elements] Arg
                {
                    if (isa Arg Token_Comma)
                    {
                        = Operation 'ERROR_UNKNOWN_STATEMENT';
                        = Keyword 'ERROR_UNKNOWN_KEYWORD';
                        continue;
                    }
                    if (isa Arg Token_Quote) {
                        = Keyword [. Arg Fallback];
                        append Code
                            'dict [my Operations] ' Keyword ' = Element;' [line];
                    }
                    else.if (isa Arg Token_Name) {
                        = Operation [. Arg Fallback];
                        = Keyword Operation;
                        append Code
                            'Element =  (new ' Operation ');' [line]
                            'list [my Elements] append Element;' [line];
                    }
                    else
                    {
                        error 'unexpected statements argument ' (. Arg Enquote (. Arg Get_Input));
                    }
                }
            }
            i= Code;
        }
        generate Statement_Syntaxes
        {
            entity Arg;
            entity Tail;
            string Syntax 'ERROR_UNKNOWN_SYNTAX';
            string Keyword 'ERROR_UNKNOWN_KEYWORD';
            string Code '';
            foreach [my Arguments] Tail
            {
                foreach [. Tail Elements] Arg
                {
                    if (isa Arg Token_Comma)
                    {
                        = Syntax 'ERROR_UNKNOWN_STATEMENT';
                        = Keyword 'ERROR_UNKNOWN_KEYWORD';
                        continue;
                    }
                    if (isa Arg Token_Quote) {
                        = Keyword [. Arg Fallback];
                        append Code
                            'dict [my Syntaxes] ' Keyword ' = Element;' [line];
                    }
                    else.if (isa Arg Token_Name) {
                        = Syntax [. Arg Fallback];
                        append Code
                            'Element =  (new ' Syntax ');' [line]
                            'list [my Elements] append Element;' [line];
                    }
                    else
                    {
                        error 'unexpected statements argument ' (. Arg Enquote (. Arg Get_Input));
                    }
                }
            }
            i= Code;
        }
        generate Syntax_Implementers_Of
        {
            string Code '[' [my Goal_Name Fallback] ':Implementers]' ;
            i= Code;
        }
        generate Syntax_Try_At_Of
        {
            string Implementer [my Implementer Fallback];
            string Test [my Test Fallback];
            string Goal_Name [my Goal_Name Fallback];
            string Code 'todo "try ' Implementer ' at ' Test ' of ' Goal_Name '";';
            i= Code;
        }
        generate Statement_Given_An_In
        {
            string Variable [my Variable Fallback];
            string List [my List Fallback];
            string Code 'for each ' Variable ' in ' List (i Fallback_Block);
            i= Code;
        }
        generate Statement_To_Analyze
        {
            string Goal_Name [my Goal_Name Fallback];
            string Test [my Test Fallback];
            string Block (i Fallback_Block);
            string Code 'method flag Analyze ' Goal_Name ' ' Test Block;
            i= Code;
        }
        generate Statement_Generate_Gal
        {
            verbosity;
            verbose "Generate_Gal";
            string Code "comment 'generate gal statement';" [line]
                "string Output '';" [line];
            entity Argument;
            string Arg_Code;
            foreach [my Arguments] Argument
            {
                = Arg_Code (append 'append Output ' [. Argument Fallback] ';' [line]);
                append Code Arg_Code;
            }
            append Code 'my= Gal Output;' [line];
            verbose Code;
            i= Code;
        }
        generate Statement_Tilda
        {
            verbosity [true];
            string Keywords;
            join Keywords [my Gs_Keywords] ' ';
            replace Keywords '~' 'tilda';
            string Args (i Fallback_Arguments);
            string Title (titlecase Keywords);
            string Name Title;
            replace Name ' ' '_';
            string Code '';
            if (or (isa [my Parent] Statement_Tilda)
                   (isa [my Parent] Method_Statement))
            {
                append Code 'i ' Name Args ';';
            }
            else
            {
                append Code 'method void ' Name Args (i Fallback_Block);
            }
            verbose Code;
            i= Code;
        }
        generate Operation_Tilda
        {
            verbosity [true];
            string Keywords;
            join Keywords [my Gs_Keywords] ' ';
            replace Keywords '~' 'tilda';
            string Args (i Fallback_Arguments);
            string Title (titlecase Keywords);
            string Name Title;
            replace Name ' ' '_';
            string Code Keywords ' / ' Args ' / ' Title;
            debug;
            verbose Code;
            i= Code;
        }
        generate Syntax_Tilda
        {
            string Args (i Fallback_Arguments);
            string Code '[' Args '.Symbol_Value]';
            i= Code;
        }
        generate Statement_Test
        {
            string Name 'Test_' [my Name Fallback];
            string Block [line] '{' [line, indent]
                'verbosity [true];' [line, indent]
                'number Test_Count 0;' [line, indent]
                'number Test_Success 0;' [line]
                [my Block Fallback_Statements]
                [indent] 'number Test_Outcome 0;' [line]
                [indent] 'if (Test_Count > 0) { Test_Outcome = (Test_Success / Test_Count); }' [line]
                [indent] 'return Test_Outcome;' [line]
            '}';
            string Code 'method object ' Name Block;
            i= Code;
        }
        generate Statement_Expected_Output
        {
            string Arguments (i Fallback_Arguments);
            string Code
                'method flag Test' [line]
                '{' [line, indent]
                    'string Expected_Output ' Arguments ';' [line, indent]
                    'return ([output] s= Expected_Output);' [line]
                '}';
            i= Code;
        }
        generate Syntax_Output
        {
            todo 'a test dialect knows how to implement this?';
            string Code
                '[output]';
            i= Code;
        }
        generate Syntax_Language_Elements
            '[' Dialect '.Elements]';
        generate Operation_Can
            '(' Successor '.Can ' Predecessor ')';
        generate Operation_Then
            '(' Successor '.Then ' Predecessor ')';
        generate Statement_Synthesize
            'method void Synthesize [object ' Predecessor ', object ' Dialect ']' (i Fallback_Block);
        generate Statement_Hope
        {
            todo 'theory of hope';
            comment "whatever you put in here, it's just going to keep doing it.";
            verbosity;
            string Arguments (i Fallback_Arguments);
            string Name 'Hope ' Arguments;
            replace Name ' ' '_';
            string Block (i Fallback_Block);
            string Main 'main' [line]
            '{' [line, indent]
                'object M = (new ' Name ');' [line, indent]
                'M.Run;' [line]
            '}' [line];
            string Code
                'class ' Name ' [is Hope]'
                Block
                Main;
            i= Code;
        }
        generate Statement_I_Generate
        {
            integer Args (list.length [my Arguments]);
            string Value '';
            if (= Args 0)
            {
                = Value "''";
            }
            else.if (= Args 1)
            {
                = Value (i Fallback_Arguments);
            }
            else
            {
                append Value '(append' (i Fallback_Arguments) ')';
            }
            string Code "push [my Code] (new Element " Value ");";
            i= Code;
        }
        generate Statement_Element
        {
            verbosity;
            string Id [my Id Fallback];
            string Class_Name [my Class_Name Fallback];
            entity Tail;
            entity Elem;
            list Elems;
            string Code
                "Elem = (new " Class_Name ");" [line]
                "Elem.Id = " (i Enquote Id) ";" [line];
            verbose "Code: " [line] Code;
            integer Level;
            strings Property Pargs Arg_Code Between;
            foreach [my Listargs] Tail
            {
                = Level 0;
                = Property "";
                = Pargs "";
                foreach [. Tail Elements] Elem
                {
                    if (= Level 1)
                    {
                        = Property [. Elem Fallback];
                    }
                    else.if (gt Level 1)
                    {
                        append Pargs ' ' [. Elem Fallback];
                    }
                    increment Level;
                }
                if (gt Level 3)
                {
                    = Pargs (append ' (append' Pargs ')');
                }
                = Arg_Code (append
                    "Elem." Property " =" Pargs ";" [line]);
                verbose Arg_Code;
                append Code Arg_Code;
            }
            append Code "push [my Cases] Elem;" [line];
            verbose "element statement voila";
            i= Code;
        }
        generate Statement_Dial
            'class Dial_' Name ' [is Dial]' (i Fallback_Block);
        generate Statement_Test_Case
        {
            string Class_Name [my Class_Name Fallback];
            = Class_Name (i Enquote Class_Name);
            string Code 'Cases = (Test_Case:Lookup_Class ' Class_Name ');' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            comment append Code 'i Append Case;' [line];
            i= Code;
        }
        generate Statement_Gal_Equal
        {
            string Args (i Fallback_Arguments);
            string Expr '';
            if (gt (list.length [my Arguments]) 1)
            {
                append Expr ' (append' Args ')';
            }
            else
            {
                append Expr Args;
            }
            string Code 'Case = (Cases:Lookup_Case' Args ');';
            i= Code;
        }
        generate Statement_Raku_Equal
        {
            string Args (i Fallback_Arguments);
            string Code '';
            if (gt (list.length [my Arguments]) 1)
            {
                append Code 'Case.Raku = (append' Args ');';
            }
            else
            {
                append Code 'Case.Raku = ' Args ';';
            }
            i= Code;
        }
        generate Statement_Fallback_Equal
        {
            string Args (i Fallback_Arguments);
            string Code '';
            if (gt (list.length [my Arguments]) 1)
            {
                append Code 'Case.Fallback = (append' Args ');';
            }
            else
            {
                append Code 'Case.Fallback = ' Args ';';
            }
            i= Code;
        }
        generate Statement_Gs_Equal
        {
            string Args (i Fallback_Arguments);
            string Code '';
            if (gt (list.length [my Arguments]) 1)
            {
                append Code 'Case.Gs = (append' Args ');';
            }
            else
            {
                append Code 'Case.Gs = ' Args ';';
            }
            i= Code;
        }
        generate Statement_Python_Equal
        {
            string Args (i Fallback_Arguments);
            string Code '';
            if (gt (list.length [my Arguments]) 1)
            {
                append Code 'Case.Python = (append' Args ');';
            }
            else
            {
                append Code 'Case.Python = ' Args ';';
            }
            i= Code;
        }
        generate Statement_Javascript_Equal
        {
            string Args (i Fallback_Arguments);
            string Code '';
            if (gt (list.length [my Arguments]) 1)
            {
                append Code 'Case.Javascript = (append' Args ');';
            }
            else
            {
                append Code 'Case.Javascript = ' Args ';';
            }
            i= Code;
        }
        generate Statement_Experience
        {
            string Class_Name [my Class_Name Fallback];
            string My_Code [my Code Fallback];
            string Performance [my Performance Fallback];
            entity Arg;
            string Code
                'Item = (new Experience '
                (i Enquote Class_Name)
                ' ' My_Code ' ' Performance
                ');' [line]
                'push Experiences Item;';
            foreach [my Listargs] Arg
            {
                append Code [line] 'push [Item.Dials] ' [. Arg Fallback] ';' [line];
            }
            i= Code;
        }
        generate Statement_Know
        {
            string Input (i Get_Input);
            string Code "comment " (i Enquote Input) ";";
            i= Code;
        }
        generate Statement_Not
            Op1 ' = (not ' Op1 ');';

        generate Statement_Return_If
        {
            string Condition [my Condition Fallback];
            string Return_Value '';
            if (defined [my Return_Value])
            {
                append Return_Value ' ' [my Return_Value Fallback];
            }
            string Code
                'if ' Condition [line]
                '{' [line, indent]
                    'return ' Return_Value ';' [line]
                '}';
            i= Code;
        }

        generate Statement_Return_If_Gs
        {
            string Return_Code 'return';
            string Condition;
            if (defined [my Arg2])
            {
                = Condition [my Arg2 Fallback];
                append Return_Code ' ' [my Arg1 Fallback];
            }
            else
            {
                = Condition [my Arg1 Fallback];
            }
            string Code
                'if ' Condition [line]
                '{' [line, indent]
                    Return_Code ';' [line]
                '}';
            i= Code;
        }

        generate Literal [my Input];
        generate Statement_Mumps_Equal
        {
            string Args (i Fallback_Arguments);
            string Code '';
            if (gt (list.length [my Arguments]) 1)
            {
                append Code 'Case.Mumps = (append' Args ');' [line];
            }
            else
            {
                append Code 'Case.Mumps = ' Args ';' [line];
            }
            i= Code;
        }
        generate Statement_Gs
        {
            string Code
                'method void Infer_Gs' [line]
                '{' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            else
            {
                entity Argument;
                string Args_Code '';
                foreach [my Arguments] Argument
                {
                    if (isa Argument Token_Name)
                    {
                        append Args_Code ' ' (append '[my ' [. Argument Fallback] ' Reference]');
                    }
                    else
                    {
                        append Args_Code ' ' [. Argument Fallback];
                    }
                }
                append Code
                    [indent] 'string Code' Args_Code ';' [line]
                    [indent] 'my= Gs Code;' [line];
            }
            append Code '}' [line];
            i= Code;
        }
        generate Statement_Python
        {
            string Code
                'method void Infer_Python' [line]
                '{' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            else
            {
                entity Argument;
                string Args_Code '';
                foreach [my Arguments] Argument
                {
                    if (isa Argument Token_Name)
                    {
                        append Args_Code ' ' (append '[my ' [. Argument Fallback] ' Reference]');
                    }
                    else
                    {
                        append Args_Code ' ' [. Argument Fallback];
                    }
                }
                append Code
                    [indent] 'string Code' Args_Code ';' [line]
                    [indent] 'my= Python Code;' [line];
            }
            append Code '}' [line];
            i= Code;
        }
        generate Statement_Html
        {
            string Code
                'method void Infer_Html' [line]
                '{' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            else
            {
                entity Argument;
                string Args_Code '';
                foreach [my Arguments] Argument
                {
                    if (isa Argument Token_Name)
                    {
                        append Args_Code ' ' (append '[my ' [. Argument Fallback] ' Html]');
                    }
                    else
                    {
                        append Args_Code ' ' [. Argument Fallback];
                    }
                }
                append Code
                    [indent] 'string Code' Args_Code ';' [line]
                    [indent] 'my= Html Code;' [line];
            }
            append Code '}' [line];
            i= Code;
        }
        generate Statement_Javascript
        {
            string Code
                'method void Infer_Javascript' [line]
                '{' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            else
            {
                entity Argument;
                string Args_Code '';
                foreach [my Arguments] Argument
                {
                    if (isa Argument Token_Name)
                    {
                        append Args_Code ' ' (append '[my ' [. Argument Fallback] ' Reference]');
                    }
                    else
                    {
                        append Args_Code ' ' [. Argument Fallback];
                    }
                }
                append Code
                    [indent] 'string Code' Args_Code ';' [line]
                    [indent] 'my= Javascript Code;' [line];
            }
            append Code '}' [line];
            i= Code;
        }
        generate Statement_Fallback
        {
            string Code
                'method void Infer_Fallback' [line]
                '{' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            else
            {
                entity Argument;
                string Args_Code '';
                foreach [my Arguments] Argument
                {
                    if (isa Argument Token_Name)
                    {
                        append Args_Code ' ' (append '[my ' [. Argument Fallback] ' Reference]');
                    }
                    else
                    {
                        append Args_Code ' ' [. Argument Fallback];
                    }
                }
                append Code
                    [indent] 'string Code' Args_Code ';' [line]
                    [indent] 'my= Fallback Code;' [line];
            }
            append Code '}' [line];
            i= Code;
        }
        generate Statement_Mumps
        {
            string Code
                'method void Infer_Mumps' [line]
                '{' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            else
            {
                entity Argument;
                string Args_Code '';
                foreach [my Arguments] Argument
                {
                    if (isa Argument Token_Name)
                    {
                        append Args_Code ' ' (append '[my ' [. Argument Fallback] ' Reference]');
                    }
                    else
                    {
                        append Args_Code ' ' [. Argument Fallback];
                    }
                }
                append Code
                    [indent] 'string Code' Args_Code ';' [line]
                    [indent] 'my= Mumps Code;' [line];
            }
            append Code '}' [line];
            i= Code;
        }
        generate Statement_C
        {
            string Code
                'method void Infer_C' [line]
                '{' [line];
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            else
            {
                entity Argument;
                string Args_Code '';
                foreach [my Arguments] Argument
                {
                    if (isa Argument Token_Name)
                    {
                        append Args_Code ' ' (append '[my ' [. Argument Fallback] ' Reference]');
                    }
                    else
                    {
                        append Args_Code ' ' [. Argument Fallback];
                    }
                }
                append Code
                    [indent] 'string Code' Args_Code ';' [line]
                    [indent] 'my= C Code;' [line];
            }
            append Code '}' [line];
            i= Code;
        }
        generate Statement_Token_Test
        {
            string Code_Text [my Code_Text Fallback];
            string Token_Code "";
            entity Arg;
            integer Tnum 0;
            integer Arg_Count (list.length [my Listargs]);
            foreach [my Listargs] Arg
            {
                string Arg_Code [. Arg Fallback];
                append Token_Code
                    "Tok = (lget [D~Tokens] " Tnum ");" [line]
                    "if ((Tok.Get_Text) sne " Arg_Code ")" [line]
                    "{" [line, indent]
                        "Deviation += 1.0;" [line]
                    "}" [line];
                increment Tnum;
            }
            string Initial_Dev "Deviation += (abs ((llength [D~Tokens]) - " Arg_Count "));" [line];
            string Code
                "D = (new Document);" [line]
                "[D~Text] = " Code_Text ";" [line]
                "Status = (D.Characterize);" [line]
                "Status = (D.Tokenize);" [line]
                "if Status" [line]
                "{" [line, indent]
                    "try" [line]
                    "{" [line, indent]
                        Initial_Dev
                        Token_Code
                    "}" [line]
                    "catch" [line]
                    "{" [line, indent]
                        "Deviation += " (* Arg_Count 10) ";" [line]
                    "}" [line]
                "}" [line]
                "else" [line]
                "{" [line, indent]
                    "Deviation += " (* Arg_Count 2) ";" [line]
                "}" [line];
            i= Code;
        }
        generate Statement_Ohlc
        {
            string Trading_Pair [my Trading_Pair Fallback];
            string Epoch [my Epoch Fallback];
            string Open [my Open Fallback];
            string High [my High Fallback];
            string Low [my Low Fallback];
            string Close [my Close Fallback];
            string Vwap [my Vwap Fallback];
            string Volume [my Volume Fallback];
            string Count [my Count Fallback];
            string Code 'i Ohlc ' Trading_Pair ' ' Epoch ' ' Open ' ' High ' ' Low ' ' Close ' ' Vwap ' ' Volume ' ' Count ';';
            i= Code;
        }
        generate Operation_Outcome
        {
            string Amount [my Amount Fallback];
            string Code '(new Outcome ' Amount ')';
            i= Code;
        }
        generate Statement_Bias
        {
            verbosity [true];
            string Bias [my Bias Fallback];
            string Name [my Parent Name Fallback];
            string Code 'comment "Bias: ' Bias ' name ' Name '";';
            string Declaration
                `object F_` Name ` = (Function:Lookup ` (i Enquote Name) `);` [line]
                `F_` Name `.Bias = ` Bias `;`;
            my= Mumps_Declaration Declaration;
            i= Code;
        }
        generate Statement_Migrate
        {
            string Name [my Name Fallback];
            string Map [my Map Fallback];
            string Deferral [my Deferral Fallback];
            string My_Code [my Code Fallback];
            string Code
                `E = (new Element ` (i Enquote Name) ` ` Map ` ` Deferral ` ` My_Code `);` [line]
                `push Migration E;`;
            i= Code;
        }
        generate Statement_Outcome
        {
            string Result [my Result Fallback];
            string Implementer (i Enquote [my Implementer Fallback]);
            string Behavior [my Behavior Fallback];
            string Code '[' Behavior '.Roster].Insert ' Implementer ' ' Result;
            entity Arg;
            foreach [my Listargs] Arg
            {
                append Code ' ' [. Arg Fallback];
            }
            append Code ';';
            i= Code;
        }
        generate Statement_Retain
        {
            string Elem [my Element Fallback];
            string QE (i Enquote Elem);
            todo 'include name, predecessors, map, code';
            debug;
            string Code `comment ` (i Enquote (append 'migrate ' Elem)) `;
Name = [` Elem `.Name];
Map = [` Elem `.Map];
Supporters = [` Elem `.Supporters];
Code = [` Elem `.Code];
debug;
todo "export the code here.";
`;
            i= Code;
        }
        generate Statement_Alpha
        {
            string Identifier [my Identifier Fallback];
            string Performance [my Performance Fallback];
            string Code `Al = (Alpha:Lookup ` Identifier `);
Al.Performance = ` Performance `;
Ros.Alpha = Al;`;
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            i= Code;
        }
        generate Statement_Member
        {
            string Identifier [my Identifier Fallback];
            string Performance [my Performance Fallback];
            string Code `Mem = (Member:Lookup ` Identifier `);
Mem.Performance = ` Performance `;
push [Ros.Members] Mem;`;
            i= Code;
        }
        generate Statement_Interface
        {
            string Return_Type [my Return_Type Fallback];
            string Code `Int = (new Interface);
Int.Return_Type = ` (i Enquote Return_Type) `;
Ros.Interface = Int;`;
            string Arg_Code;
            entity Arg;
            foreach [my Listargs] Arg
            {
                = Arg_Code [. Arg Fallback];
                append Code [line] 'push [Int.Arguments] ' (i Enquote Arg_Code) ';';
            }
            i= Code;
        }
        generate Statement_Roster
        {
            string Capacity [my Capacity Fallback];
            string Floor [my Floor Fallback];
            string Code `Ros = (new Roster);
Ros.Capacity = ` Capacity `;
Ros.Floor = ` Floor `;
Red.Roster = Ros;`;
            if (defined [my Block])
            {
                append Code [my Block Fallback_Statements];
            }
            i= Code;
        }
        generate Statement_Class_Is
        {
            string Name [my Name Gs];
            string Ancestor_Class [my Ancestor_Class Gs];
            string Code 'class ' Name ' [is ' Ancestor_Class ']' (i Gs_Block);
            i= Code;
        }

        generate Statement_Infer
        {
            string Object 'i ';
            if (defined [my Object])
            {
                = Object [my Object Fallback];
            }
            string Inference "Infer_" (titlecase [my Inference Fallback]);
            string Code Object Inference (i Fallback_Args) ';';
            i= Code;
        }

        generate Statement_Dom_Object
        {
            string Class_Name [my Class_Name Fallback];
            string Block (i Fallback_Block);
            string Code
                "class " Class_Name " [is Dom_Object]"
                Block;
            i= Code;
        }
        generate Statement_Click
        {
            string Element_Name [my Element_Name Fallback];
            string Block (i Fallback_Block);
            string Code
                "method void Click [object " Element_Name "]"
                Block;
            i= Code;
        }
    }
flowerbox 'Canonical.gal';

class.append Element
{
    method string Canonical_Variables [string Text]
    {
        string D (int2char 31);
        if (contains Text D)
        {
            list.copy Items (split Text (int2char 31));
            string Between '';
            integer Number 64;
            string Item;
            string Code '';
            foreach Items Item
            {
                append Code Between Item;
                increment Number;
                = Between (int2char Number);
            }
            return Code;
        }
        return Text;
    }
}

class Canonical_Generator [is Generator]
{
    class.property integer Example_Number 0;
    infers Canonical;
    comment infers Parse;
    comment infers Generate;
    infers Canonical;
    attribute list Elements;
    attribute list Inferences;
    constructor [entity Owner]
    {
        my= Owner Owner;
    }
    method flag Initialize
    {
        verbosity;
        verbose [class.name] ' Inits';
        infer.inits;
        return [true];
    }
    classmethod string Next_Example
    {
        increment [: Canonical_Generator Example_Number];
        string Name "Example" [: Canonical_Generator Example_Number];
        return Name;
    }
}

class.append Named_Element
{
    method string Canonical_Arguments
    {
        string Code '';
        string Arg_Code;
        entity Arg;
        foreach [my Arguments] Arg
        {
            if (isa Arg Token_Comma)
            {
                continue;
            }
            = Arg_Code [. Arg Canonical];
            append Code ' ' Arg_Code;
        }
        return Code;
    }
    method string Canonical_Args
    {
        string Code '';
        string Arg_Code;
        entity Arg;
        foreach [my Listargs] Arg
        {
            = Arg_Code [. Arg Canonical];
            if (begins Arg_Code ',')
            {
                append Code Arg_Code;
            }
            else
            {
                append Code ' ' Arg_Code;
            }
        }
        return Code;
    }
    method string Canonical_Tails
    {
        string Code '';
        entity Tail;
        foreach [my Tails] Tail
        {
            debug;
            append Code (. Tail Canonical_Tail);
        }
        return Code;
    }
}

class.append Statement
{
    method string Canonical_Block
    {
        string Code ';';
        if (defined [my Block])
        {
            = Code [my Block Canonical];
        }
        return Code;
    }
    method string Canonical_Statements
    {
        string Return '';
        if (defined [my Block])
        {
            if (defined [my Block Canonical_Statements])
            {
                = Return [my Block Canonical_Statements];
            }
        }
        return Return;
    }
}

inference string Canonical
{
    generate Element
        [my Gs];

    generate Token_Quote
    {
        string U (i Unquoted);
        string Q (i Enquote U);
        i= Q;
    }

    generate Statement
    {
        string Keywords [my Gs_Keyword];
        string Name (title.case Keywords);
        replace Name ' ' '_';
        = Keywords (i Enquote Keywords);
        string Declaration
            'statement ' Name ' ' Keywords ';' [line]
            'symbol ' Name ';' [line]
            'spell ' Name ';' [line]
            ;
        if (not (or (contains Keywords '~') (contains Keyword 'tilda')))
        {
            append Declaration
                '~ ' Keywords ';' [line];
        }
        comment `my= Canonical_Declaration Declaration;`;

        string Code  (i Gs_Key) (i Canonical_Arguments) (i Canonical_Block);
        = Code (i Canonical_Variables Code);
        i= Code;
    }
    generate Operation
    {
        comment 'This is necessary, to ensure that most statements use the canonical of their elements.';
        string Code '(' (i Gs_Key) (i Canonical_Arguments) ')';
        = Code (i Canonical_Variables Code);
        i= Code;
    }

    generate Syntax
    {
        comment 'This is necessary, to ensure that most syntaxes use the canonical of their elements.';
        string Code '[' (i Gs_Key) (i Canonical_Arguments) ']';
        = Code (i Canonical_Variables Code);
        i= Code;
    }

    generate Syntax_Tail
    {
        comment 'This is necessary, to ensure that most syntaxes use the canonical of their elements.';
        string Code '[' (i Gs_Key) (i Canonical_Arguments) ']';
        = Code (i Canonical_Variables Code);
        i= Code;
    }


    generate Canonical_Generator
    {
        verbosity;
        my= Status [true];
        entity Elem;
        entity I;
        variant Error;
        flag Status [true];
        string EF;
        foreach [my.attribute Elements] Elem
        {
            forgive
            {
                = I [. Elem Classification];
                . I Infer_Gs;
                .= Elem Gs [. I Gs];
                . I Infer_Canonical;
            }
        }
        integer Number 0;
        foreach [my.attribute Elements] Elem
        {
            try
            {
                = I [. Elem Classification];
                verbose 'canonical generating ' [classname I];
                . I Infer_Gs;
                .= Elem Gs [. I Gs];
                & Status (. I Infer_Canonical);
                .= Elem Error [. I Error];
                .= Elem Canonical [. I Canonical];
                increment Number;
                verbose Number ' ' [class.name I] ': ' [. Elem Canonical] [line];
            }
            catch Error
            {
                = Status [false];
                .= I Error Error;
                .= Elem Error Error;
                string Error_Message Error;
                string EF 'error ' (. Elem Enquote Error_Message) ';';
                .= I Canonical EF;
                .= Elem Canonical EF;
                verbose 'Error canonical element ' Number
                    ': ' [classname I]
                    ', <' Error '>'
                    ', source ' (. I Get_Input);
            }
        }
        my= Status Status;
        returnif (not Status) Status;
        string Code '';
        foreach [my.attribute Elements] Elem
        {
            if (defined [. Elem Canonical])
            {
                append Code
                    'canonical '
                    [class.name Elem] ' '
                    (. Elem Enquote [. Elem Canonical])
                    ';' [line];
            }
        }
        i= Code;
        my= Code Code;
        return [my Status];
    }

    generate Block
    {
        string Lines '';
        entity Statement;
        foreach [my Statements] Statement
        {
            append Lines [. Statement Canonical] [line];            integer Number 0;

        }
        if (s= Lines '')
        {
            i= ';';
            my= Canonical_Statements '';
        }
        else
        {
            my= Canonical_Statements (i Indent Lines);
            string Code [line] '{' [line] [my Canonical_Statements] '}';
            i= Code;
        }
    }

    generate Statements
    {
        string Code '';
        entity Statement;
        string Between '';
        foreach [my Elements] Statement
        {
            s+ Code Between [. Statement Canonical];
            = Between [line];
        }
        i= Code;
    }

    generate Token_Name
    {
        string Code 'X';
        todo 'also data type specific F I N S O';
        if (and (defined [my Data_Type]) (defined [my Data_Type Symbol_Value]))
        {
            string DT [my Data_Type Symbol_Value];
            todo 'assign the token variable based on the data type.';
            debug;
        }
        i= Code;
    }
}
inference string Parse
{
    generate Element [my Fallback];

    generate Syntax_Count
    {
        string Minimum [my Minimum Parse];
        string Maximum [my Maximum Parse];
        debug;
        verbosity [true];
    }
        generate Statement_Sequence
        {
            string Declarations '';
            string Block 'comment ' (i Enquote (i Get_Input)) ';' [line]
                'integer Start [my Position];' [line]
                'list My_Elements;' [line];
            entity Argument;
            flag Excludes [false];
            foreach [my Listargs] Argument
            {
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                if (or (isa Argument Token_Quote) (isa Argument Syntax_Line))
                {
                    string Text [. Argument Fallback];
                    append Block 
                        'if (not (i Parse_Token My_Elements ' Text ')) { i Rollback Start (append "' [my Rule_Name Fallback] ' expected "' Text '"."); return [false]; }' [line];
                }
                else.if (isa Argument Token) 
                {
                    string Name [. Argument Fallback];
                    append Block 
                        'if (not (i Parse_' Name ' My_Elements)) { debug; i Rollback Start "' [my Rule_Name Fallback] ' expected ' Name '."; return [false]; }' [line];
                }
                else.if (isa Argument Syntax_Exclude)
                {
                    = Excludes [true];
                    append Block [. Argument Fallback] [line];
                }
                else
                {
                    append Block [. Argument Fallback] [line];
                }
            }
            append Block
                'integer End [my Position];' [line]
                'object Element (new ' [my Rule_Name Fallback] ');' [line]
                '.= Element Start_Position Start;' [line]
                '.= Element End_Position End;' [line]
                '.= Element Document [self];' [line]
                '.= Element Elements My_Elements;' [line]
                'i Add_Element Element;' [line]
                'list.append Parent_Elements Element;' [line]
                'return [true];' [line];
            if Excludes
            {
                = Block (append 'list Excluded;' [line] Block);
            }

            = Block (i Indent Block);
            string Code 'method flag Parse_' [my Rule_Name Fallback] 
                ' [list Parent_Elements]' [line] 
                '{' [line]
                Block
                '}';
            my= Fallback_Declarations Declarations;
            i= Code;
        }

        generate Syntax_Sequence
        {
            string Declarations '';
            todo 'the fallback is a reference to the named rule created by this syntax.';
            todo 'the fallback declaration is the sequence function generated by this code.';
            string My_Source (i Get_Input);
            string Rule_Name [my Rule_Name Fallback];
            string Block 'comment ' (i Enquote (i Get_Input)) ';' [line]
                'integer Start [my Position];' [line]
                'list My_Elements;' [line];
            entity Argument;
            flag Excludes [false];
            foreach [my Listargs] Argument
            {
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                if (or (isa Argument Token_Quote) (isa Argument Syntax_Line))
                {
                    string Text [. Argument Fallback];
                    append Block 
                        'if (not (i Parse_Token My_Elements ' Text ')) { i Rollback Start (append "' [my Rule_Name Fallback] ' expected "' Text '"."); return [false]; }' [line];
                }
                else.if (isa Argument Token) 
                {
                    string Name [. Argument Fallback];
                    append Block 
                        'if (not (i Parse_' Name ' My_Elements)) { debug; i Rollback Start "' [my Rule_Name Fallback] ' expected ' Name '."; return [false]; }' [line];
                }
                else.if (isa Argument Syntax_Exclude)
                {
                    = Excludes [true];
                    append Block [. Argument Fallback] [line];
                }
                else
                {
                    append Block [. Argument Fallback] [line];
                }
            }
            append Block
                'integer End [my Position];' [line]
                'object Element (new ' [my Rule_Name Fallback] ');' [line]
                '.= Element Start_Position Start;' [line]
                '.= Element End_Position End;' [line]
                '.= Element Document [self];' [line]
                '.= Element Elements My_Elements;' [line]
                'i Add_Element Element;' [line]
                'list.append Parent_Elements Element;' [line]
                'return [true];' [line];
            if Excludes
            {
                = Block (append 'list Excluded;' [line] Block);
            }

            = Block (i Indent Block);
            string Code 
                Declarations
                'method flag Parse_' Rule_Name
                ' [list Parent_Elements]' [line] 
                '{' [line]
                Block
                '}';
            my= Fallback_Declaration Code;
            i= Rule_Name;
        }

        generate Statement_Either
        {
            string Declarations '';
            string Block 'comment ' (i Enquote (i Get_Input)) ';' [line];
            entity Argument;
            foreach [my Listargs] Argument
            {
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                if (or (isa Argument Token_Quote) (isa Argument Syntax_Line))
                {
                    append Block 'returnif (i Parse_Token Parent_Elements ' [. Argument Fallback] ') [true];' [line];
                }
                else.if (isa Argument Token) 
                {
                    append Block 'returnif (i Parse_' [. Argument Fallback] ' Parent_Elements) [true];' [line];
                }
                else
                {
                    append Block [. Argument Fallback];
                }
            }
            = Block (i Indent Block);
            string Code 'method flag Parse_' [my Rule_Name Fallback] 
                ' [list Parent_Elements]' [line] 
                '{' [line]
                Block
                [indent] 'return [false];' [line]
                '}';
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Count
        {
            string Minimum [my Minimum Fallback];
            string Maximum [my Maximum Fallback];
            debug;
            verbosity [true];
        }

        generate Statement_Token
        {
            string Name [my Class_Name Fallback];
            string Code 
                'method flag Parse_' Name ' [list Parent_Elements]' [line]
                '{' [line]
                [indent] 'object Top_Token (. [self] Top_Token);' [line]
                [indent] 'returnif (not (isa Top_Token ' Name ')) [false];' [line]
                [indent] 'list.append Parent_Elements Top_Token;' [line]
                [indent] 'i Consume_Token;' [line]
                [indent] 'return [true];' [line]
                '}';
            i= Code;
        }

        generate Statement_Tokens
        {
            string Code '';
            entity Argument;
            string Between '';
            foreach [my Arguments] Argument
            {
                string Name [. Argument Fallback];
                append Code Between
                    'method flag Parse_' Name ' [list Parent_Elements]' [line]
                    '{' [line]
                    [indent] 'object Top_Token (. [self] Top_Token);' [line]
                    [indent] 'returnif (not (isa Top_Token ' Name ')) [false];' [line]
                    [indent] 'list.append Parent_Elements Top_Token;' [line]
                    [indent] 'i Consume_Token;' [line]
                    [indent] 'return [true];' [line]
                    '}';
                    = Between [line];
            }
            i= Code;
        }

        generate Syntax_Repeating
        {
            string Declarations '';
            string Rule [my Rule Fallback];
            string Self_Call '(i Parse_' Rule ' My_Elements)';
            if (or (isa [my Rule] Token_Quote) (isa [my Rule] Syntax_Line))
            {
                = Self_Call (append '(i Parse_Token My_Elements ' Rule ')');
                if (defined [my Rule Fallback_Declaration])
                {
                    append Declarations [my Rule Fallback_Declaration];
                }
            }
            string Code 
                'comment `repeating ' Rule '`;' [line]
                'returnif (not ' Self_Call ') [false];' [line]
                'forever' [line] 
                '{' [line,
                indent] 'breakif (not ' Self_Call ');' [line]
                '}';
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Optional
        {
            string Declarations '';
            string Rule [my Rule Fallback];
            string Self_Call 'i Parse_' Rule ' My_Elements;';
            if (or (isa [my Rule] Token_Quote) (isa [my Rule] Syntax_Line))
            {
                = Self_Call (append 'i Parse_Token My_Elements ' Rule ';');
                if (defined [my Rule Fallback_Declaration])
                {
                    append Declarations [my Rule Fallback_Declaration];
                }
            }
            string Code 
                'comment `optional ' Rule '`;' [line]
                Self_Call;
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Optrep
        {
            string Declarations '';
            string Rule [my Rule Fallback];
            string Defines '';
            string Self_Call '(i Parse_' Rule ' My_Elements)';
            if (or (isa [my Rule] Token_Quote) (isa [my Rule] Syntax_Line))
            {
                = Self_Call (append '(i Parse_Token My_Elements ' Rule ')');
                if (defined [my Rule Fallback_Declaration])
                {
                    append Declarations [my Rule Fallback_Declaration];
                }
            }
            string Code
                'comment ' (i Enquote (i Get_Input)) ';' [line]
                'forever' [line] 
                '{' [line,
                indent] 'breakif (not ' Self_Call ');' [line]
                '}';
            if (defined [my Rule Fallback_Declaration])
            {
                my= Fallback_Declaration [my Rule Fallback_Declaration];
            }
            my= Fallback_Declaration Declarations;
            i= Code;
        }

        generate Syntax_Exclude
        {
            string Declarations '';
            string Args (i Fallback_Args);
            string Code 'comment "[exclude ' Args ']";' [line];
            entity Argument;
            foreach [my Arguments] Argument
            {
                if (defined [. Argument Fallback_Declaration])
                {
                    append Declarations [. Argument Fallback_Declaration];
                }
                comment "rule name tokens are required here, right?";
                append Code 'return if ([self].Parse_' [. Argument Fallback] ' Excluded) [false];' [line];
            }
            my= Fallback_Declaration Declarations;
            i= Code;
        }
}

inference string Generate
{
    generate Element [my Fallback];

    generate Syntax_Count
    {
        string Minimum [my Minimum Generate];
        string Maximum [my Maximum Generate];
        debug;
        verbosity [true];
        i= Code;
    }

    generate Statement_Sequence
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Syntax_Sequence
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Statement_Either
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Syntax_Count
    {
        string Minimum [my Minimum Fallback];
        string Maximum [my Maximum Fallback];
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Statement_Token
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Statement_Tokens
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Syntax_Repeating
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Syntax_Optional
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Syntax_Optrep
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

    generate Syntax_Exclude
    {
        debug;
        verbosity [true];
        string Code 'todo';
        i= Code;
    }

}comment [line] "********" [line] '* BNF.gs' [line] "********" [line];
goal.spell BNF `Backus Naur Format`
{
    dialect BNF;
    class BNF_Parser
    {
        infers Tokens;
        infers Elements;
        property object Dialect Dialect_BNF;
        property object Inferences (new List [self]);
        property object Tokens (new List [self]);
        property object Elements (new List [self]);
        property integer Position 0;
        constructor [entity Owner]
        {
            my= Owner Owner;
            my= Dialect (new Dialect_BNF);
        }
        method flag Initialize
        {
            verbosity [true];
            verbose [class.name] 'Inits';
            . [my Dialect] Initialize;
            infer.inits;
            return [true];
        }
    }
    class BNF_Parser [is Parser]
    {
        method flag Parse_Token [list Parent_Elements]
        {
            entity Top_Token (. [self] Top_Token);
            if (not (isa Top_Token Token))
            {
                return [false];
            }
            push Parent_Elements Top_Token;
            i Consume_Token;
            return [true];
        }
        method flag Parse_Name_Token [list Parent_Elements]
        {
            entity Top_Token (. [self] Top_Token);
            if (not (isa Top_Token Name_Token))
            {
                return [false];
            }
            push Parent_Elements Top_Token;
            i Consume_Token;
            return [true];
        }
        method flag Parse_Token_Quote [list Parent_Elements]
        {
            entity Top_Token (. [self] Top_Token);
            if (not (isa Top_Token Token_Quote))
            {
                return [false];
            }
            push Parent_Elements Top_Token;
            i Consume_Token;
            return [true];
        }
        method flag Parse_Token_Comment [list Parent_Elements]
        {
            entity Top_Token (. [self] Top_Token);
            if (not (isa Top_Token Token_Comment))
            {
                return [false];
            }
            push Parent_Elements Top_Token;
            i Consume_Token;
            return [true];
        }
        method flag Parse_Program [list Parent_Elements]
        {
            comment "sequence Program";
            integer Start [my Position];
            list My_Elements;
            comment `repeating Rule`;
            if (not (i Parse_Rule My_Elements))
            {
                return [false];
            }
            forever
            {
                if (not (i Parse_Rule My_Elements))
                {
                    break;
                }
            }
            integer End [my Position];
            entity Element (new Program);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_Rule [list Parent_Elements]
        {
            comment "either Rule";
            if (i Parse_Sequence_Rule Parent_Elements)
            {
                return [true];
            }
            if (i Parse_Either_Rule Parent_Elements)
            {
                return [true];
            }
            if (i Parse_Ending_Comment Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_Sequence_Rule [list Parent_Elements]
        {
            comment "sequence Sequence_Rule";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_Rule_Name My_Elements))
            {
                debug;
                i Rollback Start "Sequence_Rule expected Rule_Name.";
                return [false];
            }
            if (not (i Parse_Token My_Elements "::="))
            {
                debug;
                i Rollback Start (append "Sequence_Rule expected " "::=" ".");
                return [false];
            }
            comment `repeating Term`;
            if (not (i Parse_Term My_Elements))
            {
                return [false];
            }
            forever
            {
                if (not (i Parse_Term My_Elements))
                {
                    break;
                }
            }
            if (not (i Parse_Line_End My_Elements))
            {
                debug;
                i Rollback Start "Sequence_Rule expected Line_End.";
                return [false];
            }
            integer End [my Position];
            entity Element (new Sequence_Rule);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_Either_Rule [list Parent_Elements]
        {
            comment "sequence Either_Rule";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_Rule_Name My_Elements))
            {
                debug;
                i Rollback Start "Either_Rule expected Rule_Name.";
                return [false];
            }
            if (not (i Parse_Token My_Elements "::="))
            {
                debug;
                i Rollback Start (append "Either_Rule expected " "::=" ".");
                return [false];
            }
            if (not (i Parse_Term My_Elements))
            {
                debug;
                i Rollback Start "Either_Rule expected Term.";
                return [false];
            }
            comment `repeating Either_Tail`;
            if (not (i Parse_Either_Tail My_Elements))
            {
                return [false];
            }
            forever
            {
                if (not (i Parse_Either_Tail My_Elements))
                {
                    break;
                }
            }
            if (not (i Parse_Line_End My_Elements))
            {
                debug;
                i Rollback Start "Either_Rule expected Line_End.";
                return [false];
            }
            integer End [my Position];
            entity Element (new Either_Rule);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_Either_Tail [list Parent_Elements]
        {
            comment "sequence Either_Tail";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_Token My_Elements "|"))
            {
                debug;
                i Rollback Start (append "Either_Tail expected " "|" ".");
                return [false];
            }
            if (not (i Parse_Term My_Elements))
            {
                debug;
                i Rollback Start "Either_Tail expected Term.";
                return [false];
            }
            integer End [my Position];
            entity Element (new Either_Tail);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_Term [list Parent_Elements]
        {
            comment "either Term";
            if (i Parse_Token_Quote Parent_Elements)
            {
                return [true];
            }
            if (i Parse_Rule_Name Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_Rule_Name [list Parent_Elements]
        {
            comment "sequence Rule_Name";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_Token My_Elements "<"))
            {
                debug;
                i Rollback Start (append "Rule_Name expected " "<" ".");
                return [false];
            }
            if (not (i Parse_Name_Token My_Elements))
            {
                debug;
                i Rollback Start "Rule_Name expected Name_Token.";
                return [false];
            }
            if (not (i Parse_Token My_Elements ">"))
            {
                debug;
                i Rollback Start (append "Rule_Name expected " ">" ".");
                return [false];
            }
            integer End [my Position];
            entity Element (new Rule_Name);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_Line_End [list Parent_Elements]
        {
            comment "either Line_End";
            if (i Parse_Ending_Comment Parent_Elements)
            {
                return [true];
            }
            if (i Parse_Ending_Line Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_Ending_Comment [list Parent_Elements]
        {
            comment "sequence Ending_Comment";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_Token_Comment My_Elements))
            {
                debug;
                i Rollback Start "Ending_Comment expected Token_Comment.";
                return [false];
            }
            comment `optional.repeating [line]`;
            forever
            {
                if (not (i Parse_Token My_Elements [line]))
                {
                    break;
                }
            }
            integer End [my Position];
            entity Element (new Ending_Comment);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_Ending_Line [list Parent_Elements]
        {
            comment "sequence Ending_Line";
            integer Start [my Position];
            list My_Elements;
            comment `repeating [line]`;
            if (not (i Parse_Token My_Elements [line]))
            {
                return [false];
            }
            forever
            {
                if (not (i Parse_Token My_Elements [line]))
                {
                    break;
                }
            }
            integer End [my Position];
            entity Element (new Ending_Line);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
    }
    class ANTLR_BNF_Parser
    {
        infers Tokens;
        infers Elements;
        property object Dialect Dialect_BNF;
        property object Inferences (new List [self]);
        property object Tokens (new List [self]);
        property object Elements (new List [self]);
        property integer Position 0;
        constructor [entity Owner]
        {
            my= Owner Owner;
            my= Dialect (new Dialect_BNF);
        }
        method flag Initialize
        {
            verbosity [true];
            verbose [class.name] 'Inits';
            . [my Dialect] Initialize;
            infer.inits;
            return [true];
        }
    }
    class EBNF [is Element];
    class EBNF_Rulelist [is EBNF];
    class EBNF_Rule [is EBNF];
    class EBNF_Lhs [is EBNF];
    class EBNF_Rhs [is EBNF];
    class EBNF_Alternatives [is EBNF];
    class EBNF_Alternative [is EBNF];
    class EBNF_Bar_Tail [is EBNF];
    class EBNF_BAR [is EBNF];
    class EBNF_Element [is EBNF];
    class EBNF_Optional [is EBNF];
    class EBNF_Zeroormore [is EBNF];
    class EBNF_Text [is EBNF];
    class EBNF_ID [is EBNF];
    class EBNF_REND [is EBNF];
    class EBNF_LEND [is EBNF];
    class EBNF_LT [is EBNF];
    class EBNF_GT [is EBNF];
    class EBNF_Ruleid [is EBNF];
    class EBNF_RBRACE [is EBNF];
    class EBNF_LBRACE [is EBNF];
    class EBNF_RPAREN [is EBNF];
    class EBNF_LPAREN [is EBNF];
    class ANTLR_BNF_Parser
    {
        property object Dialect Dialect_Gs;
        property object Inferences (new List [self]);
        property object Tokens (new List [self]);
        property object Elements (new List [self]);
        property integer Position 0;
        constructor [entity Owner]
        {
            my= Owner Owner;
            my= Dialect (new Dialect_Gs);
        }
        method flag Initialize
        {
            verbosity [true];
            verbose [class.name] ' Inits';
            . [my Dialect] Initialize;
            infer.inits;
            return [true];
        }
    }
    class.append ANTLR_BNF_Parser
    {
        method flag Infer_Tokens
        {
            entity O [my Owner];
            verbosity [true];
            string Ignore;
            string Mode;
            string C;
            string Next;
            string Q '';
            integer Position;
            string Input [my Owner Input Symbol_Value];
            verbose "Input: " Input;
            integer Last (- (length Input) 1);
            tokenmode Initial;
            entity T;
            string Field_Boundaries [line] ',' '"';
            for.range Position 0 Last 1
            {
                = Next (substring Input Position 2);
                = C (firstchar Next);
                verbose Mode ' [' C ']';
                if (= Position Last)
                {
                    = Next '';
                }
                else
                {
                    = Next (lastchar Next);
                }
                if (s= Mode 'Initial')
                {
                    comment 'skip other handlers';
                }
                else.if (s= Mode 'Field')
                {
                    if (contains Field_Boundaries Char)
                    {
                        token mode Initial;
                    }
                    else
                    {
                        token append T Char Char;
                    }
                }
                else.if (s= Mode 'Quote')
                {
                    token append T Char Char;
                    if (and (s= Char '\') (s= Next '"'))
                    {
                        token mode Escape_Quote;
                        continue;
                    }
                    if (and (s= Char '"') (s= Next '"'))
                    {
                        token mode Escape_Quote;
                        continue;
                    }
                    if (s= Char '"')
                    {
                        token mode Initial;
                        continue;
                    }
                }
                else.if (s= Mode 'Escape_Quote')
                {
                    token append T Char Char;
                    token mode Quote;
                    continue;
                }
                else
                {
                    debug;
                    error 'Unknown Token Mode ' Mode;
                }
                comment 'this must go at the end to allow other handlers to delegate to Initial mode.';
                if (s= Mode 'Initial')
                {
                    if (and (s= Char '/') (s= Next '*'))
                    {
                        = T (new Token_Comment [self] Char Position Position);
                        push [my Tokens Symbol_Value] T;
                        = Mode 'Comment';
                    }
                    else.if (contains ":;()?+*|()[]{}<->~" Char)
                    {
                        = T (new Token_Punct [self] Char Position Position);
                        push [my Tokens Symbol_Value] T;
                        = Mode 'Initial';
                    }
                    else.if (or (s= Char '"') (s= Char '`') (s= Char "'"))
                    {
                        = T (new Token_Quote [self] Char Position Position);
                        push [my Tokens Symbol_Value] T;
                        = Mode 'Quote';
                    }
                    else.if (s= Char '\')
                    {
                        = T (new Token_Escape [self] Char Position Position);
                        push [my Tokens Symbol_Value] T;
                        = Mode 'Escape';
                    }
                    else.if (isident Char)
                    {
                        = T (new Token_Ident [self] Char Position Position);
                        push [my Tokens Symbol_Value] T;
                        = Mode 'Ident';
                    }
                    else.if (is.whitespace Char)
                    {
                        = T (new Token_Whitespace [self] Char Position Position);
                        comment `Whitespace tokens are not appended to the token list.`;
                        = Mode 'Whitespace';
                    }
                    else
                    {
                        debug;
                    }
                }
            }
            if Verbose
            {
                integer Position 0;
                foreach [my Tokens Symbol_Value] T
                {
                    verbose Position ' ' [class.name T] ' ' [. T Input];
                    increment Position;
                }
            }
        }
    }
    class ANTLR_BNF_Parser [is Parser]
    {
        method flag Parse_Program [list Parent_Elements]
        {
            comment "either Program";
            if (i Parse_EBNF_Rulelist Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_EBNF_Rulelist [list Parent_Elements]
        {
            comment "sequence EBNF_Rulelist";
            integer Start [my Position];
            list My_Elements;
            comment `optional.repeating EBNF_Rule`;
            forever
            {
                if (not (i Parse_EBNF_Rule My_Elements))
                {
                    break;
                }
            }
            if (not (i Parse_EOF My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Rulelist expected EOF.";
                return [false];
            }
            integer End [my Position];
            entity Element (new EBNF_Rulelist);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_EBNF_Rule [list Parent_Elements]
        {
            comment "sequence EBNF_Rule";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_EBNF_Lhs My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Rule expected EBNF_Lhs.";
                return [false];
            }
            if (not (i Parse_Token My_Elements ':'))
            {
                debug;
                i Rollback Start (append "EBNF_Rule expected " ':' ".");
                return [false];
            }
            if (not (i Parse_EBNF_Rhs My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Rule expected EBNF_Rhs.";
                return [false];
            }
            integer End [my Position];
            entity Element (new EBNF_Rule);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_EBNF_Lhs [list Parent_Elements]
        {
            comment "either EBNF_Lhs";
            if (i Parse_EBNF_ID Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_EBNF_Rhs [list Parent_Elements]
        {
            comment "either EBNF_Rhs";
            if (i Parse_EBNF_Alternatives Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_EBNF_Alternatives [list Parent_Elements]
        {
            comment "sequence EBNF_Alternatives";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_EBNF_Alternative My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Alternatives expected EBNF_Alternative.";
                return [false];
            }
            comment `optional.repeating EBNF_Bar_Tail`;
            forever
            {
                if (not (i Parse_EBNF_Bar_Tail My_Elements))
                {
                    break;
                }
            }
            integer End [my Position];
            entity Element (new EBNF_Alternatives);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_EBNF_Alternative [list Parent_Elements]
        {
            comment "either EBNF_Alternative";
            comment `optional.repeating EBNF_Element`;
            forever
            {
                if (not (i Parse_EBNF_Element My_Elements))
                {
                    break;
                }
            }
            return [false];
        }
        method flag Parse_EBNF_Element [list Parent_Elements]
        {
            comment "either EBNF_Element";
            if (i Parse_EBNF_Optional Parent_Elements)
            {
                return [true];
            }
            if (i Parse_EBNF_Zeroormore Parent_Elements)
            {
                return [true];
            }
            if (i Parse_EBNF_Text Parent_Elements)
            {
                return [true];
            }
            if (i Parse_EBNF_ID Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_EBNF_Optional [list Parent_Elements]
        {
            comment "sequence EBNF_Optional";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_EBNF_REND My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Optional expected EBNF_REND.";
                return [false];
            }
            if (not (i Parse_EBNF_Alternatives My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Optional expected EBNF_Alternatives.";
                return [false];
            }
            if (not (i Parse_EBNF_LEND My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Optional expected EBNF_LEND.";
                return [false];
            }
            integer End [my Position];
            entity Element (new EBNF_Optional);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_EBNF_Zeroormore [list Parent_Elements]
        {
            comment "sequence EBNF_Zeroormore";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_EBNF_RBRACE My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Zeroormore expected EBNF_RBRACE.";
                return [false];
            }
            if (not (i Parse_EBNF_Alternatives My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Zeroormore expected EBNF_Alternatives.";
                return [false];
            }
            if (not (i Parse_EBNF_LBRACE My_Elements))
            {
                debug;
                i Rollback Start "EBNF_Zeroormore expected EBNF_LBRACE.";
                return [false];
            }
            integer End [my Position];
            entity Element (new EBNF_Zeroormore);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_Oneormore [list Parent_Elements]
        {
            comment "sequence Oneormore";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_EBNF_RPAREN My_Elements))
            {
                debug;
                i Rollback Start "Oneormore expected EBNF_RPAREN.";
                return [false];
            }
            if (not (i Parse_EBNF_Alternatives My_Elements))
            {
                debug;
                i Rollback Start "Oneormore expected EBNF_Alternatives.";
                return [false];
            }
            if (not (i Parse_EBNF_LPAREN My_Elements))
            {
                debug;
                i Rollback Start "Oneormore expected EBNF_LPAREN.";
                return [false];
            }
            integer End [my Position];
            entity Element (new Oneormore);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_EBNF_Text [list Parent_Elements]
        {
            comment "either EBNF_Text";
            if (i Parse_EBNF_ID Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
        method flag Parse_EBNF_ID [list Parent_Elements]
        {
            comment "sequence EBNF_ID";
            integer Start [my Position];
            list My_Elements;
            if (not (i Parse_EBNF_LT My_Elements))
            {
                debug;
                i Rollback Start "EBNF_ID expected EBNF_LT.";
                return [false];
            }
            if (not (i Parse_EBNF_Ruleid My_Elements))
            {
                debug;
                i Rollback Start "EBNF_ID expected EBNF_Ruleid.";
                return [false];
            }
            if (not (i Parse_EBNF_GT My_Elements))
            {
                debug;
                i Rollback Start "EBNF_ID expected EBNF_GT.";
                return [false];
            }
            integer End [my Position];
            entity Element (new EBNF_ID);
            .= Element Start_Position Start;
            .= Element End_Position End;
            .= Element Document [self];
            .= Element Elements My_Elements;
            i Add_Element Element;
            push Parent_Elements Element;
            return [true];
        }
        method flag Parse_EBNF_Ruleid [list Parent_Elements]
        {
            comment "either EBNF_Ruleid";
            if (i Parse_EBNF_ID Parent_Elements)
            {
                return [true];
            }
            return [false];
        }
    }
    class Bnf_Gs_Generator [is Generator]
    {
        infers Gs;
        property object Elements (new List [self]);
        property object Inferences (new List [self]);
        constructor [entity Owner]
        {
            my= Owner Owner;
        }
        method flag Initialize
        {
            verbosity;
            verbose [class.name] ' Inits';
            infer.inits;
            return [true];
        }
    }
    inference string Bnf_Gs
    {
        class.append EBNF_Rulelist
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Rule
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Lhs
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Rhs
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Alternatives
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Alternative
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Bar_Tail
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_BAR
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Element
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Optional
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Zeroormore
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Text
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_ID
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_REND
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_LEND
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_LT
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_GT
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_Ruleid
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_RBRACE
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_LBRACE
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_RPAREN
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
        class.append EBNF_LPAREN
        {
            method flag Infer_
            {
                string Input (i Get_Input);
                debug;
            }
        }
    }
}
inference string Mumps
{
}

class Mumps
{
    class.property integer Label_Number 0;
    class.property integer Variable_Number 0;
    class.property entity Current_Class;
    class.method string Get_Label
    {
        increment [: Mumps Label_Number];
        string Label 'L' [: Mumps Label_Number];
        return Label;
    }
    class.method string Get_Variable
    {
        increment [: Mumps Variable_Number];
        string Var_Ref '%(' [: Mumps Variable_Number] ')';
        return Var_Ref;
    }
    class.method string Get_Reference [string Mumps]
    {
        verbosity [true];
        if (s= (substring Mumps 0 5) '$name')
        {
            return Mumps;
        }
        string Code '$name(' Mumps ')';
        verbose 'Mumps:Get_Reference ' Mumps;
        return Code;
    }
    class.method string De_Reference [string Mumps]
    {
        string Code '@(' Mumps ')';
        return Code;
    }
    class.method string Add_Subscripts [string Root, string Subscripts]
    {
        string Code '@' Root '@(' Subscripts ')';
        return Code;
    }

    class.method string Glvn [string Input]
    {
        verbosity;
        verbose '          >>> glvn ' Input;
        return Input;
    }
    class.method string String [string Input]
    {
        verbosity;
        string Code Input;
        if (s= (firstchar Code) '@')
        {
            = Code (append '$name(' Code ')');
        }
        verbose '          >>> string ' Code;
        return Code;
    }
}

class Mumps_File [is File]
{
    method flag Say
    {
        verbosity;
        entity Parent [my Symbol_Object];
        entity Generator [. Parent Generator];
        entity Elements [. Generator Elements Symbol_Value];
        entity Elem;
        entity Imp;
        string Class_Name;
        string File_Name;
        flag Genfile;
        foreach Elements Elem
        {
            = Imp [. Elem Classification];
            contif (isnull Imp);
            = Genfile (or (isa Imp Class_Statement) (isa Imp Statement_Module));
            contif (not Genfile);
            = [: Mumps Current_Class] Imp;
            . Imp Re_Mumps;
            try
            {
                = Class_Name [. Imp Name Mumps];
            }
            catch Error
            {
                = Class_Name [. Imp Class_Name];
            }
            = File_Name (append '/tmp/ramdisk/m/' Class_Name '.m');
            try
            {
                verbose "Writing " File_Name;
                file.dump [. Imp Mumps] File_Name;
            }
            catch Error
            {
                say "ERROR: " Error " creating file " File_Name;
            }
        }
        return [true];
    }
}

class.append Element
{
    property string Mumps '';
    property string Mumps_Declaration '';
    property string Mumps_Outer_Declaration '';
    method string Mq [string Unquoted]
    {
        if (contains Unquoted '"')
        {
            replace Unquoted '"' '""';
        }
        if (contains Unquoted [line])
        {
            string Repl '"_$char(10)_"';
            replace Unquoted [line] Repl;
        }
        return (append '"' Unquoted '"');
    }
    method string Matom
    {
        return [my Mumps];
    }
    method flag Infer_Mumps
    {
        verbosity;
        string Code '<' [class.name] '>';
        verbose '*** Warning, no mumps handler for ' [class.name] ' ***';
        my= Mumps Code;
    }
    method flag Re_Mumps
    {
        i Infer_Mumps;
    }
    method entity Mumps_Class
    {
        entity C [: Mumps Current_Class];
        if (isnull C)
        {
            = C (i Get_Class_Context);
        }
        return C;
    }
}
class.append Named_Element
{
    method string Mumps_Arguments [string Delim ',']
    {
        string Code '';
        string Comma '';
        entity Argument;
        string Between '';
        foreach [my Arguments] Argument
        {
            s+ Code Between [. Argument Mumps];
            = Between Delim;
        }
        return Code;
    }
    method string Mumps_Listargs [string Delim ',']
    {
        string Code '';
        string Comma '';
        entity Argument;
        string Between '';
        foreach [my Listargs] Argument
        {
            s+ Code Between [. Argument Mumps];
            = Between Delim;
        }
        return Code;
    }
    method flag Re_Mumps
    {
        entity Elem;
        foreach [my Arguments] Elem
        {
            . Elem Re_Mumps;
        }
        i Infer_Mumps;
    }
}

class.append Operation
{
    method string Mbinop [entity Arg1, string Oper, entity Arg2]
    {
        string Code
            [. Arg1 Mumps] Oper (. Arg2 Matom);
        return Code;
    }
    method string Mrepeating [string Oper]
    {
        string Code '';
        entity Arg;
        flag First [true];
        foreach [my Arguments] Arg
        {
            if First
            {
                append Code  [. Arg Mumps];
                = First [false];
            }
            else
            {
                append Code Oper (. Arg Matom);
            }
        }
        my= Mumps Code;
    }
}

class.append Binary_Operation
{
    method string Matom
    {
        return (append '(' [my Mumps] ')');
    }
}

class.append Block
{
    property string Mumps_Statements;
    method flag Infer_Mumps
    {
        string Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            append Code [. Statement Mumps];
        }
        my= Mumps Code;
        my= Mumps_Statements Code;
    }
    method flag Re_Mumps
    {
        entity Elem;
        foreach [my Statements] Elem
        {
            . Elem Re_Mumps;
        }
        i Infer_Mumps;
    }
}
class.append Statement
{
    method string Mumps_Block
    {
        if (not (defined [my Block]))
        {
            return '';
        }
        return [my Block Mumps];
    }
    method string Mumps_Statements
    {
        returnif (defined [my Block]) [my Block Mumps_Statements];
        return '';
    }
    method flag Re_Mumps
    {
        entity Elem;
        foreach [my Arguments] Elem
        {
            . Elem Re_Mumps;
        }
        if (defined [my Block])
        {
            . [my Block] Re_Mumps;
        }
        i Infer_Mumps;
    }
}

class.append Statement
{
    method flag Break_Label
    {
        return (. [my Parent] Break_Label);
    }
    method flag Continue_Label
    {
        return (. [my Parent] Continue_Label);
    }
}

class.append Iterative_Statement
{
    property string Break_Lbl;
    property string Continue_Lbl;
    method flag Break_Label
    {
        if (defined [my Break_Lbl])
        {
            return [my Break_Lbl];
        }
        my= Break_Lbl (: Mumps Get_Label);
        return [my Break_Lbl];
    }
    method flag Continue_Label
    {
        if (defined [my Continue_Lbl])
        {
            return [my Continue_Lbl];
        }
        my= Continue_Lbl (: Mumps Get_Label);
        return [my Continue_Lbl];
    }
}

class.append Token
{
    method flag Infer_Mumps
    {
        string Code [my Input];
        replace Code '_' '';
        my= Mumps Code;
    }
}

class.append Token_Name
{
    method flag Infer_Mumps
    {
        string Code [my Input];
        replace Code '_' '';
        my= Mumps Code;
    }
}

class.append Block
{
    method flag Infer_Mumps
    {
        todo 'Block in mumps';
        string Code '';
        entity Statement;
        foreach [my Statements] Statement
        {
            s+ Code [. Statement Mumps];
        }
        my= Mumps_Statements Code;
        my= Mumps Code;
    }
}

class.append Statement_Write_Line
{
    method flag Infer_Mumps
    {
        string Code [indent] 'use $principal write ' (i Mumps_Arguments) ',!' [line];
        my= Mumps Code;
    }
}
class.append Statement_Main
{
    method flag Infer_Mumps
    {
        string Code 'main(' (i Mumps_Arguments) ') ; main program' [line] (i Mumps_Block) [indent] 'quit' [line];
        my= Mumps Code;
    }
}
class.append Syntax_Line
{
    method flag Infer_Mumps
    {
        string Code '$char(10)';
        if (defined [my Count])
        {
            string Count [my Count Mumps];
            = Code (append '$$repeat^gal(' Code ',' Count ')');
        }
        my= Mumps Code;
    }
}
class.append Syntax_Indent
{
    method flag Infer_Mumps
    {
        string Code '"    "';
        if (defined [my Count])
        {
            string Count [my Count Mumps];
            = Code (append '$$repeat^gal(' Code ',' Count ')');
        }
        my= Mumps Code;
    }
}
class.append Token_Quote
{
    method flag Infer_Mumps
    {
        string Code (i Mq (i Unquoted));
        my= Mumps Code;
    }
}
class.append Statement_Comment
{
    method flag Infer_Mumps
    {
        string Text '';
        entity Argument;
        foreach [my Arguments] Argument
        {
            if (isa Argument Token_Quote)
            {
                append Text ' ' (. Argument Unquoted);
            }
            else.if (isa Argument Syntax_Line)
            {
                append Text [line];
            }
            else
            {
                append Text ' ' [. Argument Mumps];
            }
        }
        string Line;
        string Code '';
        foreach (split Text [line]) Line
        {
            contif (s= Line '');
            append Code [indent] ';' Line [line];
        }
        my= Mumps Code;
    }
}
class.append Statement_Module
{
    method flag Infer_Mumps
    {
        string Name [my Name Mumps];
        todo 'Copy the module to the Mumps directory?';
        string Code Name [line] Name ' ; ' Name ' module.' [line];
        list Functions;
        entity Stmt;
        string SC;
        foreach [my Block Statements] Stmt
        {
            if (isa Stmt Statement_Function)
            {
                push Functions Stmt;
                continue;
            }
            = SC [. Stmt Mumps];
            append Code SC;
        }
        append Code [indent] 'quit' [line];

        foreach Functions Stmt
        {
            = SC [. Stmt Mumps];
            append Code SC;
        }
        append Code [line];
        my= Mumps Code;
    }
}
class Mumps_Generator [is Generator]
{
    infers Mumps;
    property string Language_Name 'Mumps';
    property string Property_Name 'Mumps';
    property object Elements (new List [self]);
    property object Inferences (new List [self]);
    constructor [entity Owner]
    {
        my= Owner Owner;
    }
    method flag Initialize
    {
        verbosity;
        verbose [class.name] ' Inits';
        infer.inits;
        return [true];
    }
    method flag Infer_Mumps
    {
        i Compiled_Inheritance;
        verbosity [true];
        entity Elem;
        entity I;
        integer Number 0;
        variant Error;
        foreach [my.attribute Elements] Elem
        {
            try
            {
                = I [. Elem Classification];
                . I Infer_Mumps;
                .= Elem Mumps [. I Mumps];
                increment Number;
                if (sgt [. I Mumps_Outer_Declaration] "")
                {
                    verbose "Found Outer Declaration" [line] [. I Mumps_Outer_Declaration];
                }
            }
            catch Error
            {
                my= Status [false];
                comment debug;
                .= Elem Error Error;
                verbose 'Error mumps element ' Number
                    ': ' [classname I]
                    ', <' Error '>'
                    ', source ' (. I Get_Input);
            }
        }
        if (not [my Status])
        {
            say "Error Stack";
            foreach [my.attribute Elements] Elem
            {
                = I [. Elem Classification];
                . I Infer_Mumps;
                .= Elem Mumps [. I Mumps];
                increment Number;
            }
            return [false];
        }
        entity Top (list.last [my.attribute Elements]);
        . Top Infer_Mumps;
        string Code [. Top Mumps];
        my= Mumps Code;
        my= Code Code;
        return [true];
    }
}
class.append Statements
{
    method flag Infer_Mumps
    {
        string Code '';
        entity Statement;
        foreach [my Elements] Statement
        {
            s+ Code [. Statement Mumps] [line];
        }
        my= Mumps Code;
    }
}

class.append Syntax_Is { method flag Infer_Mumps
{
    my= Mumps "";
}}

class.append Statement_Class { method flag Infer_Mumps
{
    verbosity;
    string Name [my Name Mumps];
    string Qname (i Mq Name);
    replace Name '_' '';

    entity Statement;
    string Class_Properties '';
    string Class_Methods '';
    string Constructor '';
    string Properties '';
    string Methods '';
    string Main '';
    string Main_Invoke '';
    string N2;
    string Mainargs '';
    object A;
    forgive
    {
        = Constructor [my Constructor Mumps];
    }
    if (not (isnull [my Main]))
    {
        = Main [my Main Mumps];
        foreach [my Main Arguments] A
        {
            if (sgt Mainargs '')
            {
                append Mainargs ',';
            }
            append Mainargs [. A Mumps];
        }
        if (notnull Mainargs)
        {
            = Mainargs (append '(' Mainargs ')');
        }
        append Main_Invoke [indent] 'do main' Mainargs [line];
    }
    iterate [my Compiled_Class_Properties] N2 Statement
    {
        forgive
        {
            append Class_Properties [. Statement Mumps_Declaration];
        }
        forgive
        {
            append Class_Properties [. Statement Mumps];
        }
    }
    iterate [my Compiled_Class_Methods] N2 Statement
    {
        forgive
        {
            append Class_Methods [. Statement Mumps_Declaration];
        }
        forgive
        {
            append Class_Methods [. Statement Mumps];
        }
    }
    iterate [my Compiled_Properties] N2 Statement
    {
        forgive
        {
            append Properties [. Statement Mumps_Declaration];
        }
        forgive
        {
            append Properties [. Statement Mumps];
        }
    }
    iterate [my Compiled_Methods] N2 Statement
    {
        forgive
        {
            append Methods [. Statement Mumps_Declaration];
        }
        forgive
        {
            append Methods [. Statement Mumps];
        }
    }

    if (isnull Constructor)
    {
        = Constructor (append
            'new() ; constructor' [line]
            [indent] 'new %self set %self=$name(@%matrix@($increment(@%matrix)))' [line]
            [indent] 'set @%self=' (i Mq Name) [line]
            'new2 ; bless property hook' [line]
                Properties
            [indent] 'quit:$quit %self quit' [line]
        );
    }
    string Initializations
        [indent] 'quit:$data(%' Name ')' [line]
        [indent] 'set %' Name '=' Qname [line]
        [indent] "quit:$data(^%" Name ')' [line]
        [indent] 'set ^%' Name '=' Qname [line]
        [indent] 'set ^%Classes(' Qname ')=' Qname [line]
        [indent] 'set ^%' Name '("Ancestors","' Name '")=""' [line];
    iterate [my Compiled_Ancestors] N2 Statement
    {
        replace N2 '_' '';
        append Initializations
            [indent] 'set ^%' Name '("Ancestors","' N2 '")=""' [line];
    }
    object Statement;
    string Code
        Name Mainargs ' ; gal ; ' Name ' class. ;' [line]
        [indent] ';; ******************************************' [line]
        [indent] ';; *   Copyright (c) 2024 by Erik Zoltan.   *' [line]
        [indent] ';; *   All rights reserved.                 *' [line]
        [indent] ';; ******************************************' [line]
        [indent] "if '$data(%matrix) do ^gal" [line]
        [indent] 'do %init(' Qname ')' [line]
        Main_Invoke
        [indent] 'quit' [line]
        Main
        '%init(%class) ;' [line]
        Initializations
        Class_Properties
        [indent] 'quit' [line]
        Class_Methods
        Constructor
        Methods;
    my= Mumps Code;
}
    method flag Re_Mumps
    {
        verbosity [true];
        entity Statement;
        string N2;
        if (not (isnull [my Constructor]))
        {
            . [my Constructor] Re_Mumps;
        }
        if (not (isnull [my Main]))
        {
            . [my Main] Re_Mumps;
        }
        iterate [my Compiled_Class_Properties] N2 Statement
        {
            forgive
            {
                . Statement Re_Mumps;
            }
        }
        iterate [my Compiled_Class_Methods] N2 Statement
        {
            forgive
            {
                . Statement Re_Mumps;
            }
        }
        iterate [my Compiled_Properties] N2 Statement
        {
            forgive
            {
                . Statement Re_Mumps;
            }
        }
        iterate [my Compiled_Methods] N2 Statement
        {
            forgive
            {
                . Statement Re_Mumps;
            }
        }
        i Infer_Mumps;
    }
}

class.append Statement_Property { method flag Infer_Mumps
{
    verbosity [true];
    string Type [my Type Mumps];
    string Name [my Name Mumps];
    string Qname (i Mq Name);
    string Reference '@%self@(' Qname ')';
    string Declaration '';
    if (s= Type 'list')
    {
        comment append Declaration
            [indent] 'set @%self@(' Qname ')=0' [line];
        append Declaration
            [indent] '; sparse property list ' Name [line];
    }
    else.if (s= Type 'dictionary')
    {
        append Declaration
            [indent] '; sparse property dictionary ' Name [line];
    }
    else.if (defined [my Value])
    {
        append Declaration
            [indent] "set " Reference "=" [my Value Mumps] [line];
    }
    else
    {
        append Declaration
            [indent] '; sparse property ' Type ' ' Name [line];
    }
    my= Mumps_Declaration Declaration;
    my= Mumps '';
}}

class.append Operation_New { method flag Infer_Mumps
{
    string Class_Name [my Class_Name Mumps];
    string Margs "";
    entity Arg;
    string Between '';
    foreach [my Listargs] Arg
    {
        append Margs Between [. Arg Mumps];
        = Between ',';
    }
    string Code "$$new^" Class_Name '(' Margs ")";
    my= Mumps Code;
}}

class.append Declaration_Statement { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Code [indent] 'new ' Variable [line];
    if (defined [my Value])
    {
        string Value [my Value Mumps];
        append Code [indent] 'set ' Variable '=' Value [line];
    }
    my= Mumps Code;
}}

class.append Syntax_Self { method flag Infer_Mumps
{
    my= Mumps "%self";
}}

class.append Statement_Call { method flag Infer_Mumps
{
    string Target [my Target Mumps];
    string Method (i Mq [my Method Mumps]);
    replace Method '_' '';
    string Margs "";
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Margs "," [. Arg Mumps];
    }
    string Code [indent] "do dispatch" (list.length [my Listargs]) "^gal(" Target "," Method Margs ")" [line];
    my= Mumps Code;
}}

class.append Operation_Call { method flag Infer_Mumps
{
    string Object [my Object Mumps];
    string Method (i Mq [my Method Mumps]);
    replace Method '_' '';
    string Margs '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Margs ',' [. Arg Mumps];
    }
    string Code "$$dispatch" (list.length [my Listargs]) "^gal(" Object "," Method Margs ")";
    my= Mumps Code;
}}

class.append Statement_Foreach { method flag Infer_Mumps
{
    verbosity;
    string List [my List Mumps];
    string Type '';
    entity Meth_Context (i Method_Context);
    if (dict.exists [. Meth_Context Variables] List)
    {
        = Type (dict.get [. Meth_Context Variables] List);
        verbose 'foreach ' List ' is a ' Type;
    }
    if (sne Type 'list')
    {
        = List (append '$name(' List ')');
    }
    string Variable [my Variable Mumps];
    string Index (: Mumps Get_Variable);
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code [indent] 'set ' Index '=""' [line]
        Continue_Label ' ; for each ' Variable ' continue' [line]
        [indent] 'set ' Index '=$order(@' List '@(' Index '))' [line]
        [indent] 'goto:' Index '="" ' Break_Label [line]
        [indent] 'set ' Variable '=@' List '@(' Index ')' [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; for each ' Variable ' break' [line];
    my= Mumps Code;
}}

class.append Statement_For_Each_Key { method flag Infer_Mumps
{
    verbosity;
    string List [my List Mumps];
    string Type '';
    entity Meth_Context (i Method_Context);
    if (dict.exists [. Meth_Context Variables] List)
    {
        = Type (dict.get [. Meth_Context Variables] List);
        verbose 'for each key ' List ' is a ' Type;
    }
    if (sne Type 'list')
    {
        = List (append '$name(' List ')');
    }
    string Index [my Variable Mumps];
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code [indent] 'set ' Index '=""' [line]
        Continue_Label ' ; for each key ' Index ' continue' [line]
        [indent] 'set ' Index '=$order(@' List '@(' Index '))' [line]
        [indent] 'goto:' Index '="" ' Break_Label [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; for each key ' Index ' break' [line];
    my= Mumps Code;
}}

class.append Statement_For_Prev_Key { method flag Infer_Mumps
{
    verbosity;
    string List [my List Mumps];
    string Type '';
    entity Meth_Context (i Method_Context);
    if (dict.exists [. Meth_Context Variables] List)
    {
        = Type (dict.get [. Meth_Context Variables] List);
        verbose 'for each prev key ' List ' is a ' Type;
    }
    if (sne Type 'list')
    {
        = List (append '$name(' List ')');
    }
    string Index [my Variable Mumps];
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code [indent] 'set ' Index '=""' [line]
        Continue_Label ' ; for each key ' Index ' continue' [line]
        [indent] 'set ' Index '=$order(@' List '@(' Index '),-1)' [line]
        [indent] 'goto:' Index '="" ' Break_Label [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; for each prev key ' Index ' break' [line];
    my= Mumps Code;
}}

class.append Statement_For_Each_In { method flag Infer_Mumps
{
    verbosity;
    string List [my List Mumps];
    string Type '';
    entity Meth_Context (i Method_Context);
    if (dict.exists [. Meth_Context Variables] List)
    {
        = Type (dict.get [. Meth_Context Variables] List);
        verbose 'for each in ' List ' is a ' Type;
    }
    if (sne Type 'list')
    {
        = List (append '$name(' List ')');
    }
    string Variable [my Variable Mumps];
    string Index (: Mumps Get_Variable);
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code [indent] 'set ' Index '=""' [line]
        Continue_Label ' ; for each in ' Variable ' continue' [line]
        [indent] 'set ' Index '=$order(@' List '@(' Index '))' [line]
        [indent] 'goto:' Index '="" ' Break_Label [line]
        [indent] 'set ' Variable '=@' List '@(' Index ')' [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; for each in ' Variable ' break' [line];
    my= Mumps Code;
}}

class.append Statement_Method { method flag Infer_Mumps
{
    string Method_Name [my Name Mumps];
    string Args (i Mumps_Listargs);
    if (isnull Args)
    {
        = Args '%self';
    }
    else
    {
        = Args (append '%self,' Args);
    }
    string Declaration '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        if (defined [. Arg Mumps_Declaration])
        {
            append Declaration [. Arg Mumps_Declaration];
        }
    }
    string Type [my Type Mumps];
    string Block (i Mumps_Block);
    string Code
        Method_Name '(' Args ') ; method ' Type ' ' Method_Name [line]
        [indent] 'new %' [line]
        Declaration
        Block
        [indent] 'quit' [line];
    my= Mumps Code;
}}


class.append Operation_I { method flag Infer_Mumps
{
    string Method (i Mq [my Method Mumps]);
    string Margs "";
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Margs "," [. Arg Mumps];
    }
    string Code "$$dispatch" (list.length [my Listargs]) "^gal(%self," Method Margs ")";
    my= Mumps Code;
}}

class.append Statement_Return { method flag Infer_Mumps
{
    string Value '""';
    if (defined [my Value])
    {
        = Value [my Value Mumps];
    }
    string Code
        [indent] 'set %("return")=' Value [line]
        [indent] 'quit:$quit %("return") quit' [line];
    my= Mumps Code;
}}
class.append Operation_List_Last { method flag Infer_Mumps
{
    verbosity;
    string List [my List Mumps];
    string Code '$$listlast^gal($name(' List '))';
    verbose [indent] 'list last ' List ' --> ' Code;
    my= Mumps Code;
}}

class.append Operation_Greater_Than { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] ">" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_Less_Than { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "<" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_Greater_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "'<" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_Less_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "'>" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_Not_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "'=" [my Op2]);
    my= Mumps Code;
}}

class.append Statement_If { method flag Infer_Mumps
{
    string Arguments (i Mumps_Arguments);
    string Else_Label (: Mumps Get_Label);
    string End_Label [my End_Label];
    string Block (i Mumps_Block);
    string Code [indent] 'if ' Arguments [line]
        [indent] 'else  goto ' Else_Label [line]
        Block
        [indent] 'goto ' End_Label [line]
        Else_Label ' ; if-else' [line];
    if [my Is_Last]
    {
        append Code
            End_Label ' ; end if' [line];
    }
    my= Mumps Code;
}}

class.append Statement_Unless { method flag Infer_Mumps
{
    string Arguments (i Mumps_Arguments);
    string Else_Label (: Mumps Get_Label);
    string End_Label [my End_Label];
    string Block (i Mumps_Block);
    string Code [indent] 'if ' Arguments ' goto ' Else_Label [line]
        Block
        [indent] 'goto ' End_Label [line]
        Else_Label ' ; if-else' [line];
    if [my Is_Last]
    {
        append Code
            End_Label ' ; end if' [line];
    }
    my= Mumps Code;
}}

class.append Statement_Else_If { method flag Infer_Mumps
{
    string Arguments (i Mumps_Arguments);
    string Else_Label (: Mumps Get_Label);
    string End_Label [my End_Label];
    string Block (i Mumps_Block);
    string Code [indent] 'if ' Arguments [line]
        [indent] 'else  goto ' Else_Label [line]
        Block
        [indent] 'goto ' End_Label [line]
        Else_Label ' ; else-if-else' [line];
    if [my Is_Last]
    {
        append Code
            End_Label ' ; end if' [line];
    }
    my= Mumps Code;
}}

class.append Statement_Else { method flag Infer_Mumps
{
    string End_Label [my End_Label];
    string Block (i Mumps_Block);
    string Code
        Block
        End_Label ' ; end if' [line];
    my= Mumps Code;
}}

class.append Syntax_True { method flag Infer_Mumps
{
    string Code '1';
    my= Mumps Code;
}}

class.append Syntax_False { method flag Infer_Mumps
{
    string Code '0';
    my= Mumps Code;
}}

class.append Statement_List { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Actual (lowercase Variable);
    string Code [indent] 'new ' Variable ',' Actual [line]
        [indent] 'set ' Variable '=$name(' Actual '),'
                Actual '=' (list.length [my Listargs])
        [line];
    entity Arg;
    integer Item 0;
    foreach [my Listargs] Arg
    {
        increment Item;
        string Value [. Arg Mumps];
        append Code [indent] 'set ' Actual '(' Item ')=' Value [line];
    }
    my= Mumps Code;
}}

class.append Operation_String_Not_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "'=" [my Op2]);
    my= Mumps Code;
}}

class.append Statement_String { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Values '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        contif (isnull [. Arg Mumps]);
        if (s= Values '')
        {
            append Values ' set ' Variable '=' [. Arg Mumps];
        }
        else
        {
            append Values '_' (. Arg Matom);
        }
    }
    string Code [indent] 'new ' Variable Values [line];
    my= Mumps Code;
}}

class.append Operation_List_Length { method flag Infer_Mumps
{
    verbosity [true];
    string First (. [my First] Matom);
    if (sne (firstchar First) '@')
    {
        = First (append '@(' First ')');
    }
    string Code '$get(' First ',0)';
    my= Mumps Code;
}}

class.append Operation_Subtract { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "-" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_List_Get { method flag Infer_Mumps
{
    string List [my List Mumps];
    if (s= (firstchar List) '@')
    {
        = List (append '$name(' List ')');
    }
    string Code '$get(@' List '@(' [my Offset Mumps] '+1))';
    my= Mumps Code;
}}

class.append Statement_For_Range { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Start [my Start Mumps];
    string End [my End Mumps];
    string Increment '1';
    string Continue (i Continue_Label);
    string Break (i Break_Label);
    string Begin (: Mumps Get_Label);
    if (defined [my Increment])
    {
        = Increment [my Increment Mumps];
    }
    string Block (i Mumps_Block);
    string Code
        [indent] 'set ' Variable '=' Start [line]
        [indent] 'goto:$select(' Increment '<0:' Variable '<' End ',1:' Variable '>' End ') ' Break [line]
        [indent] 'goto ' Begin [line]
        Continue ' ; for range continue' [line]
        [indent] 'goto:$select(' Increment '<0:' Variable '+' Increment '<' End ',1:' Variable  '+' Increment '>' End ') ' Break [line]
        [indent] 'set ' Variable '=' Variable '+' Increment [line]
        Begin ' ; for ' Variable ' range begin' [line]
        Block
        [indent] 'goto ' Continue [line]
        Break ' ; for ' Variable ' range break' [line];
    my= Mumps Code;
}}

class.append Operation_Contains { method flag Infer_Mumps
{
    string Code (i Mbinop [my String] "[" [my Search]);
    my= Mumps Code;
}}

class.append Operation_And { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "&" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_Or { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "!" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_String_Append { method flag Infer_Mumps
{
    string Code '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        if (s= Code '')
        {
            append Code [. Arg Mumps];
        }
        else
        {
            append Code '_' (. Arg Matom);
        }
    }
    my= Mumps Code;
}}

class.append Statement_Append { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Code [indent] 'set ' Variable '=' Variable;
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Code '_' (. Arg Matom);
    }
    append Code [line];
    my= Mumps Code;
}}

class.append Operation_String_Append { method flag Infer_Mumps
{
    string Code '';
    entity Arg;
    foreach [my Arguments] Arg
    {
        if (s= Code '')
        {
            = Code [. Arg Mumps];
        }
        else
        {
            append Code '_' (. Arg Matom);
        }
    }
    my= Mumps Code;
}}

class.append Operation_First_Char { method flag Infer_Mumps
{
    string Code '$extract(' [my String_Value Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Last_Char { method flag Infer_Mumps
{
    string Code '$extract(' [my First Mumps] ',$length(' [my First Mumps] '))';
    my= Mumps Code;
}}

class.append Operation_Is_Uppercase { method flag Infer_Mumps
{
    string Code '$$isuppercase^gal(' [my First Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Is_Lowercase { method flag Infer_Mumps
{
    string Code '$$islowercase^gal(' [my First Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Titlecase { method flag Infer_Mumps
{
    string Code '$$titlecase^gal(' [my String Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Not { method flag Infer_Mumps
{
    string Code "'" (. [my Op1] Matom);
    my= Mumps Code;
}}

class.append Operation_Lowercase { method flag Infer_Mumps
{
    string Code '$translate(' [my First Mumps] ',"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")';
    my= Mumps Code;
}}

class.append Operation_Uppercase { method flag Infer_Mumps
{
    string Code '$translate(' [my First Mumps] ',"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")';
    my= Mumps Code;
}}

class.append Operation_Substring { method flag Infer_Mumps
{
    string Value [my String_Value Mumps];
    string Start_Index [my Start_Index Mumps];
    string End '$length(' Value ')';
    string Code;
    if (defined [my Length])
    {
        string Length [my Length Mumps];
        = Code (append '$$substring3^gal(' Value ',' Start_Index ',' Length ')');
    }
    else
    {
        = Code (append '$extract(' Value ',' Start_Index '+1,$length(' Value '))');
    }
    my= Mumps Code;
}}

class.append Operation_Begins { method flag Infer_Mumps
{
    string String_Value [my String_Value Mumps];
    string Code '$extract(' String_Value ',1,$length(' [my Begin_Value Mumps] '))=' (. [my Begin_Value] Matom);
    my= Mumps Code;
}}

class.append Operation_Is_Null { method flag Infer_Mumps
{
    string Code [my Op1 Mumps] `=""`;
    my= Mumps Code;
}}

class.append Operation_Not_Null { method flag Infer_Mumps
{
    string Code [my Op1 Mumps] `'=""`;
    my= Mumps Code;
}}

class.append Operation_Is_Number { method flag Infer_Mumps
{
    string Code '$$isnumber^gal(' [my Value Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Is_Punct { method flag Infer_Mumps
{
    string Code '$$ispunct^gal(' [my Character Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Is_String { method flag Infer_Mumps
{
    string Code '$$isstring^gal(' [my Value Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Is_Whitespace { method flag Infer_Mumps
{
    string Code '$$isws^gal(' [my Character Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_String_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "=" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "=" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_String_Greater { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "]" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_String_Less { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op2] "]" [my Op1]);
    my= Mumps Code;
}}

class.append Operation_String_Less_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op1] "']" [my Op2]);
    my= Mumps Code;
}}

class.append Operation_String_Greater_Equal { method flag Infer_Mumps
{
    string Code (i Mbinop [my Op2] "']" [my Op1]);
    my= Mumps Code;
}}

class.append Operation_Length { method flag Infer_Mumps
{
    string Code '$length(' [my First Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Char2int { method flag Infer_Mumps
{
    string Code '$ascii(' [my Character Mumps] ')';
    my= Mumps Code;
}}

class.append Operation_Int2char { method flag Infer_Mumps
{
    string Code '$char(' [my Integer Mumps] ')';
    my= Mumps Code;
}}

class.append Statement_List_Copy { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Actual (lowercase Variable);
    string Value (. [my Value] Matom);
    if (s= '$' (firstchar Value))
    {
        = Value (append '@' Value);
    }
    string Code [indent] 'new ' Variable ',' Actual [line]
    [indent] 'set ' Variable '=$name(' Actual ')' [line]
    [indent] 'merge ' Actual '=' Value [line];
    entity Arg;
    integer Item 0;
    my= Mumps Code;
}}

class.append Operation_Split { method flag Infer_Mumps
{
    string String [my String Mumps];
    string Delimiter [my Delimiter Mumps];
    string Code '$$split^gal(' String ',' Delimiter ')';
    my= Mumps Code;
}}

class.append Statement_Break { method flag Infer_Mumps
{
    string Code [indent] 'goto ' (i Break_Label) [line];
    my= Mumps Code;
}}

class.append Statement_Continue { method flag Infer_Mumps
{
    string Code [indent] 'goto ' (i Continue_Label) [line];
    my= Mumps Code;
}}

class.append Syntax_Property { method flag Infer_Mumps
{
    verbosity;
    string Object [my Object Mumps];
    string Property_Name [my Property_Name Mumps];
    replace Property_Name '_' '';
    entity Arg;
    string Code '@' Object '@(' (i Mq Property_Name) ')';
    foreach [my Listargs] Arg
    {
        = Code (append '@(' Code ')@(' (i Mq [. Arg Mumps]) ')');
        = Verbosity [true];
    }
    verbose 'syntax property, object ' Object ', code: ' Code;
    my= Mumps Code;
}}

class.append Syntax_My { method flag Infer_Mumps
{
    verbosity;
    string Property_Name [my Property Mumps];
    entity Arg;
    string Code '@%self@(' (i Mq Property_Name) ')';
    foreach [my Listargs] Arg
    {
        = Code (append '@(' Code ')@(' (i Mq [. Arg Mumps]) ')');
        = Verbosity [true];
    }
    verbose 'syntax my, object ' Object ', code: ' Code;
    my= Mumps Code;
}}

class.append Operation_Multiply { method flag Infer_Mumps
{
    i Mrepeating '*';
}}

class.append Operation_Add { method flag Infer_Mumps
{
    i Mrepeating '+';
}}

class.append Operation_Or { method flag Infer_Mumps
{
    i Mrepeating '!';
}}
class.append Operation_Modulo { method flag Infer_Mumps
{
    i Mrepeating '#';
}}
class.append Operation_And { method flag Infer_Mumps
{
    i Mrepeating '&';
}}
class.append Operation_And { method flag Infer_Mumps
{
    i Mrepeating '&';
}}
class.append Operation_String_Append { method flag Infer_Mumps
{
    i Mrepeating '_';
}}
class.append Operation_Subtract { method flag Infer_Mumps
{
    i Mrepeating '-';
}}
class.append Operation_Equal { method flag Infer_Mumps
{
    i Mrepeating '=';
}}
class.append Operation_Not_Equal { method flag Infer_Mumps
{
    i Mrepeating "'=";
}}
class.append Operation_Integer_Divide { method flag Infer_Mumps
{
    i Mrepeating '\';
}}
class.append Operation_Less_Than { method flag Infer_Mumps
{
    i Mrepeating '<';
}}
class.append Operation_Greater_Than { method flag Infer_Mumps
{
    i Mrepeating '>';
}}
class.append Operation_Greater_Equal { method flag Infer_Mumps
{
    i Mrepeating `'<`;
}}
class.append Operation_Less_Equal { method flag Infer_Mumps
{
    i Mrepeating `'>`;
}}
class.append Operation_Contains { method flag Infer_Mumps
{
    i Mrepeating '[';
}}
class.append Operation_String_Greater { method flag Infer_Mumps
{
    i Mrepeating ']';
}}
class.append Operation_String_Less_Equal { method flag Infer_Mumps
{
    i Mrepeating "']";
}}
class.append Operation_Divide { method flag Infer_Mumps
{
    i Mrepeating '/';
}}

class.append Statement_Class_Property { method flag Infer_Mumps
{
    string Type [my Type Mumps];
    string Name [my Name Mumps];
    string Value;
    if (defined [my Value])
    {
        = Value [my Value Mumps];
    }
    if (s= Type 'list')
    {
        = Value '0';
    }
    entity Class_Context (i Mumps_Class);
    string Class_Name (. [. Class_Context Name] Get_Input);
    replace Class_Name '_' '';
    replace Name '_' '';
    string Code '';
    if (defined Value)
    {
        append Code
            [indent] 'set ^%' Class_Name '(0,' (i Mq Name) ')=' Value [line];
    }
    my= Mumps_Declaration Code;
    my= Mumps '';
}}

class.append Statement_Add { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Code [indent] 'set ' Variable '=' Variable;
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Code '+' (. Arg Matom);
    }
    append Code [line];
    my= Mumps Code;
}}

class.append Statement_We { method flag Infer_Mumps
{
    string Method [my Method Mumps];
    string Args (i Mumps_Listargs);
    entity My_Class (i Mumps_Class);
    string Class_Name [. My_Class Name Mumps];
    string Code [indent] 'do %' Method '(' (i Mq Class_Name) ',' Args ')' [line];
    my= Mumps Code;
}}

class.append Operation_We { method flag Infer_Mumps
{
    string Method [my Method Mumps];
    string Args (i Mumps_Listargs);
    entity My_Class (i Mumps_Class);
    string Class_Name [. My_Class Name Mumps];
    string Code '$$%' Method '(' (i Mq Class_Name);
    if (sgt Args '')
    {
        append Code ',';
    }
    append Code Args ')';
    my= Mumps Code;
}}

class.append Statement_Class_Method { method flag Infer_Mumps
{
    string Return_Type (list.last [my Gs_Keywords]);
    string Method_Name [my Name Mumps];
    string Arglist '%class';
    string Args (i Mumps_Listargs);
    if (sgt Args '')
    {
        append Arglist ',' Args;
    }
    string Code
        '%' Method_Name '(' Arglist ') ; ' Return_Type ' return' [line]
        (i Mumps_Block)
        [indent] 'quit' [line];
    my= Mumps Code;
}}

class.append Statement_My_Equal { method flag Infer_Mumps
{
    string Property [my Property Mumps];
    string Value [my Value Mumps];
    string Code [indent] 'set @%self@(' (i Mq Property) ')=' Value [line];
    my= Mumps Code;
}}

class.append Statement_Constructor { method flag Infer_Mumps
{
    entity Class_Context (i Mumps_Class);
    if (isnull Class_Context)
    {
        = Class_Context (i Get_Class_Context);
    }
    string Class_Name (. [. Class_Context Name] Get_Input);
    replace Class_Name '_' '';
    string Args (i Mumps_Arguments);
    string Block (i Mumps_Block);
    string Properties '';
    string Name;
    entity Stmt;
    string Declaration '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        if (defined [. Arg Mumps_Declaration])
        {
            append Declaration [. Arg Mumps_Declaration];
        }
    }
    iterate [my Parent Compiled_Properties] Name Stmt
    {
        forgive
        {
            append Properties [. Stmt Mumps_Declaration];
        }
        forgive
        {
            append Properties [. Stmt Mumps];
        }
    }
    string Code
        'new(' Args ') ;' [line]
        [indent] 'new %self set %self=$name(@%matrix@($increment(@%matrix)))' [line]
        [indent] 'set @%self=' (i Mq Class_Name) [line]
        'new2 ; bless property hook' [line]
        Declaration
        Properties
        Block
        [indent] 'quit:$quit %self quit' [line];
    my= Mumps Code;
}}

class.append Syntax_Null { method flag Infer_Mumps
{
    my= Mumps '""';
}}

class.append Operation_Defined { method flag Infer_Mumps
{
    string First [my First Mumps];
    = First (: Mumps Glvn First);
    string Code '$data(' First ')';
    my= Mumps Code;
}}

class.append Syntax_Class_Property { method flag Infer_Mumps
{
    string Class_Name [my First Mumps];
    string Property_Name [my Second Mumps];
    string Code '^%' Class_Name '(0,' (i Mq Property_Name) ')';
    entity Arg;
    foreach [my Listargs] Arg
    {
        = Code (append '@(' Reference ')@(' (i Mq [. Arg Mumps]) ')');
    }
    my= Mumps Code;
}}

class.append Statement_Error { method flag Infer_Mumps
{
    string Error_Code '"U:"_' (i Mumps_Arguments '_');
    string Code [indent] 'set $ecode=' Error_Code [line];
    my= Mumps Code;
}}

class.append Statement_Merge_From { method flag Infer_Mumps
{
    string Source [my Source Mumps];
    string Target [my Target Mumps];
    string Code [indent] 'merge ' Source '=' Target [line];
    my= Mumps Code;
}}

class.append Statement_Merge_To { method flag Infer_Mumps
{
    string Target [my Target Mumps];
    string Source [my Source Mumps];
    string Code [indent] 'merge ' Source '=' Target [line];
    my= Mumps Code;
}}

class.append Statement_Forgive { method flag Infer_Mumps
{
    string Catch_Label (: Mumps Get_Label);
    string Statements (i Mumps_Block);
    string Code
        [indent] 'new $etrap,$estack' [line]
        [indent] 'set $etrap="quit:$estack  goto ' Catch_Label '"' [line]
        Statements
        Catch_Label ' ; Error handler.' [line]
        [indent] 'set %ecode=$zstatus,$ecode="",$zstatus=""' [line];
    my= Mumps Code;
}}

class.append Statement_Process { method flag Infer_Mumps
{
    comment 'Statement_Process';
    string Process_Name (titlecase (list.last [my Gs_Keywords]));
    string Code [indent] '; TODO process ' Process_Name [line];
    my= Mumps Code;
}}

class.append Syntax_Our { method flag Infer_Mumps
{
    comment 'Syntax_Our';
    entity Class_Context (i Mumps_Class);
    string Class_Name (. [. Class_Context Name] Get_Input);
    replace Class_Name '_' '';
    string Code
        '^%' Class_Name;
    if (defined [my Class_Property])
    {
        string Name [my Class_Property Mumps];
        append Code '(0,' (i Mq Name) ')';
    }
    my= Mumps Code;
}}

class.append Syntax_Us { method flag Infer_Mumps
{
    comment 'Syntax_Us';
    entity Class_Context (i Mumps_Class);
    string Class_Name (. [. Class_Context Name] Get_Input);
    replace Class_Name '_' '';
    string Code
        '^%' Class_Name;
    my= Mumps Code;
}}


class.append Statement_Quest { method flag Infer_Mumps
{
    comment 'Statement_Quest';
    string Name [my Name Mumps];
    string Code [indent] '; quest ' Name [line];
    my= Mumps Code;
}}

class.append Operation_Colon { method flag Infer_Mumps
{
    comment 'Operation_Colon';
    string Class [my Class Mumps];
    replace Class '_' '';
    string Method [my Method Mumps];
    replace Method '_' '';
    string Margs (i Mq Class);
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Margs "," [. Arg Mumps];
    }
    string Code '$$%' Method '^' Class '(' Margs ')';
    my= Mumps Code;
}}

class.append Statement_Colon { method flag Infer_Mumps
{
    comment 'Statement_Colon';
    string Class [my Class Mumps];
    replace Class '_' '';
    string Method [my Method Mumps];
    replace Method '_' '';
    string Margs (i Mq Class);
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Margs "," [. Arg Mumps];
    }
    string Code [indent] 'do %' Method '^' Class '(' Margs ')' [line];
    my= Mumps Code;
}}

class.append Statement_Assign { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Value [my Value Mumps];
    string Code [indent] 'set ' Variable '=' Value [line];
    my= Mumps Code;
}}


class.append Statement_Try { method flag Infer_Mumps
{
    comment 'Statement_Try';
    string End_Label [my End_Label];
    string Catch_Label (: Mumps Get_Label);
    string Block (i Mumps_Block);
    string Code
        [indent] 'new $etrap,$estack' [line]
        [indent] 'set $etrap="quit:$estack  goto ' Catch_Label '"' [line]
        Block
        [indent] 'goto ' End_Label [line]
        Catch_Label ' ; try catch label.' [line];
    my= Mumps Code;
}}

class.append Statement_Catch { method flag Infer_Mumps
{
    string Variable_Code '';
    string End_Label [my End_Label];
    if (defined [my Variable])
    {
        append Variable_Code
            [indent] 'set ' [my Variable Mumps] '=%ecode' [line];
    }
    string End_Label [my End_Label];
    string Block (i Mumps_Block);

    string Code
        [indent] 'set %ecode=$zstatus,$ecode="",$zstatus=""' [line]
        Variable_Code
        Block
        End_Label ' ; try catch end label' [line];
    my= Mumps Code;
}}

class.append Syntax_Tail { method flag Infer_Mumps
{
    comment 'Syntax_Tail.Infer_Mumps';
    entity Arg0 (list.get [my Arguments] 0);
    string Code [. Arg0 Mumps];
    forgive
    {
        entity Default (list.get [my Arguments] 1);
        string Value [. Default Mumps];
        string Declaration [indent] 'set ' Variable '=$get(' Variable ',' Value ')' [line];
        my= Mumps_Declaration Declaration;
    }
    my= Mumps Code;
}}

class.append Statement_Pay_Gratitude { method flag Infer_Mumps
{
    comment 'Statement_Pay_Gratitude';
    string Supporter [my Supporter Mumps];
    string Amount [my Amount Mumps];
    string Code [indent] 'set %("gratitude")=$increment(@' Supporter '@("Gratitude"),' Amount ')' [line];
    my= Mumps Code;
}}

class.append Operation_Name { method flag Infer_Mumps
{
    comment 'Operation_Name';
    string Glvn [my Glvn Mumps];
    if (s= (list.last [my Gs_Keywords]) '^')
    {
        = Glvn (append '^' Glvn);
    }
    string Subscripts (i Mumps_Listargs);
    if (sgt Subscripts '')
    {
        append Glvn '(' Subscripts ')';
    }
    string Code '$name(' Glvn ')';
    my= Mumps Code;
}}

class.append Statement_Glvn { method flag Infer_Mumps
{
    string Root [my Root Mumps];
    string Code
        [indent] 'new ' Root [line];
    if (defined [my Value])
    {
        string Value [my Value Mumps];
        append Code
            [indent] 'set ' Root '=' Value [line];
    }
    my= Mumps Code;
}}

class.append Operation_Glvn { method flag Infer_Mumps
{
    string Code [my Variable Mumps];
    string Next '(';
    string Subscripts (i Mumps_Listargs);
    if (s= (list.last [my Gs_Keywords]) '^')
    {
        = Code (append '^' Code);
    }
    if (sgt Subscripts '')
    {
        debugif (contains Code '$name');
        comment "this doesn't handle $name yet";
        if (s= (lastchar Code) ')')
        {
            = Code (substring Code 0 (- (length Code) 1));
            = Next ',';
        }
        append Code Next Subscripts ')';
    }
    my= Mumps Code;
}}

class.append Statement_Debug { method flag Infer_Mumps
{
    string Code [indent] 'break %debug' [line];
    my= Mumps Code;
}}

class.append Statement_File_Dump { method flag Infer_Mumps
{
    string File_Text [my File_Text Mumps];
    string File_Name [my File_Name Mumps];
    string Code [indent] 'do filedump^gal(' File_Text ',' File_Name ')' [line];
    my= Mumps Code;
}}
class.append Statement_Quit_Colon { method flag Infer_Mumps
{
    string Condition [my Condition Mumps];
    string Code [indent] 'quit:' Condition;
    forgive
    {
        append Code ' ' [my Value Mumps];
    }
    append Code [line];
    my= Mumps Code;
}}
class.append Statement_Object_New { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Class [my Class Mumps];
    string Margs (i Mumps_Listargs);
    string Code '$$new^' Class '(' Margs ')';
    my= Mumps Code;
}}
class.append Statement_Goal_Spell { method flag Infer_Mumps
{
    comment 'Statement_Goal_Spell';
    string Name [my Name Mumps];
    string Code [indent] '; goal spell ' Name [line];
    if (defined [my Description])
    {
        string Description [my Description Mumps];
        append Code [indent] '; ' Description [line];
    }
    append Code (i Mumps_Statements);
    my= Mumps Code;
}}

class.append Statement_Propset { method flag Infer_Mumps
{
    comment 'Statement_Propset';
    string Object [my Object Mumps];
    string Property [my Property Mumps];
    string Value [my Value Mumps];
    string Code [indent] 'set @' Object '@(' (i Mq Property) ')=' Value [line];
    my= Mumps Code;
}}

class.append Operation_List_Pop { method flag Infer_Mumps
{
    string List [my First Mumps];
    string Code '$$pop^gal($name(' List '))';
    my= Mumps Code;
}}

class.append Statement_Dictionary { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Actual (lowercase Variable);
    string Code
        [indent] 'new ' Variable ',' Actual [line]
        [indent] 'set ' Variable '=$name(' Actual ')' [line];
    my= Mumps Code;
}}

class.append Statement_List_Append { method flag Infer_Mumps
{
    verbosity;
    string List [my List Mumps];
    verbose 'mumps push ' List;
    string Variable List;
    if (s= (firstchar Variable) '@')
    {
        = Variable (append '$name(' Variable ')');
    }
    entity Arg;
    string Code '';
    string Argc;
    foreach [my Listargs] Arg
    {
        = Argc [. Arg Mumps];
        append Code
            [indent] 'set @' Variable '@($order(@' Variable '@(""),-1)+1)=' Argc [line]
            [indent] 'set @' Variable '=$increment(@' Variable ')' [line];
    }
    my= Mumps Code;
}}

class.append Statement_Dictionary_Assign { method flag Infer_Mumps
{
    string Dict [my Dict Mumps];
    if (s= (firstchar Dict) "@")
    {
        = Dict (append '$name(' Dict ')');
    }
    else.if (and (s= (firstchar Dict) "^")
                 (contains Dict '('))
    {
        = Dict (append '$name(' Dict ')');
    }
    string Key [my Key Mumps];
    string Value [my Value Mumps];
    string Code
        [indent] 'set @' Dict '@(' Key ')=' Value [line];
    my= Mumps Code;
}}

class.append Operation_Dict_Get { method flag Infer_Mumps
{
    string Dictionary (. [my Dictionary] Matom);
    if (s= (firstchar Dictionary) '@')
    {
        = Dictionary (append '$name(' Dictionary ')');
    }
    else.if (and (s= (firstchar Dictionary) "^")
                 (contains Dictionary '('))
    {
        = Dictionary (append '$name(' Dictionary ')');
    }
    string Key [my Key Mumps];
    string Code
        '@' Dictionary '@(' Key ')';
    my= Mumps Code;
}}

class.append Operation_Is_A { method flag Infer_Mumps
{
    verbosity;
    string Variable [my Variable Mumps];
    string Class_Name [my Class_Name Mumps];
    replace Class_Name '_' '';
    string Qname (i Mq Class_Name);
    string Code '$data(@("^%"_@(' Variable '))@("Ancestors",' Qname '))';
    verbose "!!! isa mumps " Code;
    my= Mumps Code;
}}

class.append Statement_Increment { method flag Infer_Mumps
{
    string Op1 [my Op1 Mumps];
    string Code [indent] 'set ' Op1 '=' Op1 '+1' [line];
    my= Mumps Code;
}}

class.append Statement_Decrement { method flag Infer_Mumps
{
    string Op1 [my Op1 Mumps];
    string Code [indent] 'set ' Op1 '=' Op1 '-1' [line];
    my= Mumps Code;
}}

class.append Syntax_Glvn { method flag Infer_Mumps
{
    string Root [my Root Mumps];
    string Code Root;
    my= Mumps Code;
}}

class.append Operation_Get { method flag Infer_Mumps
{
    string Glvn [my Root Mumps];
    string Args '';
    string Between '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Args Between [. Arg Mumps];
        = Between ',';
    }
    if (sgt Args '')
    {
        = Glvn (append '@$name(' Glvn ')@(' Args ')');
    }
    string Code '$get(' Glvn ')';
    my= Mumps Code;



}}

class.append Operation_Get_Global { method flag Infer_Mumps
{
    string Glvn '^' [my Root Mumps];
    string Args '';
    string Between '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Args Between [. Arg Mumps];
        = Between ',';
    }
    if (sgt Args '')
    {
        append Glvn '(' Args ')';
    }
    string Code '$get(' Glvn ')';
    my= Mumps Code;
}}

class.append Operation_Invoke { method flag Infer_Mumps
{
    string Function [my Function Mumps];
    string Arguments (i Mumps_Listargs);
    string Code '$$' Function '(' Arguments ')';
    my= Mumps Code;
}}
class.append Operation_Next { method flag Infer_Mumps
{
    string Root [my Root Mumps];
    if (s= (firstchar Root) '@')
    {
        = Root (append '$name(' Root ')');
    }
    string Args (i Mumps_Listargs);
    string Code '$order(@' Root '@(' Args '))';
    my= Mumps Code;
}}
class.append Operation_Next_Global { method flag Infer_Mumps
{
    string Root [my Root Mumps];
    string Args (i Mumps_Listargs);
    string Code '$order(^' Root '(' Args '))';
    my= Mumps Code;
}}
class.append Operation_Prev { method flag Infer_Mumps
{
    string Root [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (s= (firstchar Root) '@')
    {
        = Root (append '$name(' Root ')');
    }
    string Code '$order(@' Root '@(' Args '),-1)';
    my= Mumps Code;
}}

class.append Operation_Prev_Global { method flag Infer_Mumps
{
    string Root [my Root Mumps];
    string Args (i Mumps_Listargs);
    string Code '$order(^' Root '(' Args '),-1)';
    my= Mumps Code;
}}
class.append Operation_Random_Integer { method flag Infer_Mumps
{
    string Values [my Values Mumps];
    string Code '$random(' Values ')';
    my= Mumps Code;
}}
class.append Statement_Build { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Code [indent] 'do @("%Build^"_' Variable '_"("""_' Variable '_""")")' [line];
    my= Mumps Code;
}}
class.append Statement_Function_Invoke { method flag Infer_Mumps
{
    string Function [my Function Mumps];
    string Arguments (i Mumps_Listargs);
    string Code [indent] 'do ' Function '(' Arguments ')';
    my= Mumps Code;
}}
class.append Statement_Initialize { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Code [indent] 'do @("%init^"_' Variable '_"("""_' Variable '_""")")' [line];
    my= Mumps Code;
}}
class.append Statement_Queue { method flag Infer_Mumps
{
    string Doarg [my Method Mumps] '^Evolver';
    string Largs (i Mumps_Listargs);
    string Args 'E';
    if (sgt Largs '')
    {
        append Args ',' Largs;
    }
    append Doarg '(' Args ')';
    string Qarg (i Mq Doarg);
    string Code [indent] 'do %Insert^Queue("Queue",' Qarg ')' [line];
    my= Mumps Code;
}}
class.append Statement_Redirect { method flag Infer_Mumps
{
    string Name [my Name Mumps];
    string Args (i Mumps_Listargs);
    string Declaration '';
    entity Arg;
    foreach [my Listargs] Arg
    {
        if (defined [. Arg Mumps_Declaration])
        {
            append Declaration [. Arg Mumps_Declaration];
        }
    }
    string Type [my Return_Type Mumps];
    string Block (i Mumps_Block);
    string Code
        Name '(' Args ') ; redirect ' Type ' ' Name [line]
        Declaration
        Block
        [indent] 'quit' [line];
    my= Mumps Code;
}}
class.append Statement_Return_If_Gs { method flag Infer_Mumps
{
        verbosity [true];
        string Code '';
        string Arg1 [my Arg1 Mumps];
        if (defined [my Arg2])
        {
            append Code
                [indent] 'if ' Arg1 ' set %("return")=' [my Arg2 Mumps]
                    ' quit:$quit %("return") quit' [line];
        }
        else
        {
            append Code [indent] 'quit:' Arg1 [line];
        }
        my= Mumps Code;
}}
class.append Statement_Run_Queue { method flag Infer_Mumps
{
    string Code [indent] 'do %Run^Queue("Queue")' [line];
    my= Mumps Code;
}}
class.append Statement_Subtract { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Code [indent] 'set ' Variable '=' Variable;
    entity Arg;
    foreach [my Listargs] Arg
    {
        append Code '-' (. Arg Matom);
    }
    append Code [line];
    my= Mumps Code;
}}

class.append Syntax_Classes { method flag Infer_Mumps
{
    string Code '^Classes';
    my= Mumps Code;
}}

class.append Operation_Dict_Exists { method flag Infer_Mumps
{
    string Dictionary [my Dictionary Mumps];
    = Dictionary (: Mumps String Dictionary);
    string Key [my Key Mumps];
    string Code '$data(@' Dictionary '@(' Key '))';
    my= Mumps Code;
}}

class.append Operation_File_Exists { method flag Infer_Mumps
{
    string Path [my Path Mumps];
    string Code '$$fileexists^gal(' Path ')';
    my= Mumps Code;
}}

class.append Operation_String { method flag Infer_Mumps
{
    string Op1 [my Op1 Mumps];
    string Code Op1;
    my= Mumps Code;
}}

class.append Statement_Break_If { method flag Infer_Mumps
{
    string Condition [my Condition Mumps];
    string Code [indent] 'goto:' Condition ' ' (i Break_Label) [line];
    my= Mumps Code;
}}

class.append Statement_Continue_If { method flag Infer_Mumps
{
    string Condition [my Condition Mumps];
    string Code [indent] 'goto:' Condition ' ' (i Continue_Label) [line];
    my= Mumps Code;
}}

class.append Statement_File_Delete { method flag Infer_Mumps
{
    string Path [my Path Mumps];
    string Code [line] 'do filedelete^gal(' Path ')' [line];
    my= Mumps Code;
}}

class.append Statement_File_Readall { method flag Infer_Mumps
{
    verbosity;
    string Variable [my Variable Mumps];
    string File_Name [my File_Name Mumps];
    string Code [indent] 'set ' Variable '=$$filereadall^gal(' File_Name ')' [line];
    verbose 'mumps file readall';
    verbose Code;
    my= Mumps Code;
}}

class.append Statement_File_Read_Line { method flag Infer_Mumps
{
    verbosity;
    string Variable [my Variable Mumps];
    string File_Name [my File_Name Mumps];
    string Code [indent] 'set ' Variable '=$$filereadline^gal(' File_Name ')' [line];
    verbose 'mumps file readline';
    verbose Code;
    my= Mumps Code;
}}

class.append Statement_File_Read_List { method flag Infer_Mumps
{
    verbosity;
    string Text [my Text Mumps];
    string File [my File Mumps];
    string List [my List Mumps];
    string LC (firstchar List);
    if (or (s= LC '@') (s= LC '^'))
    {
        = List (append '$name(' List ')');
    }
    string Code [indent] 'set ' Text '=$$filereadlist^gal(' File ',' List ')' [line];
    verbose 'mumps file readline';
    verbose Code;
    my= Mumps Code;
}}

class.append Statement_I { method flag Infer_Mumps
{
    string Method [my Method Mumps];
    string Args (i Mumps_Listargs);
    string Code [indent] 'do ' Method '(' Args ')' [line];
    my= Mumps Code;
}}

class.append Statement_Shell { method flag Infer_Mumps
{
    string Code [indent] 'zsystem ' (i Mumps_Arguments '_') [line];
    my= Mumps Code;
}}

class.append Statement_Require_That_I { method flag Infer_Mumps
{
    string Self_Method [my Self_Method Mumps];
    string Code "if '$$" Self_Method '(' (i Mumps_Listargs) ') quit:$quit [false] quit' [line];
    my= Mumps Code;
}}

class.append Statement_Global_Lock { method flag Infer_Mumps
{
    string Ref [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (sgt Args '')
    {
        append Ref '(' Args ')';
    }
    string Code [indent] 'lock +^' Ref [line];
    my= Mumps Code;
}}

class.append Statement_Global_Unlock { method flag Infer_Mumps
{
    string Ref [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (sgt Args '')
    {
        append Ref '(' Args ')';
    }
    string Code [indent] 'lock -^' Ref [line];
    my= Mumps Code;
}}

class.append Statement_Lock { method flag Infer_Mumps
{
    string Ref [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (sgt Args '')
    {
        append Ref '(' Args ')';
    }
    string Code [indent] 'lock +' Ref [line];
    my= Mumps Code;
}}

class.append Statement_Unlock { method flag Infer_Mumps
{
    string Ref [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (sgt Args '')
    {
        append Ref '(' Args ')';
    }
    string Code [indent] 'lock -' Ref [line];
    my= Mumps Code;
}}

class.append Operation_Absolute { method flag Infer_Mumps
{
    string Op1 [my Op1 Mumps];
    string Code '$fnumber(' Op1 ',"-")';
    my= Mumps Code;
}}

class.append Statement_Numbers { method flag Infer_Mumps
{
    string Args (i Mumps_Arguments);
    string Code "";
    if (sgt Args "")
    {
        append Code [indent] 'new ' Args [line];
    }
    my= Mumps Code;
}}

class.append Statement_Integers { method flag Infer_Mumps
{
    string Args (i Mumps_Arguments);
    string Code "";
    if (sgt Args "")
    {
        append Code [indent] 'new ' Args [line];
    }
    my= Mumps Code;
}}

class.append Statement_Flags { method flag Infer_Mumps
{
    string Args (i Mumps_Arguments);
    string Code "";
    if (sgt Args "")
    {
        append Code [indent] 'new ' Args [line];
    }
    my= Mumps Code;
}}

class.append Statement_Strings { method flag Infer_Mumps
{
    string Args (i Mumps_Arguments);
    string Code "";
    if (sgt Args "")
    {
        append Code [indent] 'new ' Args [line];
    }
    my= Mumps Code;
}}

class.append Statement_Objects { method flag Infer_Mumps
{
    string Args (i Mumps_Arguments);
    string Code "";
    if (sgt Args "")
    {
        append Code [indent] 'new ' Args [line];
    }
    my= Mumps Code;
}}

class.append Statement_Kill { method flag Infer_Mumps
{
    string Node [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (sgt Args "")
    {
        = Node (append '@$name(' Node ')@(' Args ')');
    }
    string Code [indent] 'kill ' Node [line];
    my= Mumps Code;
}}

class.append Statement_Kill_Global { method flag Infer_Mumps
{
    string Node [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (sgt Args "")
    {
        append Node '(' Args ')';
    }
    string Code [indent] 'kill ^' Node [line];
    my= Mumps Code;
}}

class.append Operation_Default { method flag Infer_Mumps
{
    string Value [my Value Mumps];
    string Node '@$name(' [my Root Mumps] ')';
    string Args (i Mumps_Listargs);
    if (sgt Args "")
    {
        append Node '@(' Args ')';
    }
    string Code '$get(' Node ',' Value ')';
    my= Mumps Code;
}}

class.append Operation_Default_Global { method flag Infer_Mumps
{
    string Value [my Value Mumps];
    string Node [my Root Mumps];
    string Args (i Mumps_Listargs);
    if (sgt Args "")
    {
        append Node '(' Args ')';
    }
    string Code '$get(^' Node ',' Value ')';
    my= Mumps Code;
}}

class.append Statement_List_Clear { method flag Infer_Mumps
{
    string List [my List Mumps];
    string Code
        [indent] 'kill ' List [line];
    my= Mumps Code;
}}

class.append Operation_Shift { method flag Infer_Mumps
{
    string List [my First Mumps];
    string Code '$$shift^gal($name(' List '))';
    my= Mumps Code;
}}

class.append Syntax_My_Class { method flag Infer_Mumps
{
    entity Context (i Mumps_Class);
    string Code [. Context Name Mumps];
    my= Mumps Code;
}}

class.append Operation_Environment { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Code (i Mq (env Variable));
    my= Mumps Code;
}}

class.append Statement_Cd { method flag Infer_Mumps
{
    string Code [indent] 'set $zdir=' [my Directory Mumps] [line];
}}

class.append Argument_Syntax { method flag Infer_Mumps
{
    verbosity;
    string Code [my Variable Mumps];
    my= Mumps Code;
    forgive
    {
        string Value [my Default_Value Mumps];
        string Declaration [indent] 'set ' Code '=$get(' Code ',' Value ')' [line];
        my= Mumps_Declaration Declaration;
        verbose '     argument syntax declaration: ' Declaration;
    }
}}

class.append Statement_Iterate { method flag Infer_Mumps
{
    string Dictionary '$name(' [my Dictionary Mumps] ')';
    string Key_Variable [my Key_Variable Mumps];
    string Value_Variable [my Value_Variable Mumps];
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code
        [indent] 'set ' Key_Variable '=""' [line]
        Continue_Label ' ; iterate continue' [line]
        [indent] 'set ' Key_Variable '=$order(@' Dictionary '@(' Key_Variable '))' [line]
        [indent] 'goto:' Key_Variable '="" ' Break_Label [line]
        [indent] 'set ' Value_Variable '=@' Dictionary '@(' Key_Variable ')' [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; iterate break' [line];
    my= Mumps Code;
}}

class.append Statement_Reverse_Iterate { method flag Infer_Mumps
{
    string Dictionary '$name(' [my Dictionary Mumps] ')';
    string Key_Variable [my Key_Variable Mumps];
    string Value_Variable [my Value_Variable Mumps];
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code
        [indent] 'set ' Key_Variable '=""' [line]
        Continue_Label ' ; iterate continue' [line]
        [indent] 'set ' Key_Variable '=$order(@' Dictionary '@(' Key_Variable '),-1)' [line]
        [indent] 'goto:' Key_Variable '="" ' Break_Label [line]
        [indent] 'set ' Value_Variable '=@' Dictionary '@(' Key_Variable ')' [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; iterate break' [line];
    my= Mumps Code;
}}

class.append Statement_Do { method flag Infer_Mumps
{
    verbosity;
    string Doarg [my Doarg Mumps];
    string Code [indent] 'do @' Doarg [line];
    verbose "    do @ " Code;
    my= Mumps Code;
}}

class.append Syntax_Outcomes { method flag Infer_Mumps
{
    verbosity;
    string Code '^O($job)';
    verbose "    Syntax_Outcomes " Code;
    my= Mumps Code;
}}

class.append Syntax_Future { method flag Infer_Mumps
{
    verbosity [true];
    string Code '$name(^F)';
    verbose "    Syntax_Future " Code;
    my= Mumps Code;
}}

class.append Statement_Retain { method flag Infer_Mumps
{
    verbosity [true];
    string Element [my Element Mumps];
    string Bias [my Bias Mumps];
    debug;
    string Code 'todo';
    verbose "    retain " Code;
    my= Mumps Code;
}}

class.append Statement_Forever { method flag Infer_Mumps
{
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code
        Continue_Label ' ; forever continue' [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; forever break' [line];
    my= Mumps Code;
}}

class.append Statement_Open { method flag Infer_Mumps
{
    verbosity;
    string Code [indent] 'open ' [my Device Mumps] ':(recordsize=1048576)';
    if (defined [my Timeout])
    {
        append Code ':' [my Timeout Mumps];
    }
    append Code [line];
    verbose "    open " Code;
    my= Mumps Code;
}}

class.append Statement_Create { method flag Infer_Mumps
{
    verbosity;
    string Code [indent] 'open ' [my Device Mumps] ':(newversion:recordsize=1048576)' [line];
    verbose "    create " Code;
    my= Mumps Code;
}}


class.append Statement_File_Append { method flag Infer_Mumps
{
    verbosity;
    string File_Text [my File_Text Mumps];
    string File_Name [my File_Name Mumps];
    string Code [indent] 'use ' File_Name ' write ' File_Text;
    verbose "    file append " Code;
    my= Mumps Code;
}}

class.append Statement_Close { method flag Infer_Mumps
{
    verbosity;
    string Code [indent] 'close ' [my Device Mumps] [line];
    verbose "    close " Code;
    my= Mumps Code;
}}

class.append Statement_While { method flag Infer_Mumps
{
    string Condition [my Condition Mumps];
    string Break_Label (i Break_Label);
    string Continue_Label (i Continue_Label);
    string Code
        Continue_Label ' ; while continue' [line]
        [indent] 'if ' Condition [line]
        [indent] 'else  goto ' Break_Label [line]
        (i Mumps_Block)
        [indent] 'goto ' Continue_Label [line]
        Break_Label ' ; while break' [line];
    my= Mumps Code;
}}

class.append Syntax_Job { method flag Infer_Mumps
{
    verbosity;
    string Code '$job';
    verbose "    job " Code;
    my= Mumps Code;
}}

class.append Statement_Default { method flag Infer_Mumps
{
    verbosity;
    string Variable [my Variable Mumps];
    string Value [my Value Mumps];
    string Code [indent] 'set ' Variable '=$get(' Variable ',' Value ')' [line];
    verbose "    default " Code;
    my= Mumps Code;
}}

class.append Statement_Job { method flag Infer_Mumps
{
    verbosity;
    string Method [my Method Mumps];
    string Class [my Class Mumps];
    object Arg;
    string Args '';
    foreach [my Listargs] Arg
    {
        append Args ',' [. Arg Mumps];
    }
    string Code [indent] 'job ' Method '^' Class '("' Class '"' Args ')' [line];
    verbose "    job " Code;
    my= Mumps Code;
}}

class.append Syntax_Class_Name { method flag Infer_Mumps
{
    verbosity;
    string Code '%self';
    if (defined [my Object])
    {
        = Code (append '@' [my Object Mumps]);
    }
    verbose 'syntax class name ' Code;
    my= Mumps Code;
}}

class.append Syntax_Class { method flag Infer_Mumps
{
    verbosity [true];
    string Code '%self';
    if (defined [my Object])
    {
        = Code (append '@' [my Object Mumps]);
    }
    my= Mumps Code;
}}

class.append Syntax_List { method flag Infer_Mumps
{
    verbosity;
    string Code [my Variable Mumps];
    verbose '     list argument syntax code: ' Code;
    my= Mumps Code;
    forgive
    {
        string Value [my Default_Value Mumps];
        string Declaration [indent] 'set ' Code '=$get(' Code ',' Value ')' [line];
        my= Mumps_Declaration Declaration;
        verbose '     list argument syntax declaration: ' Declaration;
    }
}}

class.append Statement_Copy_From { method flag Infer_Mumps
{
    string Source [my Source Mumps];
    string Target [my Target Mumps];
    if (sne (firstchar Target) '@')
    {
        = Target (append '@' Target);
    }
    if (sne (firstchar Source) '@')
    {
        = Source (append '@' Source);
    }
    string Code
        [indent] 'kill ' Source [line]
        [indent] 'merge ' Source '=' Target [line]
        ;
    my= Mumps Code;
}}

class.append Statement_Copy_To { method flag Infer_Mumps
{
    string Target [my Target Mumps];
    string Source [my Source Mumps];
    if (sne (firstchar Target) '@')
    {
        = Target (append '@' Target);
    }
    if (sne (firstchar Source) '@')
    {
        = Source (append '@' Source);
    }
    string Code
        [indent] 'kill ' Source [line]
        [indent] 'merge ' Source '=' Target [line]
        ;
    my= Mumps Code;
}}

class.append Statement_Global_List { method flag Infer_Mumps
{
    string Variable [my Variable Mumps];
    string Actual (lowercase Variable);
    string Code [indent] 'new ' Variable [line]
        [indent] 'set ' Variable '=$name(@%matrix@($increment(@%matrix))),'
                '@' Variable '=' (list.length [my Listargs])
        [line];
    entity Arg;
    integer Item 0;
    foreach [my Listargs] Arg
    {
        increment Item;
        string Value [. Arg Mumps];
        append Code [indent] 'set @' Variable '@(' Item ')=' Value [line];
    }
    my= Mumps Code;
}}

class.append Statement_Bless { method flag Infer_Mumps
{
    verbosity;
    string Object [my Object Mumps];
    string Class [my Class Mumps];
    string Code
        [indent] 'set @' Object '=' Class ' do' [line]
        [indent] '. new %self set %self=' Object ' do new2^@' Class [line]
        ;
    verbose "    ~ " Code;
    my= Mumps Code;
}}

class.append Operation_Number { method flag Infer_Mumps
{
    string Op1 [my Op1 Mumps];
    string Code Op1 '+0';
    my= Mumps Code;
}}

class.append Operation_Integer { method flag Infer_Mumps
{
    string Op1 [my Op1 Mumps] '\1';
    string Code Op1;
    my= Mumps Code;
}}

class.append Operation_Flag { method flag Infer_Mumps
{
    string Op1 [my Op1 Mumps];
    string Code Op1 '&1';
    my= Mumps Code;
}}

class.append Operation_Uuid { method flag Infer_Mumps
{
    string Code '$$guid^gal';
    my= Mumps Code;
}}

class.append Operation_QSubscript { method flag Infer_Mumps
{
    verbosity;
    string Glvn [my Glvn Mumps];
    string Subscript [my Subscript Mumps];
    string Code '$qsubscript(' Glvn ',' Subscript ')';
    verbose "    qsubscript " Code;
    my= Mumps Code;
}}

class.append Operation_QLength { method flag Infer_Mumps
{
    verbosity;
    string Glvn [my Glvn Mumps];
    string Code '$qlength(' Glvn ')';
    verbose "    qlength " Code;
    my= Mumps Code;
}}

class.append Syntax_Tail { method flag Infer_Mumps
{
    verbosity [true];
    string Code 'ERROR SYNTAX TAIL';
    error Code;
    my= Mumps Code;
}}

class.append Syntax_Roster_Floor { method flag Infer_Mumps
{
    verbosity;
    string Code [: C Floor];
    verbose [indent] "syntax roster floor " Code;
    my= Mumps Code;
}}

class.append Statement_Function { method flag Infer_Mumps
{
    verbosity;
    string Return [my Return_Type Mumps];
    string Name [my Name Mumps];
    string Args (i Mumps_Listargs);
    string Block (i Mumps_Block);
    string Code
        Name '(' Args ') ; ' Return [line]
        Block
        [indent] 'quit' [line];
    verbose "    function " Code;
    my= Mumps Code;
}}

class.append Operation_New_My_Class { method flag Infer_Mumps
{
    verbosity;
    string Args (i Mumps_Arguments);
    string Code '$$new(' Args ')';
    verbose "    new my class " Code;
    my= Mumps Code;
}}

class.append Operation_New_Our_Class { method flag Infer_Mumps
{
    verbosity;
    string Args (i Mumps_Arguments);
    string Code '$$new(' Args ')';
    verbose "    new our class " Code;
    my= Mumps Code;
}}

class.append Statement_Replace { method flag Infer_Mumps
{
    verbosity;
    string Variable [my Variable Mumps];
    string Search_Text [my Search_Text Mumps];
    string Replace_Text [my Replace_Text Mumps];
    string Code [indent] 'set ' Variable '=$$Replace^%debug(' Variable ',' Search_Text ',' Replace_Text ')' [line];
    verbose "    replace " Code;
    my= Mumps Code;
}}

class.append Statement_Array_Number { method flag Infer_Mumps
{
    verbosity [true];
    string Name [my Name Mumps];
    string Size [my Size Mumps];
    string Lname 'l' Name;
    string Length (list.length [my Listargs]);
    string Code
        [indent] 'new ' Name ' set ' Name '=' Length [line];
    integer Node 0;
    object Arg;
    foreach [my Listargs] Arg
    {
        increment Node;
        append Code
            [indent] 'set ' Name '(' Node ')=' [. Arg Mumps] [line];
    }
    my= Mumps Code;
}}

class.append Operation_Ternary { method flag Infer_Mumps
{
    verbosity;
    string Condition [my Condition Mumps];
    string If [my If Mumps];
    string Else [my Else Mumps];
    string Code '$select(' Condition ':' If ',1:' Else ')';
    verbose "    operation ternary " Code;
    my= Mumps Code;
}}

class.append Operation_Round { method flag Infer_Mumps
{
    verbosity [true];
    string Number [my Number Mumps];
    string Decimals [my Decimals Mumps];
    string Code '$justify(' Number ',0,' Decimals ')';
    verbose "    Operation_Round " Code;
    my= Mumps Code;
}}

comment `
class.append ~ { method flag Infer_Mumps
{
    verbosity [true];
    string Code 'todo';
    debug;
    verbose "    ~ " Code;
    my= Mumps Code;
}}
`;
class Goal_Raku [is Goal]
{
}
class Spell_Raku [is Spell]
{
}
class Raku_Parser
{
    property object Dialect Dialect_Gs;
    property object Inferences (new List [self]);
    property object Tokens (new List [self]);
    property object Elements (new List [self]);
    property integer Position 0;
    constructor [entity Owner]
    {
        my= Owner Owner;
        my= Dialect (new Dialect_Gs);
    }
    method flag Initialize
    {
        flag Verbose [true];
        if Verbose
        {
            writeline [class.name] ' Inits';
        }
        . [my Dialect] Initialize;
        infer.inits;
        return [true];
    }
}
class Raku_Generator [is Generator]
{
    infers Raku;
    property string Language_Name 'Raku';
    property string Property_Name 'Raku';
    property object Elements (new List [self]);
    property object Inferences (new List [self]);
    constructor [entity Owner]
    {
        my= Owner Owner;
    }
    method flag Initialize
    {
        flag Verbose [false];
        if Verbose
        {
            writeline [class.name] ' Inits';
        }
        infer.inits;
        return [true];
    }
    method flag Infer_Raku
    {
        flag Verbose [false];
        entity Elem;
        entity I;
        integer Number 0;
        variant Error;
        foreach [my Elements Symbol_Value] Elem
        {
            try
            {
                = I [. Elem Classification];
                . I Infer_Raku;
                .= Elem Raku [. I Raku];
                increment Number;
            }
            catch Error
            {
                my= Status [false];
                .= Elem Error Error;
                if Verbose
                {
                    writeline 'Error raku element ' Number ': ' [classname I] ', <' Error '>, source ' (. I Get_Input);
                }
            }
        }
        if (not [my Status])
        {
            return [false];
        }
        entity Top (list.last [my Elements Symbol_Value]);
        . Top Infer_Raku;
        string Code [. Top Raku];
        my= Raku Code;
        my= Code Code;
        return [true];
    }
}
inference string Raku;
class Variable_Statement [is Line_Statement]
{
    class.property integer Variable_Number 0;
    property string Variable_Name '';
    method flag Generate
    {
        . [self] Infer_Fallback;
        my= Gal [my Fallback];
        my= Code [my Fallback];
    }
    method string Inner_Code
    {
        . [self] Generate;
        entity Arg;
        string Code '';
        string Child_Code;
        foreach [my Arguments] Arg
        {
            if (isa Arg Name)
            {
                continue;
            }
            if (isa Arg Variable_Statement)
            {
                = Child_Code (. Arg Inner_Code);
                s+ Code Child_Code;
            }
            else
            {
                debug;
            }
        }
        s+ Code [indent] [my Fallback] [line];
        return Code;
    }
    method string Generate_Implementer
    {
        string Code (i Inner_Code) [indent] 'return ' [my Variable_Name] ';';
        return Code;
    }
    method string Unique_Variable
    {
        if (s= [my Variable_Name] '')
        {
            increment [: Variable_Statement Variable_Number];
            string Text [my Variable_Prefix] [: Variable_Statement Variable_Number];
            my= Variable_Name Text;
        }
        return [my Variable_Name];
    }
    method void Wipe_Variables
    {
        my= Variable_Name '';
        my= Definition '';
        entity Arg;
        foreach [my Arguments] Arg
        {
            . Arg Wipe_Variables;
        }
    }
    method void Expression_Generate
    {
        if (isnull [my Expression])
        {
            string Prefix (i Unique_Variable) ' = ';
            string Expression [my Code];
            replace Expression Prefix '';
            my= Expression Expression;
        }
        if (isnull [my Reference])
        {
            my= Reference (i Unique_Variable);
        }
    }
    method flag Is_Expression
    {
        return [true];
    }
}
class Flag_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'F';
    property string Data_Type 'flag';
}
class Integer_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'I';
    property string Data_Type 'integer';
}
class Number_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'N';
    property string Data_Type 'number';
}
class String_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'S';
    property string Data_Type 'string';
}
class List_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'L';
    property string Data_Type 'list';
}
class Dictionary_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'D';
    property string Data_Type 'dictionary';
}
class Object_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'O';
    property string Data_Type 'object';
}
class Variant_Variable_Statement [is Variable_Statement]
{
    property string Variable_Prefix 'V';
    property string Data_Type 'variant';
}
class Statement_Variable_Dot [is Flag_Variable_Statement]
{
    property string Keyword 'string .';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) '.' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.' (. [my Op2] Unique_Variable) ';';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'object')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'property')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_And [is Flag_Variable_Statement]
{
    property string Keyword 'flag and';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' and ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' and ' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' && ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' && ' (. [my Op2] Unique_Variable) ';';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'flag')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'flag')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Or [is Flag_Variable_Statement]
{
    property string Keyword 'flag or';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' or ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' or ' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' || ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' || ' (. [my Op2] Unique_Variable) ';';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'flag')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'flag')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Not [is Flag_Variable_Statement]
{
    property string Keyword 'flag not';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (not ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = not ' [my Op1 Reference];
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = !' (. [my Op1] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = !' (. [my Op1] Unique_Variable) ';';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'flag')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Append [is String_Variable_Statement]
{
    property string Keyword 'string append';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'string ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' append ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' + ' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' + ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'char* ' (i Unique_Variable) ' = ' 'strcat(' (. [my Op1] Unique_Variable) ', ' (. [my Op2] Unique_Variable) ');';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Firstchar [is String_Variable_Statement]
{
    property string Keyword 'string firstchar';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'string ' (i Unique_Variable) ' (firstchar ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[0]';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.charAt(0);';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'char ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[0];';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Lastchar [is String_Variable_Statement]
{
    property string Keyword 'string lastchar';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'string ' (i Unique_Variable) ' (lastchar ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[-1]';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.charAt(' (. [my Op1] Unique_Variable) '.length -1);';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'char ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[strlen(' (. [my Op1] Unique_Variable) ')-1];';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Lowercase [is String_Variable_Statement]
{
    property string Keyword 'string lowercase';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'string ' (i Unique_Variable) ' (lowercase ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.lower()';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) 'toLowerCase();';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'for(int i = 0; Op1[i]; i++) { Op1[i] = tolower(Op1[i]); }';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Uppercase [is String_Variable_Statement]
{
    property string Keyword 'string uppercase';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'string ' (i Unique_Variable) ' (uppercase ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.upper()';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.toUpperCase();';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'for(int i = 0; Op1[i]; i++)
        {
            Op1[i] = toupper(Op1[i]);
        }';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Titlecase [is String_Variable_Statement]
{
    property string Keyword 'string titlecase';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'string ' (i Unique_Variable) ' (titlecase ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.title()';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = goalspell.titlecase(' (. [my Op1] Unique_Variable) ');';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'todo';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Substring [is String_Variable_Statement]
{
    property string Keyword 'string substring';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument String_Value';
        }
        my= String_Value (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Start_Index';
        }
        my= Start_Index (shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Length (shift [my Listargs]);
        }
    }
    property object String_Value (new Argument [self]);
    property object Start_Index (new Argument [self]);
    property object Length;
    method void Infer_Fallback
    {
        string Code 'string ' (. [my String_Value] Unique_Variable) ' ' (. [my Start_Index] Unique_Variable);
        if (defined [my Length])
        {
            append Code ' ' [my Length Reference];
        }
        append Code ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string SVal (. [my String_Value] Unique_Variable);
        string Start (. [my Start_Index] Unique_Variable);
        string Code (i Unique_Variable) ' = ';
        if (defined [my Length])
        {
            string Len [my Length Reference];
            if (s= Len '1')
            {
                append Code (append SVal '[' Start ']');
            }
            else
            {
                append Code (append SVal '[' Start ':(' Start ')+(' Len ')]');
            }
        }
        else
        {
            append Code (append SVal '[' Start ':]');
        }
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code (. [my String_Value] Unique_Variable) '.substr(' (. [my Start_Index] Unique_Variable);
        if (defined [my Length])
        {
            append Code ', ' [my Length Reference];
        }
        append Code ');';
        my= Javascript Code;
    }
    method void Infer_C
    {
        comment `TODO: "substring functions seem complicated in C, I'm going to wait to do this one"`;
    }
    method flag Can [list Preds]
    {
        if (lt (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'integer')
        {
            return [false];
        }
        if (= (list.length Preds) 2)
        {
            return [true];
        }
        if (s!= [. (list.get Preds 2) Data_Type] 'integer')
        {
            return [false];
        }
        if (= (list.length Preds) 3)
        {
            return [true];
        }
        return [false];
    }
}
class Statement_Variable_Begins [is Flag_Variable_Statement]
{
    property string Keyword 'flag begins';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' begins ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[: len(' (. [my Op2] Unique_Variable) ')] == ' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.substr(0, ' (. [my Op2] Unique_Variable) '.length -1) == ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = strncmp(' (. [my Op2] Unique_Variable) ', ' (. [my Op1] Unique_Variable) ', strlen(' (. [my Op2] Unique_Variable) ')) == 0;';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Contains [is Flag_Variable_Statement]
{
    property string Keyword 'flag contains';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' contains ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op2] Unique_Variable) ' in ' (. [my Op1] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.includes(' (. [my Op2] Unique_Variable) ');';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = strstr(' (. [my Op1] Unique_Variable) ', ' (. [my Op2] Unique_Variable) ');';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Is_Null [is Flag_Variable_Statement]
{
    property string Keyword 'flag isnull';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (is null ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) " in (None, '')";
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' == null || ' (. [my Op1] Unique_Variable) " == '';";
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' == NULL;';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Is_Number [is Flag_Variable_Statement]
{
    property string Keyword 'flag isnumber';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (is_number ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'isinstance(' (. [my Op1] Unique_Variable) ', (int, float, complex))';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' '(typeof ' (. [my Op1] Unique_Variable) " === 'number');";
        my= Javascript Code;
    }
    comment "TODO: 'come back to this'";
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Is_Punct [is Flag_Variable_Statement]
{
    property string Keyword 'flag ispunct';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (is punct ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' in string.punctuation';
        my= Python Code;
    }
    comment "TODO: javascript 'write statement in Javascript.gal' 'TODO'";
    method void Infer_C
    {
        string Code 'TODO';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Is_String [is Flag_Variable_Statement]
{
    property string Keyword 'flag isstring';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (is string ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'isinstance(' (. [my Op1] Unique_Variable) ', str)';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' '(typeof ' (. [my Op1] Unique_Variable) " === 'string');";
        my= Javascript Code;
    }
    comment "TODO: 'come back to this'";
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Is_Uppercase [is Flag_Variable_Statement]
{
    property string Keyword 'flag isupper';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (isupper ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.isupper()';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.match(/[A-Z]/);';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' >= A && ' (. [my Op1] Unique_Variable) " <= 'Z';";
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Is_Lowercase [is Flag_Variable_Statement]
{
    property string Keyword 'flag islower';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (islower ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.islower()';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.match(/[a-z]/);';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' >= a && ' (. [my Op1] Unique_Variable) " <= 'z';";
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Is_Whitespace [is Flag_Variable_Statement]
{
    property string Keyword 'flag iswhitespace';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (is whitespace ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = (' (. [my Op1] Unique_Variable) " in ' \n\r\t')";
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' "' \t\n\r'.includes(" (. [my Op1] Unique_Variable) ');';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = isspace(' (. [my Op1] Unique_Variable) ');';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Not_Null [is Flag_Variable_Statement]
{
    property string Keyword 'flag notnull';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (not (is null ' (. [my Op1] Unique_Variable) '));';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) " > ''";
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' '(' (. [my Op1] Unique_Variable) ' != null && ' (. [my Op1] Unique_Variable) " > '');";
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' != NULL;';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_String_Equal [is Flag_Variable_Statement]
{
    property string Keyword 'flag s=';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' s= ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'str(' (. [my Op1] Unique_Variable) ') == str(' (. [my Op2] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.toString() == ' (. [my Op2] Unique_Variable) '.toString();';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = strcmp(' (. [my Op1] Unique_Variable) ', ' (. [my Op2] Unique_Variable) ');';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_String_Greater [is Flag_Variable_Statement]
{
    property string Keyword 'flag sgt';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' sgt ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'str(' (. [my Op1] Unique_Variable) ') > str(' (. [my Op2] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.toString() > ' (. [my Op2] Unique_Variable) '.toString();';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_String_Not_Equal [is Flag_Variable_Statement]
{
    property string Keyword 'flag sne';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' sne ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'str(' (. [my Op1] Unique_Variable) ') != str(' (. [my Op2] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.toString() != ' (. [my Op2] Unique_Variable) '.toString();';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = !(strcmp(' (. [my Op1] Unique_Variable) ', ' (. [my Op2] Unique_Variable) '));';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Char2int [is Integer_Variable_Statement]
{
    property string Keyword 'integer char2int';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'integer ' (i Unique_Variable) ' (chartoint ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'ord(' (. [my Op1] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.charCodeAt(0);';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'int ' (i Unique_Variable) ' = int ' (. [my Op1] Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ';';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_String_Length [is Integer_Variable_Statement]
{
    property string Keyword 'integer length';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'integer ' (i Unique_Variable) ' (length ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'len(' (. [my Op1] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.length;';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'int ' (i Unique_Variable) ' = strlen(' (. [my Op1] Unique_Variable) ');';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Equal [is Flag_Variable_Statement]
{
    property string Keyword 'flag ==';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' = ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' == ' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' == ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' == ' (. [my Op2] Unique_Variable);
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s= [. (list.get Preds 0) Data_Type] 'number')
        {
            return [false];
        }
        if (s= [. (list.get Preds 1) Data_Type] 'number')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Greater [is Flag_Variable_Statement]
{
    property string Keyword 'flag gt';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' gt ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' > ' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' > ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' > ' (. [my Op2] Unique_Variable);
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s= [. (list.get Preds 0) Data_Type] 'number')
        {
            return [false];
        }
        if (s= [. (list.get Preds 1) Data_Type] 'number')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Less [is Flag_Variable_Statement]
{
    property string Keyword 'flag lt';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (' (. [my Op1] Unique_Variable) ' lt ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' lt ' (. [my Op2] Unique_Variable);
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' lt ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' lt ' (. [my Op2] Unique_Variable);
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s= [. (list.get Preds 0) Data_Type] 'number')
        {
            return [false];
        }
        if (s= [. (list.get Preds 1) Data_Type] 'number')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_List_Split [is List_Variable_Statement]
{
    property string Keyword 'list split';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'list ' (i Unique_Variable) ' (split ' (. [my Op1] Unique_Variable) ' ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.split(' (. [my Op2] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.split(' (. [my Op2] Unique_Variable) ');';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'char* ' (i Unique_Variable) ' = ';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'string')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'string')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_List_Get [is Variant_Variable_Statement]
{
    property string Keyword 'variant list get';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'variant ' (i Unique_Variable) ' (list get ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[' (. [my Op2] Unique_Variable) ']';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[' (. [my Op2] Unique_Variable) '];';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'char ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[' (. [my Op2] Unique_Variable) '];';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'list')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'integer')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_List_Last [is Variant_Variable_Statement]
{
    property string Keyword 'variant list last';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'variant ' (i Unique_Variable) ' (list last ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (. [my Op1] Unique_Variable) '[-1]';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code (. [my Op1] Unique_Variable) '.slice(-1)';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'char ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '[sizeof(' (. [my Op1] Unique_Variable) ')-1];';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'list')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_List_Length [is Integer_Variable_Statement]
{
    property string Keyword 'integer list length';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'integer ' (i Unique_Variable) ' (list length ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'len(' (. [my Op1] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) '.length;';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'int ' (i Unique_Variable) ' = sizeof(' (. [my Op1] Unique_Variable) ');';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'list')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Isa [is Flag_Variable_Statement]
{
    property string Keyword 'flag isa';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op2';
        }
        my= Op2 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    property object Op2 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'flag ' (i Unique_Variable) ' (isa ' (. [my Op1] Unique_Variable) ' ' (. [my Op2] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code (i Unique_Variable) ' = ' 'isinstance(' (. [my Op1] Unique_Variable) ', Main_Module.' (. [my Op2] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ' instanceof ' (. [my Op2] Unique_Variable) ';';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'bool ' (i Unique_Variable) ' = ';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 2)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'object')
        {
            return [false];
        }
        if (s!= [. (list.get Preds 1) Data_Type] 'class')
        {
            return [false];
        }
        return [true];
    }
}
class Statement_Variable_Int2char [is String_Variable_Statement]
{
    property string Keyword 'string int2char';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Op1';
        }
        my= Op1 (shift [my Listargs]);
    }
    property object Op1 (new Argument [self]);
    method void Infer_Fallback
    {
        string Code 'string ' (i Unique_Variable) ' = (int2char ' (. [my Op1] Unique_Variable) ');';
        my= Fallback Code;
    }
    method void Infer_Python
    {
        string Code 'chr(' (. [my Op1] Unique_Variable) ')';
        my= Python Code;
    }
    method void Infer_Javascript
    {
        string Code 'var ' (i Unique_Variable) ' = String.fromCharCode(' (. [my Op1] Unique_Variable) ');';
        my= Javascript Code;
    }
    method void Infer_C
    {
        string Code 'char ' (i Unique_Variable) ' = char ' (. [my Op1] Unique_Variable) ' = ' (. [my Op1] Unique_Variable) ';';
        my= C Code;
    }
    method flag Can [list Preds]
    {
        if (!= (list.length Preds) 1)
        {
            return [false];
        }
        if (s!= [. (list.get Preds 0) Data_Type] 'integer')
        {
            return [false];
        }
        return [true];
    }
}
comment '**************' [line] '* Parallel.txt' [line] '**************';
class Statement_Abstract [is Scoped_Statement]
{
    property string Keyword 'abstract';
    method void Attributes
    {
        if (= (list.length [my Listargs]) 0)
        {
            error 'missing required argument Name';
        }
        my= Name (shift [my Listargs]);
        if (gt (list.length [my Listargs]) 0)
        {
            my= Default_Keyword (shift [my Listargs]);
        }
        if (gt (list.length [my Listargs]) 0)
        {
            my= Ancestor (shift [my Listargs]);
        }
    }
    property object Name (new Argument [self]);
    property object Default_Keyword;
    property object Ancestor;
    method void Infer_Fallback
    {
        string Name [my Name Fallback];
        string Default_Keyword [my Default_Keyword Fallback];
        string Ancestor [my Ancestor Fallback];
        string Class_Declaration 'class ' Name ' [is ' Ancestor '];';
        string Statement_Declaration 'statement ' Name ' ' Default_Keyword ' Abstract;';
        string Code 'comment ' (i Enquote (append 'abstract ' Name ' ' Default_Keyword ' ' Ancestor ';')) [line] Class_Declaration [line] Statement_Declaration [line];
        my= Fallback Code;
        return [true];
    }
}
flowerbox 'Location.gal';

    inference entity Location
    {
        isa Gal_Parser
        {
            entity Elem;
            foreach [my.attribute Elements] Elem
            {
                . Elem Infer_Location;
            }
            return [true];
        }
        isa Gs_Parser
        {
            entity Elem;
            foreach [my.attribute Elements] Elem
            {
                . Elem Infer_Location;
            }
            return [true];
        }
        isa Element
        {
            entity Doc;
            entity Start;
            entity End;
            returnif (defined [my Location]);
            entity First (list.get [my Elements] 0);
            entity Last (list.last [my Elements]);
            entity Doc [. First Location Document];
            integer Start [. First Location Start_Position];
            integer End [. Last Location End_Position];
            entity.new Loc Location Doc Start End;
            it= Loc;
        }
    }
flowerbox 'Tokens.gal';

goal.spell Tokens
    `group characters into meaningful language tokens such as words and punctuation`
{
    class Tokens [is List];

    class.append Parser
    {
        method flag Balanced_Quotes [string First, string Last]
        {
            returnif (and (s= First '"') (s= Last '"')) [true];
            returnif (and (s= First "'") (s= Last "'")) [true];
            returnif (and (s= First '`') (s= Last '`')) [true];
            returnif (and (s= First '«') (s= Last '»')) [true];
            returnif (and (s= First '‘') (s= Last '’')) [true];
            returnif (and (s= First '“') (s= Last '”')) [true];
            returnif (and (s= First '‹') (s= Last '›')) [true];
            return [false];
        }
        method flag Consume_Token
        {
            if (ge [my Position] 
                (list.length [my.attribute Tokens]))
            {
                return [false];
            }
            entity Top (list.get [my.attribute Tokens] [my Position]);
            .= Top Error [null];
            i Add_Element Top;
            ++ [my Position];
            return [true];
        }
    }

    inference list Tokens
    {
        isa Gal_Parser
        {
            entity O [my Owner];
            verbosity;
            string Ignore;
            strings Mode C Next;
            string Q '';
            integer Position;
            string Input [my.attribute Owner Input];
            verbose "Input: " Input;
            integer Last (- (length Input) 1);
            tokenmode Initial;
            entity T;
            for.range Position 0 Last 1
            {
                = Next (substring Input Position 2);
                = C (firstchar Next);
                verbose Mode ' [' C ']';
                if (= Position Last)
                {
                    = Next '';
                }
                else
                {
                    = Next (lastchar Next);
                }

                if (tokenmode Initial)
                {
                }
                else.if (tokenmode Quote)
                {
                    token.append T C Position;
                    if (i Balanced_Quotes Q C)
                    {
                        tokenmode Initial;
                        continue;
                    }
                }
                else.if (tokenmode Whitespace)
                {
                    if (is.whitespace C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    tokenmode Initial;
                }
                else.if (tokenmode Number)
                {
                    if (contains '0123456789.' C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    tokenmode Initial;
                }
                else.if (tokenmode Name)
                {
                    if (isident C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    else
                    {
                        tokenmode Initial;
                    }
                }
                else.if (tokenmode Keyword)
                {
                    if (or (is.whitespace C) (contains "([{<~,;>}])" C))
                    {
                        tokenmode Initial;
                    }
                    else.if (or (contains '`"' C) (s= "'" C))
                    {
                        tokenmode Initial;
                    }
                    else
                    {
                        token.append T C Position;
                        continue;
                    }
                }
                else
                {
                    debug;
                    error 'Unknown Token Mode ' Mode;
                }
                if (tokenmode Initial)
                {
                    comment `«»‘’“”‹›`;
                    if (or (s= C "'") (contains '"`«‘“‹' C))
                    {
                        = Q C;
                        newtoken T Quote Quote C Position Position;
                    }
                    else.if (s= C '(')
                    {
                        newtoken T Operation_Start Initial C Position Position;
                    }
                    else.if (s= C ')')
                    {
                        newtoken T Operation_End Initial C Position Position;
                    }
                    else.if (s= C '[')
                    {
                        newtoken T Syntax_Start Initial C Position Position;
                    }
                    else.if (s= C ']')
                    {
                        newtoken T Syntax_End Initial C Position Position;
                    }
                    else.if (s= C '{')
                    {
                        newtoken T Block_Start Initial C Position Position;
                    }
                    else.if (s= C '}')
                    {
                        newtoken T Block_End Initial C Position Position;
                    }
                    else.if (s= C ',')
                    {
                        newtoken T Comma Initial C Position Position;
                    }
                    else.if (s= C ';')
                    {
                        newtoken T Semi Initial C Position Position;
                    }
                    else.if (s= C '~')
                    {
                        newtoken T Tilde Initial C Position Position;
                    }
                    else.if (is.whitespace C)
                    {
                        skiptoken T Whitespace Whitespace C Position Position;
                    }
                    else.if (is.uppercase C)
                    {
                        newtoken T Name Name C Position Position;
                    }
                    else.if (or (contains '01234567890' C)
                                (and (contains '-.'  C) (contains '01234567890' Next)))
                    {
                        newtoken T Number Number C Position Position;
                    }
                    else
                    {
                        newtoken T Keyword Keyword C Position Position;
                    }
                }
            }
            if Verbose
            {
                integer Position 0;
                foreach [my.attribute Tokens] T
                {
                    writeline Position ' ' [class.name T] ' ' [. T Input];
                    ++ Position;
                }
            }
        }
        isa Gs_Parser
        {
            entity O [my Owner];
            verbosity;
            string Ignore;
            strings Mode C Next;
            string Q '';
            integer Position;
            string Input [my.attribute Owner Input];
            verbose "Input: " Input;
            integer Last (- (length Input) 1);
            tokenmode Initial;
            entity T;
            for.range Position 0 Last 1
            {
                = Next (substring Input Position 2);
                = C (firstchar Next);
                verbose Mode ' [' C ']';
                if (= Position Last)
                {
                    = Next '';
                }
                else
                {
                    = Next (lastchar Next);
                }

                if (tokenmode Initial)
                {
                }
                else.if (tokenmode Quote)
                {
                    token.append T C Position;
                    if (i Balanced_Quotes Q C)
                    {
                        tokenmode Initial;
                        continue;
                    }
                }
                else.if (tokenmode Whitespace)
                {
                    if (is.whitespace C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    tokenmode Initial;
                }
                else.if (tokenmode Number)
                {
                    if (contains '0123456789.' C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    tokenmode Initial;
                }
                else.if (tokenmode Name)
                {
                    if (isident C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    else
                    {
                        tokenmode Initial;
                    }
                }
                else.if (tokenmode Keyword)
                {
                    if (or (is.whitespace C) (contains "([{<,;>}])0123456789$" C))
                    {
                        tokenmode Initial;
                    }
                    else.if (or (contains '`"' C) (s= "'" C))
                    {
                        tokenmode Initial;
                    }
                    else.if (isupper C)
                    {
                        tokenmode Initial;
                    }
                    else
                    {
                        token.append T C Position;
                        continue;
                    }
                }
                else
                {
                    debug;
                    error 'Unknown Token Mode ' Mode;
                }
                if (tokenmode Initial)
                {
                    if (or (s= C "'") (contains '"`«‘“‹' C))
                    {
                        = Q C;
                        newtoken T Quote Quote C Position Position;
                    }
                    else.if (s= C '(')
                    {
                        newtoken T Operation_Start Initial C Position Position;
                    }
                    else.if (s= C ')')
                    {
                        newtoken T Operation_End Initial C Position Position;
                    }
                    else.if (s= C '[')
                    {
                        newtoken T Syntax_Start Initial C Position Position;
                    }
                    else.if (s= C ']')
                    {
                        newtoken T Syntax_End Initial C Position Position;
                    }
                    else.if (s= C '{')
                    {
                        newtoken T Block_Start Initial C Position Position;
                    }
                    else.if (s= C '}')
                    {
                        newtoken T Block_End Initial C Position Position;
                    }
                    else.if (s= C ',')
                    {
                        newtoken T Comma Initial C Position Position;
                    }
                    else.if (s= C ';')
                    {
                        newtoken T Semi Initial C Position Position;
                    }
                    else.if (is.whitespace C)
                    {
                        skiptoken T Whitespace Whitespace C Position Position;
                    }
                    else.if (or (is.uppercase C) (s= C '$'))
                    {
                        newtoken T Name Name C Position [self];
                    }
                    else.if (or (contains '01234567890' C)
                                (and (contains '-.'  C) (contains '01234567890' Next)))
                    {
                        newtoken T Number Number C Position Position;
                    }
                    else
                    {
                        newtoken T Keyword Keyword C Position Position;
                    }
                }
            }
            if Verbose
            {
                integer Position 0;
                foreach [my.attribute Tokens] T
                {
                    writeline Position ' ' [class.name T] ' ' [. T Input];
                    ++ Position;
                }
            }
        }
        isa BNF_Parser
        {
            entity O [my Owner];
            verbosity;
            verbose 'TOKENIZE BNF BEGIN';
            string Ignore;
            strings Mode C Next;
            string Q '';
            integer Position;
            string Input [my.attribute Owner Input];
            verbose "Input: " Input;
            integer Last (- (length Input) 1);
            tokenmode Initial;
            entity T;
            for.range Position 0 Last 1
            {
                = Next (substring Input Position 2);
                = C (firstchar Next);
                verbose Mode ' [' C ']';
                if (= Position Last)
                {
                    = Next '';
                }
                else
                {
                    = Next (lastchar Next);
                }

                if (tokenmode Initial)
                {
                }
                else.if (tokenmode Quote)
                {
                    token.append T C Position;
                    if (i Balanced_Quotes Q C)
                    {
                        tokenmode Initial;
                        continue;
                    }
                }
                else.if (tokenmode Whitespace)
                {
                    if (s= C [line])
                    {
                        tokenmode Initial;
                    }
                    else.if (is.whitespace C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    tokenmode Initial;
                }
                else.if (tokenmode Number)
                {
                    if (contains '0123456789.' C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    tokenmode Initial;
                }
                else.if (tokenmode Name)
                {
                    if (isident C)
                    {
                        token.append T C Position;
                        continue;
                    }
                    else
                    {
                        tokenmode Initial;
                    }
                }
                else.if (tokenmode Keyword)
                {
                    if (or (is.whitespace C) (contains "|:#" C))
                    {
                        tokenmode Initial;
                    }
                    else.if (or (contains '`"' C) (s= "'" C))
                    {
                        tokenmode Initial;
                    }
                    else
                    {
                        token.append T C Position;
                        continue;
                    }
                }
                else.if (tokenmode Comment)
                {
                    if (s= C [line])
                    {
                        tokenmode Initial;
                        continue;
                    }
                }
                else.if (tokenmode Token)
                {
                    debug;
                    comment 'This should not occur?';
                }
                else
                {
                    debug;
                    error 'Unknown Token Mode ' Mode;
                }
                if (tokenmode Initial)
                {
                    if (or (s= C "'") (contains '"`«‘“‹' C))
                    {
                        = Q C;
                        newtoken T Quote Quote C Position Position;
                    }
                    if (contains '|:=' C)
                    {
                        newtoken T Keyword Keyword C Position Position;
                    }
                    if (contains '#;' C)
                    {
                        newtoken T Comment Comment C Position Position;
                    }
                    else.if (contains '~!@$%^&*_-+{[()]}\;?,./' C)
                    {
                        newtoken T Token Initial C Position Position;
                    }
                    else.if (s= '<' C)
                    {
                        newtoken T Name_Special Name_Special C Position Position;
                    }
                    else.if (s= C [line])
                    {
                        newtoken T Token Initial C Position Position;
                    }
                    else.if (is.whitespace C)
                    {
                        skiptoken T Whitespace Whitespace C Position Position;
                    }
                    else.if (or (is.uppercase C) (is.lowercase C))
                    {
                        newtoken T Name Name C Position Position;
                    }
                    else.if (or (contains '01234567890' C)
                                (and (contains '-.'  C) (contains '01234567890' Next)))
                    {
                        newtoken T Number Number C Position Position;
                    }
                    else
                    {
                        debug;
                        newtoken T Token Initial C Position Position;
                    }
                }
            }
            if Verbose
            {
                integer Position 0;
                foreach [my.attribute Tokens] T
                {
                    writeline Position ' ' [class.name T] ' ' [. T Input];
                    ++ Position;
                }
            }
            verbose 'TOKENIZE BNF END';
        }
    }
}
flowerbox 'Classification.gal';

goal Classification
    `infer the language element that implements a parsed statement, operation or syntax`;

spell Verb
{
    class.append Named_Element
    {
        property string Verb;
        property list Verbs;
    }

    inference string Verb
    {
        isa Gal_Parser
        {
            entity Elem;
            foreach [my.attribute Elements] Elem
            {
                . Elem Infer_Verb;
                if (and (isnull [. Elem Verb])
                        (isa Elem Named_Element))
                {
                    contif (isa Elem Tail);
                    if (isa Elem Syntax)
                    {
                        debug;
                        .= Elem Verb 'hello';
                    }
                    else
                    {
                        debug;
                        .= Elem Verb 'invoke';
                    }
                }
            }
            return [true];
        }
        isa Gs_Parser
        {
            entity Elem;
            foreach [my.attribute Elements] Elem
            {
                . Elem Infer_Verb;
                if (and (isnull [. Elem Verb])
                        (isa Elem Named_Element))
                {
                    contif (isa Elem Tail);
                    if (isa Elem Syntax)
                    {
                        debug;
                        .= Elem Verb 'hello';
                    }
                    else
                    {
                        .= Elem Verb 'invoke';
                        push [. Elem Verbs] 'invoke';
                    }
                }
            }
            return [true];
        }
        isa Element
        {
            it= '';
        }
        isa Named_Element
        {
            verbosity [false];
            string Vrb '';
            string Between '';
            entity Elem;
            list New_Verbs;
            my= Verbs New_Verbs;
            foreach [my Elements] Elem
            {
                if (isa Elem Keyword_Token)
                {
                    append Vrb Between [. Elem Input];
                    = Between ' ';
                    list.append [my Verbs] Vrb;
                }
            }
            if (contains Vrb ' ')
            {
                string V Vrb;
                replace V ' ' '';
                if (contains V '.')
                {
                    list.append [my Verbs] V;
                    verbose 'infer verb ' V;
                }
            }
            verbose [class.name [self]] ' ' Vrb;
            it= Vrb;
        }
        isa Syntax_Tail
        {
            flag Verbose [false];
            string Vrb '';
            string Between '';
            entity Elem;
            list New_Verbs;
            my= Verbs New_Verbs;
            foreach [my Elements] Elem
            {
                contif (isa Elem Token_Comma);
                if (isa Elem Keyword_Token)
                {
                    append Vrb Between [. Elem Input];
                    = Between ' ';
                    list.append [my Verbs] Vrb;
                }
            }
            verbose [class.name [self]] ' ' Vrb;
            it= Vrb;
        }
        isa Operation_Tail
        {
            flag Verbose [false];
            string Vrb '';
            string Between '';
            entity Elem;
            list New_Verbs;
            my= Verbs New_Verbs;
            foreach [my Elements] Elem
            {
                contif (isa Elem Token_Comma);
                if (isa Elem Keyword_Token)
                {
                    append Vrb Between [. Elem Input];
                    = Between ' ';
                    list.append [my Verbs] Vrb;
                }
            }
            verbose [class.name [self]] ' ' Vrb;
            it= Vrb;
        }
    }
}

spell Classification
{
    class.append Element
    {
        property entity Classification;
        property list Classifications;
        property string Class_Name;
    }

    inference entity Classification
    {

        isa Gal_Parser
        {
            verbosity [true];
            entity Elem;
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    if (not (. Elem Infer_Classification))
                    {
                        my= Status [false];
                        .= Elem Error 'Unable to classify this language element.';
                        verbose 'gal classify: ' [. Elem Error];
                    }
                }
                catch Error
                {
                    my= Status [false];
                    .= Elem Error Error;
                }
            }
            return [my Status];
        }

        isa Gs_Parser
        {
            verbosity [true];
            entity Elem;
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    if (not (. Elem Infer_Classification))
                    {
                        my= Status [false];
                        .= Elem Error 'Unable to classify this language element.';
                        verbose 'goalspell classify: ' [. Elem Error];
                    }
                }
                catch Error
                {
                    my= Status [false];
                    .= Elem Error Error;
                }
            }
            return [my Status];
        }

        isa Element
        {
            it= [self];
        }

        isa Statement
        {
            verbosity [true];
            string Verb;
            string Last '<unknown keyword>';
            entity Singleton;
            entity Classification;
            flag Found [false];
            foreach [my Verbs] Verb
            {
                if (dict.exists [my Document Dialect Statements] Verb)
                {
                    = Singleton (dict.get [my Document Dialect Statements] Verb);
                    = Classification (. Singleton Factory [self]);
                    list.append [my Classifications] Classification;
                    my= Verb Verb;
                    it= Classification;
                    = Found [true];
                    = Last Verb;
                }
            }
            if (not Found)
            {
                verbose 'Default Statement ' [my Verb];
                entity Singleton (new Statement);
                = Classification (. Singleton Factory [self]);
                list.append [my Classifications] Classification;
                it= Classification;
            }
            string Class_Name [class.name [my Classification]];
            my= Class_Name Class_Name;
            = [my Classification Class_Name] Class_Name;
        }

        isa Operation
        {
            verbosity [true];
            string Verb;
            string Last '<unknown keyword>';
            entity Singleton;
            entity Classification;
            flag Found [false];
            foreach [my Verbs] Verb
            {
                if (dict.exists [my Document Dialect Operations] Verb)
                {
                    = Singleton (dict.get [my Document Dialect Operations] Verb);
                    = Classification (. Singleton Factory [self]);
                    list.append [my Classifications] Classification;
                    my= Verb Verb;
                    it= Classification;
                    = Found [true];
                }
            }
            if (not Found)
            {
                verbose 'Default Operation ' [my Verb];
                entity Singleton (new Operation);
                = Classification (. Singleton Factory [self]);
                list.append [my Classifications] Classification;
                my= Verb Last;
                it= Classification;
            }
            string Class_Name [class.name [my Classification]];
            my= Class_Name Class_Name;
            = [my Classification Class_Name] Class_Name;
        }

        isa Syntax
        {
            verbosity [true];
            string Verb;
            string Last '<unknown keyword>';
            entity Singleton;
            entity Classification;
            flag Found [false];
            foreach [my Verbs] Verb
            {
                if (dict.exists [my Document Dialect Syntaxes] Verb)
                {
                    = Singleton (dict.get [my Document Dialect Syntaxes] Verb);
                    = Classification (. Singleton Factory [self]);
                    list.append [my Classifications] Classification;
                    my= Verb Verb;
                    it= Classification;
                    = Found [true];
                }
            }
            if (not Found)
            {
                verbose 'Default Syntax ' [my Verb];
                entity Singleton (new Syntax);
                = Classification (. Singleton Factory [self]);
                list.append [my Classifications] Classification;
                my= Verb Last;
                it= Classification;
            }
            string Class_Name [class.name [my Classification]];
            my= Class_Name Class_Name;
            = [my Classification Class_Name] Class_Name;
       }
    }
}
flowerbox 'Components.gal';

goal Components `infer the components, attributes and structure of language elements`;

class.append Element
{
    property string Id;
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}

class.append Named_Element
{
    method flag Allow_Suffix [string Suffix]
    {
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Action
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " void variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Implementers
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}
class.append Statement_Function_Pointer
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}
class.append Statement_Interface
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}
class.append Statement_Infer
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}
class.append Syntax_Function_Pointer
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}
class.append Statement_Obj
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " = " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Implementer
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " = " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Array
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Property
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Gpu_Property
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Constant
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Class_Property
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Attribute
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Class_Attribute
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Method
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Function
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Redirect
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Async_Method
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Feature
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Inference
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Behavior_Statement
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Class_Method
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Symbol
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Spell
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Statement_Collates
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " by property " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Declaration_Statement
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " = " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}
class.append Syntax_Set
{
    method flag Allow_Suffix [string Suffix]
    {
        returnif (contains " = " (s+ Suffix ' ')) [true];
        my= Error (append 'Unexpected extra keywords "' Suffix '".');
        return [false];
    }
}

class.append Comment_Statement
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}
class.append Statement_Process
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}

class.append Statement_Tilda
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}

class.append Statement_Gal_Statement
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}

class.append Statement_Gal_Operation
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}

class.append Statement_Gal_Syntax
{
    method flag Allow_Suffix [string Suffix]
    {
        return [true];
    }
}

spell Components
{
    class Components [is List]
    {
        method flag Infer
        {
            require.that (. [my Symbol_Object] Infer_Components);
            return [true];
        }
    }

    inference flag Components
    {
        isa Gal_Parser
        {
            entity Elem;
            foreach [my.attribute Elements] Elem
            {
                . Elem Infer_Components;
            }
            return [true];
        }
        isa Gs_Parser
        {
            verbosity;
            entity Elem;
            flag Status [true];
            foreach [my.attribute Elements] Elem
            {
                verbose [classname [. Elem Classification]] ' Components';
                if (not (. Elem Infer_Components))
                {
                    = Status [false];
                }
            }
            return Status;
        }
        isa Element
        {
            return [true];
        }
        isa Statement
        {
            verbosity;
            entity I [my Classification];
            entity Elem;
            entity BE;
            string Keyword '';
            string Verb [my Verb];
            string Verb_Tail Verb;
            string Suffix '';
            foreach [my Elements] Elem
            {
                entity Imp [. Elem Classification];
                .= Elem Parent [self];
                .= Imp Parent I;
                if (isa Elem Block)
                {
                    .= I Block Imp;
                    my= Block Imp;
                    foreach [. Imp Statements] BE
                    {
                        .= BE Parent I;
                    }
                }
                else.if (isa Elem Keyword_Token)
                {
                    string Input [. Elem Input];
                    list.append [. I Gal_Keywords] Input;
                    list.append [. I Gs_Keywords] Input;
                    if (startswith Verb_Tail Input)
                    {
                        = Verb_Tail (substring Verb_Tail (length Input));
                    }
                    else
                    {
                        append Suffix ' ' Input;
                        list.append [. I Keywords] Imp;
                    }
                }
                else.if (isa Elem Boundary_Token)
                {
                    continue;
                }
                else
                {
                    list.append [my Arguments] Elem;
                    list.append [my Listargs] Elem;
                    list.append [. I Arguments] Imp;
                    list.append [. I Listargs] Imp;
                    if (isa Imp Syntax)
                    {
                        entity SE;
                        foreach [. Elem Tails] SE
                        {
                            list.append [my Arguments] SE;
                            list.append [my Listargs] SE;
                        }
                        foreach [. Imp Tails] SE
                        {
                            list.append [. I Arguments] SE;
                            list.append [. I Listargs] SE;
                        }
                    }
                }
                if (isa Elem Tail)
                {
                    entity C [. Elem Classification];
                    verbose "Tail in Statement";
                    push [my Tails] Elem;
                    push [. I Tails] C;
                }
            }
            .= I Gal_Keyword Verb;
            .= I Gal_Key_Suffix Suffix;
            .= I Gs_Keyword Verb;
            if (sgt Suffix '')
            {
                string All_Keywords;
                join All_Keywords [. I Gs_Keywords] ' ';
                string Gs_Keywords (substring All_Keywords (length Verb));
                .= I Gs_Suffix Gs_Keywords;
                if (sgt Gs_Keywords '')
                {
                    return (. I Allow_Suffix Gs_Keywords);
                }
            }
            return [true];
        }
        isa Operation
        {
            entity I [my Classification];
            entity Elem;
            string Keyword '';
            string Verb [my Verb];
            string Verb_Tail Verb;
            string Suffix '';
            comment `
This is because when the root example is an operation, this somehow happens twice, and we can get double keywords and double arguments.
A better solution for the future will be to stop it from being re-invoked in the first place.`;
            if (gt (list.length [. I Gal_Keywords]) 0)
            {
                list New_Gal;
                .= I Gal_Keywords New_Gal;
            }
            if (gt (list.length [. I Gs_Keywords]) 0)
            {
                list New_Gs;
                .= I Gs_Keywords New_Gs;
            }
            if (gt (list.length [. I Arguments]) 0)
            {
                list New_Args;
                .= I Arguments New_Args;
            }
            if (gt (list.length [. I Listargs]) 0)
            {
                list New_Listargs;
                .= I Listargs New_Listargs;
            }
            foreach [my Elements] Elem
            {
                entity Imp [. Elem Classification];
                .= Elem Parent [self];
                .= Imp Parent I;
                if (isa Elem Keyword_Token)
                {
                    string Input [. Elem Input];
                    list.append [. I Gal_Keywords] Input;
                    list.append [. I Gs_Keywords] Input;
                    if (startswith Verb_Tail Input)
                    {
                        = Verb_Tail (substring Verb_Tail (length Input));
                    }
                    else
                    {
                        append Suffix ' ' Input;
                        list.append [. I Keywords] Imp;
                    }
                }
                else.if (isa Elem Boundary_Token)
                {
                    continue;
                }
                else
                {
                    list.append [my Arguments] Elem;
                    list.append [my Listargs] Elem;
                    list.append [. I Arguments] Imp;
                    list.append [. I Listargs] Imp;
                }
                if (isa Elem Tail)
                {
                    say "Tail of Operation";
                }
            }
            .= I Gal_Keyword Verb;
            .= I Gal_Key_Suffix Suffix;
            .= I Gs_Keyword Verb;
            return [true];
        }
        isa Syntax
        {
            entity I [my Classification];
            entity Elem;
            string Keyword '';
            string Verb [my Verb];
            string Verb_Tail Verb;
            string Suffix '';
            foreach [my Elements] Elem
            {
                todo "Examine syntax arguments process.";
                entity Imp [. Elem Classification];
                .= Elem Parent [self];
                .= Imp Parent I;
                if (isa Elem Keyword_Token)
                {
                    string Input [. Elem Input];
                    list.append [. I Gal_Keywords] Input;
                    list.append [. I Gs_Keywords] Input;
                    if (startswith Verb_Tail Input)
                    {
                        = Verb_Tail (substring Verb_Tail (length Input));
                    }
                    else
                    {
                        append Suffix ' ' Input;
                        list.append [. I Keywords] Imp;
                    }
                }
                else.if (isa Elem Syntax_Tail)
                {
                    list.append [. I Tails] Imp;
                }
                else.if (isa Elem Syntax_Token)
                {
                    continue;
                }
                else
                {
                    list.append [my Arguments] Elem;
                    list.append [my Listargs] Elem;
                    list.append [. I Arguments] Imp;
                    list.append [. I Listargs] Imp;
                }
            }
            .= I Gal_Keyword Verb;
            .= I Gal_Key_Suffix Suffix;
            .= I Gs_Keyword Verb;
            return [true];
        }
        isa Statement_Tail
        {
            entity I [my Classification];
            entity Elem;
            foreach [my Elements] Elem
            {
                entity Imp [. Elem Classification];
                .= Elem Parent [self];
                .= Imp Parent I;
            }
            return [true];
        }
        isa Tail
        {
            entity I [my Classification];
            entity Elem;
            string Keyword '';
            string Verb [my Verb];
            string Verb_Tail Verb;
            string Suffix '';
            foreach [my Elements] Elem
            {
                entity Imp [. Elem Classification];
                .= Elem Parent [self];
                .= Imp Parent I;
                if (isa Elem Keyword_Token)
                {
                    string Input [. Elem Input];
                    list.append [. I Gal_Keywords] Input;
                    list.append [. I Gs_Keywords] Input;
                    if (startswith Verb_Tail Input)
                    {
                        = Verb_Tail (substring Verb_Tail (length Input));
                    }
                    else
                    {
                        append Suffix ' ' Input;
                        list.append [. I Keywords] Imp;
                    }
                }
                else.if (isa Elem Syntax_Tail)
                {
                    list.append [. I Tails] Imp;
                }
                else.if (isa Elem Syntax_Token)
                {
                    continue;
                }
                else
                {
                    list.append [my Arguments] Elem;
                    list.append [my Listargs] Elem;
                    comment 'NOTE cross mapping of [my Arguments] and [I.Arguments]';
                }
                if (isa Elem Tail)
                {
                    say "Tail in Tail";
                    comment `list.append [. I Tails] Imp;`;
                }
            }
            .= I Gal_Keyword Verb;
            .= I Gal_Key_Suffix Suffix;
            .= I Gs_Keyword Verb;
            return [true];
        }
        isa Block
        {
            entity I [my Parent];
            entity Elem;
            entity Statements [my Classification Statements];
            foreach [my Elements] Elem
            {
                contif (isa Elem Token_Block_Start);
                contif (isa Elem Token_Block_End);
                entity Imp [. Elem Classification];
                .= Elem Parent I;
                .= Imp Parent I;
                list.append Statements Imp;
            }
            return [true];
        }
    }
    class.append Element
    {
        method flag Attributes;
    }

    class.append Named_Element
    {
        property list Keywords;
    }

    inference flag Attributes
    {
        isa Gal_Parser
        {
            verbosity;
            flag Status [true];
            entity Elem;
            entity I;
            variant Err;
            integer Offset 0;
            string Id;
            foreach [my.attribute Elements] Elem
            {
                increment Offset;
                = Id (string Offset);
                .= Elem Id Id;
                try
                {
                    = I [. Elem Classification];
                    .= I Id Id;
                    . I Attributes;
                    . I Infer_Attributes;
                }
                catch Err
                {
                    verbose "Error: " Err;
                    verbose (. Elem Get_Input);
                    verbose;
                    .= Elem Error Err;
                    = Status [false];
                }
            }
            return Status;
        }
        isa Gs_Parser
        {


            flag Status [true];
            entity Elem;
            entity I;
            variant Err;
            integer Offset 0;
            string Id;
            foreach [my.attribute Elements] Elem
            {
                increment Offset;
                = Id (string Offset);
                .= Elem Id Id;
                try
                {
                    = I [. Elem Classification];
                    .= I Id Id;
                    . I Attributes;
                    . I Infer_Attributes;
                }
                catch Err
                {
                    verbose "Error: " Err;
                    verbose (. Elem Get_Input);
                    verbose;
                    .= Elem Error Err;
                    = Status [false];
                }
            }
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    = I [. Elem Classification];
                    . I Infer_Attributes;
                }
                catch Err
                {
                    verbose "Error: " Err;
                    verbose (. Elem Get_Input);
                    verbose;
                    .= Elem Error Err;
                    = Status [false];
                }
            }
            return Status;
        }
        isa Element
        {
            return [true];
        }
        isa Append_Names_Statement
        {
            verbosity;
            entity Argument;
            string Name '';
            string Between '';
            foreach [my Arguments] Argument
            {
                if (isa Argument Token_Name)
                {
                    append Name Between [. Argument Input];
                    = Between '_';
                }
                else.if (isa Argument Token_Quote)
                {
                    my= Description Argument;
                }
                else
                {
                    debug;
                    verbose 'Unexpected Argument';
                }
            }
            my= Name Name;
        }
    }

    inference flag Structure
    {
        isa Gal_Parser
        {
            verbose;
            entity Elem;
            entity I;
            variant Err;
            flag Status [true];
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    = I [. Elem Classification];
                    . I Infer_Structure;
                }
                catch Err
                {
                    .= Elem Error Err;
                    verbose 'Structure Error: ' Err;
                    verbose (. Elem Get_Input);
                    verbose;
                    = Status [false];
                }
            }
            return Status;
        }
        isa Gs_Parser
        {
            verbosity [true];
            comment verbose 'structre inference';
            entity Elem;
            entity I;
            flag Status [true];
            variant Err;
            foreach [my.attribute Elements] Elem
            {
                try
                {
                    = I [. Elem Classification];
                    . I Infer_Structure;
                }
                catch Err
                {
                    .= Elem Error Err;
                    verbose 'Structure Error: ' Err;
                    verbose (. Elem Get_Input);
                    verbose;
                    = Status [false];
                }
            }
            return Status;
        }
        isa Element
        {
            return [true];
        }
        isa Block
        {
            entity Statement;
            flag Iffy [false];
            entity The_If;
            entity The_Try;
            foreach [my Statements] Statement
            {
                if (isa Statement Conditional_Statement)
                {
                    if (isa Statement Iffy_Statement)
                    {
                        = Iffy [true];
                        = The_If Statement;
                        .= Statement If_Statement The_If;
                        .= Statement Last_Else The_If;
                        .= Statement End_Label (: Mumps Get_Label);
                        .= Statement Is_Last [true];
                    }
                    else
                    {
                        debugif (not Iffy);
                        .= [. The_If Last_Else] Is_Last [false];
                        .= Statement Is_Last [true];
                        .= Statement If_Statement The_If;
                        .= The_If Last_Else Statement;
                        .= Statement End_Label [. The_If End_Label];
                    }
                }
                else
                {
                    = Iffy [false];
                    = If_Statement [null];
                }
                if (isa Statement Error_Handling_Statement)
                {
                    if (isa Statement Statement_Try)
                    {
                        = Trying [true];
                        = The_Try Statement;
                        .= Statement Try_Statement The_Try;
                        .= Statement End_Label (: Mumps Get_Label);
                    }
                    else
                    {
                        debugif (not Trying);
                        .= Statement Try_Statement The_Try;
                        .= Statement End_Label [. The_Try End_Label];
                    }
                }
                else
                {
                    = Trying [false];
                    = Try_Statement [null];
                }
            }
        }
        isa Statement_Codebox
        {
            string Name (. [my Name] Get_Input);
            entity Statement;
            foreach [my Block Statements] Statement
            {
                .= Statement Parent_Name Name;
            }
            return [true];
        }
        isa Statement_Class_Append
        {
            verbosity;
            string Name (. [my Name] Get_Input);
            verbose 'class append ' Name;
            if (not (dict.exists [: Statement_Class Names] Name))
            {
                error "'class append' could not append to nonexistent class " Name;
            }
            entity Class (dict.get [: Statement_Class Names] Name);
            my= Primary_Class Class;
            verbose [indent] 'inferred primary class object';
            entity Statement;
            forgive
            {
                foreach [my Block Statements] Statement
                {
                    verbose [indent] 'class append to ' Name ': ' [. Statement Gs_Keywords];
                    list.append [. Class Appended_Statements] Statement;
                }
            }
        }
        isa Statement_Class_Set
        {
            verbosity;
            verbose ' *** inferring structure of ' [self];
            string Name (. [my Name] Get_Input);
            if (not (dict.exists [: Statement_Class Names] Name))
            {
                error "'class set' could not append to nonexistent class " Name;
            }
            entity Class (dict.get [: Statement_Class Names] Name);
            entity Statement;
            forgive
            {
                foreach [my Block Statements] Statement
                {
                    verbose 'class set to ' Name ': ' Statement;
                    list.append [. Class Appended_Statements] Statement;
                }
            }
        }
        isa Statement_Class_Is
        {
            verbosity;
            comment verbose ' *** inferring structure of ' [self];
            string Name (. [my Name] Get_Input);
            if (dict.exists [: Statement_Class Names] Name)
            {
                entity Class (dict.get [: Statement_Class Names] Name);
                entity Statement;
                forgive
                {
                    foreach [my Block Statements] Statement
                    {
                        verbose 'class set ' Name ': ' Statement;
                        list.append [. Class Appended_Statements] Statement;
                    }
                }
            }
            else
            {
                dict.assign [: Statement_Class Names] Name [self];
                verbose "'class is' registers class " Name;
            }
        }
        isa Statement_Crown
        {
            string Class_Name (. [my Owner_Class] Get_Input);
            string Behavior_Name (. [my Behavior_Name] Get_Input);
            entity Class;
            if (dict.get [: Statement_Class Names] Class_Name)
            {
                = Class (dict.get [: Statement_Class Names] Class_Name);
            }
            else
            {
                return;
            }
            entity Statement;
            entity BS;
            string BN;
            foreach [. Class Block Statements] Statement
            {
                if (isa Statement Behavior_Statement)
                {
                    = BN (. [. Statement Behavior_Name] Get_Input);
                    contif (sne BN Behavior_Name);
                    object B [. Statement Block];
                    .= Statement Block [my Block];
                    my= Block B;
                    break;
                }
            }
        }
        isa Behavior_Statement
        {
            entity Class_Context (i Get_Class_Context);
            string Class_Name (. [. Class_Context Name] Get_Input);
            string Behavior_Name (. [my Behavior_Name] Get_Input);
            string Entity_Behavior_Class "Behavior_" Class_Name '_' Behavior_Name;
            string Qclass (i Enquote Entity_Behavior_Class);
            forgive
            {
                entity Behavior_Class (dict.get [: Statement_Class Names] "Behavior");
                string Register
                    'push [our Registry] [: ' Entity_Behavior_Class '];';
                string Append Register [line]
                    'dict [our Names] ' Qclass ' = [: ' Entity_Behavior_Class '];';
                entity.new Register_Element Literal Append;
                entity Statement;
                entity Theirs;
                string Method_Name;
                flag Found [false];
                foreach [. Behavior_Class Block Statements] Statement
                {
                    contif (not (isa Statement Statement_Class_Method));
                    = Method_Name (. [. Statement Name] Get_Input);
                    contif (sne Method_Name 'Initialize');
                    foreach [. Statement Block Statements] Theirs
                    {
                        if (s= (. Theirs Get_Input) Register)
                        {
                            = Found [true];
                            break;
                        }
                    }
                    if (not Found)
                    {
                        push [. Statement Block Statements] Register_Element;
                    }
                    break;
                }
            }
        }

        isa Statement_Tests_Append
        {
            string Name (. [my Parent Name] Get_Input);
            entity Class (dict.get [: Statement_Class Names] Name);
            debug;
            todo 'There are many issues still left here to resolve!!!';
            entity Statement;
            foreach [my Block Statements] Statement
            {
                list.append [. Class Appended_Statements] Statement;
            }
        }
        isa Syntax_Is
        {
            entity Cls (i Get_Class_Context);
            string Name [. Cls Name Input];
            string Ancestor [my Superclass Input];
            push [. Cls Ancestors] Ancestor;
        }
        isa Class_Statement
        {
            entity Statement;
            if (defined [my Block])
            {
                foreach [my Block Statements] Statement
                {
                    if (isa Statement Statement_Property)
                    {
                        my= Generate_Constructor [true];
                        push [my Property_Statements] Statement;
                    }
                    else.if (isa Statement Statement_Main)
                    {
                        my= Main Statement;
                    }
                    else.if (isa Statement Statement_Constructor)
                    {
                        my= Has_Constructor [true];
                        my= Constructor Statement;
                    }
                    else.if (isa Statement Statement_Infers)
                    {
                        append [my Infer_Inits] 'list [my Inferences ~] append (new Inference_' (. [. Statement Inference] Get_Input) ' [self]);' [line];
                    }
                    else.if (isa Statement Statement_Class_Method)
                    {
                        push [my Class_Methods] Statement;
                    }
                    else.if (isa Statement Method_Statement)
                    {
                        push [my Methods] Statement;
                    }
                    else.if (isa Statement Statement_Class_Property)
                    {
                        push [my Class_Property_Statements] Statement;
                    }
                }
            }
        }

        isa Argument_Syntax
        {
            verbosity [true];
            string Variable [my Variable Input];
            string Type [my Gs_Keyword];
            = [my Data_Type Symbol_Value] Type;
            entity Context (i Method_Context);
            if (isnull Context)
            {
                verbose 'missing variable context in argument syntax, encountered ' (i Enquote (i Get_Input));
            }
            else
            {
                comment verbose 'argument syntax noted ' Variable ' as ' Type;
                dict.assign [. Context Variables] Variable Type;
            }
        }

        isa Declaration_Statement
        {
            verbosity [true];
            string Variable [my Variable Input];
            string Type [my Gs_Keyword];
            = [my Data_Type Symbol_Value] Type;
            entity Context (i Method_Context);
            if (isnull Context)
            {
                verbose 'missing variable context in declaration statement, encountered ' (i Enquote (i Get_Input));
            }
            else
            {
                comment verbose 'declaration statement noted ' Variable ' as ' Type;
                dict.assign [. Context Variables] Variable Type;
            }
        }

        isa Statement_Bind
        {
            verbosity [true];
            string Variable [my Variable Input];
            string Type [my Class Input];
            = [my Data_Type Symbol_Value] Type;
            entity Context (i Method_Context);
            if (isnull Context)
            {
                verbose 'missing variable context in declaration statement, encountered ' (i Enquote (i Get_Input));
            }
            else
            {
                comment verbose 'bind statement noted ' Variable ' as ' Type;
                dict.assign [. Context Variables] Variable Type;
            }
        }

        isa Statement_List_Copy
        {
            verbosity [true];
            string Variable [my Variable Input];
            string Type 'list';
            entity Context (i Method_Context);
            if (isnull Context)
            {
                verbose 'missing variable context in declaration statement, encountered ' (i Enquote (i Get_Input));
            }
            else
            {
                comment verbose 'list copy statement noted ' Variable ' as ' Type;
                dict.assign [. Context Variables] Variable Type;
            }
        }
    }
}
flowerbox 'Data_Types.gal';

goal Data_Types `infer data types of tokens and elements`;

spell Data_Types
{
    class Data_Type [is Symbol]
    {
        property entity Symbol_Object;
        property string Symbol_Value;
        constructor [entity Object]
        {
            my= Symbol_Object Object;
        }
    }

    class.append Element
    {
        attribute string Data_Type Data_Type [self];
    }
    class.append Named_Element
    {
        method void Argument_Types [string Type]
        {
            entity Argument;
            foreach [my Arguments] Argument
            {
                .= Argument Data_Type Type;
            }
        }
    }

    inference string Data_Types
    {
        isa Gal_Parser
        {
            entity Elem;
            entity I;
            foreach [my.attribute Elements] Elem
            {
                = I [. Elem Classification];
                . I Infer_Data_Types;
            }
        }
        isa Gs_Parser
        {
            entity Elem;
            entity I;
            foreach [my.attribute Elements] Elem
            {
                = I [. Elem Classification];
                . I Infer_Data_Types;
            }
        }
        isa Element;
        isa Statement
        {
            verbosity;
            comment debug;
            verbose [class.name [self]];
        }
        isa Operation
        {
            verbosity;
            comment debug;
            verbose [class.name [self]];
        }
        isa Syntax
        {
            verbosity;
            comment debug;
            verbose [class.name [self]];
        }
        isa Statement_Flowerbox
        {
            i Argument_Types 'string';
        }
        isa Statement_Comment
        {
            i Argument_Types 'string';
        }
        isa Statement_Function_Invoke
        {
            .= [my Function] Data_Type 'method';
            .= [my Function] Usage 'method';
        }
        isa Statement_Include
        {
            .= [my File_Name] Data_Type 'module';
            .= [my File_Name] Usage 'module';
        }
        isa Statement_Constant
        {
            string Type [my Type Input];
            .= [my Name] Data_Type Type;
            .= [my Name] Usage 'constant';
            .= [my Value] Data_Type Type;
        }
        isa Statement_Global
        {
            string Type [my Type Input];
            .= [my Name] Data_Type Type;
            .= [my Value] Data_Type Type;
        }
        isa Syntax_True
        {
            my= Data_Type 'flag';
        }
        isa Syntax_False
        {
            my= Data_Type 'flag';
        }
        isa Operation_If
        {
            .= [my Condition] Data_Type 'flag';
            my= Data_Type [my If_Value Data_Type];
        }
        isa Operation_New
        {
            my= Data_Type 'object';
            .= [my Class_Name] Data_Type 'class';
            .= [my Class_Name] Usage 'class';
        }
        isa Syntax_Is_Main
        {
            my= Data_Type 'flag';
        }
        isa Statement_Exit
        {
            if (defined [my Return_Value])
            {
                .= [my Return_Value] Data_Type 'integer';
            }
        }
        isa Statement_If
        {
            .= [my Condition] Data_Type 'flag';
        }
        isa Statement_Module
        {
            .= [my Name] Data_Type 'module';
            .= [my Name] Usage 'module';
        }
        isa Syntax_Line
        {
            my= Data_Type 'string';
        }
    }
}

flowerbox 'Human.gal';

goal.spell Value `all human beings exude value at an equal and continuous rate for as long as they are alive`
{
    class Contest
    {
        attribute number Score;
        attribute entity Winner;
    }
    class Currency
    {
        class.attribute list Instances;
        attribute number Amount;
        attribute entity Owner;
    }

    contest Value;
    currency Value;
}


goal.spell Human Being `homo sapiens`
{
    class Human_Beings
    {
        class.attribute list Everyone;
    }

    currency Support_Gratitude
    {
        class.method flag Cycle
        {
            flag Status [true];
            entity Person;
            entity Supporter;
            foreach [class.attribute Human_Beings Everyone] Person
            {
                number Outcome [attribute Person Outcome];
                number Outcome_Certainty [attribute Person Outcome Certainty];
                number Weighted_Outcome (* Outcome Outcome_Certainty);
                number Person_Weight 0;
                foreach [attribute Person Outcome Outcome_Supports] Supporter
                {
                    number Support_Weight [attribute Supporter Support_Weight];
                    number Support_Certainty [attribute Supporter Certainty];
                    add Person_Weight (* Support_Weight Support_Certainty);
                }
                foreach [attribute Person Outcome Outcome_Supports] Supporter
                {
                    number Support_Weight [attribute Supporter Support_Weight];
                    number Support_Certainty [attribute Supporter Certainty];
                    number Gratitude_Amount (/ Weighted_Outcome (* Support_Weight Support_Certainty));
                    todo `what information is relevant when paying?`;
                    we Pay Person [attribute Supporter] Gratitude_Amount;
                }
            }
            return Status;
        }
    }

    symbol entity Outcome_Support
    {
        attribute number Support_Weight;
        attribute entity Support_Gratitude;
    }

    symbol number Human_Outcome
    {
        property number Inverse_Outcome;
        attribute list Outcome_Supports;
    }

    symbol entity Human_Identity
    {
        todo;
    }

    class Human_Being
    {
        attribute entity Identity Human_Identity;
        attribute entity Outcome Human_Outcome;
    }

}

goal.spell Altruism `Altruism is the desire for universal positive human outcome. It makes decisions based on the impact they have on the outcomes of human beings. Human importance and human equality are core concepts of altruism.`
{
    class.append Element
    {
        property number Gratitude 0;
    }

    inference percentage Altruism
    {
        isa Choice
        {
            todo 'infer the degree to which this choice serves altruism';
            debug;
        }
    }

    inference entity Choice
    {
        todo 'infer the choice that best serves altruism';
        isa Element
        {
            todo 'infer the implementor that best serves altruism';
            debug; 
        }
    }
}
flowerbox 'Main.gal';

class Runtime_Translator
{
    method string Compile [string Text]
    {
            verbosity;
            entity.new Trans Translator;
            = [attribute Trans Input] Text;
            .= Trans Parser (new Gs_Parser Trans);
            .= Trans Generator (new Gs_Generator Trans);
            flag Status (. Trans Initialize);
            if (not Status) 
            { 
                my= Error 'Error intiailizing Goalspell Translator'; 
                return [false];
            }
            = Status (. [. Trans Parser] Infer);
            if (not Status)
            {
                my= Error (. [. Trans Parser] Error_Report);
                writeline [my Error];
                return '';
            }
            entity Top (list.last [~ Trans Parser Elements]);
            if (isa Top Keyword_Token)
            {
                returnif (contains " quit q exit bye " (append " " Text " ")) "exit";
                writeline "Unknown command " Text;
                return "";
            }
            else.if (or (isa Top Operation) (isa Top Syntax) (isa Top Token))
            {
                string Write_Source 'writeline ' Text ';';
                = [attribute Trans Input] Write_Source;
                .= Trans Parser (new Gs_Parser Trans);
                . Trans Initialize;
                = Status (. [. Trans Parser] Infer);
                if (not Status) 
                { 
                    my= Error 'Error intiailizing Expression Translator'; 
                    return [false];
                }
            }
            = [. Trans Generator Elements] [. Trans Parser Elements];
            = Status (. [. Trans Generator] Infer);
            string Gs [. Trans Generator Code];
            returnif (not Status) [true];
            verbose 'goalspell ' Gs;
            string Fallback Gs;
            entity.new Fb_Gen Fallback_Generator Trans;
            .= Fb_Gen Elements [. Trans Parser Elements];
            = Status (. Fb_Gen Initialize);
            = Status (. Fb_Gen Infer);
            string Fallback [. Fb_Gen Code];
            verbose 'fallback ' Fallback;

            string Atomic Fallback;
            if (sne Fallback Gs)
            {
                entity.new Atomic_Trans Translator;
                = [attribute Atomic_Trans Input] Fallback;
                .= Atomic_Trans Parser (new Gs_Parser Atomic_Trans);
                .= Atomic_Trans Generator (new Fallback_Generator Atomic_Trans);
                flag Status (. Atomic_Trans Initialize);
                if (not Status)
                { 
                    error 'Error intiailizing Atomic Translator'; 
                }
                = Status (. [. Atomic_Trans Parser] Infer);
                if (not Status) 
                { 
                    error (. [. Atomic_Trans Parser] Error_Report);
                }
                = [. Atomic_Trans Generator Elements] [. Atomic_Trans Parser Elements];
                = Status (. [. Atomic_Trans Generator] Infer);
                = Atomic [. Atomic_Trans Generator Code];
                verbose 'atomic ' Atomic;
            }
            string Compiled '';
            if Status
            {
                entity.new Target_Trans Translator;
                = [attribute Target_Trans Input] Atomic;
                .= Target_Trans Parser (new Gs_Parser Target_Trans);
                .= Target_Trans Generator (new [generator] Target_Trans);
                flag Status (. Target_Trans Initialize);
                if (not Status) { debug; }
                = Status (. [. Target_Trans Parser] Infer);
                if (not Status) { debug; }
                = [. Target_Trans Generator Elements] [. Target_Trans Parser Elements];
                = Status (. [. Target_Trans Generator] Infer);
                if (not Status)
                {
                    writeline [. Target_Trans Generator Code];
                }
                else
                {
                    = Compiled [. Target_Trans Generator Code];
                }

                verbose 'compiled ' Compiled;
            }
        return Compiled;
    }
}

class Translation_Factory
{
    todo 'How do we add initializations.';

    method entity Get_Translator [string Input_Format, string Output_Format]
    {
        verbosity;
        entity.new Trans Translator;

        if (s= Input_Format 'gal')
        {
            .= Trans Parser (new Gal_Parser Trans);
        }
        else.if (or (s= Input_Format 'goalspell') (s= Input_Format 'gs'))
        {
            .= Trans Parser (new Gs_Parser Trans);
        }
        else.if (or (s= Input_Format 'generator') (s= Input_Format 'gen'))
        {
            entity Parser (new Gs_Parser Trans)
            .= Parser Dialect (new Dialect_Generator);
            .= Trans Parser Parser;
        }
        else.if (s= Input_Format 'bnf')
        {
            .= Trans Parser (new BNF_Parser Trans);
        }
        else.if (s= Input_Format 'antlr')
        {
            .= Trans Parser (new ANTLR_BNF_Parser Trans);
        }
        else.if (s= Input_Format 'raku')
        {
            .= Trans Parser (new Raku_Parser Trans);
        }
        else
        {
            error 'Unknown input format ' Input_Format;
        }

        comment debug;
        if (s= Output_Format 'gal')
        {
            .= Trans Generator (new Gal_Generator Trans);
        }
        else.if (or (s= Output_Format 'goalspell') (s= Output_Format 'gs'))
        {
            .= Trans Generator (new Gs_Generator Trans);
        }
        else.if (s= Output_Format 'c')
        {
            .= Trans Generator (new C_Generator Trans);
        }
        else.if (or (s= Output_Format 'javascript') (s= Output_Format 'js'))
        {
            .= Trans Generator (new Javascript_Generator Trans);
        }
        else.if (or (s= Output_Format 'python') (s= Output_Format 'py'))
        {
            .= Trans Generator (new Python_Generator Trans);
        }
        else.if (s= Output_Format 'html')
        {
            .= Trans Generator (new Html_Generator Trans);
        }
        else.if (s= Output_Format 'java')
        {
            .= Trans Generator (new Java_Generator Trans);
            todo 'Java file per class';
        }
        else.if (or (s= Output_Format 'fallback') (s= Output_Format 'fb'))
        {
            .= Trans Generator (new Fallback_Generator Trans);
        }
        else.if (s= Output_Format 'raku')
        {
            .= Trans Generator (new Raku_Generator Trans);
        }
        else.if (s= Output_Format 'canonical')
        {
            .= Trans Generator (new Canonical_Generator Trans);
        }
        else.if (or (s= Output_Format 'mumps') (s= Output_Format 'm'))
        {
            .= Trans Generator (new Mumps_Generator Trans);
            .= Trans Output (new Mumps_File Trans);
        }
        else.if (s= Output_Format 'php')
        {
            .= Trans Generator (new PHP_Generator Trans);
        }
        else.if (s= Output_Format 'example')
        {
            .= Trans Generator (new Example_Generator Trans);            
        }
        else.if (s= Output_Format 'bnfgs')
        {
            .= Trans Generator (new Bnf_Gs_Generator Trans);
        }
        else.if (s= Output_Format 'perl')
        {
            .= Trans Generator (new Perl_Generator Trans);
        }
        else.if (s= Output_Format 'tests')
        {
            .= Trans Generator (new Test_Generator Trans);
        }
        else
        {
            error 'Unknown output format ' Output_Format;
        }

        return Trans;
    }
}

main [string Input_Format, string Output_Format, string Input_File, string Output_File]
{
    verbosity;
    flag Interactive [true];
    forgive
    {
        = Interactive (isnull Output_File);
    }
    if Interactive
    {
        entity.new RT Runtime_Translator;
        strings Input;
        forever
        {
            readline '~ ' Input;
            breakif (isnull Input);
            comment 'compile Compiled Input;';
            string Compiled (. RT Compile Input);
            breakif (s= Compiled "exit");
            if (notnull Compiled) 
            {
                verbose 'example' [line] '{' [line] Input [line] '}' [line];
                verbose 'code box Prompt_' (: Fallback_Generator Next_Example) ' { pane "goalspell prompt" ‹~ ' Input;
                try
                {
                    execute Compiled;
                }
                catch Error
                {
                    writeline "Executing compiled code: " Compiled;
                    writeline "ERROR: " Error;
                }
                verbose '~ ›;}' [line];
            }
            else
            {
                writeline [indent] 'Warning, no compiled code.';
            }
        }
        writeline;
        comment exit 0;
    }
    else
    {
        verbose "Translate " Input_File " from " Input_Format " to " Output_Format " in " Output_File;

        entity.new Factory Translation_Factory;
        entity Trans (. Factory Get_Translator Input_Format Output_Format);

        .= [. Trans Input] File_Name Input_File;
        .= [. Trans Output] File_Name Output_File;

        verbose 'Running Translator';
        comment `Translator.Initialize doesn't take an argument.`;
        flag Status (. Trans Initialize);
        and Status (. Trans Run);
        if (not Status)
        {
            writeline 'ERROR status returned.';
            if (not [. Trans Parser Status])
            {
                writeline (. [. Trans Parser] Error_Report);
            }
            if (not [. Trans Generator Status])
            {
                writeline (. [. Trans Generator] Error_Report);
            }
        }
        verbose 'Result: ' Status;
        comment verbose 'File Text: ' [attribute Trans Output];
        comment exit (not Status);
    }
}
