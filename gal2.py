#!/usr/bin/python
# gal.py
import zdebug
import datetime
import readline
import re
import sys
import os.path
import uuid
#import tty

class gal:
    @classmethod
    def substring(String, Start, Length):
        return String[Start:Start+Length]
    @classmethod
    def backslash(cls, Count=1):
        Slashes = '\\' * Count
        return Slashes
    @classmethod
    def file_append(cls,file_name,file_text):
        append_file = open(file_name,'a')
        append_file.write(file_text)
        append_file.close()
    @classmethod
    def file_exists(cls,file_name):
        return os.path.exists(file_name)
    @classmethod
    def read_char(cls):
        #tty.setraw(sys.stdin.fileno())
        tty.setcbreak(sys.stdin.fileno())
        return sys.stdin.read(1)

# goalspell.py

class Goal:
    pass
class Spell:
    pass
class Goal_License (Goal):
    pass
class Spell_License (Spell):
    pass
class License:
    License_Text = ''''''  +  '\n'  +  '''Closed Source goalspell License'''  +  '\n'  +  ''''''  +  '\n'  +  '''goalspell programming language'''  +  '\n'  +  '''Copyright (c) 2022 Erik Zoltán. All Rights Reserved.'''  +  '\n'  +  ''''''  +  '\n'  +  '''goalspell contains a licensing spell. Over time, the text that appears here will be changed by the goalspell compiler. Initially, this programming languge is closed source, all rights reserved. '''  +  '\n'  +  ''''''  +  '\n'  +  '''The goalspell compiler is dedicated to altruism. It tries to select the goalspell code that best serves human outcome. This license is defined in goalspell code. Future versions of goalspell are likely to be released under different license terms. '''  +  '\n'  +  ''''''  +  '\n'  +  '''If you download, execute or examine the source code of the goalspell compiler, it means that you have purchased a licensed copy of goalspell. If that is not the case, it means that you are in violation of this license. '''  +  '\n'  +  ''''''
    @classmethod
    def Publish(cls):
        License_Text = str(License.License_Text)
        _FH = open('LICENSE', "w")
        _FH.write(License_Text)
        _FH.close()
        return True
    @classmethod
    def Get(cls):
        if License.Instance is not None:
            return License.Instance
        Lic = License()
        License.Instance = Lic
        return Lic
# comment "(append `mildbeard` [line] `    {` [line] `        name 'Erik Zoltán';` [line] `        email 'mildbeard@pm.me';` [line] `        outcome 0.5;` [line] `    }`)";
# comment '**** Knowledge.gal ****';
class Goal_Knowledge (Goal):
    pass
class Spell_Knowledge (Spell):
    pass
class Symbol:
    def __init__(self):
        super().__init__()
        self.Symbol_Object = None
        self.Symbol_Value = None
class Thing:
    pass
class Entity:
    pass
class Flag (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Integer (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Number (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class String (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class List (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = []
    def Clear(self):
        self.Symbol_Value.clear()
class Dictionary (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = {}
class Object (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Amount (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Argument (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Keyword (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class File_Like (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
    def See(self):
        pass
    def Say(self):
        pass
class File (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
        self.File_Name = None
    def See(self):
        # comment 'debug';
        Verbose = False
        if not self.File_Name:
            return True
        try:
            _FH = open(self.File_Name, "r")
            self.Symbol_Value = _FH.read()
            _FH.close()
            if Verbose:
                print('read ', self.Symbol_Value, sep='')
            return True
        except Exception as Error:
            print("Error ", Error, sep='')
            return False
    def Say(self):
        Verbose = False
        if not self.File_Name:
            return True
        try:
            if Verbose:
                print('write ', self.Symbol_Value, sep='')
            _FH = open(self.File_Name, "w")
            _FH.write(self.Symbol_Value)
            _FH.close()
            return True
        except Exception as Error:
            print("Error ", Error, sep='')
            return False
class Class_Symbol (Symbol):
    pass
class Class_List (Class_Symbol):
    def __init__(self):
        super().__init__()
        self.Symbol_Value = []
# comment '**** Intelligence.gal ****';
class Goal_Intelligence (Goal):
    pass
class Spell_Intelligence (Spell):
    pass
class Context (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Inference:
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Owner = None
    def Initialize(self):
        return self.Status
    def Infer(self):
        return self.Status
class Thinker:
    def __init__(self):
        super().__init__()
        self.Status = True
        self.Inferences = List(self)
        self.Contest = Object(self)
    def Initialize(self):
        return self.Status
    def Infer(self):
        Inference = None
        self.Status = True
        Verbose = False
        if Verbose:
            print('   ', self.__class__.__name__, ' iterate ', len(self.Inferences.Symbol_Value), ' inferences.', sep='')
        for Inference in self.Inferences.Symbol_Value:
            if Verbose:
                print('      Inference: ', Inference.__class__.__name__, sep='')
            self.Status &= Inference.Infer()
            if not self.Status:
                break
        return self.Status
    def Choose(self):
        zdebug.zbreak()
        return self.Status
class Talker (Thinker):
    def See(self):
        return self.Status
    def Say(self):
        return self.Status
class Translator (Talker):
    def __init__(self):
        super().__init__()
        self.Input = File(self)
        self.Output = File(self)
        self.Parser = None
        self.Generator = None
    def Initialize(self):
        self.Status = self.Parser.Initialize()
        self.Status &= self.Generator.Initialize()
        return self.Status
    def See(self):
        return self.Input.See()
    def Say(self):
        return self.Output.Say()
    def Infer_Input(self):
        Verbose = False
        if not self.Parser.Infer():
            if Verbose:
                print(self.Parser.Error_Report())
            self.Status = False
            return self.Status
        return self.Status
    def Infer_Output(self):
        Verbose = False
        if not self.Generator.Infer():
            if Verbose:
                print(self.Generator.Error_Report())
            self.Status = False
            return self.Status
        self.Status = self.Generator.Status
        Code = str(self.Generator.Code)
        self.Output.Symbol_Value = Code
        return self.Status
    def Choose(self):
        # comment 'TODO:Implementors not Classifications';
        self.Generator.Elements.Symbol_Value = self.Parser.Elements.Symbol_Value
        Element = None
        Choice = None
        for Element in self.Generator.Elements.Symbol_Value:
            for Choice in Element.Classifications:
                if Element.Classification.Gratitude < Choice.Gratitude:
                    Element.Classification = Choice
        return self.Status
    def Run(self):
        Verbose = False
        if Verbose:
            print('See')
        if not self.See():
            return False
        if Verbose:
            print('infer input')
        if not self.Infer_Input():
            return False
        if Verbose:
            print('choose')
        if not self.Choose():
            return False
        if Verbose:
            print('infer output')
        if not self.Infer_Output():
            return False
        if Verbose:
            print('Say')
        if not self.Say():
            return False
        if Verbose:
            print('Success')
        return self.Status
class Language_Intelligence (Thinker):
    def __init__(self):
        super().__init__()
        self.Language_Name = None
        self.Owner = None
        self.Status = True
    def Error_Report(self):
        Status = True
        Report = ''
        Element = None
        Error = None
        Text = None
        N = 0
        Errors = 0
        Report += str(self.__class__.__name__) + ' Error Report' + str('\n')
        for Element in self.Elements.Symbol_Value:
            if Element.Classification is not None and Element.Classification.Error is not None:
                Status = False
                Report += str(N) + '+ ' + str(Element.Classification.__class__.__name__) + ': <' + str(Element.Classification.Error) + '>' + str('\n')
                Text = Element.Get_Input()
                if len(Text) > 70:
                    Text = Text[0:(0)+(70)]  +  '...'
                Report += str("    ") + str(Text) + str('\n')
                Errors += 1
            elif Element.Error is not None:
                Class_Name = str(Element.__class__.__name__)
                if Element.Classification is not None:
                    Class_Name = Element.Classification.__class__.__name__
                try:
                    Class_Name += '/' + str(Element.Verb)
                except Exception:
                    pass
                try:
                    Class_Name += '/' + str(Element.Classification.Verb)
                except Exception:
                    pass
                Status = False
                Report += str(N) + ') ' + str(Element.__class__.__name__) + ': <' + str(Element.Error) + '>' + str('\n')
                Text = Element.Get_Input()
                if len(Text) > 70:
                    Text = Text[0:(0)+(70)]  +  '...'
                Report += str("    ") + str(Text) + str('\n')
                Errors += 1
            N += 1
        Report += str(self.__class__.__name__) + ' logged ' + str(Errors) + ' Errors'
        return Report
    def Infer(self):
        Inference = None
        self.Status = True
        Verbose = True
        # comment 'verbose    [class.name [my]] iterate  (list.length [my.attribute Inferences]) inferences.';
        for Inference in self.Inferences.Symbol_Value:
            # comment 'verbose      Inference:  [class.name Inference]';
            self.Status &= Inference.Infer()
            if not self.Status:
                if Verbose:
                    print("    ", 'ERROR in ', Inference.__class__.__name__, '.', sep='')
        if not self.Status:
            Report = str(self.Error_Report())
            self.Code = Report
        return self.Status
class Parser (Language_Intelligence):
    def Dump(self):
        Element = None
        Offset = 0
        for Element in self.Elements.Symbol_Value:
            print('   ', Offset, ' ', Element.To_String(), sep='')
            Offset += 1
    def Initialize(self):
        zdebug.zbreak()
        # comment 'THIS DOES NOT INHERIT.';
    def Top_Token(self):
        if self.Position >= len(self.Tokens.Symbol_Value):
            return False
        Top = self.Tokens.Symbol_Value[self.Position]
        return Top
    def Add_Element(self, New_Element):
        if New_Element.Error is not None:
            zdebug.zbreak()
        self.Elements.Symbol_Value.extend([New_Element])
    def Parse_Token(self, Parent_Elements, Token_Input):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token):
            return False
        Input = str(Top_Token.Input)
        if str(Input) != str(Token_Input):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Rollback(self, Start, Message):
        Element = self.Top_Token()
        if Element:
            Element.Error = Message
        while self.Position > Start:
            Element = self.Elements.Symbol_Value.pop()
            self.Position = self.Position - 1
    def Balanced_Quotes(self, First, Last):
        if str(First) == '"' and str(Last) == '"':
            return True
        if str(First) == "'" and str(Last) == "'":
            return True
        if str(First) == '`' and str(Last) == '`':
            return True
        if str(First) == '«' and str(Last) == '»':
            return True
        if str(First) == '‘' and str(Last) == '’':
            return True
        if str(First) == '“' and str(Last) == '”':
            return True
        if str(First) == '‹' and str(Last) == '›':
            return True
        return False
    def Consume_Token(self):
        if self.Position >= len(self.Tokens.Symbol_Value):
            return False
        Top = self.Tokens.Symbol_Value[self.Position]
        Top.Error = None
        self.Add_Element(Top)
        self.Position += 1
        return True
    def Infer_Elements(self):
        Verbose = False
        # comment 'debug';
        Parse_Result = self.Parse_Program(self.Elements.Symbol_Value)
        Length = len(self.Tokens.Symbol_Value)
        if self.Position < Length:
            Error_Message = 'Parsed ' + str(self.Position) + ' tokens out of ' + str(Length) + '. Unexpected text at end:'
            T = None
            S = None
            At_End = ''
            for T in range(self.Position, Length+1):
                if T >= Length:
                    break
                S = self.Tokens.Symbol_Value[T].Input
                At_End += ' ' + str(S)
            Length = len(At_End)
            if Length > 200:
                At_End = At_End[0:(0)+(100)]  +  '...'  +  At_End[Length - 100:]
            Error_Message += str(At_End)
            if Verbose:
                print(Error_Message)
            Parse_Result = False
            # comment 'error Error_Message';
        return Parse_Result
        return True
class Generator (Language_Intelligence):
    def __init__(self):
        super().__init__()
        self.Code = ''
    def Compiled_Inheritance(self):
        Verbose = False
        Elem = None
        Classification = None
        for Elem in self.Elements.Symbol_Value:
            if not Elem.Classification is not None:
                continue
            Classification = Elem.Classification
            if isinstance(Classification, Class_Statement):
                if Verbose:
                    print('inherit ', Classification.Name.Input, sep='')
                Classification.Inherit()
class Inference_Elements (Inference):
    def Infer(self):
        if not self.Owner.Infer_Elements():
            return False
        return True
class Elements (List):
    pass
# comment '**** Language.gal ****';
class Goal_Language (Goal):
    pass
class Spell_Language (Spell):
    pass
class Registry:
    pass
class Element:
    def __init__(self):
        super().__init__()
        self.Location = None
        self.Parent = None
        self.Classification = None
        self.Implementer = None
        self.Owner = None
        self.Reference = None
        self.Error = None
        self.Property_Name = None
        self.Language_Name = None
        self.Class_Context = None
        self.Usage = 'value'
        self.Inner_Type = None
        self.Outer_Type = None
        self.Javascript_Precedence = 999
        self.Python_Precedence = 999
        self.Html_Text = None
        self.C = None
        self.C_Precedence = 999
        self.C_Declaration = ''
        self.Fallback_Declaration = ''
        self.Mumps = ''
        self.Mumps_Declaration = ''
        self.Mumps_Outer_Declaration = ''
        self.Classification = None
        self.Classifications = []
        self.Class_Name = None
        self.Id = None
        self.Data_Type = Data_Type(self)
        self.Gratitude = 0
    def Method_Context(self):
        if self.Parent is not None:
            return self.Parent.Method_Context()
        return None
    def To_String(self):
        String = str(self.__class__.__name__) + ' ' + str(self.Location.Start_Position) + '-' + str(self.Location.End_Position)
        return String
    def Get_Input(self):
        return self.Location.Get_Input()
    def Unquoted(self):
        return self.Get_Input()
    def Enquote(self, Text):
        if not "'" in Text:
            return "'"  +  Text  +  "'"
        if not '"' in Text:
            return '"'  +  Text  +  '"'
        if not "`" in Text:
            return "`"  +  Text  +  "`"
        if not '“' in Text and not '”' in Text:
            return '“'  +  Text  +  '”'
        if not '‘' in Text and not '’' in Text:
            return '‘'  +  Text  +  '’'
        if not '«' in Text and not '»' in Text:
            return '«'  +  Text  +  '»'
        if not '‹' in Text and not '›' in Text:
            return '‹'  +  Text  +  '›'
        return "'ERROR goalspell compiler DEEPLY ENQUOTED STRING FAILED HERE'"
    def Get_Language_Name(self):
        if self.Language_Name is not None:
            return self.Language_Name
        Name = None
        if self.Parent is not None:
            Name = self.Parent.Get_Language_Name()
            if (Name is not None and str(Name) > ""):
                return Name
        if self.Owner is not None:
            Name = self.Owner.Get_Language_Name()
            if (Name is not None and str(Name) > ""):
                return Name
        return ''
    def Get_Property_Name(self):
        if self.Property_Name is not None:
            return self.Property_Name
        Name = None
        if self.Parent is not None:
            Name = self.Parent.Get_Property_Name()
            if (Name is not None and str(Name) > ""):
                return Name
        if self.Owner is not None:
            Name = self.Owner.Get_Property_Name()
            if (Name is not None and str(Name) > ""):
                return Name
        return ''
    def Get_Class_Context(self):
        if self.Class_Context is not None:
            return self.Class_Context
        Name = None
        if self.Parent is not None:
            Name = self.Parent.Get_Class_Context()
            if (Name is not None and str(Name) > ""):
                return Name
        if self.Owner is not None:
            Name = self.Owner.Get_Class_Context()
            if (Name is not None and str(Name) > ""):
                return Name
        return None
    def Get_Module_Name(self):
        if self.Parent is not None:
            return self.Parent.Get_Module_Name()
        raise Exception('Module not known')
    def Indent(self, Text):
        if (Text in (None, "")):
            return ''
        Qchars = '"' + "'" + "`" + '“' + '‘' + '«' + '‹'
        Qend = {}
        Qend['"'] = '"';
        Qend["'"] = "'";
        Qend['`'] = '`';
        Qend['“'] = '”';
        Qend['‘'] = '’';
        Qend['«'] = '»';
        Qend['‹'] = '›';
        P = None
        C = None
        I = ''
        Quote = False
        Q = ''
        Between = ''
        E = len(Text) - 1
        if not Text[0] in Qchars:
            Between = "    "
        for P in range(0, E+1):
            C = Text[P]
            I += str(Between) + str(C)
            Between = ''
            if Quote:
                if str(C) == str(Q):
                    Quote = False
                    Q = ''
            elif C == '\n':
                Between = "    "
            elif C in Qchars:
                Quote = True
                Q = Qend[C]
        return I
    def Minify(self, Text):
        Text = Text.replace('\n', ' ')
        while '  ' in Text:
            Text = Text.replace('  ', ' ')
        return Text
    def Py_Indent(self, Text):
        if (Text in (None, "")):
            return ''
        C = None
        C3 = None
        I = ''
        Quote = False
        Q = ''
        Between = ''
        E = len(Text) - 1
        if not Text[0] in ''''"''':
            Between = "    "
        P = -1
        while P < E:
            P += 1
            C = Text[P]
            C3 = Text[P:(P)+(3)]
            I += str(Between) + str(C)
            Between = ''
            if Quote:
                if str(C3) == str(Q):
                    Quote = False
                    I += str(Q[1:(1)+(2)])
                    P += 2
                    Q = ''
                elif str(C) == str(Q):
                    Quote = False
                    Q = ''
                elif str(C) == '\\':
                    P += 1
                    I += str(Text[P])
            elif C == '\n':
                Between = "    "
            elif str(C3) == "'''" or str(C3) == '"""':
                Quote = True
                Q = C3
                I += str(Q[1:(1)+(2)])
                P += 2
            elif str(C) == "'" or str(C) == '"':
                Quote = True
                Q = C
        return I
    def Py_Enquote(self, Text):
        if '\\' in Text:
            Text = Text.replace('\\', '\\\\')
        if '\n' in Text:
            Text = Text.replace('\n', '\\n')
        if not "'" in Text:
            return "'"  +  Text  +  "'"
        if not '"' in Text:
            return '"'  +  Text  +  '"'
        if not "'''" in Text:
            Text = Text.replace("'", "\\'")
            return "'''"  +  Text  +  "'''"
        if not '"""' in Text:
            Text = Text.replace('"', '\\"')
            return '"""'  +  Text  +  '"""'
        return "'ERROR goalspell py_enquote DEEPLY QUOTED STRING'"
    def Js_Enquote(self, Text):
        if '\n' in Text:
            Text = Text.replace('\n', '\\n')
        if not "'" in Text:
            return "'"  +  Text  +  "'"
        if not '"' in Text:
            return '"'  +  Text  +  '"'
        if not "`" in Text:
            return "`"  +  Text  +  "`"
        if not "\\'" in Text:
            Text = Text.replace("'", "\\'")
            return "'"  +  Text  +  "'"
        if not '\\"' in Text:
            Text = Text.replace('"', '\\"')
            return '"'  +  Text  +  '"'
        if not '\\`' in Text:
            Text = Text.replace('`', '\\`')
            return '`'  +  Text  +  '`'
        zdebug.zbreak()
        # comment 'replace Text"\x22';
        # comment "replace Text'\x72";
        # comment 'replace Text`\x60';
        return "'"  +  Text  +  "'"
    def Html_Enquote(self, Text):
        if '&' in Text:
            Text = Text.replace('&', '&#38;')
        if '>' in Text:
            Text = Text.replace('>', '&#62;')
        if '<' in Text:
            Text = Text.replace('<', '&#60;')
        if '"' in Text:
            Text = Text.replace('"', '&#34;')
        if "'" in Text:
            Text = Text.replace("'", '&#39;')
        if "?" in Text:
            Text = Text.replace("?", '&#63;')
        if "\\" in Text:
            Text = Text.replace("\\", '&#92;')
        return "'"  +  Text  +  "'"
    def Html_Url(self, Document):
        Text = str(Document.Html_Text) + '.html'
        return Text
    def C_Type(self, Type):
        if str(Type) == 'number':
            return 'float'
        if str(Type) == 'integer':
            return 'int'
        if str(Type) == 'time':
            return 'int'
        if str(Type) == 'flag':
            return 'bool'
        if str(Type) == 'outcome':
            return 'float'
        if str(Type) == 'certainty':
            return 'float'
        return Type
    def C_Format_Code(self, Type):
        if str(Type) == 'number':
            return '%0.5f'
        if str(Type) == 'integer':
            return '%d'
        if str(Type) == 'time':
            return '%d'
        if str(Type) == 'flag':
            return '%d'
        if str(Type) == 'outcome':
            return '%0.5f'
        if str(Type) == 'certainty':
            return '%0.5f'
        return '%s'
    def C_Copyright(self):
        Text = str('\n') + str('''/*'''  +  '\n'  +  '''******************************************'''  +  '\n'  +  '''*   Copyright (c) 2024 by Erik Zoltan.   *'''  +  '\n'  +  '''*   All rights reserved.                 *'''  +  '\n'  +  '''******************************************'''  +  '\n'  +  '''*/''') + str('\n')
        return Text
    def Line_String(self, Input_String):
        # comment 'TODO:resolve line breaks here.';
        Return_String = str(self.Enquote(Input_String))
        return Return_String
    def Canonical_Variables(self, Text):
        D = str(chr(31))
        if D in Text:
            Items = Text.split(chr(31))
            Between = ''
            Number = 64
            Item = None
            Code = ''
            for Item in Items:
                Code += str(Between) + str(Item)
                Number += 1
                Between = chr(Number)
            return Code
        return Text
    def Mq(self, Unquoted):
        if '"' in Unquoted:
            Unquoted = Unquoted.replace('"', '""')
        if '\n' in Unquoted:
            Repl = '"_$char(10)_"'
            Unquoted = Unquoted.replace('\n', Repl)
        return '"'  +  Unquoted  +  '"'
    def Matom(self):
        return self.Mumps
    def Infer_Mumps(self):
        Verbose = False
        Code = '<' + str(self.__class__.__name__) + '>'
        if Verbose:
            print('*** Warning, no mumps handler for ', self.__class__.__name__, ' ***', sep='')
        self.Mumps = Code
    def Re_Mumps(self):
        self.Infer_Mumps()
    def Mumps_Class(self):
        C = Mumps.Current_Class
        if (C in (None, "")):
            C = self.Get_Class_Context()
        return C
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        pass
    def Infer_Gal(self):
        Gen = ''
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = ''
        self.Gs = Gen
        return True
    def Infer_Python(self):
        return True
    def Infer_Html(self):
        Code = str(self.Get_Input())
        self.Html_Text = Code
        self.Html = Code
        return True
    def Infer_Fallback(self):
        Code = str(self.Gs)
        self.Fallback = Code
        self.Reference = Code
        return True
    def Infer_Canonical(self):
        Gen = str(self.Gs)
        self.Canonical = Gen
        return True
    def Infer_Parse(self):
        Gen = str(self.Fallback)
        self.Parse = Gen
        return True
    def Infer_Generate(self):
        Gen = str(self.Fallback)
        self.Generate = Gen
        return True
    def Infer_Location(self):
        Doc = None
        Start = None
        End = None
        if self.Location is not None:
            return
        First = self.Elements[0]
        Last = self.Elements[-1]
        Doc = First.Location.Document
        Start = First.Location.Start_Position
        End = Last.Location.End_Position
        Loc = Location(Doc, Start, End)
        self.Location = Loc
        return True
    def Infer_Verb(self):
        self.Verb = ''
        return True
    def Infer_Classification(self):
        self.Classification = self
        return True
    def Infer_Components(self):
        return True
        return True
    def Infer_Attributes(self):
        return True
        return True
    def Infer_Structure(self):
        return True
        return True
    def Infer_Data_Types(self):
        return True
    def Infer_Choice(self):
        # comment 'TODO:infer the implementor that best serves altruism';
        zdebug.zbreak()
        return True
class Token (Element):
    def __init__(self, Document, Character, Start, End):
        super().__init__()
        self.propinit()
        self.Input = Character
        self.Location = Location(Document, Start, End)
    def propinit(self):
        self.Input = None
    def To_String(self):
        String = str(self.__class__.__name__) + ' ' + str(self.Location.Start_Position) + '-' + str(self.Location.End_Position) + ' input ' + str(self.Input)
        return String
    def Get_Input(self):
        return self.Input
    def Is_Value(self):
        return False
    def Infer_Mumps(self):
        Code = str(self.Input)
        Code = Code.replace('_', '')
        self.Mumps = Code
    def Infer_Gal(self):
        Gen = str(self.Input)
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = str(self.Input)
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Input)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Input)
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Input)
        self.C = Gen
        return True
class Literal (Element):
    def __init__(self, Text):
        super().__init__()
        self.Input = Text
        self.Gs = Text
        self.Fallback = Text
    def Get_Input(self):
        return self.Input
    def Infer_Gs(self):
        Gen = str(self.Input)
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Gen = str(self.Input)
        self.Fallback = Gen
        return True
class Location:
    def __init__(self, Doc, Start, End):
        super().__init__()
        self.propinit()
        self.Document = Doc
        self.Start_Position = Start
        self.End_Position = End
    def propinit(self):
        self.Document = None
        self.Start_Position = None
        self.End_Position = None
    def Get_Input(self):
        Verbose = True
        try:
            X = self.End_Position - self.Start_Position + 1
        except Exception as Error:
            if Verbose:
                print(Error)
        # comment 'integer Length (+ (- [my End_Position] [my Start_Position]) 1)';
        Input = '<unknown input>'
        try:
            End = self.End_Position
            Start = self.Start_Position
            Diff = End - Start
            Length = Diff + 1
            Input = self.Document.Owner.Input.Symbol_Value[Start:(Start)+(Length)]
        except Exception:
            pass
        return Input
class Dialect:
    def __init__(self):
        super().__init__()
        self.Statements = {}
        self.Operations = {}
        self.Syntaxes = {}
class Syntax_Token (Token):
    def Infer_Html(self):
        Code = str(self.Get_Input())
        self.Html_Text = ''
        self.Html = Code
        return True
class Boundary_Token (Syntax_Token):
    pass
class Non_Boundary_Token (Token):
    def Is_Value(self):
        return True
class Atomic_Token (Non_Boundary_Token):
    pass
class Name_Token (Non_Boundary_Token):
    pass
class Keyword_Token (Name_Token):
    pass
class Token_Keyword (Keyword_Token):
    pass
class Token_Name (Name_Token):
    def Infer_Mumps(self):
        Code = str(self.Input)
        Code = Code.replace('_', '')
        self.Mumps = Code
    def Infer_Javascript(self):
        Input = str(self.Input)
        if '$' in Input:
            Input = Input.replace('$', '')
        self.Javascript = Input
        return True
    def Infer_Python(self):
        Input = str(self.Input)
        if '$' in Input:
            Input = Input.replace('$', '')
        self.Python = Input
        return True
    def Infer_Canonical(self):
        Code = 'X'
        # comment 'TODO:also data type specific F I N S O';
        if self.Data_Type is not None and self.Data_Type.Symbol_Value is not None:
            DT = str(self.Data_Type.Symbol_Value)
            # comment 'TODO:assign the token variable based on the data type.';
            zdebug.zbreak()
        self.Canonical = Code
        return True
class Token_Whitespace (Non_Boundary_Token):
    pass
class Token_Number (Atomic_Token):
    pass
class Token_Quote (Atomic_Token):
    def Unquoted(self):
        Input = str(self.Get_Input())
        End = len(Input) - 2
        Unquoted = str(Input[1:(1)+(End)])
        return Unquoted
    def Js_Enquote(self, Text):
        if '\n' in Text:
            Text = Text.replace('\n', '\\n')
        if not "'" in Text:
            return "'"  +  Text  +  "'"
        if not '"' in Text:
            return '"'  +  Text  +  '"'
        if not "`" in Text:
            return "`"  +  Text  +  "`"
        return "'ERROR js_enquote goalspell DEEPLY ENQUOTED STRING FAILURE'"
    def C_Enquote(self, Text):
        if '\\' in Text:
            Text = Text.replace('\\', '\\\\')
        if '"' in Text:
            Text = Text.replace('"', '\\"')
        if '\n' in Text:
            Text = Text.replace('\n', '\\n')
        if chr(9) in Text:
            Text = Text.replace(chr(9), '\\t')
        if chr(13) in Text:
            Text = Text.replace(chr(13), '\\r')
        return '"'  +  Text  +  '"'
    def Infer_Mumps(self):
        Code = str(self.Mq(self.Unquoted()))
        self.Mumps = Code
    def Infer_Javascript(self):
        U = str(self.Unquoted())
        Code = str(self.Js_Enquote(U))
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Verbose = False
        U = str(self.Unquoted())
        Code = str(self.Py_Enquote(U))
        if Verbose:
            print("input: ", self.Input, ", U: ", U, ", Code: ", Code, sep='')
        self.Python = Code
        return True
    def Infer_Html(self):
        self.Html_Text = self.Unquoted()
        self.Html = self.Get_Input()
        return True
    def Infer_C(self):
        U = str(self.Unquoted())
        Code = str(self.C_Enquote(U))
        self.C = Code
        return True
    def Infer_Fallback(self):
        U = str(self.Unquoted())
        Q = str(self.Enquote(U))
        self.Fallback = Q
        return True
    def Infer_Canonical(self):
        U = str(self.Unquoted())
        Q = str(self.Enquote(U))
        self.Canonical = Q
        return True
class Token_Syntax_Start (Boundary_Token):
    pass
class Token_Syntax_End (Boundary_Token):
    pass
class Token_Operation_Start (Boundary_Token):
    pass
class Token_Operation_End (Boundary_Token):
    pass
class Token_Statement_Start (Syntax_Token):
    pass
class Token_Statement_End (Syntax_Token):
    pass
class Token_Block_Start (Boundary_Token):
    pass
class Token_Block_End (Boundary_Token):
    pass
class Token_Comma (Syntax_Token):
    pass
class Token_Tilde (Keyword_Token):
    def Is_Value(self):
        return True
class Token_Semi (Boundary_Token):
    pass
class Token_Comment (Non_Boundary_Token):
    pass
class Token_Token (Token):
    pass
class Token_Name_Special (Token_Name):
    pass
class Named_Element (Element):
    def __init__(self):
        super().__init__()
        self.Arguments = []
        self.Listargs = []
        self.Gal_Keywords = []
        self.Gal_Keyword = ''
        self.Gal_Key_Suffix = ''
        self.Gs_Statements = ''
        self.Gs_Keywords = []
        self.Gs_Keyword = None
        self.Gs_Suffix = ''
        self.Verb = None
        self.Verbs = []
        self.Keywords = []
    def Factory(self, Parsed_Element):
        New_Element = self.__class__()
        New_Element.Owner = Parsed_Element
        New_Element.Location = Parsed_Element.Location
        return New_Element
    def To_String(self):
        String = str(self.__class__.__name__) + ' ' + str(self.Location.Start_Position) + '-' + str(self.Location.End_Position)
        Imp = self.Classification
        Arg = None
        Args = ''
        Between = ''
        for Arg in Imp.Arguments:
            Args += str(Between) + str(Arg.__class__.__name__)
            Between = ', '
        if str(Args) > '':
            Args = ' ('  +  Args  +  ')'
        String += str(Args)
        return String
    def Gal_Arguments(self):
        Code = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Arguments:
            Arg_Code = Arg.Gal
            if Arg_Code[:len(',')] == ',':
                Code += str(Arg_Code)
            else:
                Code += ' ' + str(Arg_Code)
        return Code
    def Gal_Key(self):
        Code = ''
        Between = ''
        Key = None
        for Key in self.Gal_Keywords:
            Code += str(Between) + str(Key)
            Between = ' '
        return Code
    def Gal_Listargs(self):
        Code = ''
        Arg = None
        for Arg in self.Listargs:
            Code += ' ' + str(Arg.Gal)
        return Code
    def Gal_Tails(self):
        Code = ''
        Tail = None
        for Tail in self.Tails:
            Code += str(Tail.Gal_Tail())
        return Code
    def Gs_Arguments(self):
        Code = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Arguments:
            if isinstance(Arg, Syntax_Token):
                continue
            Arg_Code = Arg.Gs
            if Arg_Code[:len(',')] == ',':
                Code += str(Arg_Code)
            else:
                Code += ' ' + str(Arg_Code)
        return Code
    def Gs_Key(self):
        Code = ''
        Between = ''
        Key = None
        for Key in self.Gs_Keywords:
            Code += str(Between) + str(Key)
            Between = ' '
        return Code
    def Gs_Listargs(self):
        Code = ''
        Arg = None
        for Arg in self.Listargs:
            if isinstance(Arg, Syntax_Token):
                continue
            Code += ' ' + str(Arg.Gs)
        return Code
    def Gs_Tails(self):
        Code = ''
        Tail = None
        for Tail in self.Tails:
            Code += str(Tail.Gs_Tail())
        return Code
    def Javascript_Arguments(self, Separator):
        Argument = None
        Args_Js = ''
        Between = ''
        for Argument in self.Arguments:
            if not Argument.Javascript is not None:
                raise Exception('Argument Javascript not defined: ' + str(Argument.Gal))
            Arg_Js = str(Argument.Javascript)
            Args_Js += str(Between) + str(Arg_Js)
            Between = Separator
        return Args_Js
    def Javascript_Args(self, Separator):
        Argument = None
        Args_Js = ''
        Between = ''
        for Argument in self.Listargs:
            if not Argument.Javascript is not None:
                raise Exception('Argument Javascript not defined: ' + str(Argument.Gal))
            Arg_Js = str(Argument.Javascript)
            Args_Js += str(Between) + str(Arg_Js)
            Between = Separator
        return Args_Js
    def Javascript_Repeating(self):
        Operator = ' ' + str(self.Javascript_Operator) + ' '
        Precedence = self.Javascript_Precedence
        Argument = None
        Args_Js = ''
        Between = ''
        for Argument in self.Arguments:
            if not Argument.Javascript is not None:
                raise Exception('Argument Javascript not defined: ' + str(Argument.Gal))
            Arg_Js = str(Argument.Javascript)
            if Precedence >= Argument.Javascript_Precedence:
                Arg_Js = '('  +  Arg_Js  +  ')'
            Args_Js += str(Between) + str(Arg_Js)
            Between = Operator
        return Args_Js
    def Javascript_Unary(self):
        Operator = ' ' + str(self.Javascript_Operator) + ' '
        Precedence = self.Javascript_Precedence
        Argument = self.Arguments[0]
        if not Argument.Javascript is not None:
            raise Exception('Argument Javascript not defined: ' + str(Argument.Gal))
        Arg_Js = str(Argument.Javascript)
        if Precedence >= Argument.Javascript_Precedence:
            Arg_Js = '('  +  Arg_Js  +  ')'
        Code = str(Operator) + str(Arg_Js)
        return Code
    def Python_Arguments(self, Separator):
        Argument = None
        Args_Py = ''
        Between = ''
        for Argument in self.Arguments:
            if not Argument.Python is not None:
                raise Exception('Argument Python not defined: ' + str(Argument.Gal))
            Arg_Py = str(Argument.Python)
            Args_Py += str(Between) + str(Arg_Py)
            Between = Separator
        return Args_Py
    def Python_Args(self, Separator):
        Argument = None
        Args_Py = ''
        Between = ''
        for Argument in self.Listargs:
            if not Argument.Python is not None:
                raise Exception('Argument Python not defined: ' + str(Argument.Gal))
            Arg_Py = str(Argument.Python)
            Args_Py += str(Between) + str(Arg_Py)
            Between = Separator
        return Args_Py
    def Python_Repeating(self):
        Operator = ' ' + str(self.Python_Operator) + ' '
        Precedence = self.Python_Precedence
        Argument = None
        Args_Py = ''
        Between = ''
        for Argument in self.Arguments:
            if not Argument.Python is not None:
                raise Exception('Argument Python not defined: ' + str(Argument.Gal))
            Arg_Py = str(Argument.Python)
            if Precedence >= Argument.Python_Precedence:
                Arg_Py = '('  +  Arg_Py  +  ')'
            Args_Py += str(Between) + str(Arg_Py)
            Between = Operator
        return Args_Py
    def Python_Unary(self):
        Operator = ' ' + str(self.Python_Operator) + ' '
        Precedence = self.Python_Precedence
        Argument = self.Arguments[0]
        if not Argument.Python is not None:
            raise Exception('Argument Python not defined: ' + str(Argument.Gal))
        Arg_Py = str(Argument.Python)
        if Precedence >= Argument.Python_Precedence:
            Arg_Py = '('  +  Arg_Py  +  ')'
        Code = str(Operator) + str(Arg_Py)
        return Code
    def Python_String_Args(self, Separator):
        Argument = None
        Args_Py = ''
        Between = ''
        for Argument in self.Listargs:
            if not Argument.Python is not None:
                raise Exception('Argument Python not defined: ' + str(Argument.Gal))
            Arg_Py = str(Argument.Python)
            if isinstance(Argument, Token_Quote):
                Args_Py += str(Between) + str(Arg_Py)
            else:
                Args_Py += str(Between) + 'str(' + str(Arg_Py) + ')'
            Between = Separator
        return Args_Py
    def Html_Arguments(self):
        Code = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Arguments:
            Arg_Code = Arg.Html
            if Arg_Code[:len(',')] == ',':
                Code += str(Arg_Code)
            else:
                Code += ' ' + str(Arg_Code)
        return Code
    def Html_Arguments_Text(self):
        Code = ''
        Between = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Arguments:
            Arg_Code = Arg.Html_Text
            if Arg_Code[:len(',')] == ',':
                Code += str(Arg_Code)
            else:
                Code += str(Between) + str(Arg_Code)
            Between = ' '
        return Code
    def C_Arguments(self, Separator):
        Argument = None
        Args_C = ''
        Between = ''
        for Argument in self.Arguments:
            if not Argument.C is not None:
                raise Exception('Argument C not defined: ' + str(Argument.Get_Input()))
            Arg_C = str(Argument.C)
            Args_C += str(Between) + str(Arg_C)
            Between = Separator
        return Args_C
    def C_Args(self, Separator):
        Argument = None
        Args_C = ''
        Between = ''
        for Argument in self.Listargs:
            if not Argument.C is not None:
                raise Exception('Argument C not defined: ' + str(Argument.Get_Input()))
            Arg_C = str(Argument.C)
            Args_C += str(Between) + str(Arg_C)
            Between = Separator
        return Args_C
    def C_Repeating(self):
        Operator = ' ' + str(self.C_Operator) + ' '
        Precedence = self.C_Precedence
        Argument = None
        Args_C = ''
        Between = ''
        for Argument in self.Arguments:
            if not Argument.C is not None:
                raise Exception('Argument C not defined: ' + str(Argument.Get_Input()))
            Arg_C = str(Argument.C)
            if Precedence >= Argument.C_Precedence:
                Arg_C = '('  +  Arg_C  +  ')'
            Args_C += str(Between) + str(Arg_C)
            Between = Operator
        return Args_C
    def C_Unary(self):
        Operator = ' ' + str(self.C_Operator) + ' '
        Precedence = self.C_Precedence
        Argument = self.Arguments[0]
        if not Argument.C is not None:
            raise Exception('Argument C not defined: ' + str(Argument.Get_Input()))
        Arg_C = str(Argument.C)
        if Precedence >= Argument.C_Precedence:
            Arg_C = '('  +  Arg_C  +  ')'
        Code = str(Operator) + str(Arg_C)
        return Code
    def Fallback_Arguments(self):
        Code = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Arguments:
            if isinstance(Arg, Token_Comma):
                continue
            Arg_Code = Arg.Fallback
            Code += ' ' + str(Arg_Code)
        return Code
    def Fallback_Args(self):
        Code = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Listargs:
            Arg_Code = Arg.Fallback
            if Arg_Code[:len(',')] == ',':
                Code += str(Arg_Code)
            else:
                Code += ' ' + str(Arg_Code)
        return Code
    def Fallback_Tails(self):
        Code = ''
        Tail = None
        for Tail in self.Tails:
            zdebug.zbreak()
            Code += str(Tail.Fallback_Tail())
        return Code
    def Canonical_Arguments(self):
        Code = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Arguments:
            if isinstance(Arg, Token_Comma):
                continue
            Arg_Code = Arg.Canonical
            Code += ' ' + str(Arg_Code)
        return Code
    def Canonical_Args(self):
        Code = ''
        Arg_Code = None
        Arg = None
        for Arg in self.Listargs:
            Arg_Code = Arg.Canonical
            if Arg_Code[:len(',')] == ',':
                Code += str(Arg_Code)
            else:
                Code += ' ' + str(Arg_Code)
        return Code
    def Canonical_Tails(self):
        Code = ''
        Tail = None
        for Tail in self.Tails:
            zdebug.zbreak()
            Code += str(Tail.Canonical_Tail())
        return Code
    def Mumps_Arguments(self, Delim = ','):
        Code = ''
        Comma = ''
        Argument = None
        Between = ''
        for Argument in self.Arguments:
            Code += str(Between) + str(Argument.Mumps)
            Between = Delim
        return Code
    def Mumps_Listargs(self, Delim = ','):
        Code = ''
        Comma = ''
        Argument = None
        Between = ''
        for Argument in self.Listargs:
            Code += str(Between) + str(Argument.Mumps)
            Between = Delim
        return Code
    def Re_Mumps(self):
        Elem = None
        for Elem in self.Arguments:
            Elem.Re_Mumps()
        self.Infer_Mumps()
    def Allow_Suffix(self, Suffix):
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Argument_Types(self, Type):
        Argument = None
        for Argument in self.Arguments:
            Argument.Data_Type = Type
    def Infer_Verb(self):
        Verbose = False
        Vrb = ''
        Between = ''
        Elem = None
        New_Verbs = []
        self.Verbs = New_Verbs
        for Elem in self.Elements:
            if isinstance(Elem, Keyword_Token):
                Vrb += str(Between) + str(Elem.Input)
                Between = ' '
                self.Verbs.extend([Vrb])
        if ' ' in Vrb:
            V = str(Vrb)
            V = V.replace(' ', '')
            if '.' in V:
                self.Verbs.extend([V])
                if Verbose:
                    print('infer verb ', V, sep='')
        if Verbose:
            print(self.__class__.__name__, ' ', Vrb, sep='')
        self.Verb = Vrb
        return True
class Tail (Named_Element):
    def Infer_Components(self):
        I = self.Classification
        Elem = None
        Keyword = ''
        Verb = str(self.Verb)
        Verb_Tail = str(Verb)
        Suffix = ''
        for Elem in self.Elements:
            Imp = Elem.Classification
            Elem.Parent = self
            Imp.Parent = I
            if isinstance(Elem, Keyword_Token):
                Input = str(Elem.Input)
                I.Gal_Keywords.extend([Input])
                I.Gs_Keywords.extend([Input])
                if Verb_Tail[:len(Input)] == Input:
                    Verb_Tail = Verb_Tail[len(Input):]
                else:
                    Suffix += ' ' + str(Input)
                    I.Keywords.extend([Imp])
            elif isinstance(Elem, Syntax_Tail):
                I.Tails.extend([Imp])
            elif isinstance(Elem, Syntax_Token):
                continue
            else:
                self.Arguments.extend([Elem])
                self.Listargs.extend([Elem])
                # comment 'NOTE cross mapping of [my Arguments] and [I.Arguments]';
            if isinstance(Elem, Tail):
                print("Tail in Tail")
                # comment 'list.append [. I Tails] Imp;';
        I.Gal_Keyword = Verb
        I.Gal_Key_Suffix = Suffix
        I.Gs_Keyword = Verb
        return True
        return True
class Statements (Element):
    def Infer_Mumps(self):
        Code = ''
        Statement = None
        for Statement in self.Elements:
            Code += str(Statement.Mumps) + str('\n')
        self.Mumps = Code
    def Infer_Gal(self):
        # comment 'debug';
        Code = ''
        Statement = None
        for Statement in self.Elements:
            Code += str(Statement.Gal) + str('\n')
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Code = ''
        Statement = None
        Between = ''
        for Statement in self.Elements:
            Code += str(Between) + str(Statement.Gs)
            Between = '\n'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        # comment 'debug';
        Code = ''
        Statement = None
        Between = ''
        for Statement in self.Elements:
            Code += str(Between) + str(Statement.Javascript)
            Between = '\n'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        # comment 'debug';
        Code = ''
        Statement = None
        Between = ''
        for Statement in self.Elements:
            Code += str(Between) + str(Statement.Python)
            Between = '\n'
        self.Python = Code
        return True
    def Infer_Html(self):
        # comment 'debug';
        Code = ''
        Statement = None
        for Statement in self.Elements:
            Code += str(Statement.Html) + str('\n')
        self.Html = Code
        return True
    def Infer_C(self):
        # comment 'debug';
        Code = ''
        Statement = None
        Between = ''
        for Statement in self.Elements:
            Code += str(Between) + str(Statement.C)
            Between = '\n'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Code = ''
        Statement = None
        Between = ''
        for Statement in self.Elements:
            Code += str(Between) + str(Statement.Fallback)
            Between = '\n'
        self.Fallback = Code
        return True
    def Infer_Canonical(self):
        Code = ''
        Statement = None
        Between = ''
        for Statement in self.Elements:
            Code += str(Between) + str(Statement.Canonical)
            Between = '\n'
        self.Canonical = Code
        return True
class Expressions (Element):
    def Infer_Gs(self):
        Code = ''
        Statement = None
        Between = ''
        for Statement in self.Elements:
            Code += str(Between) + str(Statement.Gs)
            Between = '\n'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        # comment 'debug';
        Code = ''
        Expression = None
        Between = ''
        for Expression in self.Elements:
            Code += str(Between) + str(Expression.Javascript)
            Between = ', '
        self.Javascript = Code
        return True
    def Infer_Python(self):
        # comment 'debug';
        Code = ''
        Expression = None
        Between = ''
        for Expression in self.Elements:
            Code += str(Between) + str(Expression.Python)
            Between = ', '
        self.Python = Code
        return True
    def Infer_C(self):
        # comment 'debug';
        Code = ''
        Expression = None
        Between = ''
        for Expression in self.Elements:
            Code += str(Between) + str(Expression.C)
            Between = ', '
        self.C = Code
        return True
class Operation (Named_Element):
    def __init__(self):
        super().__init__()
        self.Tails = []
        self.Tails = []
    def Then(self, Predecessor):
        Keyword = str(self.Gs_Keyword)
        Arguments = ""
        Pred = None
        for Pred in Predecessor:
            Arguments += " " + str(Predecessor.Gs)
        Code = "(" + str(Keyword) + str(Arguments) + ")"
        return Code
    def Can(self, Predecessor):
        return False
    def Gal_Tail(self):
        Gal = str(self.Gal)
        Length = len(Gal) - 2
        Middle = str(Gal[1:(1)+(Length)])
        Code = ', ' + str(Middle)
        return Code
    def Gs_Tail(self):
        Gs = str(self.Gs)
        Length = len(Gs) - 2
        Middle = str(Gs[1:(1)+(Length)])
        Code = ', ' + str(Middle)
        return Code
    def Mbinop(self, Arg1, Oper, Arg2):
        Code = str(Arg1.Mumps) + str(Oper) + str(Arg2.Matom())
        return Code
    def Mrepeating(self, Oper):
        Code = ''
        Arg = None
        First = True
        for Arg in self.Arguments:
            if First:
                Code += str(Arg.Mumps)
                First = False
            else:
                Code += str(Oper) + str(Arg.Matom())
        self.Mumps = Code
    def Infer_Gal(self):
        Gen = '(' + str(self.Gal_Key()) + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Gs_Key()) + str(self.Gs_Arguments()) + ')'
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        # comment 'This is necessary, to ensure that most statements use the fallback of their elements.';
        Code = '(' + str(self.Gs_Key()) + str(self.Fallback_Arguments()) + ')'
        self.Fallback = Code
        return True
    def Infer_Canonical(self):
        # comment 'This is necessary, to ensure that most statements use the canonical of their elements.';
        Code = '(' + str(self.Gs_Key()) + str(self.Canonical_Arguments()) + ')'
        Code = self.Canonical_Variables(Code)
        self.Canonical = Code
        return True
    def Infer_Classification(self):
        Verbose = True
        Verb = None
        Last = '<unknown keyword>'
        Singleton = None
        Classification = None
        Found = False
        for Verb in self.Verbs:
            if Verb in self.Document.Dialect.Operations.keys():
                Singleton = self.Document.Dialect.Operations[Verb]
                Classification = Singleton.Factory(self)
                self.Classifications.extend([Classification])
                self.Verb = Verb
                self.Classification = Classification
                Found = True
        if not Found:
            if Verbose:
                print('Default Operation ', self.Verb, sep='')
            Singleton = Operation()
            Classification = Singleton.Factory(self)
            self.Classifications.extend([Classification])
            self.Verb = Last
            self.Classification = Classification
        Class_Name = str(self.Classification.__class__.__name__)
        self.Class_Name = Class_Name
        self.Classification.Class_Name = Class_Name
        return True
    def Infer_Components(self):
        I = self.Classification
        Elem = None
        Keyword = ''
        Verb = str(self.Verb)
        Verb_Tail = str(Verb)
        Suffix = ''
        # comment '(append `` [line] `This is because when the root example is an operation, this somehow happens twice, and we can get double keywords and double arguments.` [line] `A better solution for the future will be to stop it from being re-invoked in the first place.`)';
        if len(I.Gal_Keywords) > 0:
            New_Gal = []
            I.Gal_Keywords = New_Gal
        if len(I.Gs_Keywords) > 0:
            New_Gs = []
            I.Gs_Keywords = New_Gs
        if len(I.Arguments) > 0:
            New_Args = []
            I.Arguments = New_Args
        if len(I.Listargs) > 0:
            New_Listargs = []
            I.Listargs = New_Listargs
        for Elem in self.Elements:
            Imp = Elem.Classification
            Elem.Parent = self
            Imp.Parent = I
            if isinstance(Elem, Keyword_Token):
                Input = str(Elem.Input)
                I.Gal_Keywords.extend([Input])
                I.Gs_Keywords.extend([Input])
                if Verb_Tail[:len(Input)] == Input:
                    Verb_Tail = Verb_Tail[len(Input):]
                else:
                    Suffix += ' ' + str(Input)
                    I.Keywords.extend([Imp])
            elif isinstance(Elem, Boundary_Token):
                continue
            else:
                self.Arguments.extend([Elem])
                self.Listargs.extend([Elem])
                I.Arguments.extend([Imp])
                I.Listargs.extend([Imp])
            if isinstance(Elem, Tail):
                print("Tail of Operation")
        I.Gal_Keyword = Verb
        I.Gal_Key_Suffix = Suffix
        I.Gs_Keyword = Verb
        return True
        return True
    def Infer_Data_Types(self):
        Verbose = False
        # comment 'debug';
        if Verbose:
            print(self.__class__.__name__)
        return True
class Operation_Tail (Tail):
    def Infer_Gal(self):
        Code = str(self.Gal_Arguments())
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Code = str(self.Gs_Arguments())
        self.Gs = Code
        return True
    def Infer_Verb(self):
        Verbose = False
        Vrb = ''
        Between = ''
        Elem = None
        New_Verbs = []
        self.Verbs = New_Verbs
        for Elem in self.Elements:
            if isinstance(Elem, Token_Comma):
                continue
            if isinstance(Elem, Keyword_Token):
                Vrb += str(Between) + str(Elem.Input)
                Between = ' '
                self.Verbs.extend([Vrb])
        if Verbose:
            print(self.__class__.__name__, ' ', Vrb, sep='')
        self.Verb = Vrb
        return True
class Syntax (Named_Element):
    def __init__(self):
        super().__init__()
        self.Tails = []
        self.Tails = []
    def Then(self, Predecessor):
        Keyword = str(self.Gs_Keyword)
        Arguments = ""
        Pred = None
        for Pred in Predecessor:
            Arguments += " " + str(Predecessor.Gs)
        Code = "[" + str(Keyword) + str(Arguments) + "]"
        return Code
    def Can(self, Predecessor):
        return False
    def Syntax_Gal(self, Code):
        return '['  +  Code  +  ']'
    def Old_Syntax_Gal(self, Code):
        Ret = ''
        if isinstance(self.Owner, Syntax_Tail):
            if str(Code[0]) != ',':
                Ret += ', '
            Ret += str(Code)
        else:
            Ret += '[' + str(Code) + ']'
        return Ret
    def Gal_Tail(self):
        Gal = str(self.Gal)
        Length = len(Gal) - 2
        Middle = str(Gal[1:(1)+(Length)])
        Code = ', ' + str(Middle)
        return Code
    def Syntax_Gs(self, Code):
        Text = str('['  +  Code  +  ']')
        return Text
    def Old_Syntax_Gs(self, Code):
        Ret = ''
        if isinstance(self.Owner, Syntax_Tail):
            if str(Code[0]) != ',':
                Ret += ', '
            Ret += str(Code)
        else:
            Ret += '[' + str(Code) + ']'
        return Ret
    def Gs_Tail(self):
        Gs = str(self.Gs)
        Length = len(Gs) - 2
        Middle = str(Gs[1:(1)+(Length)])
        Code = ', ' + str(Middle)
        return Code
    def Infer_Gal(self):
        Code = str(self.Gal_Key()) + str(self.Gal_Arguments())
        self.Gal = self.Syntax_Gal(Code)
        return True
    def Infer_Gs(self):
        Code = str(self.Gs_Key()) + str(self.Gs_Arguments())
        self.Gs = self.Syntax_Gs(Code)
        return True
    def Infer_C(self):
        # comment 'Syntax.Infer_C: Override at subclass';
        # comment 'debug';
        print("Syntax: ", self.__class__.__name__, ' ', self.Get_Input(), sep='')
        return True
    def Infer_Fallback(self):
        # comment 'This is necessary, to ensure that most syntaxes use the fallback of their elements.';
        Code = '[' + str(self.Gs_Key()) + str(self.Fallback_Arguments()) + ']'
        self.Fallback = Code
        return True
    def Infer_Canonical(self):
        # comment 'This is necessary, to ensure that most syntaxes use the canonical of their elements.';
        Code = '[' + str(self.Gs_Key()) + str(self.Canonical_Arguments()) + ']'
        Code = self.Canonical_Variables(Code)
        self.Canonical = Code
        return True
    def Infer_Classification(self):
        Verbose = True
        Verb = None
        Last = '<unknown keyword>'
        Singleton = None
        Classification = None
        Found = False
        for Verb in self.Verbs:
            if Verb in self.Document.Dialect.Syntaxes.keys():
                Singleton = self.Document.Dialect.Syntaxes[Verb]
                Classification = Singleton.Factory(self)
                self.Classifications.extend([Classification])
                self.Verb = Verb
                self.Classification = Classification
                Found = True
        if not Found:
            if Verbose:
                print('Default Syntax ', self.Verb, sep='')
            Singleton = Syntax()
            Classification = Singleton.Factory(self)
            self.Classifications.extend([Classification])
            self.Verb = Last
            self.Classification = Classification
        Class_Name = str(self.Classification.__class__.__name__)
        self.Class_Name = Class_Name
        self.Classification.Class_Name = Class_Name
        return True
    def Infer_Components(self):
        I = self.Classification
        Elem = None
        Keyword = ''
        Verb = str(self.Verb)
        Verb_Tail = str(Verb)
        Suffix = ''
        for Elem in self.Elements:
            # comment 'TODO:Examine syntax arguments process.';
            Imp = Elem.Classification
            Elem.Parent = self
            Imp.Parent = I
            if isinstance(Elem, Keyword_Token):
                Input = str(Elem.Input)
                I.Gal_Keywords.extend([Input])
                I.Gs_Keywords.extend([Input])
                if Verb_Tail[:len(Input)] == Input:
                    Verb_Tail = Verb_Tail[len(Input):]
                else:
                    Suffix += ' ' + str(Input)
                    I.Keywords.extend([Imp])
            elif isinstance(Elem, Syntax_Tail):
                I.Tails.extend([Imp])
            elif isinstance(Elem, Syntax_Token):
                continue
            else:
                self.Arguments.extend([Elem])
                self.Listargs.extend([Elem])
                I.Arguments.extend([Imp])
                I.Listargs.extend([Imp])
        I.Gal_Keyword = Verb
        I.Gal_Key_Suffix = Suffix
        I.Gs_Keyword = Verb
        return True
        return True
    def Infer_Data_Types(self):
        Verbose = False
        # comment 'debug';
        if Verbose:
            print(self.__class__.__name__)
        return True
class Syntax_Tail (Tail):
    def Syntax_Gs(self, Code):
        Text = str('['  +  Code  +  ']')
        return Text
    def Infer_Mumps(self):
        # comment 'Syntax_Tail.Infer_Mumps';
        Arg0 = self.Arguments[0]
        Code = str(Arg0.Mumps)
        try:
            Default = self.Arguments[1]
            Value = str(Default.Mumps)
            Declaration = str("    ") + 'set ' + str(Variable) + '=$get(' + str(Variable) + ',' + str(Value) + ')' + str('\n')
            self.Mumps_Declaration = Declaration
        except Exception:
            pass
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        Code = 'ERROR SYNTAX TAIL'
        raise Exception(str(Code))
        self.Mumps = Code
    def Infer_Gal(self):
        zdebug.zbreak()
        # comment 'TODO:translate object syntax tail to entity for gal output.';
        Code = str(self.Gal_Arguments())
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Code = str(self.Verb) + ' ' + str(self.Gs_Arguments())
        self.Gs = self.Syntax_Gs(Code)
        return True
    def Infer_C(self):
        raise Exception("Reduce to fallback before compiling into C.")
        return True
    def Infer_Fallback(self):
        # comment 'This is necessary, to ensure that most syntaxes use the fallback of their elements.';
        Code = '[' + str(self.Gs_Key()) + str(self.Fallback_Arguments()) + ']'
        self.Fallback = Code
        return True
    def Infer_Canonical(self):
        # comment 'This is necessary, to ensure that most syntaxes use the canonical of their elements.';
        Code = '[' + str(self.Gs_Key()) + str(self.Canonical_Arguments()) + ']'
        Code = self.Canonical_Variables(Code)
        self.Canonical = Code
        return True
    def Infer_Verb(self):
        Verbose = False
        Vrb = ''
        Between = ''
        Elem = None
        New_Verbs = []
        self.Verbs = New_Verbs
        for Elem in self.Elements:
            if isinstance(Elem, Token_Comma):
                continue
            if isinstance(Elem, Keyword_Token):
                Vrb += str(Between) + str(Elem.Input)
                Between = ' '
                self.Verbs.extend([Vrb])
        if Verbose:
            print(self.__class__.__name__, ' ', Vrb, sep='')
        self.Verb = Vrb
        return True
class Statement (Named_Element):
    def __init__(self):
        super().__init__()
        self.Block = None
        self.Tails = []
        self.Tails = []
        self.Parent_Name = ''
    def Then(self, Predecessor):
        # comment 'TODO:Block? Right now we only do line statements.';
        Keyword = str(self.Gs_Keyword)
        Arguments = ""
        Pred = None
        for Pred in Predecessor:
            Arguments += " " + str(Predecessor.Gs)
        Code = str(Keyword) + str(Arguments) + ";"
        return Code
    def Can(self, Predecessor):
        return False
    def Gal_Block(self):
        Code = ';'
        if self.Block is not None:
            Code = self.Block.Gal
        return Code
    def Gs_Block(self):
        Code = ';'
        try:
            Code = self.Block.Gs
        except Exception:
            pass
        return Code
    def Javascript_Block(self):
        if self.Block is not None:
            return self.Block.Javascript
        return ' { }'
    def Javascript_Statements(self):
        if not self.Block is not None:
            return ''
        return self.Block.Javascript_Statements
    def Python_Block(self):
        if self.Block is not None:
            return self.Block.Python
        else:
            return ':'  +  '\n'  +  "    "  +  'pass'  +  '\n'
    def Python_Statements(self):
        if self.Block is not None:
            return self.Block.Python_Statements
        else:
            return ''
    def Html_Block(self):
        Code = ';'
        if self.Block is not None:
            Code = self.Block.Html
        return Code
    def Html_Block_Text(self):
        Code = ''
        if self.Block is not None:
            Code = self.Block.Html_Text
        return Code
    def C_Block(self):
        if self.Block is not None:
            return self.Block.C
        return ' { }'
    def C_Statements(self):
        if not self.Block is not None:
            return ''
        return self.Block.C_Statements
    def Fallback_Block(self):
        Code = ';'
        if self.Block is not None:
            Code = self.Block.Fallback
        return Code
    def Fallback_Statements(self):
        Return = ''
        if self.Block is not None:
            if self.Block.Fallback_Statements is not None:
                Return = self.Block.Fallback_Statements
        return Return
    def Canonical_Block(self):
        Code = ';'
        if self.Block is not None:
            Code = self.Block.Canonical
        return Code
    def Canonical_Statements(self):
        Return = ''
        if self.Block is not None:
            if self.Block.Canonical_Statements is not None:
                Return = self.Block.Canonical_Statements
        return Return
    def Mumps_Block(self):
        if not self.Block is not None:
            return ''
        return self.Block.Mumps
    def Mumps_Statements(self):
        if self.Block is not None:
            return self.Block.Mumps_Statements
        return ''
    def Re_Mumps(self):
        Elem = None
        for Elem in self.Arguments:
            Elem.Re_Mumps()
        if self.Block is not None:
            self.Block.Re_Mumps()
        self.Infer_Mumps()
    def Break_Label(self):
        return self.Parent.Break_Label()
    def Continue_Label(self):
        return self.Parent.Continue_Label()
    def Infer_Gal(self):
        Gen = str(self.Gal_Key()) + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = str(self.Gs_Key()) + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Keywords = str(self.Gs_Keyword)
        Name = str(Keywords.title())
        Name = Name.replace(' ', '_')
        Keywords = self.Enquote(Keywords)
        Declaration = 'statement ' + str(Name) + ' ' + str(Keywords) + ';' + str('\n') + 'symbol ' + str(Name) + ';' + str('\n') + 'spell ' + str(Name) + ';' + str('\n')
        if not '~' in Keywords or 'tilda' in Keyword:
            Declaration += '~ ' + str(Keywords) + ';' + str('\n')
        # comment 'my= Fallback_Declaration Declaration;';
        Code = str(self.Gs_Key()) + str(self.Fallback_Arguments()) + str(self.Fallback_Block())
        self.Fallback = Code
        return True
    def Infer_Canonical(self):
        Keywords = str(self.Gs_Keyword)
        Name = str(Keywords.title())
        Name = Name.replace(' ', '_')
        Keywords = self.Enquote(Keywords)
        Declaration = 'statement ' + str(Name) + ' ' + str(Keywords) + ';' + str('\n') + 'symbol ' + str(Name) + ';' + str('\n') + 'spell ' + str(Name) + ';' + str('\n')
        if not '~' in Keywords or 'tilda' in Keyword:
            Declaration += '~ ' + str(Keywords) + ';' + str('\n')
        # comment 'my= Canonical_Declaration Declaration;';
        Code = str(self.Gs_Key()) + str(self.Canonical_Arguments()) + str(self.Canonical_Block())
        Code = self.Canonical_Variables(Code)
        self.Canonical = Code
        return True
    def Infer_Classification(self):
        Verbose = True
        Verb = None
        Last = '<unknown keyword>'
        Singleton = None
        Classification = None
        Found = False
        for Verb in self.Verbs:
            if Verb in self.Document.Dialect.Statements.keys():
                Singleton = self.Document.Dialect.Statements[Verb]
                Classification = Singleton.Factory(self)
                self.Classifications.extend([Classification])
                self.Verb = Verb
                self.Classification = Classification
                Found = True
                Last = Verb
        if not Found:
            if Verbose:
                print('Default Statement ', self.Verb, sep='')
            Singleton = Statement()
            Classification = Singleton.Factory(self)
            self.Classifications.extend([Classification])
            self.Classification = Classification
        Class_Name = str(self.Classification.__class__.__name__)
        self.Class_Name = Class_Name
        self.Classification.Class_Name = Class_Name
        return True
    def Infer_Components(self):
        Verbose = False
        I = self.Classification
        Elem = None
        BE = None
        Keyword = ''
        Verb = str(self.Verb)
        Verb_Tail = str(Verb)
        Suffix = ''
        for Elem in self.Elements:
            Imp = Elem.Classification
            Elem.Parent = self
            Imp.Parent = I
            if isinstance(Elem, Block):
                I.Block = Imp
                self.Block = Imp
                for BE in Imp.Statements:
                    BE.Parent = I
            elif isinstance(Elem, Keyword_Token):
                Input = str(Elem.Input)
                I.Gal_Keywords.extend([Input])
                I.Gs_Keywords.extend([Input])
                if Verb_Tail[:len(Input)] == Input:
                    Verb_Tail = Verb_Tail[len(Input):]
                else:
                    Suffix += ' ' + str(Input)
                    I.Keywords.extend([Imp])
            elif isinstance(Elem, Boundary_Token):
                continue
            else:
                self.Arguments.extend([Elem])
                self.Listargs.extend([Elem])
                I.Arguments.extend([Imp])
                I.Listargs.extend([Imp])
                if isinstance(Imp, Syntax):
                    SE = None
                    for SE in Elem.Tails:
                        self.Arguments.extend([SE])
                        self.Listargs.extend([SE])
                    for SE in Imp.Tails:
                        I.Arguments.extend([SE])
                        I.Listargs.extend([SE])
            if isinstance(Elem, Tail):
                C = Elem.Classification
                if Verbose:
                    print("Tail in Statement")
                self.Tails.extend([Elem])
                I.Tails.extend([C])
        I.Gal_Keyword = Verb
        I.Gal_Key_Suffix = Suffix
        I.Gs_Keyword = Verb
        if str(Suffix) > '':
            All_Keywords = None
            All_Keywords = ' '.join(I.Gs_Keywords)
            Gs_Keywords = str(All_Keywords[len(Verb):])
            I.Gs_Suffix = Gs_Keywords
            if str(Gs_Keywords) > '':
                return I.Allow_Suffix(Gs_Keywords)
        return True
        return True
    def Infer_Data_Types(self):
        Verbose = False
        # comment 'debug';
        if Verbose:
            print(self.__class__.__name__)
        return True
class Statement_Tail (Tail):
    def Infer_Gal(self):
        Code = str(self.Gal_Arguments())
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Code = ',' + str('\n') + str("    ")
        First = True
        Between = ''
        Argument = None
        for Argument in self.Arguments:
            if First:
                First = False
                continue
            Code += str(Between) + str(Argument.Gs)
            Between = ' '
        self.Gs = Code
        return True
    def Infer_Gs(self):
        Verbose = False
        Code = ""
        Between = ""
        Arg = None
        for Arg in self.Elements:
            Code += str(Between) + str(Arg.Gs)
            Between = " "
        self.Gs = Code
        if Verbose:
            print("Hello Statement_Tail.Gs")
        return True
    def Infer_C(self):
        Code = ''
        Elem = None
        Arg = None
        for Elem in self.Elements:
            if isinstance(Elem, Token_Comma):
                continue
            Code += str(Elem.C)
        for Arg in self.Arguments:
            zdebug.zbreak()
        self.C = Code
        return True
    def Infer_Components(self):
        I = self.Classification
        Elem = None
        for Elem in self.Elements:
            Imp = Elem.Classification
            Elem.Parent = self
            Imp.Parent = I
        return True
        return True
class Block (Element):
    def __init__(self):
        super().__init__()
        self.Statements = []
        self.Gal_Statements = ''
        self.Gs_Statements = ''
        self.Javascript_Statements = ''
        self.Python_Statements = ''
        self.C_Statements = ''
        self.C_Lines = ''
        self.Mumps_Statements = None
    def To_String(self):
        String = str(self.__class__.__name__) + ' ' + str(self.Location.Start_Position) + '-' + str(self.Location.End_Position)
        Imp = self.Classification
        Stmt = None
        Code = ''
        for Stmt in Imp.Statements:
            Code += ' ' + str(Stmt.__class__.__name__) + ';'
        String += ' {' + str(Code) + '}'
        return String
    def Infer_Mumps(self):
        Code = ''
        Statement = None
        for Statement in self.Statements:
            Code += str(Statement.Mumps)
        self.Mumps = Code
        self.Mumps_Statements = Code
    def Re_Mumps(self):
        Elem = None
        for Elem in self.Statements:
            Elem.Re_Mumps()
        self.Infer_Mumps()
    def Infer_Mumps(self):
        # comment 'TODO:Block in mumps';
        Code = ''
        Statement = None
        for Statement in self.Statements:
            Code += str(Statement.Mumps)
        self.Mumps_Statements = Code
        self.Mumps = Code
    def Infer_Gal(self):
        Line = None
        Statements = ''
        for Line in self.Statements:
            Statements += str(Line.Gal) + str('\n')
        Statements = self.Indent(Statements)
        Code = str('\n') + '{' + str('\n') + str(Statements) + '}'
        self.Gal_Statements = Statements
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Line = None
        Statements = ''
        try:
            for Line in self.Statements:
                Statements += str(Line.Gs) + str('\n')
            Statements = self.Indent(Statements)
        except Exception:
            pass
        Code = str('\n') + '{' + str('\n') + str(Statements) + '}'
        self.Gs = Code
        self.Gs_Statements = Statements
        return True
    def Infer_Javascript(self):
        Line = None
        Statements = ''
        for Line in self.Statements:
            Statements += str(Line.Javascript) + str('\n')
        Statements = self.Indent(Statements)
        Code = str('\n') + '{' + str('\n') + str(Statements) + '}'
        self.Javascript = Code
        self.Javascript_Statements = Statements
        return True
    def Infer_Python(self):
        Line = None
        Statements = ''
        Between = ''
        Found = False
        for Line in self.Statements:
            if not isinstance(Line, Statement_Comment):
                Found = True
            Statements += str(Between) + str(Line.Python)
            Between = '\n'
        if not Found:
            if str(Statements) > '':
                Statements += str('\n')
            Statements += 'pass'
        Statements = self.Py_Indent(Statements)
        Code = ':' + str('\n') + str(Statements)
        self.Python = Code
        self.Python_Statements = Statements
        return True
    def Infer_Html(self):
        Line = None
        Statements = str('\n')
        Text = str('\n')
        for Line in self.Statements:
            Statements += str(Line.Html) + str('\n')
            Text += str(Line.Html_Text) + str('\n')
        # comment '= Text (i Indent Text)';
        self.Html_Text = Text
        # comment 'string Code (i Indent Statements)';
        Code = str(Statements)
        self.Html = Code
        return True
    def Infer_C(self):
        Line = None
        Statements = ''
        for Line in self.Statements:
            Statements += str(Line.C) + str('\n')
        self.C_Lines = Statements
        Statements = self.Indent(Statements)
        Code = str('\n') + '{' + str('\n') + str(Statements) + '}'
        self.C = Code
        self.C_Statements = Statements
        return True
    def Infer_Fallback(self):
        Lines = ''
        Statement = None
        for Statement in self.Statements:
            Lines += str(Statement.Fallback) + str('\n')
            Number = 0
        if str(Lines) == '':
            self.Fallback = ';'
            self.Fallback_Statements = ''
        else:
            self.Fallback_Statements = self.Indent(Lines)
            Code = str('\n') + '{' + str('\n') + str(self.Fallback_Statements) + '}'
            self.Fallback = Code
        return True
    def Infer_Canonical(self):
        Lines = ''
        Statement = None
        for Statement in self.Statements:
            Lines += str(Statement.Canonical) + str('\n')
            Number = 0
        if str(Lines) == '':
            self.Canonical = ';'
            self.Canonical_Statements = ''
        else:
            self.Canonical_Statements = self.Indent(Lines)
            Code = str('\n') + '{' + str('\n') + str(self.Canonical_Statements) + '}'
            self.Canonical = Code
        return True
    def Infer_Components(self):
        I = self.Parent
        Elem = None
        Statements = self.Classification.Statements
        for Elem in self.Elements:
            if isinstance(Elem, Token_Block_Start):
                continue
            if isinstance(Elem, Token_Block_End):
                continue
            Imp = Elem.Classification
            Elem.Parent = I
            Imp.Parent = I
            Statements.extend([Imp])
        return True
        return True
    def Infer_Structure(self):
        Statement = None
        Iffy = False
        The_If = None
        The_Try = None
        for Statement in self.Statements:
            if isinstance(Statement, Conditional_Statement):
                if isinstance(Statement, Iffy_Statement):
                    Iffy = True
                    The_If = Statement
                    Statement.If_Statement = The_If
                    Statement.Last_Else = The_If
                    Statement.End_Label = Mumps.Get_Label()
                    Statement.Is_Last = True
                else:
                    if not Iffy:
                        zdebug.zbreak()
                    The_If.Last_Else.Is_Last = False
                    Statement.Is_Last = True
                    Statement.If_Statement = The_If
                    The_If.Last_Else = Statement
                    Statement.End_Label = The_If.End_Label
            else:
                Iffy = False
                If_Statement = None
            if isinstance(Statement, Error_Handling_Statement):
                if isinstance(Statement, Statement_Try):
                    Trying = True
                    The_Try = Statement
                    Statement.Try_Statement = The_Try
                    Statement.End_Label = Mumps.Get_Label()
                else:
                    if not Trying:
                        zdebug.zbreak()
                    Statement.Try_Statement = The_Try
                    Statement.End_Label = The_Try.End_Label
            else:
                Trying = False
                Try_Statement = None
        return True
# comment '**** Language Element Superclasses ****';
class Line_Statement (Statement):
    pass
class Scoped_Statement (Statement):
    pass
class Append_Args_Statement (Line_Statement):
    pass
class Argument_Statement (Line_Statement):
    pass
class Assignment_Statement (Line_Statement):
    pass
class Declaration_Statement (Line_Statement):
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'new ' + str(Variable) + str('\n')
        if self.Value is not None:
            Value = str(self.Value.Mumps)
            Code += str("    ") + 'set ' + str(Variable) + '=' + str(Value) + str('\n')
        self.Mumps = Code
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " = ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Infer_Javascript(self):
        if not self.Variable.Javascript is not None:
            raise Exception(str(self.Failure_Message('Variable Javascript is undefined')))
        Variable_Javascript = str(self.Variable.Javascript)
        Value_Javascript = ''
        if self.Value is not None:
            Value_Javascript = ' = '  +  self.Value.Javascript
        Code = 'var ' + str(Variable_Javascript) + str(Value_Javascript) + ';'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        if not self.Variable.Python is not None:
            raise Exception(str(self.Failure_Message('Variable Python is undefined')))
        Variable_Python = str(self.Variable.Python)
        Value_Python = 'None'
        if self.Value is not None:
            if not self.Value.Python is not None:
                raise Exception(str(self.Failure_Message('Value Python is undefined')))
            Value_Python = self.Value.Python
        Code = str(Variable_Python) + ' = ' + str(Value_Python)
        self.Python = Code
        return True
    def Infer_Structure(self):
        Verbose = True
        Variable = str(self.Variable.Input)
        Type = str(self.Gs_Keyword)
        self.Data_Type.Symbol_Value = Type
        Context = self.Method_Context()
        if (Context in (None, "")):
            if Verbose:
                print('missing variable context in declaration statement, encountered ', self.Enquote(self.Get_Input()), sep='')
        else:
            # comment 'verbosedeclaration statement noted  Variable as  Type';
            Context.Variables[Variable] = Type;
        return True
class Output_Statement (Line_Statement):
    pass
class Iterative_Statement (Scoped_Statement):
    def __init__(self):
        super().__init__()
        self.Break_Lbl = None
        self.Continue_Lbl = None
    def Break_Label(self):
        if self.Break_Lbl is not None:
            return self.Break_Lbl
        self.Break_Lbl = Mumps.Get_Label()
        return self.Break_Lbl
    def Continue_Label(self):
        if self.Continue_Lbl is not None:
            return self.Continue_Lbl
        self.Continue_Lbl = Mumps.Get_Label()
        return self.Continue_Lbl
class Class_Statement (Scoped_Statement):
    def __init__(self):
        super().__init__()
        self.Ancestors = []
        self.Generate_Constructor = False
        self.Has_Constructor = False
        self.Infer_Inits = ''
        self.Inferences = []
        self.Is_Compiled = False
        self.Compiled_Methods = {}
        self.Compiled_Properties = {}
        self.Compiled_Class_Methods = {}
        self.Compiled_Class_Properties = {}
        self.Compiled_Ancestors = {}
        self.Appended_Statements = []
        self.Constructor = None
        self.Main = None
        self.Class_Property_Statements = []
        self.Property_Statements = []
        self.Class_Methods = []
        self.Methods = []
        self.Main_Body = []
    def Factory(self, Parsed_Element):
        Verbose = False
        Class_Name = ""
        Between = ""
        Argument = None
        for Argument in Parsed_Element.Elements:
            if isinstance(Argument, Token_Name):
                Class_Name += str(Between) + str(Argument.Get_Input())
                Between = '_'
        if Verbose:
            print("Class.Factory got name '", Class_Name, "'.", sep='')
        New_Element = self.__class__()
        New_Element.Owner = Parsed_Element
        New_Element.Location = Parsed_Element.Location
        Existing = New_Element
        if Class_Name in Statement_Class.Names.keys():
            if Verbose:
                print("    ", 'Class.Factory returns existing class object ', Existing.__class__.__name__, ' ', Existing, sep='')
            Existing = Statement_Class.Names[Class_Name]
        else:
            if Verbose:
                print("    ", 'Class.Factory method registers the new class ', Class_Name, ' as ', New_Element.__class__.__name__, sep='')
            Statement_Class.Names[Class_Name] = New_Element;
        New_Element.Implementer = Existing
        return New_Element
    def Append_Statement(self, Statement):
        if isinstance(Statement, Statement_Class_Property):
            # comment 'TODO:';
            pass
        elif isinstance(Statement, Statement_Constructor):
            self.Constructor = Statement
        elif isinstance(Statement, Statement_Property):
            # comment 'TODO:';
            pass
        elif isinstance(Statement, Statement_Main):
            zdebug.zbreak()
            self.Main = Statement
            self.Main_Body.extend([Statement])
        else:
            self.Main_Body.extend([Statement])
    def Get_Class_Context(self):
        return self
    def Inherit(self):
        Verbose = True
        if self.Is_Compiled:
            return
        Stmt = None
        S2 = None
        Name = None
        My_Name = str(self.Name.Input)
        for Name in self.Ancestors:
            if Verbose:
                print("    ", 'class ', My_Name, ' looks up ancestor ', Name, sep='')
            S2 = Statement_Class.Names[Name]
            self.Compiled_Ancestors[Name] = S2;
            S2.Inherit()
            for Name, Stmt in S2.Compiled_Ancestors.items():
                self.Compiled_Ancestors[Name] = S2;
            for Name, Stmt in S2.Compiled_Class_Properties.items():
                self.Compiled_Class_Properties[Name] = Stmt;
            for Name, Stmt in S2.Compiled_Class_Methods.items():
                self.Compiled_Class_Methods[Name] = Stmt;
            for Name, Stmt in S2.Compiled_Properties.items():
                self.Compiled_Properties[Name] = Stmt;
            for Name, Stmt in S2.Compiled_Methods.items():
                self.Compiled_Methods[Name] = Stmt;
        for Stmt in self.Class_Property_Statements:
            Name = Stmt.Name.Input
            self.Compiled_Class_Properties[Name] = Stmt;
        for Stmt in self.Class_Methods:
            Name = Stmt.Name.Input
            self.Compiled_Class_Methods[Name] = Stmt;
        for Stmt in self.Property_Statements:
            Name = Stmt.Name.Input
            self.Compiled_Properties[Name] = Stmt;
        for Stmt in self.Methods:
            Name = Stmt.Name.Input
            self.Compiled_Methods[Name] = Stmt;
        self.Is_Compiled = True
    def Infer_Structure(self):
        Statement = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                if isinstance(Statement, Statement_Property):
                    self.Generate_Constructor = True
                    self.Property_Statements.extend([Statement])
                elif isinstance(Statement, Statement_Main):
                    self.Main = Statement
                elif isinstance(Statement, Statement_Constructor):
                    self.Has_Constructor = True
                    self.Constructor = Statement
                elif isinstance(Statement, Statement_Infers):
                    self.Infer_Inits += 'list [my Inferences ~] append (new Inference_' + str(Statement.Inference.Get_Input()) + ' [self]);' + str('\n')
                elif isinstance(Statement, Statement_Class_Method):
                    self.Class_Methods.extend([Statement])
                elif isinstance(Statement, Method_Statement):
                    self.Methods.extend([Statement])
                elif isinstance(Statement, Statement_Class_Property):
                    self.Class_Property_Statements.extend([Statement])
        return True
class Behavior_Statement (Scoped_Statement):
    def __init__(self):
        super().__init__()
        self.Variables = {}
    def Method_Context(self):
        return self
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Infer_Structure(self):
        Class_Context = self.Get_Class_Context()
        Class_Name = str(Class_Context.Name.Get_Input())
        Behavior_Name = str(self.Behavior_Name.Get_Input())
        Entity_Behavior_Class = "Behavior_" + str(Class_Name) + '_' + str(Behavior_Name)
        Qclass = str(self.Enquote(Entity_Behavior_Class))
        try:
            Behavior_Class = Statement_Class.Names["Behavior"]
            Register = 'push [our Registry] [: ' + str(Entity_Behavior_Class) + '];'
            Append = str(Register) + str('\n') + 'dict [our Names] ' + str(Qclass) + ' = [: ' + str(Entity_Behavior_Class) + '];'
            Register_Element = Literal(Append)
            Statement = None
            Theirs = None
            Method_Name = None
            Found = False
            for Statement in Behavior_Class.Block.Statements:
                if not isinstance(Statement, Statement_Class_Method):
                    continue
                Method_Name = Statement.Name.Get_Input()
                if str(Method_Name) != 'Initialize':
                    continue
                for Theirs in Statement.Block.Statements:
                    if str(Theirs.Get_Input()) == str(Register):
                        Found = True
                        break
                if not Found:
                    Statement.Block.Statements.extend([Register_Element])
                break
        except Exception:
            pass
        return True
class Conditional_Statement (Scoped_Statement):
    def __init__(self):
        super().__init__()
        self.If_Statement = None
        self.Last_If = False
        self.Is_Last = False
        self.End_Label = None
class Error_Handling_Statement (Scoped_Statement):
    def __init__(self):
        super().__init__()
        self.Try_Statement = None
        self.End_Label = None
class Iffy_Statement (Conditional_Statement):
    pass
class Comment_Statement (Append_Args_Statement):
    def Allow_Suffix(self, Suffix):
        return True
class Method_Statement (Scoped_Statement):
    def __init__(self):
        super().__init__()
        self.Variables = {}
    def Method_Context(self):
        return self
    def Get_Property_Name(self):
        try:
            Method_Name = str(self.Name.Get_Input())
            if 'Infer_' in Method_Name:
                Method_Name = Method_Name.replace('Infer_', '')
                return Method_Name
        except Exception:
            pass
        return self.Parent.Get_Property_Name()
class Class_Method_Statement (Method_Statement):
    pass
class Symbol_Statement (Class_Statement):
    pass
class Attribute_Value_Statement (Line_Statement):
    def Infer_Gal(self):
        Gen = 'my' + str(self.__class__.Property_Name) + ' attribute = ' + str(self.Value.Gal) + ';'
        self.Gal = Gen
        return True
class Feature_Assignment_Statement (Line_Statement):
    pass
class Object_Definition_Statement (Scoped_Statement):
    pass
class Definition_Statement (Scoped_Statement):
    Base_Class = None
    def __init__(self):
        super().__init__()
        self.Name_Arg = None
        self.Keyword = None
        self.Root_Type = None
    def Get_Class_Context(self):
        return self
    def Infer_Fallback(self):
        Base_Class = str(self.__class__.Base_Class)
        Class_Name = str(Base_Class) + '_' + str(self.Name.Fallback)
        Keyword = str(self.Keyword.Fallback)
        if isinstance(self.Keyword, Token_Quote):
            Keyword = self.Keyword.Unquoted()
        Gal_Keyword = str(Keyword)
        Gal_Keyword = Gal_Keyword.replace(' ', '.')
        Code = 'class ' + str(Class_Name)
        if self.Ancestor is not None:
            Code += ' [is ' + str(self.Ancestor.Fallback) + '_' + str(Base_Class) + ']'
        else:
            Code += ' [is ' + str(self.__class__.Base_Class) + ']'
        Code += str('\n') + '{' + str('\n') + str("    ") + "class property string Gal_Keyword " + str(self.Enquote(Gal_Keyword)) + ";" + str('\n') + str("    ") + "class property string Keyword " + str(self.Enquote(Keyword)) + ";" + str('\n')
        Attribute_Statements = ''
        Statement = None
        if self.Block is not None:
            Code += str(self.Fallback_Statements())
            for Statement in self.Block.Statements:
                if Statement.Fallback_Declaration is not None:
                    Attribute_Statements += str(Statement.Fallback_Declaration)
        Indented = str(self.Indent(Attribute_Statements))
        Attribute_Method = 'method flag Attributes' + str('\n') + '{' + str('\n') + str(Indented) + str('\n') + str("    ") + 'return [true];' + str('\n') + '}' + str('\n')
        Code += str(self.Indent(Attribute_Method))
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Feature_Statement (Attribute_Value_Statement):
    def Infer_Fallback(self):
        Property_Name = str(self.Property_Name)
        Parent = str(self.Parent.Name.Fallback)
        Value = str(self.Value.Fallback)
        Code = '[' + str(Parent) + '.' + str(Property_Name) + '.Symbol_Value] = ' + str(Value) + ';'
        self.Fallback = Code
        return True
class Thing_Statement (Scoped_Statement):
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Class_Name = str(self.Thing_Type)
        Code = 'object ' + str(Name) + ' new ' + str(Class_Name) + ';'
        if self.Text is not None:
            Code += str('\n') + str(Name) + '.Text = ' + str(self.Text.Fallback) + ';'
        Code += str('\n') + str(self.Fallback_Statements())
        self.Fallback = Code
        return True
class Amount_Statement (Scoped_Statement):
    def Infer_Gs(self):
        Gsk = str(self.Gs_Keyword)
        Amount = str(self.Amount.Gs)
        Unit = str(self.Unit.Symbol_Value.Gs)
        Code = str(Gsk) + ' ' + str(Amount) + ' ' + str(Unit) + ';'
        self.Gs = Code
        return True
    def Infer_Fallback(self):
        Parent = str(self.Parent.Name.Fallback)
        Amount = str(self.Enquote(self.Amount.Fallback))
        Unit = str(self.Enquote(self.Unit.Symbol_Value.Fallback))
        Property_Name = str(self.Property_Name)
        Code = '[' + str(Parent) + '.' + str(Property_Name) + '.Symbol_Value] = ' + str(Amount) + ';' + str('\n') + '[' + str(Parent) + '.' + str(Property_Name) + '.Unit] = ' + str(Unit) + ';'
        self.Fallback = Code
        return True
class Append_Names_Statement (Scoped_Statement):
    def Infer_Attributes(self):
        Verbose = False
        Argument = None
        Name = ''
        Between = ''
        for Argument in self.Arguments:
            if isinstance(Argument, Token_Name):
                Name += str(Between) + str(Argument.Input)
                Between = '_'
            elif isinstance(Argument, Token_Quote):
                self.Description = Argument
            else:
                zdebug.zbreak()
                if Verbose:
                    print('Unexpected Argument')
        self.Name = Name
        return True
class Dialect_Statement (Line_Statement):
    pass
class Unary_Operation (Operation):
    def Infer_Javascript(self):
        Code = str(self.Javascript_Unary())
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = str(self.Python_Unary())
        self.Python = Code
        return True
    def Infer_C(self):
        Code = str(self.C_Unary())
        self.C = Code
        return True
class Binary_Operation (Operation):
    def Matom(self):
        return '('  +  self.Mumps  +  ')'
    def Infer_Javascript(self):
        Code = str(self.Javascript_Repeating())
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = str(self.Python_Repeating())
        self.Python = Code
        return True
    def Infer_C(self):
        Code = str(self.C_Repeating())
        self.C = Code
        return True
    def Infer_Fallback(self):
        Code = '('
        Append = ' ' + str(self.Gs_Keyword)
        Between = ''
        Argument = None
        for Argument in self.Arguments:
            Code += str(Between) + str(Argument.Fallback) + str(Append)
            Append = ''
            Between = ' '
        Code += ')'
        self.Fallback = Code
        return True
class Repeating_Operation (Binary_Operation):
    def Infer_Javascript(self):
        Code = str(self.Javascript_Repeating())
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = str(self.Python_Repeating())
        self.Python = Code
        return True
    def Infer_C(self):
        Code = str(self.C_Repeating())
        self.C = Code
        return True
    def Infer_Fallback(self):
        Code = '('
        Append = ' ' + str(self.Gs_Keyword)
        Between = ''
        Argument = None
        for Argument in self.Arguments:
            Code += str(Between) + str(Argument.Fallback) + str(Append)
            Append = ''
            Between = ' '
        Code += ')'
        self.Fallback = Code
        return True
class Argument_Syntax (Syntax):
    def Infer_Mumps(self):
        Verbose = False
        Code = str(self.Variable.Mumps)
        self.Mumps = Code
        try:
            Value = str(self.Default_Value.Mumps)
            Declaration = str("    ") + 'set ' + str(Code) + '=$get(' + str(Code) + ',' + str(Value) + ')' + str('\n')
            self.Mumps_Declaration = Declaration
            if Verbose:
                print('     argument syntax declaration: ', Declaration, sep='')
        except Exception:
            pass
    def Infer_Javascript(self):
        Code = str(self.Variable.Javascript)
        if self.Default_Value is not None:
            Code += '=' + str(self.Default_Value.Javascript)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = str(self.Variable.Python)
        if self.Default_Value is not None:
            Code += '=' + str(self.Default_Value.Python)
        self.Python = Code
        return True
    def Infer_Structure(self):
        Verbose = True
        Variable = str(self.Variable.Input)
        Type = str(self.Gs_Keyword)
        self.Data_Type.Symbol_Value = Type
        Context = self.Method_Context()
        if (Context in (None, "")):
            if Verbose:
                print('missing variable context in argument syntax, encountered ', self.Enquote(self.Get_Input()), sep='')
        else:
            # comment 'verboseargument syntax noted  Variable as  Type';
            Context.Variables[Variable] = Type;
        return True
# comment '**** Statement Classes ****';
class Statement_Article (Append_Names_Statement):
    Gal_Keyword = 'article'
    Gs_Keyword = 'article'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Description = None
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Description = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Verbose = False
        Code = ""
        Argument = None
        Title = ""
        Name = ""
        Between = ""
        for Argument in self.Arguments:
            if isinstance(Argument, Name_Token):
                Name += str(Between) + str(Argument.Fallback)
                Between = ' '
            elif isinstance(Argument, Token_Quote):
                Title = Argument.Fallback
            else:
                zdebug.zbreak()
                if Verbose:
                    print('Unexpected argument type?')
        if str(Name) > "":
            Code += 'title' + str(self.Enquote(Name)) + ';' + str('\n')
        if str(Title) > "":
            Code += 'subtitle ' + str(Title) + ';' + str('\n')
        Statements = str(self.Block.Fallback_Statements)
        Code += str(Statements)
        self.Fallback = Code
        return True
class Statement_Article_Reference (Append_Names_Statement):
    Gal_Keyword = 'article.reference'
    Gs_Keyword = 'article.reference'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Description = None
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Description = self.Listargs.pop(0)
    def Infer_Html(self):
        Name = str(self.Name)
        Title = str(Name)
        Title = Title.replace('_', ' ')
        Code = '<p><a href="articles/' + str(Name) + '.html">' + str(Title) + '</a>'
        if self.Description is not None:
            Code += ': ' + str(self.Description.Html_Text)
        Code += '</p>'
        self.Html = Code
        return True
class Statement_Article_Plan (Append_Names_Statement):
    Gal_Keyword = 'article.plan'
    Gs_Keyword = 'article.plan'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Description = None
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Description = self.Listargs.pop(0)
    def Infer_Html(self):
        Name = str(self.Name)
        Title = str(Name)
        Title = Title.replace('_', ' ')
        Code = '<p>' + str(Title)
        if self.Description is not None:
            Code += ': ' + str(self.Description.Html_Text)
        Code += ' (future)</p>'
        self.Html = Code
        return True
class Statement_Atomic (Statement):
    Gal_Keyword = 'atomic'
    Gs_Keyword = 'atomic'
    def __init__(self):
        super().__init__()
        self.Source = None
        self.Target = None
    # comment 'atomic Gs_Code Atomic_Code;';
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Source')
        self.Source = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Target')
        self.Target = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Source = str(self.Source.Fallback)
        Target = str(self.Target.Fallback)
        Fallback_Generator.Example_Number += 1
        VN = Fallback_Generator.Example_Number
        Code = '''comment 'atomic ''' + str(Source) + ''' ''' + str(Target) + str('''';'''  +  '\n'  +  '''object Factory''') + str(VN) + str(''' new Translation_Factory;'''  +  '\n'  +  '''object Trans''') + str(VN) + ''' (Factory''' + str(VN) + str('''.Get_Translator 'goalspell' 'goalspell');'''  +  '\n'  +  '''dictionary Sources''') + str(VN) + str(''';'''  +  '\n'  +  '''forever'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    dict assign Sources''') + str(VN) + ''' ''' + str(Source) + str(''' [true];'''  +  '\n'  +  '''    [Trans''') + str(VN) + '''.Input Symbol_Value] = ''' + str(Source) + str(''';'''  +  '\n'  +  '''    [Trans''') + str(VN) + str('''.Output Symbol_Value] = '';'''  +  '\n'  +  '''    flag Status''') + str(VN) + ''' = (Trans''' + str(VN) + str('''.Initialize);'''  +  '\n'  +  '''    and Status''') + str(VN) + ''' (Trans''' + str(VN) + str('''.Run);'''  +  '\n'  +  '''    if (not Status''') + str(VN) + str(''') { error "Atomic Failed"; }'''  +  '\n'  +  '''    ''') + str(Target) + ''' = [Trans''' + str(VN) + str('''.Output Symbol_Value];'''  +  '\n'  +  '''    break if (dict exists Sources''') + str(VN) + ''' ''' + str(Target) + str(''');'''  +  '\n'  +  '''    ''') + str(Source) + ''' = ''' + str(Target) + str(''';'''  +  '\n'  +  '''}''')
        self.Fallback = Code
        return True
class Statement_Defined (Scoped_Statement):
    Gal_Keyword = 'defined'
    Gs_Keyword = 'defined'
    def __init__(self):
        super().__init__()
        self.Value_Reference = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value_Reference')
        self.Value_Reference = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Value_Js = str(self.Value_Reference.Javascript)
        Block_Js = str(self.Block.Javascript)
        zdebug.zbreak()
        return True
    def Infer_Python(self):
        Value_Python = str(self.Value_Reference.Python)
        Block_Python = str(self.Python_Block())
        zdebug.zbreak()
        return True
class Statement_Gal_Statement (Definition_Statement):
    Gal_Keyword = 'statement'
    Gs_Keyword = 'statement'
    Gal_Keyword = 'statement'
    Base_Class = 'Statement'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
        self.Ancestor = None
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Keyword')
        self.Keyword = self.Keywords.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Gal(self):
        Name = str(self.Name.Gal)
        Keyword = str(self.Keyword.Gal)
        Gal_Name = str(Name)
        Gs_Name = str(Name)
        if isinstance(Token_Quote, self.Keyword):
            Gal_Name = self.Keyword.Unquoted()
        else:
            Gs_Name = self.Enquote(Gs_Name)
        Gal_Name = Gal_Name.replace(' ', '.')
        Code = 'statement ' + str(Name) + ' ' + str(Keyword)
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gal)
        Code += str('\n') + '{' + str('\n') + str("    ") + 'property string Gal_Keyword ' + str(Gal_Name) + ';' + str('\n') + str("    ") + 'property string Gs_Keyword ' + str(Gs_Name) + ';' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Gal_Statements)
        Code += '}'
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Name = str(self.Name.Gs)
        Keyword = str(self.Keyword.Gs)
        Code = 'statement ' + str(Name) + ' ' + str(self.Enquote(Keyword))
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gs)
        Code += str(self.Gs_Block())
        self.Gs = Code
        return True
class Statement_Gs_Statement (Definition_Statement):
    Gal_Keyword = 'statement'
    Gs_Keyword = 'statement'
    Gal_Keyword = 'statement'
    Base_Class = 'Statement'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
        self.Ancestor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Keyword = None
        Ancestor = 'Statement'
        Argument_Statements = ''
        Attribute_Method = ''
        Statement = None
        Keyword = self.Keyword.Fallback
        if self.Ancestor is not None:
            Ancestor = self.Ancestor.Fallback  +  '_Statement'
        if self.Block is not None:
            for Statement in self.Block.Statements:
                if Statement.Fallback_Declaration is not None:
                    Argument_Statements += str(Statement.Fallback_Declaration)
            if str(Argument_Statements) > "":
                Argument_Statements = self.Indent(Argument_Statements)
                Attribute_Method += 'method void Attributes' + str('\n') + '{' + str('\n') + str(Argument_Statements) + '}' + str('\n')
                Attribute_Method = self.Indent(Attribute_Method)
        Code = 'class Statement_' + str(Name) + ' [is ' + str(Ancestor) + ']' + str('\n') + '{' + str('\n') + str("    ") + 'property string Keyword ' + str(Keyword) + ';' + str('\n') + str(Attribute_Method) + str(self.Fallback_Statements()) + '}'
        self.Fallback = Code
        return True
class Statement_Gal_Operation (Definition_Statement):
    Gal_Keyword = 'operation'
    Gs_Keyword = 'operation'
    Gal_Keyword = 'operation'
    Base_Class = 'Operation'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
        self.Ancestor = None
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Keyword')
        self.Keyword = self.Keywords.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Gal(self):
        Code = 'operation ' + str(self.Name.Gal) + ' ' + str(self.Keyword.Gal)
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gal)
        Code += str(self.Gal_Block())
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Code = 'operation ' + str(self.Name.Gs) + ' ' + str(self.Enquote(self.Keyword.Gs))
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gs)
        Code += str(self.Gs_Block())
        self.Gs = Code
        return True
class Statement_Gs_Operation (Definition_Statement):
    Gal_Keyword = 'operation'
    Gs_Keyword = 'operation'
    Gal_Keyword = 'operation'
    Base_Class = 'Operation'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
        self.Ancestor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Gs(self):
        Code = 'operation ' + str(self.Name.Gs) + ' ' + str(self.Keyword.Gs)
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gs)
        Code += str(self.Gs_Block())
        self.Gs = Code
        return True
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Keyword = None
        Ancestor = 'Operation'
        Keyword = self.Keyword.Fallback
        Argument_Statements = ''
        Attribute_Method = ''
        Statement = None
        if self.Ancestor is not None:
            Ancestor = self.Ancestor.Fallback  +  '_Operation'
        if self.Block is not None:
            for Statement in self.Block.Statements:
                if Statement.Fallback_Declaration is not None:
                    Argument_Statements += str(Statement.Fallback_Declaration)
            if str(Argument_Statements) > "":
                Argument_Statements = self.Indent(Argument_Statements)
                Attribute_Method += 'method void Attributes' + str('\n') + '{' + str('\n') + str(Argument_Statements) + '}' + str('\n')
                Attribute_Method = self.Indent(Attribute_Method)
        Code = 'class Operation_' + str(Name) + ' [is ' + str(Ancestor) + ']' + str('\n') + '{' + str('\n') + str("    ") + 'property string Keyword ' + str(Keyword) + ';' + str('\n') + str(Attribute_Method) + str(self.Fallback_Statements()) + '}'
        self.Fallback = Code
        return True
class Statement_Gal_Syntax (Definition_Statement):
    Gal_Keyword = 'syntax'
    Gs_Keyword = 'syntax'
    Gal_Keyword = 'syntax'
    Base_Class = 'Syntax'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
        self.Ancestor = None
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Keyword')
        self.Keyword = self.Keywords.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Gal(self):
        Code = 'syntax ' + str(self.Name.Gal) + ' ' + str(self.Keyword.Gal)
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gal)
        Code += str(self.Gal_Block())
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Code = 'syntax ' + str(self.Name.Gs) + ' ' + str(self.Enquote(self.Keyword.Gs))
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gs)
        Code += str(self.Gs_Block())
        self.Gs = Code
        return True
class Statement_Gs_Syntax (Definition_Statement):
    Gal_Keyword = 'syntax'
    Gs_Keyword = 'syntax'
    Gal_Keyword = 'syntax'
    Base_Class = 'Syntax'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
        self.Ancestor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Gs(self):
        Code = 'syntax ' + str(self.Name.Gs) + ' ' + str(self.Keyword.Gs)
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gs)
        Code += str(self.Gs_Block())
        self.Gs = Code
        return True
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Keyword = None
        Ancestor = 'Syntax'
        Keyword = self.Keyword.Fallback
        Argument_Statements = ''
        Attribute_Method = ''
        Statement = None
        if self.Ancestor is not None:
            Ancestor = self.Ancestor.Fallback  +  '_Syntax'
        if self.Block is not None:
            for Statement in self.Block.Statements:
                if Statement.Fallback_Declaration is not None:
                    Argument_Statements += str(Statement.Fallback_Declaration)
            if str(Argument_Statements) > "":
                Argument_Statements = self.Indent(Argument_Statements)
                Attribute_Method += 'method void Attributes' + str('\n') + '{' + str('\n') + str(Argument_Statements) + '}' + str('\n')
                Attribute_Method = self.Indent(Attribute_Method)
        Code = 'class Syntax_' + str(Name) + ' [is ' + str(Ancestor) + ']' + str('\n') + '{' + str('\n') + str("    ") + 'property string Keyword ' + str(Keyword) + ';' + str('\n') + str(Attribute_Method) + str(self.Fallback_Statements()) + '}'
        self.Fallback = Code
        return True
class Statement_Module (Scoped_Statement):
    Gal_Keyword = 'module'
    Gs_Keyword = 'module'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Variables = {}
    def Get_Module_Name(self):
        return self.Name.Get_Input()
    def Method_Context(self):
        return self
    def Infer_Mumps(self):
        Name = str(self.Name.Mumps)
        # comment 'TODO:Copy the module to the Mumps directory?';
        Code = str(Name) + str('\n') + str(Name) + ' ; ' + str(Name) + ' module.' + str('\n')
        Functions = []
        Stmt = None
        SC = None
        for Stmt in self.Block.Statements:
            if isinstance(Stmt, Statement_Function):
                Functions.extend([Stmt])
                continue
            SC = Stmt.Mumps
            Code += str(SC)
        Code += str("    ") + 'quit' + str('\n')
        for Stmt in Functions:
            SC = Stmt.Mumps
            Code += str(SC)
        Code += str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Name = str(self.Name.Mumps)
        # comment 'TODO:Copy the module to the Mumps directory?';
        Code = str(Name) + str('\n') + str(Name) + ' ; ' + str(Name) + ' module.' + str('\n')
        Functions = []
        Stmt = None
        SC = None
        for Stmt in self.Block.Statements:
            if isinstance(Stmt, Statement_Function):
                Functions.extend([Stmt])
                continue
            SC = Stmt.Mumps
            Code += str(SC)
        Code += str("    ") + 'quit' + str('\n')
        for Stmt in Functions:
            SC = Stmt.Mumps
            Code += str(SC)
        Code += str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Preamble = str(''''''  +  '\n'  +  '''class gal '''  +  '\n'  +  '''{ '''  +  '\n'  +  '''    constructor() { } '''  +  '\n'  +  '''    static backslash(Count=1) '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        return "\\\\".repeat(Count);'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    static file_append(filename, addtext)'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        gal.fs.appendFileSync(filename, addtext);'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    static file_exists(filename)'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        return gal.fs.existSync(filename);'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''}'''  +  '\n'  +  '''gal.fs = require("fs");'''  +  '\n'  +  '''gal.file_reader = require("fs");'''  +  '\n'  +  '''gal.read_file = function(File_Name) '''  +  '\n'  +  '''{'''  +  '\n'  +  '''    gal.file_reader.readFileSync(File_Name, 'utf8');'''  +  '\n'  +  '''};'''  +  '\n'  +  '''gal.write_file = function(File_Name, File_Text) '''  +  '\n'  +  '''{'''  +  '\n'  +  '''    gal.file_reader.writeFileSunc(File_Name, File_Text);'''  +  '\n'  +  '''}'''  +  '\n'  +  '''''')
        Code = ''
        Statement = None
        for Statement in self.Block.Statements:
            Code += str(Statement.Javascript)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Preamble = str('''#!/usr/bin/python'''  +  '\n'  +  ''''''  +  '\n'  +  '''# module ''') + str(self.Name.Python) + str(''''''  +  '\n'  +  ''''''  +  '\n'  +  '''import os'''  +  '\n'  +  '''import sys'''  +  '\n'  +  '''from Runtime import Runtime'''  +  '\n'  +  ''''''  +  '\n'  +  '''#INPUT = []'''  +  '\n'  +  '''#OUTPUT = ""'''  +  '\n'  +  ''''''  +  '\n'  +  '''''')
        Code = str(Preamble)
        Statement = None
        for Statement in self.Block.Statements:
            Code += str(Statement.Python) + str('\n')
        self.Python = Code
        return True
    def Infer_C(self):
        Name = str(self.Name.C)
        Includes = str(''''''  +  '\n'  +  '''#include <stdio.h>'''  +  '\n'  +  '''#include <stdlib.h>'''  +  '\n'  +  '''#include <math.h>'''  +  '\n'  +  '''#include <stdbool.h>'''  +  '\n'  +  '''#include <string.h>'''  +  '\n'  +  '''#include <time.h>'''  +  '\n'  +  '''''')
        # comment 'debug';
        # comment 'TODO:first get the declarations.';
        # comment 'TODO:then get the executables.';
        Code = str(self.C_Copyright()) + str(Includes) + str(self.Block.C_Lines)
        self.C = Code
        return True
    def Infer_Data_Types(self):
        self.Name.Data_Type = 'module'
        self.Name.Usage = 'module'
        return True
class Statement_Function (Method_Statement):
    Gal_Keyword = 'function'
    Gs_Keyword = 'function'
    def __init__(self):
        super().__init__()
        self.Return_Type = None
        self.Name = None
        self.Variables = {}
    def Method_Context(self):
        return self
    def Infer_Mumps(self):
        Verbose = False
        Return = str(self.Return_Type.Mumps)
        Name = str(self.Name.Mumps)
        Args = str(self.Mumps_Listargs())
        Block = str(self.Mumps_Block())
        Code = str(Name) + '(' + str(Args) + ') ; ' + str(Return) + str('\n') + str(Block) + str("    ") + 'quit' + str('\n')
        if Verbose:
            print("    function ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Return = str(self.Return_Type.Mumps)
        Name = str(self.Name.Mumps)
        Args = str(self.Mumps_Listargs())
        Block = str(self.Mumps_Block())
        Code = str(Name) + '(' + str(Args) + ') ; ' + str(Return) + str('\n') + str(Block) + str("    ") + 'quit' + str('\n')
        if Verbose:
            print("    function ", Code, sep='')
        self.Mumps = Code
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Return_Type')
        self.Return_Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'function ' + str(self.Name.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'def ' + str(self.Name.Python) + '(' + str(self.Python_Args(",")) + ')' + str(self.Python_Block())
        self.Python = Gen
        return True
    def Infer_C(self):
        Return = str(self.C_Type(self.Return_Type.C))
        Name = str(self.Name.C)
        Args = str(self.C_Args(', '))
        Block = str(self.C_Block())
        Code = str(Return) + ' ' + str(Name) + '(' + str(Args) + ')' + str(Block)
        self.C = Code
        return True
class Statement_Redirect (Method_Statement):
    Gal_Keyword = 'redirect'
    Gs_Keyword = 'redirect'
    def __init__(self):
        super().__init__()
        self.Return_Type = None
        self.Name = None
    def Infer_Mumps(self):
        Name = str(self.Name.Mumps)
        Args = str(self.Mumps_Listargs())
        Declaration = ''
        Arg = None
        for Arg in self.Listargs:
            if Arg.Mumps_Declaration is not None:
                Declaration += str(Arg.Mumps_Declaration)
        Type = str(self.Return_Type.Mumps)
        Block = str(self.Mumps_Block())
        Code = str(Name) + '(' + str(Args) + ') ; redirect ' + str(Type) + ' ' + str(Name) + str('\n') + str(Declaration) + str(Block) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Name = str(self.Name.Mumps)
        Args = str(self.Mumps_Listargs())
        Declaration = ''
        Arg = None
        for Arg in self.Listargs:
            if Arg.Mumps_Declaration is not None:
                Declaration += str(Arg.Mumps_Declaration)
        Type = str(self.Return_Type.Mumps)
        Block = str(self.Mumps_Block())
        Code = str(Name) + '(' + str(Args) + ') ; redirect ' + str(Type) + ' ' + str(Name) + str('\n') + str(Declaration) + str(Block) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Return_Type')
        self.Return_Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_C(self):
        Verbose = False
        Return = str(self.C_Type(self.Return_Type.C))
        Name = str(self.Name.C)
        Args = str(self.C_Args(', '))
        Statements = str(self.Block.C_Statements)
        Types = ''
        Call_Args = ''
        Arg = None
        Arg_Arg = None
        A = None
        T = None
        Between = ''
        for Arg in self.Listargs:
            A = Arg.Gs_Keyword
            T = self.C_Type(A)
            Types += str(Between) + str(T)
            Arg_Arg = Arg.Arguments[0]
            Call_Args += str(Between) + str(Arg_Arg.C)
            Between = ', '
        if Verbose:
            print("Redirect ", Name, " GSType ", self.Return_Type.C, " Ctype ", Return, sep='')
        Declaration = str(Return) + ' (*' + str(Name) + '_Implementer)(' + str(Types) + ') = NULL;' + str('\n')
        Invocation = '(*' + str(Name) + '_Implementer)(' + str(Call_Args) + ')'
        Redirection = 'if (' + str(Name) + '_Implementer != NULL && ' + str(Name) + '_Implementer != ' + str(Name) + ')' + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + 'return ' + str(Invocation) + ';' + str('\n') + str("    ") + '}' + str('\n')
        if str(Name) != str(C.Behavior):
            Declaration = ''
            Redirection = ''
        Code = str('\n') + str(Declaration) + str(Return) + ' ' + str(Name) + '(' + str(Args) + ')' + str('\n') + '{' + str('\n') + str(Redirection) + str(Statements) + '}'
        self.C = Code
        return True
class Statement_Redirect_To (Line_Statement):
    Gal_Keyword = 'redirect.to'
    Gs_Keyword = 'redirect.to'
    def __init__(self):
        super().__init__()
        self.Url = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Url')
        self.Url = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'window.location.replace(' + str(self.Url.Javascript) + ')'
        self.Javascript = Gen
        return True
class Statement_Function_Pointer (Scoped_Statement):
    Gal_Keyword = 'function.pointer'
    Gs_Keyword = 'function.pointer'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_C(self):
        Verbose = True
        Between = ''
        Word = None
        Arglist = ''
        Rtype = ''
        for Word in self.Gs_Keywords:
            if ' '  +  Word  +  ' ' in ' implementers fptr ':
                continue
            Word = self.C_Type(Word)
            if (Rtype in (None, "")):
                Rtype = Word
            else:
                Arglist += str(Between) + str(Word)
                Between = ', '
        Name = str(self.Name.C)
        Code = str(Rtype) + '(*' + str(Name) + ')(' + str(Arglist) + ') = NULL;'
        self.C = Code
        return True
class Statement_Include (Line_Statement):
    Gal_Keyword = 'include'
    Gs_Keyword = 'include'
    def __init__(self):
        super().__init__()
        self.File_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
    def Infer_Gs(self):
        File_Name = str(self.File_Name.Unquoted())
        if not "." in File_Name:
            File_Name += ".gs"
        File_Text = None
        _FH = open(File_Name, "r")
        File_Text = _FH.read()
        _FH.close()
        Code = str(File_Text)
        self.Gs = Code
        return True
    def Infer_Data_Types(self):
        self.File_Name.Data_Type = 'module'
        self.File_Name.Usage = 'module'
        return True
class Statement_Constant (Line_Statement):
    Gal_Keyword = 'constant'
    Gs_Keyword = 'constant'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Value = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_C(self):
        Gen = '#define ' + str(self.C_Arguments(' '))
        self.C = Gen
        return True
    def Infer_Data_Types(self):
        Type = str(self.Type.Input)
        self.Name.Data_Type = Type
        self.Name.Usage = 'constant'
        self.Value.Data_Type = Type
        return True
class Statement_Global (Line_Statement):
    Gal_Keyword = 'global'
    Gs_Keyword = 'global'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Value = None
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Data_Types(self):
        Type = str(self.Type.Input)
        self.Name.Data_Type = Type
        self.Value.Data_Type = Type
        return True
class Statement_Exit (Line_Statement):
    Gal_Keyword = 'exit'
    Gs_Keyword = 'exit'
    def __init__(self):
        super().__init__()
        self.Return_Value = None
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Return_Value = self.Listargs.pop(0)
    def Infer_Data_Types(self):
        if self.Return_Value is not None:
            self.Return_Value.Data_Type = 'integer'
        return True
class Statement_Speaking (Line_Statement):
    Gal_Keyword = 'speaking'
    Gs_Keyword = 'speaking'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Verbose = True
        zdebug.zbreak()
        if Verbose:
            print('speaking statement generation')
        return True
class Statement_Author (Line_Statement):
    Gal_Keyword = 'author'
    Gs_Keyword = 'author'
    Gal_Keyword = 'author'
    Gs_Keyword = 'author'
    def Attributes(self):
        pass
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<h4>by ' + str(self.Html_Arguments_Text()) + str(self.Html_Block_Text()) + '</h4>'
        self.Html_Text = Code
        self.Html = Code
        return True
    def Infer_Fallback(self):
        Gen = 'comment Author:' + str(self.Fallback_Arguments()) + ';'
        self.Fallback = Gen
        return True
class Statement_Document (Scoped_Statement):
    Gal_Keyword = 'document'
    Gs_Keyword = 'document'
    def Attributes(self):
        pass
class Statement_Title (Feature_Statement):
    Gal_Keyword = 'title'
    Gs_Keyword = 'title'
    Gal_Keyword = 'title'
    Gs_Keyword = 'title'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Title'
        self.Value = None
    def Attributes(self):
        pass
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Html(self):
        Code = '<h1>' + str(self.Html_Arguments_Text()) + str(self.Html_Block_Text()) + '</h1>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Subtitle (Line_Statement):
    Gal_Keyword = 'subtitle'
    Gs_Keyword = 'subtitle'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<h3>' + str(self.Html_Arguments_Text()) + str(self.Html_Block_Text()) + '</h3>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Chapter (Scoped_Statement):
    Gal_Keyword = 'chapter'
    Gs_Keyword = 'chapter'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<h2>' + str(self.Html_Arguments_Text()) + '</h2>' + str(self.Html_Block_Text())
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Section (Scoped_Statement):
    Gal_Keyword = 'section'
    Gs_Keyword = 'section'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<h3>' + str(self.Html_Arguments_Text()) + '</h3>' + str(self.Html_Block_Text())
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Paragraph (Scoped_Statement):
    Gal_Keyword = 'paragraph'
    Gs_Keyword = 'paragraph'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<p>' + str(self.Html_Arguments_Text()) + str('\n') + str(self.Html_Block_Text()) + '</p>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Codebox (Scoped_Statement):
    Gal_Keyword = 'codebox'
    Gs_Keyword = 'codebox'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Html(self):
        Name = str(self.Name.Html_Text)
        Block = str(self.Block.Html)
        Starting_Code = ''
        if len(self.Block.Statements) > 0:
            First = self.Block.Statements[0]
            Starting_Code = First.Html_Text
        Code = '''<div>''' + str(Block) + '''<div class="codebox" id="''' + str(Name) + '">' + str(Starting_Code) + '</div>' + '</div>'
        self.Html_Text = Code
        self.Html = Code
        return True
    def Infer_Structure(self):
        Name = str(self.Name.Get_Input())
        Statement = None
        for Statement in self.Block.Statements:
            Statement.Parent_Name = Name
        return True
        return True
class Statement_Example (Scoped_Statement):
    Gal_Keyword = 'example'
    Gs_Keyword = 'example'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Verbose = True
        Error_Status = True
        Text = ''
        Argument = None
        for Argument in self.Listargs:
            Text += str(Argument.Unquoted())
        if self.Block is not None:
            Text += str(self.Block.Gs_Statements)
        Trans = Translator()
        Trans.Input.Symbol_Value = Text
        Trans.Parser = Gs_Parser(Trans)
        Trans.Generator = Gs_Generator(Trans)
        Status = Trans.Initialize()
        if not Status:
            self.Error = 'Error intiailizing Goalspell Translator'
            return False
        Status = Trans.Parser.Infer()
        if not Status:
            self.Error = Trans.Parser.Error_Report()
            if Verbose:
                print(self.Error)
            return False
        Trans.Generator.Elements = Trans.Parser.Elements
        Status = Trans.Generator.Infer()
        Gs = str(Trans.Generator.Code)
        if not Status:
            return True
        if Verbose:
            print('gs ', Gs, sep='')
        Fallback = str(Gs)
        Fb_Gen = Fallback_Generator(Trans)
        Fb_Gen.Elements = Trans.Parser.Elements
        Status = Fb_Gen.Initialize()
        Status = Fb_Gen.Infer()
        if not Status:
            zdebug.zbreak()
        Fallback = str(Fb_Gen.Code)
        if Verbose:
            print('fallback ', Fallback, sep='')
        Atomic = str(Fallback)
        if str(self.Minify(Fallback)) != str(self.Minify(Gs)):
            Atomic_Trans = Translator()
            Atomic_Trans.Input.Symbol_Value = Fallback
            Atomic_Trans.Parser = Gs_Parser(Atomic_Trans)
            Atomic_Trans.Generator = Fallback_Generator(Atomic_Trans)
            Status = Atomic_Trans.Initialize()
            if not Status:
                raise Exception('Error intiailizing Atomic Translator')
            try:
                Status = Atomic_Trans.Parser.Infer()
            except Exception as Error:
                zdebug.zbreak()
                print("Error '", Error, "' parsing Fallback Code: ", Fallback, sep='')
                Status = False
            if not Status:
                raise Exception(str(Atomic_Trans.Parser.Error_Report()))
            Atomic_Trans.Generator.Elements = Atomic_Trans.Parser.Elements
            Status = Atomic_Trans.Generator.Infer()
            Atomic = Atomic_Trans.Generator.Code
            if Verbose:
                print('atomic ', Atomic, sep='')
        Python = ''
        Javascript = ''
        Mumps = ''
        PHP = ''
        Raku = ''
        if Status:
            Py_Trans = Translator()
            Py_Trans.Input.Symbol_Value = Atomic
            Py_Trans.Parser = Gs_Parser(Py_Trans)
            Py_Trans.Generator = Python_Generator(Py_Trans)
            Status = Py_Trans.Initialize()
            if not Status:
                zdebug.zbreak()
            Status = Py_Trans.Parser.Infer()
            if Status or Error_Status:
                Python = Py_Trans.Parser.Error_Report()
            else:
                if "\\" in Python:
                    Python = Python.replace("\\", '&#92;')
        if Status:
            Py_Trans.Generator.Elements = Py_Trans.Parser.Elements
            Status = Py_Trans.Generator.Infer()
            # comment 'if (not Status)';
            Python = Py_Trans.Generator.Code
            if Verbose:
                print('python ', Python, sep='')
            Js_Gen = Javascript_Generator(Py_Trans)
            Js_Gen.Elements = Py_Trans.Parser.Elements
            Status = Js_Gen.Initialize()
            if not Status:
                zdebug.zbreak()
            Status = Js_Gen.Infer()
            # comment 'if (not Status)';
            if Status or Error_Status:
                Javascript = Js_Gen.Code
            else:
                if "\\" in Javascript:
                    Javascript = Javascript.replace("\\", '&#92;')
            if Verbose:
                print('javascript ', Javascript, sep='')
            # comment "(append `` [line] `                entity.new PHP_Gen PHP_Generator Py_Trans;` [line] `                .= PHP_Gen Elements [. Py_Trans Parser Elements];` [line] `                = Status (. PHP_Gen Initialize);` [line] `                if (not Status) { debug; }` [line] `                = Status (. PHP_Gen Infer);` [line] `                comment if (not Status) { debug; }` [line] `				if (or Status Error_Status)` [line] `				{` [line] `	                = PHP [. PHP_Gen Code];` [line] `				}` [line] `                verbose 'php ' PHP;` [line] ``)";
            # comment "(append `` [line] `                entity.new Raku_Gen Raku_Generator Py_Trans;` [line] `                .= Raku_Gen Elements [. Py_Trans Parser Elements];` [line] `                = Status (. Raku_Gen Initialize);` [line] `                if (not Status) { debug; }` [line] `                = Status (. Raku_Gen Infer);` [line] `                comment if (not Status) { debug; }` [line] `				if (or Status Error_Status)` [line] `				{` [line] `   		            = Raku [. Raku_Gen Code];` [line] `				}` [line] `                verbose 'raku ' Raku;` [line] ``)";
            M_Gen = Mumps_Generator(Py_Trans)
            M_Gen.Elements = Py_Trans.Parser.Elements
            Status = M_Gen.Initialize()
            if not Status:
                zdebug.zbreak()
            Status = M_Gen.Infer()
            # comment 'if (not Status)';
            if Status or Error_Status:
                Mumps = M_Gen.Code
            if Verbose:
                print('mumps ', Mumps, sep='')
        Panes = 'pane "goalspell" ' + str(self.Line_String(Gs)) + ';' + str('\n')
        if str(self.Minify(Gs)) != str(self.Minify(Fallback)):
            Panes += 'pane "fallback" ' + str(self.Line_String(Fallback)) + ';' + str('\n')
            if str(self.Minify(Fallback)) != str(self.Minify(Atomic)):
                Panes += 'pane "atomic" ' + str(self.Line_String(Atomic)) + ';' + str('\n')
        if str(Python) > '':
            Panes += 'pane "Python" ' + str(self.Line_String(Python)) + ';' + str('\n')
        if str(Javascript) > '':
            Panes += 'pane "Javascript" ' + str(self.Line_String(Javascript)) + ';' + str('\n')
        if str(PHP) > '':
            Panes += 'pane "PHP" ' + str(self.Line_String(PHP)) + ';' + str('\n')
        if str(Raku) > '':
            Panes += 'pane "Raku" ' + str(self.Line_String(Raku)) + ';' + str('\n')
        if str(Mumps) > '':
            Panes += 'pane "MUMPS" ' + str(self.Line_String(Mumps)) + ';' + str('\n')
        Example_Name = str(Fallback_Generator.Next_Example())
        Code = 'code box ' + str(Example_Name) + str('\n') + '{' + str('\n') + str(Panes) + '}'
        self.Fallback = Code
        return True
class Statement_Pane (Line_Statement):
    Gal_Keyword = 'pane'
    Gs_Keyword = 'pane'
    def __init__(self):
        super().__init__()
        self.Selection = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Selection')
        self.Selection = self.Listargs.pop(0)
    def Infer_Html(self):
        Inner_Text = ''
        Arg = None
        for Arg in self.Listargs:
            Inner_Text += str(Arg.Html_Text)
        # comment '= Inner_Text (i Js_Enquote Inner_Text)';
        Inner_Quoted = str(self.Js_Enquote(Inner_Text))
        Parent_Name = str(self.Js_Enquote(self.Parent_Name))
        Handler = 'code_box(' + str(Parent_Name) + ',' + str(Inner_Quoted) + ');'
        # comment '= Handler (i Js_Enquote Handler)';
        Html_Generator.Entity_Number += 1
        Button_Name = 'Button_' + str(Html_Generator.Entity_Number)
        Code = '''<button id=''' + str(self.Html_Enquote(Button_Name)) + '''>''' + str(self.Selection.Html_Text) + '</button>'
        Code += '<script>document.getElementById(' + str(self.Js_Enquote(Button_Name)) + ').addEventListener("click", function() { ' + str(Handler) + ' });</script>'
        self.Html_Text = Inner_Text
        self.Html = Code
        return True
class Statement_Diagram (Line_Statement):
    Gal_Keyword = 'diagram'
    Gs_Keyword = 'diagram'
    def __init__(self):
        super().__init__()
        self.File_Name = None
        self.Width = None
        self.Height = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Width = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Height = self.Listargs.pop(0)
    def Infer_Html(self):
        File = str(self.File_Name.Html_Text)
        Height = str(self.Height.Html_Text)
        Width = str(self.Width.Html_Text)
        Code = '''<img src=''' + str(File) + ''' height=''' + str(Height) + ''' width=''' + str(Width) + '''>'''
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Numbered_List (Scoped_Statement):
    Gal_Keyword = 'numbered.list'
    Gs_Keyword = 'numbered.list'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<ol>' + str(self.Html_Arguments_Text()) + str(self.Html_Block_Text()) + '</ol>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_List_Item (Line_Statement):
    Gal_Keyword = 'list.item'
    Gs_Keyword = 'list.item'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Items = str(self.Html_Arguments_Text()) + str(self.Html_Block_Text())
        Code = '<li>' + str(Items) + '</li>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Terminology (Scoped_Statement):
    Gal_Keyword = 'terminology'
    Gs_Keyword = 'terminology'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<table>' + str(self.Html_Block_Text()) + '</table>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Term (Line_Statement):
    Gal_Keyword = 'term'
    Gs_Keyword = 'term'
    def __init__(self):
        super().__init__()
        self.Word = None
        self.Definition = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Word')
        self.Word = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Definition')
        self.Definition = self.Listargs.pop(0)
    def Infer_Html(self):
        Word = str(self.Word.Html_Text)
        Definition = str(self.Definition.Html_Text)
        Code = '<tr><th>' + str(Word) + '</th><td>' + str(Definition) + '</td></tr>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Note (Line_Statement):
    Gal_Keyword = 'note'
    Gs_Keyword = 'note'
    def Attributes(self):
        pass
    def Infer_Html(self):
        Code = '<div class="note">' + str(self.Html_Arguments_Text()) + '</div>'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Ingredients (Scoped_Statement):
    Gal_Keyword = 'ingredients'
    Gs_Keyword = 'ingredients'
    Gal_Keyword = 'ingredients'
    Gal_Keyword = 'ingredients'
    Gs_Keyword = 'ingredients'
    Gs_Keyword = 'ingredients'
    def Fallback_Generate(self):
        Gal_Code = 'hello'
        self.Fallback = Gal_Code
    def Fallback_Generate(self):
        Gal_Code = 'hello'
        self.Fallback = Gal_Code
    def Attributes(self):
        return True
    def Attributes(self):
        return True
    def Attributes(self):
        pass
class Statement_Steps (Scoped_Statement):
    Gal_Keyword = 'steps'
    Gs_Keyword = 'steps'
    def Attributes(self):
        pass
class Statement_Recipe (Scoped_Statement):
    Gal_Keyword = 'recipe'
    Gs_Keyword = 'recipe'
    Gal_Keyword = 'recipe'
    Gal_Keyword = 'recipe'
    Gs_Keyword = 'recipe'
    Gs_Keyword = 'recipe'
    def __init__(self):
        super().__init__()
        self.Thing_Type = 'Thing_Recipe'
        self.Thing_Type = 'Thing_Recipe'
        self.Name = Argument(self)
        self.Name = Argument(self)
        self.Text = None
        self.Text = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
        return True
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
        return True
    def Attributes(self):
        pass
class Statement_Menu_Bar (Scoped_Statement):
    Gal_Keyword = 'menu_bar'
    Gs_Keyword = 'menu_bar'
    def __init__(self):
        super().__init__()
        self.Title = None
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Title')
        self.Title = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Name = self.Listargs.pop(0)
    def Infer_Html(self):
        # comment 'debug';
        Code = str('\n') + '<!-- Menu Bar: ' + str(self.Title.Html_Text) + '-->' + str('\n') + str(self.Html_Block_Text()) + '<!-- End of menu bar: ' + str(self.Title.Html_Text) + '-->' + str('\n')
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Menu_Dropdown (Scoped_Statement):
    Gal_Keyword = 'menu_dropdown'
    Gs_Keyword = 'menu_dropdown'
    def __init__(self):
        super().__init__()
        self.Title = None
        self.Document = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Title')
        self.Title = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Document = self.Listargs.pop(0)
    def Infer_Html(self):
        Block_Code = str(self.Html_Block_Text())
        Menu_Text = str(self.Title.Html_Text)
        if self.Document is not None:
            Url = str(self.Html_Url(self.Document))
            Menu_Text = '<a href="'  +  Url  +  '">'  +  Menu_Text  +  '</a>'
        Inner_Code = '<div class="dropbtn">' + str(Menu_Text) + '</div>' + str('\n') + '<div class="dropdown-content">' + str('\n') + str(self.Indent(Block_Code)) + '</div>' + str('\n')
        Code = '<div class="dropdown">' + str('\n') + str("    ") + str(self.Indent(Inner_Code)) + '</div>' + str('\n')
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Menu_Item (Line_Statement):
    Gal_Keyword = 'menu_item'
    Gs_Keyword = 'menu_item'
    def __init__(self):
        super().__init__()
        self.Title = None
        self.Document = None
        self.Url = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Title')
        self.Title = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Document = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Url = self.Listargs.pop(0)
    def Infer_Html(self):
        # comment 'debug';
        Title = str(self.Title.Html_Text)
        Url = '#'
        if self.Url is not None:
            Url = self.Html_Url(self.Url)
        elif self.Document is not None:
            Url = self.Html_Url(self.Document)
        Code = '<a href="' + str(Url) + '">' + str(Title) + '</a>' + str('\n')
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Document_Reference (Scoped_Statement):
    Gal_Keyword = 'document_reference'
    Gs_Keyword = 'document_reference'
    def __init__(self):
        super().__init__()
        self.Document = None
        self.Title = None
        self.Url = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Document')
        self.Document = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Title')
        self.Title = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Url = self.Listargs.pop(0)
    def Infer_Html(self):
        Code = '<!-- reference document ' + str(self.Document.Html_Text) + ', ' + str(self.Title.Html_Text) + ' -->'
        self.Html_Text = Code
        self.Html = Code
        return True
class Statement_Site (Scoped_Statement):
    Gal_Keyword = 'site'
    Gs_Keyword = 'site'
    def __init__(self):
        super().__init__()
        self.Document = None
        self.Title = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Document')
        self.Document = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Title')
        self.Title = self.Listargs.pop(0)
class Statement_Action (Scoped_Statement):
    Gal_Keyword = 'action'
    Gs_Keyword = 'action'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Class_Name = None
        self.Parent_Class = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " void variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " void variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Parent_Class = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Type = str(self.Type.Fallback)
        Name = str(self.Class_Name.Fallback)
        Parent_Class = "Action"
        if self.Parent_Class is not None:
            Parent_Class = self.Parent_Class.Fallback
        Block = ''
        if self.Block is not None:
            Block = self.Block.Fallback_Statements
        Code = 'class Action_' + str(Name) + ' [is ' + str(Parent_Class) + ']' + str('\n') + '{' + str('\n') + str("    ") + 'property object Symbol_Object;' + str('\n') + str("    ") + 'constructor [object Object]' + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + 'my Symbol_Object = Object;' + str('\n') + str("    ") + '}' + str('\n') + str(Block) + '}'
        self.Fallback = Code
        return True
class Statement_Add (Line_Statement):
    Gal_Keyword = 'add'
    Gs_Keyword = 'add'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Variable)
        Arg = None
        for Arg in self.Listargs:
            Code += '+' + str(Arg.Matom())
        Code += str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Variable)
        Arg = None
        for Arg in self.Listargs:
            Code += '+' + str(Arg.Matom())
        Code += str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = str(self.Variable.Gs) + ' +=' + str(self.Gs_Listargs()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' += ' + str(self.Javascript_Args(' + ')) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' += ' + str(self.Python_Args(' + '))
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Variable.C) + ' += ' + str(self.C_Args(' + ')) + ';'
        self.C = Gen
        return True
class Statement_Alert (Line_Statement):
    Gal_Keyword = 'alert'
    Gs_Keyword = 'alert'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'alert(' + str(self.Javascript_Arguments(", ")) + ')'
        self.Javascript = Gen
        return True
class Statement_Alpha (Scoped_Statement):
    Gal_Keyword = 'alpha'
    Gs_Keyword = 'alpha'
    def __init__(self):
        super().__init__()
        self.Identifier = None
        self.Performance = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Identifier')
        self.Identifier = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Performance = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Identifier = str(self.Identifier.Fallback)
        Performance = str(self.Performance.Fallback)
        Code = '''Al = (Alpha:Lookup ''' + str(Identifier) + str(''');'''  +  '\n'  +  '''Al.Performance = ''') + str(Performance) + str(''';'''  +  '\n'  +  '''Ros.Alpha = Al;''')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        self.Fallback = Code
        return True
class Statement_Amount (Scoped_Statement):
    Gal_Keyword = 'amount'
    Gs_Keyword = 'amount'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Quote_Name = str(self.Enquote(Name))
        Keyword = str(self.Keyword.Fallback)
        Symbol_Code = 'symbol number ' + str(Name) + ' Amount;'
        Attribute_Code = 'property number ' + str(Name) + ' ' + str(Name) + ';'
        Statement_Code = 'statement ' + str(Name) + " " + str(Keyword) + " Amount" + str('\n') + '{' + str('\n') + str("    ") + 'property string Property_Name ' + str(Quote_Name) + ';' + str('\n') + str("    ") + 'argument Amount;' + str('\n') + str("    ") + 'keyword Unit;' + str('\n') + '}'
        Code = str(Symbol_Code) + str('\n') + str(Statement_Code)
        # comment 'TODO:Attribute code is a property!';
        self.Fallback = Code
        return True
class Statement_Analysis (Scoped_Statement):
    Gal_Keyword = 'analysis'
    Gs_Keyword = 'analysis'
    def Attributes(self):
        pass
class Statement_Analyze (Scoped_Statement):
    Gal_Keyword = 'analyze'
    Gs_Keyword = 'analyze'
    def __init__(self):
        super().__init__()
        self.Behavior = None
        self.Test = None
        self.Map = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Behavior')
        self.Behavior = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Test')
        self.Test = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Map')
        self.Map = self.Listargs.pop(0)
    def Infer_C(self):
        Beh = str(self.Behavior.C)
        Tst = str(self.Test.C)
        Map = str(self.Map.C)
        C.Behavior = Beh
        C.Test = Tst
        C.Map = Map
        Code = '// ANALYZE ' + str(Map) + ' redirect ' + str(Beh) + ' with ' + str(Tst) + str('\n')
        self.C = Code
        return True
class Statement_And (Line_Statement):
    Gal_Keyword = 'and'
    Gs_Keyword = 'and'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'and' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = str(self.Variable.Gs) + ' &=' + str(self.Gs_Listargs()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' &= ' + str(self.Javascript_Args(' && ')) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' &= ' + str(self.Python_Args(' && '))
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Variable.C) + ' &= ' + str(self.C_Args(' && ')) + ';'
        self.C = Gen
        return True
class Statement_Append (Append_Args_Statement):
    Gal_Keyword = 'append'
    Gs_Keyword = 'append'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Variable)
        Arg = None
        for Arg in self.Listargs:
            Code += '_' + str(Arg.Matom())
        Code += str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Variable)
        Arg = None
        for Arg in self.Listargs:
            Code += '_' + str(Arg.Matom())
        Code += str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' += ' + str(self.Javascript_Args(' + ')) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' += ' + str(self.Python_Args(' + '))
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Variable.C) + ' += ' + str(self.C_Args(' + ')) + ';'
        self.C = Gen
        return True
class Statement_Append_Token (Line_Statement):
    Gal_Keyword = 'append.token'
    Gs_Keyword = 'append.token'
    def __init__(self):
        super().__init__()
        self.Mode = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Mode')
        self.Mode = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Mode = str(self.Mode.Fallback)
        Code = 'token append T Char ' + str(Mode) + ';'
        self.Fallback = Code
        return True
class Statement_Argument (Argument_Statement):
    Gal_Keyword = 'argument'
    Gs_Keyword = 'argument'
    def __init__(self):
        super().__init__()
        self.Argument_Name = None
        self.Type_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Argument_Name')
        self.Argument_Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Type_Value = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Argument_Name = str(self.Argument_Name.Fallback)
        Code = 'property object ' + str(Argument_Name) + ';'
        Declaration = "if ((llength [my Listargs]) = 0)" + str('\n') + "{" + str('\n') + str("    ") + "error 'missing required argument " + str(Argument_Name) + "';" + str('\n') + "}" + str('\n') + 'my ' + str(Argument_Name) + ' = (shift [my Listargs]);' + str('\n')
        if self.Type_Value is not None:
            Declaration += '[my ' + str(Argument_Name) + ' Usage] = ' + str(self.Type_Value.Fallback) + ';' + str('\n')
        self.Fallback_Declaration = Declaration
        self.Fallback = Code
        return True
class Statement_Array (Statement):
    Gal_Keyword = 'array'
    Gs_Keyword = 'array'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_C(self):
        Type = "float"
        Name = str(self.Name.C)
        Indexes = ''
        Index_Between = ''
        Inits = ''
        I = ''
        Inits_Between = ''
        Arg = None
        for Arg in self.Listargs:
            Indexes += str(Index_Between) + str(Arg.C)
            Index_Between = ']['
        Code = str(Type) + ' ' + str(Name) + '[' + str(Indexes) + ']'
        Code += ';'
        self.C = Code
        return True
class Statement_Array_Of (Statement):
    Gal_Keyword = 'array.of'
    Gs_Keyword = 'array.of'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Class = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
    def Infer_C(self):
        Class = str(self.Class.C)
        Name = str(self.Name.C)
        Code = str(self.C_Type(Class)) + ' ' + str(Name) + '['
        if len(self.Listargs) > 0:
            Code += str(self.C_Args(']['))
        Code += ']'
        if self.Block is not None:
            Code += ' = {'
            Stmt = None
            Between = ''
            for Statement in self.Block.Statements:
                Code += str(Between) + str('\n') + str("    ") + str(Statement.C)
                Between = ','
            Code += str('\n') + '}'
        Code += ';'
        self.C = Code
        return True
class Statement_Array_Number (Statement):
    Gal_Keyword = 'array.number'
    Gs_Keyword = 'array.number'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Size = None
    def Infer_Mumps(self):
        Verbose = True
        Name = str(self.Name.Mumps)
        Size = str(self.Size.Mumps)
        Lname = 'l' + str(Name)
        Length = str(len(self.Listargs))
        Code = str("    ") + 'new ' + str(Name) + ' set ' + str(Name) + '=' + str(Length) + str('\n')
        Node = 0
        Arg = None
        for Arg in self.Listargs:
            Node += 1
            Code += str("    ") + 'set ' + str(Name) + '(' + str(Node) + ')=' + str(Arg.Mumps) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        Name = str(self.Name.Mumps)
        Size = str(self.Size.Mumps)
        Lname = 'l' + str(Name)
        Length = str(len(self.Listargs))
        Code = str("    ") + 'new ' + str(Name) + ' set ' + str(Name) + '=' + str(Length) + str('\n')
        Node = 0
        Arg = None
        for Arg in self.Listargs:
            Node += 1
            Code += str("    ") + 'set ' + str(Name) + '(' + str(Node) + ')=' + str(Arg.Mumps) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Size')
        self.Size = self.Listargs.pop(0)
    def Infer_C(self):
        Type = 'float'
        Name = str(self.Name.C)
        Size = str(self.Size.C)
        Inits = ''
        I = ''
        Inits_Between = ''
        Arg = None
        for Arg in self.Listargs:
            if isinstance(Arg, Syntax_Array):
                I += str(Inits_Between) + str(Arg.C)
                Inits += str(Inits_Between) + str(Arg.C)
                if len(I) > 80:
                    Inits += str('\n')
                    I = ""
                Inits_Between = ', '
            elif isinstance(Arg, Token):
                I += str(Inits_Between) + str(Arg.C)
                Inits += str(Inits_Between) + str(Arg.C)
                if len(I) > 80:
                    Inits += str('\n') + str("    ")
                    I = ""
                Inits_Between = ', '
            else:
                zdebug.zbreak()
                # comment 'TODO:what kind of argument got passed to statement_array, and how do we handle it?';
        Code = '#define top_' + str(Name) + ' ' + str(Size) + str('\n') + str(Type) + ' ' + str(Name) + '[top_' + str(Name) + ']'
        if (Inits is not None and str(Inits) > ""):
            Code += ' = {' + str('\n') + str("    ") + '  ' + str(Inits) + '}'
        Code += ';'
        self.C = Code
        return True
class Statement_Assign (Line_Statement):
    Gal_Keyword = '='
    Gs_Keyword = '='
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Value) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Value) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = str(self.Variable.Gs) + ' = ' + str(self.Value.Gs) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' = ' + str(self.Value.Javascript) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' = ' + str(self.Value.Python)
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Variable.C) + ' = ' + str(self.Value.C) + ';'
        self.C = Gen
        return True
    def Infer_Fallback(self):
        Gen = str(self.Variable.Fallback) + ' = ' + str(self.Value.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_Async_Method (Method_Statement):
    Gal_Keyword = 'async.method'
    Gs_Keyword = 'async.method'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'async ' + str(self.Name.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
class Statement_Attribute (Line_Statement):
    Gal_Keyword = 'attribute'
    Gs_Keyword = 'attribute'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Property_Name = None
        self.Value = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property_Name')
        self.Property_Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Property_Fallback = str(self.Property_Name.Fallback)
        Type_Fallback = str(self.Type.Fallback)
        Ancestor_Fallback = 'Symbol'
        Class_Fallback = str(Type_Fallback[0].upper()) + str(Type_Fallback[1:])
        Value_Code = '(new ' + str(Class_Fallback) + " [self]"
        if self.Value is not None:
            Value = self.Value
            if isinstance(Value, Name_Token):
                Value_Code = '(new '  +  Value.Fallback  +  " [self]"
            elif isinstance(Value, Atomic_Token):
                Value_Code += ' ' + str(self.Value.Fallback)
            else:
                zdebug.zbreak()
        Value_Code += ');'
        Code = 'property object ' + str(Property_Fallback) + ' ' + str(Value_Code)
        self.Fallback = Code
        return True
class Statement_Behavior (Behavior_Statement):
    Gal_Keyword = 'behavior'
    Gs_Keyword = 'behavior'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Behavior_Name = None
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Behavior_Name')
        self.Behavior_Name = self.Listargs.pop(0)
    def Infer_Gs(self):
        Code = str(self.Gs_Key()) + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Code
        return True
    def Infer_Fallback(self):
        Class_Context = self.Get_Class_Context()
        Class_Name = str(Class_Context.Name.Get_Input())
        Behavior_Name = str(self.Behavior_Name.Get_Input())
        Entity_Behavior_Class = "Behavior_" + str(Class_Name) + '_' + str(Behavior_Name)
        Type = str(self.Type.Fallback)
        Ancestor = 'Behavior'
        Args = str(self.Fallback_Args())
        Call_Args = ''
        Arg = None
        ArgArg = None
        for Arg in self.Listargs:
            ArgArg = Arg.Arguments[0]
            Call_Args += ' ' + str(ArgArg.Fallback)
        Entity_Return = str(Entity_Behavior_Class) + ':Execute [self]' + str(Call_Args)
        Behavior_Return = '[our Implementer].Execute [self]' + str(Call_Args)
        if str(Type) == 'void':
            Entity_Return += ";"
            Behavior_Return += ";"
        else:
            Entity_Return = 'return ('  +  Entity_Return  +  ');'
            Behavior_Return = 'return ('  +  Behavior_Return  +  ');'
        Behavior_Statements = str("    ") + 'if (defined [our Implementer])' + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + str(Behavior_Return) + str('\n') + str("    ") + '}' + str('\n')
        if self.Block is not None and self.Block.Fallback_Statements is not None:
            Behavior_Statements += str(self.Block.Fallback_Statements)
        else:
            Behavior_Statements += str("    ") + 'error "' + str(Behavior_Name) + ' implementer not defined.";' + str('\n')
        Method = 'method ' + str(Type) + ' ' + str(Behavior_Name) + str(self.Fallback_Args()) + str('\n') + '{' + str('\n') + str("    ") + str(Entity_Return) + str('\n') + '}'
        Behavior_Code = 'class ' + str(Entity_Behavior_Class) + ' [is Behavior]' + str('\n') + '{' + str('\n') + str("    ") + 'class property object Implementer;' + str('\n') + str("    ") + 'class property string Data_Type "' + str(Type) + '";' + str('\n') + str("    ") + 'class property object Roster (new Roster);' + str('\n') + str("    ") + 'class method ' + str(Type) + ' Execute [object Owner]' + str(self.Fallback_Args()) + str('\n') + str("    ") + '{' + str('\n') + str(self.Indent(Behavior_Statements)) + str("    ") + '}' + str('\n') + '}' + str('\n')
        Code = str(Method)
        self.Fallback = Code
        self.Fallback_Declaration = Behavior_Code
        return True
class Statement_Bias (Line_Statement):
    Gal_Keyword = 'bias'
    Gs_Keyword = 'bias'
    def __init__(self):
        super().__init__()
        self.Bias = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Bias')
        self.Bias = self.Listargs.pop(0)
    def Infer_C(self):
        Gen = ''
        self.C = Gen
        return True
    def Infer_Fallback(self):
        Verbose = True
        Bias = str(self.Bias.Fallback)
        Name = str(self.Parent.Name.Fallback)
        Code = 'comment "Bias: ' + str(Bias) + ' name ' + str(Name) + '";'
        Declaration = '''object F_''' + str(Name) + ''' = (Function:Lookup ''' + str(self.Enquote(Name)) + ''');''' + str('\n') + '''F_''' + str(Name) + '''.Bias = ''' + str(Bias) + ''';'''
        self.Mumps_Declaration = Declaration
        self.Fallback = Code
        return True
class Statement_Bind (Declaration_Statement):
    Gal_Keyword = 'bind'
    Gs_Keyword = 'bind'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Variable = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_C(self):
        Verbose = True
        Class = str(self.Class.C)
        Variable = str(self.Variable.C)
        Code = 'int ' + str(Variable)
        if self.Value is not None:
            Value = str(self.Value.C)
            Code += ' = ' + str(Value)
        Code += '; // bound to class ' + str(Class)
        if Verbose:
            print(' ~ bind: ', Code, sep='')
        self.C = Code
        if Verbose:
            print('bind ', Variable, ' to ', Class, sep='')
        Meth_Context = self.Method_Context()
        Meth_Context.Variables[Variable] = Class;
        return True
    def Infer_Structure(self):
        Verbose = True
        Variable = str(self.Variable.Input)
        Type = str(self.Class.Input)
        self.Data_Type.Symbol_Value = Type
        Context = self.Method_Context()
        if (Context in (None, "")):
            if Verbose:
                print('missing variable context in declaration statement, encountered ', self.Enquote(self.Get_Input()), sep='')
        else:
            # comment 'verbosebind statement noted  Variable as  Type';
            Context.Variables[Variable] = Type;
        return True
class Statement_Bless (Line_Statement):
    Gal_Keyword = 'bless'
    Gs_Keyword = 'bless'
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Class = None
    def Infer_Mumps(self):
        Verbose = False
        Object = str(self.Object.Mumps)
        Class = str(self.Class.Mumps)
        Code = str("    ") + 'set @' + str(Object) + '=' + str(Class) + ' do' + str('\n') + str("    ") + '. new %self set %self=' + str(Object) + ' do new2^@' + str(Class) + str('\n')
        if Verbose:
            print("    ~ ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Object = str(self.Object.Mumps)
        Class = str(self.Class.Mumps)
        Code = str("    ") + 'set @' + str(Object) + '=' + str(Class) + ' do' + str('\n') + str("    ") + '. new %self set %self=' + str(Object) + ' do new2^@' + str(Class) + str('\n')
        if Verbose:
            print("    ~ ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
class Statement_Break (Line_Statement):
    Gal_Keyword = 'break'
    Gs_Keyword = 'break'
    def Infer_Mumps(self):
        Code = str("    ") + 'goto ' + str(self.Break_Label()) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str("    ") + 'goto ' + str(self.Break_Label()) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'break;'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'break'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'break;'
        self.C = Gen
        return True
class Statement_Break_If (Line_Statement):
    Gal_Keyword = 'breakif'
    Gs_Keyword = 'breakif'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Code = str("    ") + 'goto:' + str(Condition) + ' ' + str(self.Break_Label()) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Code = str("    ") + 'goto:' + str(Condition) + ' ' + str(self.Break_Label()) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'break.if' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'break if' + str(self.Gs_Arguments()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'if (' + str(self.Condition.Javascript) + ') { break; }'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'if ' + str(self.Condition.Python) + ':' + str('\n') + str("    ") + 'break'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'if (' + str(self.Condition.C) + ') { break; }'
        self.C = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'if ' + str(self.Condition.Fallback) + ' { break; }'
        self.Fallback = Gen
        return True
class Statement_Build (Line_Statement):
    Gal_Keyword = 'build'
    Gs_Keyword = 'build'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'do @("%Build^"_' + str(Variable) + '_"("""_' + str(Variable) + '_""")")' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'do @("%Build^"_' + str(Variable) + '_"("""_' + str(Variable) + '_""")")' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
class Statement_C (Scoped_Statement):
    Gal_Keyword = 'c'
    Gs_Keyword = 'c'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'method void Infer_C' + str('\n') + '{' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        else:
            Argument = None
            Args_Code = ''
            for Argument in self.Arguments:
                if isinstance(Argument, Token_Name):
                    Args_Code += ' ' + str('[my '  +  Argument.Fallback  +  ' Reference]')
                else:
                    Args_Code += ' ' + str(Argument.Fallback)
            Code += str("    ") + 'string Code' + str(Args_Code) + ';' + str('\n') + str("    ") + 'my= C Code;' + str('\n')
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Call (Line_Statement):
    Gal_Keyword = '.'
    Gs_Keyword = '.'
    def __init__(self):
        super().__init__()
        self.Target = None
        self.Method = None
    def Infer_Mumps(self):
        Target = str(self.Target.Mumps)
        Method = str(self.Mq(self.Method.Mumps))
        Method = Method.replace('_', '')
        Margs = ""
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = str("    ") + "do dispatch" + str(len(self.Listargs)) + "^gal(" + str(Target) + "," + str(Method) + str(Margs) + ")" + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Target = str(self.Target.Mumps)
        Method = str(self.Mq(self.Method.Mumps))
        Method = Method.replace('_', '')
        Margs = ""
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = str("    ") + "do dispatch" + str(len(self.Listargs)) + "^gal(" + str(Target) + "," + str(Method) + str(Margs) + ")" + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Target')
        self.Target = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = str(self.Target.Gs) + '.' + str(self.Method.Gs) + str(self.Gs_Listargs()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Target.Javascript) + '.' + str(self.Method.Javascript) + '(' + str(self.Javascript_Args(', ')) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Target.Python) + '.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Target.Python) + '.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Object = str(self.Object.C)
        Method = str(self.Method.C)
        Arguments = str(self.C_Args(', '))
        Code = '(' + str(Object) + '->' + str(Method) + ')(' + str(Arguments) + ');'
        self.C = Code
        return True
    def Infer_C(self):
        Target = str(self.Target.C)
        Method = str(self.Method.C)
        Args = str(self.C_Args(', '))
        if str(Args) != '':
            Args = ', '  +  Args
        Context = self.Method_Context()
        Type = '<UNKNOWN TYPE>'
        if Target in Context.Variables.keys():
            Type = Context.Variables[Target]
        Code = str(Type) + '_meth_' + str(Method) + '(' + str(Target) + str(Args) + ');'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Gen = str(self.Target.Fallback) + '.' + str(self.Method.Fallback) + str(self.Fallback_Args()) + ';'
        self.Fallback = Gen
        return True
class Statement_Catch (Error_Handling_Statement):
    Gal_Keyword = 'catch'
    Gs_Keyword = 'catch'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable_Code = ''
        End_Label = str(self.End_Label)
        if self.Variable is not None:
            Variable_Code += str("    ") + 'set ' + str(self.Variable.Mumps) + '=%ecode' + str('\n')
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'set %ecode=$zstatus,$ecode="",$zstatus=""' + str('\n') + str(Variable_Code) + str(Block) + str(End_Label) + ' ; try catch end label' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable_Code = ''
        End_Label = str(self.End_Label)
        if self.Variable is not None:
            Variable_Code += str("    ") + 'set ' + str(self.Variable.Mumps) + '=%ecode' + str('\n')
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'set %ecode=$zstatus,$ecode="",$zstatus=""' + str('\n') + str(Variable_Code) + str(Block) + str(End_Label) + ' ; try catch end label' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Variable = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Code = 'catch'
        if self.Variable is not None:
            Code += ' (' + str(self.Variable.Javascript) + ')'
        Code += str(self.Javascript_Block())
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = 'except Exception'
        if self.Variable is not None:
            Code += ' as ' + str(self.Variable.Python)
        Code += str(self.Python_Block())
        self.Python = Code
        return True
class Statement_Cd (Line_Statement):
    Gal_Keyword = 'cd'
    Gs_Keyword = 'cd'
    def __init__(self):
        super().__init__()
        self.Directory = None
    def Infer_Mumps(self):
        Code = str("    ") + 'set $zdir=' + str(self.Directory.Mumps) + str('\n')
    def Infer_Mumps(self):
        Code = str("    ") + 'set $zdir=' + str(self.Directory.Mumps) + str('\n')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Directory')
        self.Directory = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'process.chdir(' + str(self.Directory.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'os.chdir(' + str(self.Directory.Python) + ')'
        self.Python = Gen
        return True
class Statement_Class_Append (Scoped_Statement):
    Gal_Keyword = 'class.append'
    Gs_Keyword = 'class.append'
    def __init__(self):
        super().__init__()
        self.Primary_Class = None
        self.Generate_Constructor = False
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'class.append' + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Verbose = False
        Code = ''
        if not self.Primary_Class is not None:
            Code += 'class append' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        if Verbose:
            print('goalspell class append: ', Code, sep='')
        self.Gs = Code
        return True
    def Infer_Fallback(self):
        Verbose = True
        Code = ''
        if not self.Primary_Class is not None:
            Code = self.Gs
        if Verbose:
            print('fallback class append: ', Code, sep='')
        self.Fallback = Code
        return True
    def Infer_Structure(self):
        Verbose = False
        Name = str(self.Name.Get_Input())
        if Verbose:
            print('class append ', Name, sep='')
        if not Name in Statement_Class.Names.keys():
            raise Exception("'class append' could not append to nonexistent class " + str(Name))
        Class = Statement_Class.Names[Name]
        self.Primary_Class = Class
        if Verbose:
            print("    ", 'inferred primary class object', sep='')
        Statement = None
        try:
            for Statement in self.Block.Statements:
                if Verbose:
                    print("    ", 'class append to ', Name, ': ', Statement.Gs_Keywords, sep='')
                Class.Appended_Statements.extend([Statement])
        except Exception:
            pass
        return True
class Statement_Class_Set (Scoped_Statement):
    Gal_Keyword = 'class.set'
    Gs_Keyword = 'class.set'
    def __init__(self):
        super().__init__()
        self.Primary_Class = None
        self.Generate_Constructor = False
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = 'class set' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        self.Fallback = ''
        return True
    def Infer_Structure(self):
        Verbose = False
        if Verbose:
            print(' *** inferring structure of ', self, sep='')
        Name = str(self.Name.Get_Input())
        if not Name in Statement_Class.Names.keys():
            raise Exception("'class set' could not append to nonexistent class " + str(Name))
        Class = Statement_Class.Names[Name]
        Statement = None
        try:
            for Statement in self.Block.Statements:
                if Verbose:
                    print('class set to ', Name, ': ', Statement, sep='')
                Class.Appended_Statements.extend([Statement])
        except Exception:
            pass
        return True
class Statement_Class_Attribute (Scoped_Statement):
    Gal_Keyword = 'class.attribute'
    Gs_Keyword = 'class.attribute'
    def __init__(self):
        super().__init__()
        self.Data_Type = None
        self.Property_Name = None
        self.Class = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Data_Type')
        self.Data_Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property_Name')
        self.Property_Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Class = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Property_Fallback = str(self.Property_Name.Fallback)
        Type_Fallback = str(self.Data_Type.Fallback)
        Ancestor_Fallback = 'Attribute'
        Class_Fallback = None
        if self.Class is not None:
            Class_Fallback = self.Class.Fallback
        else:
            Type_Name = str(Type_Fallback[0].upper()) + str(Type_Fallback[1:])
            Class_Fallback = Type_Name
        # comment "Class Property entities don't know their owner!";
        Code = 'class.property object ' + str(Property_Fallback) + ' (new Class_' + str(Class_Fallback) + ');' + str('\n')
        self.Fallback = Code
        return True
class Statement_Class (Class_Statement):
    Gal_Keyword = 'class'
    Gs_Keyword = 'class'
    Names = {}
    def __init__(self):
        super().__init__()
        self.Name = None
    def Infer_Mumps(self):
        Verbose = False
        Name = str(self.Name.Mumps)
        Qname = str(self.Mq(Name))
        Name = Name.replace('_', '')
        Statement = None
        Class_Properties = ''
        Class_Methods = ''
        Constructor = ''
        Properties = ''
        Methods = ''
        Main = ''
        Main_Invoke = ''
        N2 = None
        Mainargs = ''
        A = None
        try:
            Constructor = self.Constructor.Mumps
        except Exception:
            pass
        if not (self.Main in (None, "")):
            Main = self.Main.Mumps
            for A in self.Main.Arguments:
                if str(Mainargs) > '':
                    Mainargs += ','
                Mainargs += str(A.Mumps)
            if (Mainargs is not None and str(Mainargs) > ""):
                Mainargs = '('  +  Mainargs  +  ')'
            Main_Invoke += str("    ") + 'do main' + str(Mainargs) + str('\n')
        for N2, Statement in self.Compiled_Class_Properties.items():
            try:
                Class_Properties += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Class_Properties += str(Statement.Mumps)
            except Exception:
                pass
        for N2, Statement in self.Compiled_Class_Methods.items():
            try:
                Class_Methods += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Class_Methods += str(Statement.Mumps)
            except Exception:
                pass
        for N2, Statement in self.Compiled_Properties.items():
            try:
                Properties += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Properties += str(Statement.Mumps)
            except Exception:
                pass
        for N2, Statement in self.Compiled_Methods.items():
            try:
                Methods += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Methods += str(Statement.Mumps)
            except Exception:
                pass
        if (Constructor in (None, "")):
            Constructor = 'new() ; constructor'  +  '\n'  +  "    "  +  'new %self set %self=$name(@%matrix@($increment(@%matrix)))'  +  '\n'  +  "    "  +  'set @%self='  +  self.Mq(Name)  +  '\n'  +  'new2 ; bless property hook'  +  '\n'  +  Properties  +  "    "  +  'quit:$quit %self quit'  +  '\n'
        Initializations = str("    ") + 'quit:$data(%' + str(Name) + ')' + str('\n') + str("    ") + 'set %' + str(Name) + '=' + str(Qname) + str('\n') + str("    ") + "quit:$data(^%" + str(Name) + ')' + str('\n') + str("    ") + 'set ^%' + str(Name) + '=' + str(Qname) + str('\n') + str("    ") + 'set ^%Classes(' + str(Qname) + ')=' + str(Qname) + str('\n') + str("    ") + 'set ^%' + str(Name) + '("Ancestors","' + str(Name) + '")=""' + str('\n')
        for N2, Statement in self.Compiled_Ancestors.items():
            N2 = N2.replace('_', '')
            Initializations += str("    ") + 'set ^%' + str(Name) + '("Ancestors","' + str(N2) + '")=""' + str('\n')
        Statement = None
        Code = str(Name) + str(Mainargs) + ' ; gal ; ' + str(Name) + ' class. ;' + str('\n') + str("    ") + ';; ******************************************' + str('\n') + str("    ") + ';; *   Copyright (c) 2024 by Erik Zoltan.   *' + str('\n') + str("    ") + ';; *   All rights reserved.                 *' + str('\n') + str("    ") + ';; ******************************************' + str('\n') + str("    ") + "if '$data(%matrix) do ^gal" + str('\n') + str("    ") + 'do %init(' + str(Qname) + ')' + str('\n') + str(Main_Invoke) + str("    ") + 'quit' + str('\n') + str(Main) + '%init(%class) ;' + str('\n') + str(Initializations) + str(Class_Properties) + str("    ") + 'quit' + str('\n') + str(Class_Methods) + str(Constructor) + str(Methods)
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Name = str(self.Name.Mumps)
        Qname = str(self.Mq(Name))
        Name = Name.replace('_', '')
        Statement = None
        Class_Properties = ''
        Class_Methods = ''
        Constructor = ''
        Properties = ''
        Methods = ''
        Main = ''
        Main_Invoke = ''
        N2 = None
        Mainargs = ''
        A = None
        try:
            Constructor = self.Constructor.Mumps
        except Exception:
            pass
        if not (self.Main in (None, "")):
            Main = self.Main.Mumps
            for A in self.Main.Arguments:
                if str(Mainargs) > '':
                    Mainargs += ','
                Mainargs += str(A.Mumps)
            if (Mainargs is not None and str(Mainargs) > ""):
                Mainargs = '('  +  Mainargs  +  ')'
            Main_Invoke += str("    ") + 'do main' + str(Mainargs) + str('\n')
        for N2, Statement in self.Compiled_Class_Properties.items():
            try:
                Class_Properties += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Class_Properties += str(Statement.Mumps)
            except Exception:
                pass
        for N2, Statement in self.Compiled_Class_Methods.items():
            try:
                Class_Methods += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Class_Methods += str(Statement.Mumps)
            except Exception:
                pass
        for N2, Statement in self.Compiled_Properties.items():
            try:
                Properties += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Properties += str(Statement.Mumps)
            except Exception:
                pass
        for N2, Statement in self.Compiled_Methods.items():
            try:
                Methods += str(Statement.Mumps_Declaration)
            except Exception:
                pass
            try:
                Methods += str(Statement.Mumps)
            except Exception:
                pass
        if (Constructor in (None, "")):
            Constructor = 'new() ; constructor'  +  '\n'  +  "    "  +  'new %self set %self=$name(@%matrix@($increment(@%matrix)))'  +  '\n'  +  "    "  +  'set @%self='  +  self.Mq(Name)  +  '\n'  +  'new2 ; bless property hook'  +  '\n'  +  Properties  +  "    "  +  'quit:$quit %self quit'  +  '\n'
        Initializations = str("    ") + 'quit:$data(%' + str(Name) + ')' + str('\n') + str("    ") + 'set %' + str(Name) + '=' + str(Qname) + str('\n') + str("    ") + "quit:$data(^%" + str(Name) + ')' + str('\n') + str("    ") + 'set ^%' + str(Name) + '=' + str(Qname) + str('\n') + str("    ") + 'set ^%Classes(' + str(Qname) + ')=' + str(Qname) + str('\n') + str("    ") + 'set ^%' + str(Name) + '("Ancestors","' + str(Name) + '")=""' + str('\n')
        for N2, Statement in self.Compiled_Ancestors.items():
            N2 = N2.replace('_', '')
            Initializations += str("    ") + 'set ^%' + str(Name) + '("Ancestors","' + str(N2) + '")=""' + str('\n')
        Statement = None
        Code = str(Name) + str(Mainargs) + ' ; gal ; ' + str(Name) + ' class. ;' + str('\n') + str("    ") + ';; ******************************************' + str('\n') + str("    ") + ';; *   Copyright (c) 2024 by Erik Zoltan.   *' + str('\n') + str("    ") + ';; *   All rights reserved.                 *' + str('\n') + str("    ") + ';; ******************************************' + str('\n') + str("    ") + "if '$data(%matrix) do ^gal" + str('\n') + str("    ") + 'do %init(' + str(Qname) + ')' + str('\n') + str(Main_Invoke) + str("    ") + 'quit' + str('\n') + str(Main) + '%init(%class) ;' + str('\n') + str(Initializations) + str(Class_Properties) + str("    ") + 'quit' + str('\n') + str(Class_Methods) + str(Constructor) + str(Methods)
        self.Mumps = Code
    def Re_Mumps(self):
        Verbose = True
        Statement = None
        N2 = None
        if not (self.Constructor in (None, "")):
            self.Constructor.Re_Mumps()
        if not (self.Main in (None, "")):
            self.Main.Re_Mumps()
        for N2, Statement in self.Compiled_Class_Properties.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        for N2, Statement in self.Compiled_Class_Methods.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        for N2, Statement in self.Compiled_Properties.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        for N2, Statement in self.Compiled_Methods.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        self.Infer_Mumps()
    def Re_Mumps(self):
        Verbose = True
        Statement = None
        N2 = None
        if not (self.Constructor in (None, "")):
            self.Constructor.Re_Mumps()
        if not (self.Main in (None, "")):
            self.Main.Re_Mumps()
        for N2, Statement in self.Compiled_Class_Properties.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        for N2, Statement in self.Compiled_Class_Methods.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        for N2, Statement in self.Compiled_Properties.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        for N2, Statement in self.Compiled_Methods.items():
            try:
                Statement.Re_Mumps()
            except Exception:
                pass
        self.Infer_Mumps()
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Gs(self):
        Verbose = True
        self.Error = None
        Arguments = str(self.Gs_Arguments())
        Argument = None
        Name = str(self.Name.Gs)
        Search = ' ' + str(Name) + ' '
        Statements = ''
        Statement = None
        Between = ''
        SGS = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                Statements += str(Between) + str(Statement.Gs)
                Between = '\n'
        for Statement in self.Appended_Statements:
            SGS = Statement.Gs
            Statements += str(Between) + str(SGS)
            if Verbose:
                print('class ', Name, ' appending ', SGS, sep='')
            Between = '\n'
        if str(Statements) > '':
            Statements = self.Indent(Statements)
            if str(Statements[-1]) != str('\n'):
                Statements += str('\n')
        Code = 'class' + str(Arguments) + str('\n') + '{' + str('\n') + str(Statements) + '}' + str('\n')
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Verbose = False
        # comment 'debug';
        Name = str(self.Name.Javascript)
        Null_Block = True
        Arguments = str(self.Javascript_Arguments(' '))
        Class_Properties = ''
        Properties = ''
        Class_Methods = ''
        Statements = ''
        Statement = None
        Line_Code = None
        Null_Block = True
        Constructor = ''
        Block = ''
        if self.Block is not None:
            for Statement in self.Block.Statements:
                Line_Code = Statement.Javascript  +  '\n'
                if not isinstance(Statement, Comment_Statement):
                    Null_Block = False
                if isinstance(Statement, Statement_Property):
                    Properties += str(Line_Code)
                elif isinstance(Statement, Statement_Class_Property):
                    Class_Properties += str(Line_Code)
                elif isinstance(Statement, Statement_Class_Method):
                    Class_Methods += str(Line_Code)
                else:
                    Statements += str(Line_Code)
        if str(Class_Properties) > '':
            Block += str(self.Indent(Class_Properties))
        if str(Class_Methods) > '':
            Block += str(self.Indent(Class_Methods))
        if self.Generate_Constructor:
            Null_Block = False
            Function = 'constructor'
            Super = str("    ") + 'super(...arguments);' + str('\n')
            if self.Has_Constructor:
                Function = 'propinit'
                Super = ''
            if str(Name) == 'Goal':
                Super = ''
            Constructor = str(Function) + '()' + str('\n') + '{' + str('\n')
            Constructor += str(Super)
            Constructor += str(self.Indent(Properties))
            Constructor += '}' + str('\n')
        if str(Constructor) > '':
            Block += str(self.Indent(Constructor))
        if str(Statements) > '':
            Block += str(self.Indent(Statements))
        Code = 'class ' + str(Arguments) + str('\n') + '{' + str('\n') + str(Block) + '}' + str('\n')
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Verbose = False
        # comment 'debug';
        Null_Block = True
        Arguments = str(self.Python_Arguments(' '))
        Class_Properties = ''
        Properties = ''
        Class_Methods = ''
        Statements = ''
        Statement = None
        Line_Code = None
        Null_Block = True
        Constructor = ''
        Block = ''
        if self.Block is not None:
            for Statement in self.Block.Statements:
                Line_Code = Statement.Python  +  '\n'
                if not isinstance(Statement, Comment_Statement):
                    Null_Block = False
                if isinstance(Statement, Statement_Property):
                    Properties += str(Line_Code)
                elif isinstance(Statement, Statement_Class_Property):
                    Class_Properties += str(Line_Code)
                elif isinstance(Statement, Statement_Class_Method):
                    Class_Methods += str(Line_Code)
                else:
                    Statements += str(Line_Code)
        if str(Class_Properties) > '':
            Block += str(self.Py_Indent(Class_Properties))
        if str(Class_Methods) > '':
            Block += str(self.Py_Indent(Class_Methods))
        if self.Generate_Constructor:
            Null_Block = False
            Function = '__init__'
            Super = str("    ") + 'super().__init__()' + str('\n')
            if self.Has_Constructor:
                Function = 'propinit'
                Super = ''
            Constructor = 'def ' + str(Function) + '(self):' + str('\n')
            Constructor += str(Super)
            Constructor += str(self.Py_Indent(Properties))
        if str(Constructor) > '':
            Block += str(self.Py_Indent(Constructor))
        if str(Statements) > '':
            Block += str(self.Py_Indent(Statements))
        if Null_Block or str(Block) == '':
            Block += str("    ") + 'pass' + str('\n')
        Code = 'class ' + str(Arguments) + ':' + str('\n') + str(Block)
        self.Python = Code
        return True
    def Infer_C(self):
        Capacity = '1'
        # comment 'TODO:this still needs a rewrite';
        Name = str(self.Name.C)
        zdebug.zbreak()
        # comment 'TODO:first get the declarations.';
        # comment 'TODO:then get the executables.';
        Block = str(self.C_Statements())
        # comment 'string Old_Codetypedef  Name [line]{ [line] Block}  Name;';
        Stmt = None
        Inits = "unsigned int self = last_" + str(Name) + '++;' + str('\n')
        for Stmt in self.Block.Statements:
            if isinstance(Stmt, Statement_Property):
                if Stmt.Value is not None:
                    Inits += str(Stmt.C_Declaration) + str('\n')
            elif isinstance(Stmt, Statement_Pobj):
                if Stmt.Initializer is not None:
                    Inits += str(Stmt.C_Declaration) + str('\n')
        Inits += 'return self;' + str('\n')
        Constructor = 'unsigned int ' + str(Name) + '_constructor()' + str('\n') + '{' + str('\n') + str(self.Indent(Inits)) + '}' + str('\n')
        Code = str('\n') + '// class ' + str(Name) + ' begins' + str('\n') + 'int last_' + str(Name) + ' = -1;' + str('\n') + '#ifndef ' + str(Name) + '_Capacity' + str('\n') + '#define ' + str(Name) + '_Capacity ' + str(Capacity) + str('\n') + '#endif' + str('\n') + str(Block) + str(Constructor) + '// class ' + str(Name) + ' ends' + str('\n')
        self.C = Code
        return True
    def Infer_Fallback(self):
        Verbose = False
        self.Error = None
        Arguments = str(self.Fallback_Arguments())
        Argument = None
        Ancestor = ' [is Object]'
        Name = str(self.Name.Fallback)
        Post_Statements = ''
        Search = ' ' + str(Name) + ' '
        if Search in ' Goal Symbol Egg Object ':
            Ancestor = ''
        for Argument in self.Arguments:
            if isinstance(Argument, Syntax_Is):
                Ancestor = ''
        Arguments += str(Ancestor)
        Declarations = ''
        Statements = ''
        Statement = None
        Between = ''
        SFB = None
        Dec = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                if str(Statement.Fallback_Declaration) > '':
                    Declarations += str(Statement.Fallback_Declaration) + str('\n')
                Statements += str(Between) + str(Statement.Fallback)
                Between = '\n'
        for Statement in self.Appended_Statements:
            if str(Statement.Fallback_Declaration) > '':
                Dec = Statement.Fallback_Declaration
                if Verbose:
                    print('class ', Name, ' declares ', Dec, sep='')
                Declarations += str(Dec) + str('\n')
            SFB = Statement.Fallback
            Statements += str(Between) + str(SFB)
            if Verbose:
                print('class ', Name, ' appending ', SFB, sep='')
            Between = '\n'
        if str(Statements) > '':
            Statements = self.Indent(Statements)
            if str(Statements[-1]) != str('\n'):
                Statements += str('\n')
        Code = str(Declarations) + 'class' + str(Arguments) + str('\n') + '{' + str('\n') + str(Statements) + '}' + str('\n') + str(Post_Statements)
        self.Fallback = Code
        return True
class Statement_Class_Is (Class_Statement):
    Gal_Keyword = 'class.is'
    Gs_Keyword = 'class.is'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Ancestor_Class = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Ancestor_Class')
        self.Ancestor_Class = self.Listargs.pop(0)
    def Infer_Gs(self):
        Verbose = False
        Name = str(self.Name.Gs)
        # comment "debugif (s= Name 'Document')";
        Ancestor_Class = str(self.Ancestor_Class.Gs)
        if Verbose:
            print('gs: class ', Name, ' is ', Ancestor_Class, sep='')
        self.Error = None
        Statements = ''
        Statement = None
        Between = ''
        SGS = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                Statements += str(Between) + str(Statement.Gs)
                Between = '\n'
        Canonical = Statement_Class.Names[Name]
        for Statement in Canonical.Appended_Statements:
            SGS = Statement.Gs
            Statements += str(Between) + str(SGS)
            if Verbose:
                print("    ", 'class ', Name, ' appending ', SGS, sep='')
            Between = '\n'
        if str(Statements) > '':
            Statements = self.Indent(Statements)
            if str(Statements[-1]) != str('\n'):
                Statements += str('\n')
        Code = 'class ' + str(Name) + ' [is ' + str(Ancestor_Class) + ']' + str('\n') + '{' + str('\n') + str(Statements) + '}' + str('\n')
        self.Gs = Code
        return True
    def Infer_Fallback(self):
        Name = str(self.Name.Gs)
        Ancestor_Class = str(self.Ancestor_Class.Gs)
        Code = 'class ' + str(Name) + ' [is ' + str(Ancestor_Class) + ']' + str(self.Gs_Block())
        self.Fallback = Code
        return True
    def Infer_Structure(self):
        Verbose = False
        # comment 'verbose *** inferring structure of  [my]';
        Name = str(self.Name.Get_Input())
        if Name in Statement_Class.Names.keys():
            Class = Statement_Class.Names[Name]
            Statement = None
            try:
                for Statement in self.Block.Statements:
                    if Verbose:
                        print('class set ', Name, ': ', Statement, sep='')
                    Class.Appended_Statements.extend([Statement])
            except Exception:
                pass
        else:
            Statement_Class.Names[Name] = self;
            if Verbose:
                print("'class is' registers class ", Name, sep='')
        return True
class Statement_Copy_From (Line_Statement):
    Gal_Keyword = 'copy.from'
    Gs_Keyword = 'copy.from'
    def __init__(self):
        super().__init__()
        self.Target = None
        self.Source = None
    def Infer_Mumps(self):
        Source = str(self.Source.Mumps)
        Target = str(self.Target.Mumps)
        if str(Target[0]) != '@':
            Target = '@'  +  Target
        if str(Source[0]) != '@':
            Source = '@'  +  Source
        Code = str("    ") + 'kill ' + str(Source) + str('\n') + str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Source = str(self.Source.Mumps)
        Target = str(self.Target.Mumps)
        if str(Target[0]) != '@':
            Target = '@'  +  Target
        if str(Source[0]) != '@':
            Source = '@'  +  Source
        Code = str("    ") + 'kill ' + str(Source) + str('\n') + str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Target = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Source')
        self.Source = self.Listargs.pop(0)
class Statement_Copy_To (Line_Statement):
    Gal_Keyword = 'copy.to'
    Gs_Keyword = 'copy.to'
    def __init__(self):
        super().__init__()
        self.Source = None
        self.Target = None
    def Infer_Mumps(self):
        Target = str(self.Target.Mumps)
        Source = str(self.Source.Mumps)
        if str(Target[0]) != '@':
            Target = '@'  +  Target
        if str(Source[0]) != '@':
            Source = '@'  +  Source
        Code = str("    ") + 'kill ' + str(Source) + str('\n') + str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Target = str(self.Target.Mumps)
        Source = str(self.Source.Mumps)
        if str(Target[0]) != '@':
            Target = '@'  +  Target
        if str(Source[0]) != '@':
            Source = '@'  +  Source
        Code = str("    ") + 'kill ' + str(Source) + str('\n') + str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Source')
        self.Source = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Target = self.Listargs.pop(0)
class Statement_Egg (Class_Statement):
    Gal_Keyword = 'egg'
    Gs_Keyword = 'egg'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Ancestor = ' [is Egg]'
        if str(Name) == 'Egg':
            Ancestor = ''
        Code = 'class ' + str(Name) + str(Ancestor) + str(self.Fallback_Block())
        self.Fallback = Code
        return True
class Statement_Class_Module (Class_Statement):
    Gal_Keyword = 'class.module'
    Gs_Keyword = 'class.module'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = 'module ' + str(self.Name.Fallback) + ' { ' + 'class ' + str(self.Fallback_Arguments()) + str(self.Fallback_Block()) + ' }' + str('\n')
        self.Fallback = Gen
        return True
class Statement_Classify (Method_Statement):
    Gal_Keyword = 'classify'
    Gs_Keyword = 'classify'
    def Attributes(self):
        pass
class Statement_Class_Method (Class_Method_Statement):
    Gal_Keyword = 'class.method'
    Gs_Keyword = 'class.method'
    def __init__(self):
        super().__init__()
        self.Return_Type = None
        self.Name = None
    def Infer_Mumps(self):
        Return_Type = str(self.Gs_Keywords[-1])
        Method_Name = str(self.Name.Mumps)
        Arglist = '%class'
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Arglist += ',' + str(Args)
        Code = '%' + str(Method_Name) + '(' + str(Arglist) + ') ; ' + str(Return_Type) + ' return' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Return_Type = str(self.Gs_Keywords[-1])
        Method_Name = str(self.Name.Mumps)
        Arglist = '%class'
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Arglist += ',' + str(Args)
        Code = '%' + str(Method_Name) + '(' + str(Arglist) + ') ; ' + str(Return_Type) + ' return' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Return_Type')
        self.Return_Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'class.method ' + str(self.Gal_Keywords[-1]) + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Return_Type = str(self.Gs_Keywords[-1])
        if not Return_Type in ' void flag integer percent number string object entity list dictionary variant glvn ':
            raise Exception('Invalid return type "' + str(Return_Type) + '".')
        Code = '''class method ''' + str(Return_Type) + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Gen = 'static ' + str(self.Name.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Code = '@classmethod' + str('\n') + 'def ' + str(self.Name.Python) + '(cls'
        Args = str(self.Python_Args(', '))
        if str(Args) > '':
            Code += ', ' + str(Args)
        Code += ')' + str(self.Python_Block())
        self.Python = Code
        return True
class Statement_Class_Property (Line_Statement):
    Gal_Keyword = 'class.property'
    Gs_Keyword = 'class.property'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Value = None
    def Infer_Mumps(self):
        Type = str(self.Type.Mumps)
        Name = str(self.Name.Mumps)
        Value = None
        if self.Value is not None:
            Value = self.Value.Mumps
        if str(Type) == 'list':
            Value = '0'
        Class_Context = self.Mumps_Class()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Name = Name.replace('_', '')
        Code = ''
        if Value is not None:
            Code += str("    ") + 'set ^%' + str(Class_Name) + '(0,' + str(self.Mq(Name)) + ')=' + str(Value) + str('\n')
        self.Mumps_Declaration = Code
        self.Mumps = ''
    def Infer_Mumps(self):
        Type = str(self.Type.Mumps)
        Name = str(self.Name.Mumps)
        Value = None
        if self.Value is not None:
            Value = self.Value.Mumps
        if str(Type) == 'list':
            Value = '0'
        Class_Context = self.Mumps_Class()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Name = Name.replace('_', '')
        Code = ''
        if Value is not None:
            Code += str("    ") + 'set ^%' + str(Class_Name) + '(0,' + str(self.Mq(Name)) + ')=' + str(Value) + str('\n')
        self.Mumps_Declaration = Code
        self.Mumps = ''
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Type = str(self.Gal_Keywords[-1])
        Name = str(self.Name.Gal)
        Value = ''
        if self.Value is not None:
            Value += ' ' + str(self.Value.Gal)
        Code = 'class.property ' + str(Type) + ' ' + str(Name) + str(Value) + ';'
        self.Gal = Code
        return True
    def Infer_Gs(self):
        Type = str(self.Gs_Keywords[-1])
        Name = str(self.Name.Gs)
        Value = ''
        if self.Value is not None:
            Value += ' ' + str(self.Value.Gs)
        Code = 'class property ' + str(Type) + ' ' + str(Name) + str(Value) + ';'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Name_Code = str(self.Name.Javascript)
        Value_Code = ''
        DT = str(self.Gs_Keywords[-1])
        DT = ' '  +  DT  +  ' '
        if DT in ' dict dictionary hash ':
            Value_Code = '{}'
        elif DT in ' list array ':
            Value_Code = '[]'
        if self.Value is not None:
            Value_Code = self.Value.Javascript
        Code = "static " + str(Name_Code) + ' = ' + str(Value_Code) + ';'
        if str(Value_Code) == '':
            Code = '// '  +  Name_Code  +  ' = null;'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Name_Code = str(self.Name.Python)
        Value_Code = 'None'
        DT = str(self.Gs_Keywords[-1])
        DT = ' '  +  DT  +  ' '
        if DT in ' dict dictionary hash ':
            Value_Code = '{}'
        elif DT in ' list array ':
            Value_Code = '[]'
        # comment 'writelineproperty before defined';
        if self.Value is not None:
            Value_Code = self.Value.Python
        # comment 'writelineproperty after defined';
        Code = str(Name_Code) + ' = ' + str(Value_Code)
        # comment 'writelineProperty Code  Code';
        self.Python = Code
        return True
    def Infer_Fallback(self):
        Type = str(self.Gs_Keywords[-1])
        Name = str(self.Name.Fallback)
        Value = ''
        if self.Value is not None:
            Value += ' ' + str(self.Value.Fallback)
        Code = 'class property ' + str(Type) + ' ' + str(Name) + str(Value) + ';'
        self.Fallback = Code
        return True
class Statement_Classpropset (Assignment_Statement):
    Gal_Keyword = ':='
    Gs_Keyword = ':='
    def __init__(self):
        super().__init__()
        self.Target = None
        self.Property = None
        self.Expression = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Target')
        self.Target = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property')
        self.Property = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Expression')
        self.Expression = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Target.Javascript) + '.' + str(self.Property.Javascript) + ' = ' + str(self.Expression.Javascript) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Target.Python) + '.' + str(self.Property.Python) + ' = ' + str(self.Expression.Python)
        self.Python = Gen
        return True
class Statement_Click (Method_Statement):
    Gal_Keyword = 'click'
    Gs_Keyword = 'click'
    def __init__(self):
        super().__init__()
        self.Element_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Element_Name')
        self.Element_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Element_Name = str(self.Element_Name.Fallback)
        Block = str(self.Fallback_Block())
        Code = "method void Click [object " + str(Element_Name) + "]" + str(Block)
        self.Fallback = Code
        return True
class Statement_Close (Line_Statement):
    Gal_Keyword = 'close'
    Gs_Keyword = 'close'
    def __init__(self):
        super().__init__()
        self.Device = None
    def Infer_Mumps(self):
        Verbose = False
        Code = str("    ") + 'close ' + str(self.Device.Mumps) + str('\n')
        if Verbose:
            print("    close ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Code = str("    ") + 'close ' + str(self.Device.Mumps) + str('\n')
        if Verbose:
            print("    close ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Device')
        self.Device = self.Listargs.pop(0)
class Statement_Collates (Line_Statement):
    Gal_Keyword = 'collates'
    Gs_Keyword = 'collates'
    def __init__(self):
        super().__init__()
        self.Property_Name = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " by property ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " by property ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property_Name')
        self.Property_Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Property_Name = str(self.Property_Name.Javascript)
        Code = '// Collates by property ' + str(Property_Name) + str('\n')
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Property_Name = str(self.Property_Name.Python)
        Code = 'def __lt__(self, other):' + str('\n') + str("    ") + 'return self.' + str(Property_Name) + ' < other.' + str(Property_Name) + str('\n') + 'def __gt__(self, other):' + str('\n') + str("    ") + 'return self.' + str(Property_Name) + ' > other.' + str(Property_Name)
        self.Python = Code
        return True
class Statement_Colon (Line_Statement):
    Gal_Keyword = ':'
    Gs_Keyword = ':'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Method = None
    def Infer_Mumps(self):
        # comment 'Statement_Colon';
        Class = str(self.Class.Mumps)
        Class = Class.replace('_', '')
        Method = str(self.Method.Mumps)
        Method = Method.replace('_', '')
        Margs = str(self.Mq(Class))
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = str("    ") + 'do %' + str(Method) + '^' + str(Class) + '(' + str(Margs) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Statement_Colon';
        Class = str(self.Class.Mumps)
        Class = Class.replace('_', '')
        Method = str(self.Method.Mumps)
        Method = Method.replace('_', '')
        Margs = str(self.Mq(Class))
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = str("    ") + 'do %' + str(Method) + '^' + str(Class) + '(' + str(Margs) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Gs(self):
        Class = str(self.Class.Gs)
        Method = str(self.Method.Gs)
        Code = str(Class) + ':' + str(Method) + str(self.Gs_Listargs()) + str(self.Gs_Block())
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Gen = str(self.Class.Javascript) + '.' + str(self.Method.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Class.Python) + '.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
class Statement_Comment (Comment_Statement):
    Gal_Keyword = '#'
    Gs_Keyword = '#'
    def Infer_Mumps(self):
        Text = ''
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Token_Quote):
                Text += ' ' + str(Argument.Unquoted())
            elif isinstance(Argument, Syntax_Line):
                Text += str('\n')
            else:
                Text += ' ' + str(Argument.Mumps)
        Line = None
        Code = ''
        for Line in Text.split('\n'):
            if str(Line) == '':
                continue
            Code += str("    ") + ';' + str(Line) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Text = ''
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Token_Quote):
                Text += ' ' + str(Argument.Unquoted())
            elif isinstance(Argument, Syntax_Line):
                Text += str('\n')
            else:
                Text += ' ' + str(Argument.Mumps)
        Line = None
        Code = ''
        for Line in Text.split('\n'):
            if str(Line) == '':
                continue
            Code += str("    ") + ';' + str(Line) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Code = str(self.Gal_Key_Suffix)
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Syntax_Line):
                Code += str('\n')
            elif isinstance(Argument, Syntax_Indent):
                Code += str("    ")
            elif isinstance(Argument, Token_Quote):
                Code += ' ' + str(Argument.Unquoted())
            else:
                Code += ' ' + str(Argument.Javascript)
        if '\n' in Code:
            Code = '/*'  +  '\n'  +  Code  +  '\n'  +  '*/'  +  '\n'
        else:
            Code = '//'  +  Code  +  '\n'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = '#' + str(self.Gal_Key_Suffix)
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Syntax_Line):
                Code += str('\n') + '#'
            elif isinstance(Argument, Token_Quote):
                Text = str(Argument.Unquoted())
                if '\n' in Text:
                    Line = None
                    Between = ' '
                    Lines = Text.split('\n')
                    for Line in Lines:
                        Code += str(Between) + str(Line)
                        Between = '\n'  +  '# '
                else:
                    Code += ' ' + str(Text)
            else:
                Code += ' ' + str(Argument.Python)
        self.Python = Code
        return True
    def Infer_C(self):
        Code = str(self.Gal_Key_Suffix)
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Syntax_Line):
                Code += str('\n')
            elif isinstance(Argument, Syntax_Indent):
                Code += str("    ")
            elif isinstance(Argument, Token_Quote):
                Code += ' ' + str(Argument.Unquoted())
            else:
                Code += ' ' + str(Argument.C)
        if '\n' in Code:
            Code = '/*'  +  '\n'  +  Code  +  '\n'  +  '*/'
        else:
            Code = '//'  +  Code
        self.C = Code
        return True
    def Infer_Data_Types(self):
        self.Argument_Types('string')
        return True
class Statement_Compile (Line_Statement):
    Gal_Keyword = 'compile'
    Gs_Keyword = 'compile'
    def __init__(self):
        super().__init__()
        self.From = None
        self.Source = None
        self.To = None
        self.Target = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument From')
        self.From = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Source')
        self.Source = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument To')
        self.To = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Target')
        self.Target = self.Listargs.pop(0)
    def Infer_Fallback(self):
        From = str(self.From.Fallback)
        Source = str(self.Source.Fallback)
        To = str(self.To.Fallback)
        Target = str(self.Target.Fallback)
        Fallback_Generator.Example_Number += 1
        VN = Fallback_Generator.Example_Number
        Code = '''comment 'compile ''' + str(From) + ''' ''' + str(Source) + ''' ''' + str(To) + ''' ''' + str(Target) + str('''';'''  +  '\n'  +  '''object Factory''') + str(VN) + str(''' new Translation_Factory;'''  +  '\n'  +  '''object Trans''') + str(VN) + ''' (Factory''' + str(VN) + '''.Get_Translator ''' + str(From) + ''' ''' + str(To) + str(''');'''  +  '\n'  +  '''[Trans''') + str(VN) + '''.Input Symbol_Value] = ''' + str(Source) + str(''';'''  +  '\n'  +  '''[Trans''') + str(VN) + str('''.Output Symbol_Value] = '';'''  +  '\n'  +  '''flag Status''') + str(VN) + ''' = (Trans''' + str(VN) + str('''.Initialize);'''  +  '\n'  +  '''and Status''') + str(VN) + ''' (Trans''' + str(VN) + str('''.Run);'''  +  '\n'  +  '''if (not Status''') + str(VN) + str(''') { error "Compile Failed"; }'''  +  '\n'  +  '''''') + str(Target) + ''' = [Trans''' + str(VN) + '''.Output Symbol_Value];'''
        self.Fallback = Code
        return True
class Statement_Confirm_Exit_If (Line_Statement):
    Gal_Keyword = 'confirm.exit.if'
    Gs_Keyword = 'confirm.exit.if'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Condition = str(self.Condition.Javascript)
        Code = 'window.onbeforeunload = e => (' + str(Condition) + ') ? true : null;'
        self.Javascript = Code
        return True
class Statement_Constructor (Method_Statement):
    Gal_Keyword = 'constructor'
    Gs_Keyword = 'constructor'
    def Infer_Mumps(self):
        Class_Context = self.Mumps_Class()
        if (Class_Context in (None, "")):
            Class_Context = self.Get_Class_Context()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Args = str(self.Mumps_Arguments())
        Block = str(self.Mumps_Block())
        Properties = ''
        Name = None
        Stmt = None
        Declaration = ''
        Arg = None
        for Arg in self.Listargs:
            if Arg.Mumps_Declaration is not None:
                Declaration += str(Arg.Mumps_Declaration)
        for Name, Stmt in self.Parent.Compiled_Properties.items():
            try:
                Properties += str(Stmt.Mumps_Declaration)
            except Exception:
                pass
            try:
                Properties += str(Stmt.Mumps)
            except Exception:
                pass
        Code = 'new(' + str(Args) + ') ;' + str('\n') + str("    ") + 'new %self set %self=$name(@%matrix@($increment(@%matrix)))' + str('\n') + str("    ") + 'set @%self=' + str(self.Mq(Class_Name)) + str('\n') + 'new2 ; bless property hook' + str('\n') + str(Declaration) + str(Properties) + str(Block) + str("    ") + 'quit:$quit %self quit' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Class_Context = self.Mumps_Class()
        if (Class_Context in (None, "")):
            Class_Context = self.Get_Class_Context()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Args = str(self.Mumps_Arguments())
        Block = str(self.Mumps_Block())
        Properties = ''
        Name = None
        Stmt = None
        Declaration = ''
        Arg = None
        for Arg in self.Listargs:
            if Arg.Mumps_Declaration is not None:
                Declaration += str(Arg.Mumps_Declaration)
        for Name, Stmt in self.Parent.Compiled_Properties.items():
            try:
                Properties += str(Stmt.Mumps_Declaration)
            except Exception:
                pass
            try:
                Properties += str(Stmt.Mumps)
            except Exception:
                pass
        Code = 'new(' + str(Args) + ') ;' + str('\n') + str("    ") + 'new %self set %self=$name(@%matrix@($increment(@%matrix)))' + str('\n') + str("    ") + 'set @%self=' + str(self.Mq(Class_Name)) + str('\n') + 'new2 ; bless property hook' + str('\n') + str(Declaration) + str(Properties) + str(Block) + str("    ") + 'quit:$quit %self quit' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Code = 'constructor('
        Args = str(self.Javascript_Args(', '))
        if str(Args) > '':
            Code += str(Args)
        Class_Object = self.Get_Class_Context()
        Name = str(Class_Object.Name.Javascript)
        Super = str("    ") + 'super(...arguments);' + str('\n')
        if str(Name) == 'Goal':
            Super = ''
        Code += ') {' + str('\n') + str(Super)
        if self.Parent.Generate_Constructor:
            # comment 'debug';
            Code += str("    ") + 'this.propinit();' + str('\n')
        Code += str(self.Javascript_Statements()) + '}' + str('\n')
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = 'def __init__(self'
        Args = str(self.Python_Args(', '))
        if str(Args) > '':
            Code += ', ' + str(Args)
        Code += '):' + str('\n') + str("    ") + 'super().__init__()' + str('\n')
        if self.Parent.Generate_Constructor:
            Code += str("    ") + 'self.propinit()' + str('\n')
        Code += str(self.Python_Statements())
        self.Python = Code
        return True
class Statement_Contest (Scoped_Statement):
    Gal_Keyword = 'contest'
    Gs_Keyword = 'contest'
    def Attributes(self):
        pass
class Statement_Continue (Line_Statement):
    Gal_Keyword = 'continue'
    Gs_Keyword = 'continue'
    def Infer_Mumps(self):
        Code = str("    ") + 'goto ' + str(self.Continue_Label()) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str("    ") + 'goto ' + str(self.Continue_Label()) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'continue;'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'continue'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'continue;'
        self.C = Gen
        return True
class Statement_Continue_If (Line_Statement):
    Gal_Keyword = 'contif'
    Gs_Keyword = 'contif'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Code = str("    ") + 'goto:' + str(Condition) + ' ' + str(self.Continue_Label()) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Code = str("    ") + 'goto:' + str(Condition) + ' ' + str(self.Continue_Label()) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'contif' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'if ' + str(self.Condition.Fallback) + ' { continue; }'
        self.Fallback = Gen
        return True
class Statement_Create (Line_Statement):
    Gal_Keyword = 'create'
    Gs_Keyword = 'create'
    def __init__(self):
        super().__init__()
        self.Device = None
    def Infer_Mumps(self):
        Verbose = False
        Code = str("    ") + 'open ' + str(self.Device.Mumps) + ':(newversion:recordsize=1048576)' + str('\n')
        if Verbose:
            print("    create ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Code = str("    ") + 'open ' + str(self.Device.Mumps) + ':(newversion:recordsize=1048576)' + str('\n')
        if Verbose:
            print("    create ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Device')
        self.Device = self.Listargs.pop(0)
class Statement_Crown (Scoped_Statement):
    Gal_Keyword = 'crown'
    Gs_Keyword = 'crown'
    def __init__(self):
        super().__init__()
        self.Owner_Class = None
        self.Behavior_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Owner_Class')
        self.Owner_Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Behavior_Name')
        self.Behavior_Name = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = ''
        self.Gs = Gen
        return True
    def Infer_Structure(self):
        Class_Name = str(self.Owner_Class.Get_Input())
        Behavior_Name = str(self.Behavior_Name.Get_Input())
        Class = None
        if Statement_Class.Names[Class_Name]:
            Class = Statement_Class.Names[Class_Name]
        else:
            return
        Statement = None
        BS = None
        BN = None
        for Statement in Class.Block.Statements:
            if isinstance(Statement, Behavior_Statement):
                BN = Statement.Behavior_Name.Get_Input()
                if str(BN) != str(Behavior_Name):
                    continue
                B = Statement.Block
                Statement.Block = self.Block
                self.Block = B
                break
        return True
class Statement_Currency (Scoped_Statement):
    Gal_Keyword = 'currency'
    Gs_Keyword = 'currency'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = 'class Currency_' + str(self.Name.Fallback) + ' [is Currency]' + str(self.Fallback_Args()) + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Statement_Date (Line_Statement):
    Gal_Keyword = 'date'
    Gs_Keyword = 'date'
    def Attributes(self):
        pass
class Statement_Debug (Line_Statement):
    Gal_Keyword = 'debug'
    Gs_Keyword = 'debug'
    def Infer_Mumps(self):
        Code = str("    ") + 'break %debug' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str("    ") + 'break %debug' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'debugger;'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'import zdebug; zdebug.zbreak()'
        self.Python = Gen
        return True
class Statement_Debug_If (Line_Statement):
    Gal_Keyword = 'debugif'
    Gs_Keyword = 'debugif'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = 'if ' + str(self.Condition.Fallback) + ' { debug; }'
        self.Fallback = Gen
        return True
class Statement_Decrement (Line_Statement):
    Gal_Keyword = '--'
    Gs_Keyword = '--'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str("    ") + 'set ' + str(Op1) + '=' + str(Op1) + '-1' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str("    ") + 'set ' + str(Op1) + '=' + str(Op1) + '-1' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = str(self.Op1.Gs) + '--;'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Op1.Javascript) + "--;"
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Op1.Python) + ' -= 1'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Op1.C) + "--;"
        self.C = Gen
        return True
class Statement_Default (Line_Statement):
    Gal_Keyword = 'default'
    Gs_Keyword = 'default'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$get(' + str(Variable) + ',' + str(Value) + ')' + str('\n')
        if Verbose:
            print("    default ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$get(' + str(Variable) + ',' + str(Value) + ')' + str('\n')
        if Verbose:
            print("    default ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Dialect (Scoped_Statement):
    Gal_Keyword = 'dialect'
    Gs_Keyword = 'dialect'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Ancestor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Ancestor = 'Dialect'
        if self.Ancestor is not None:
            Ancestor = self.Ancestor.Fallback  +  '_Dialect'
        Body = ''
        Fback = 'my Name = ' + str(self.Enquote(Name)) + ';' + str('\n')
        Statement = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                if isinstance(Statement, Method_Statement) or isinstance(Statement, Statement_Main):
                    Body += str(Statement.Fallback) + str('\n')
                else:
                    if Statement.Fallback_Declaration is not None:
                        Body += str(Statement.Fallback_Declaration) + str('\n')
                    if Statement.Fallback is not None:
                        Fback += str(Statement.Fallback) + str('\n')
        Method = 'method flag Initialize' + str('\n') + '{' + str('\n') + str("    ") + 'object Element;' + str('\n') + str(self.Indent(Fback)) + str('\n') + str("    ") + 'return [true];' + str('\n') + '}'
        Body = self.Indent(Body)
        Method = self.Indent(Method)
        Code = 'class Dialect_' + str(Name) + ' [is ' + str(Ancestor) + ']' + str('\n') + '{' + str('\n') + str(self.Indent(Method)) + str(self.Indent(Body)) + '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Dial (Scoped_Statement):
    Gal_Keyword = 'dial'
    Gs_Keyword = 'dial'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = 'class Dial_' + str(self.Name.Fallback) + ' [is Dial]' + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Statement_Dictionaries (Line_Statement):
    Gal_Keyword = 'dictionaries'
    Gs_Keyword = 'dictionaries'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'dictionary ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Dictionary (Declaration_Statement):
    Gal_Keyword = 'dictionary'
    Gs_Keyword = 'dictionary'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = ''
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Code = str("    ") + 'new ' + str(Variable) + ',' + str(Actual) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(' + str(Actual) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Code = str("    ") + 'new ' + str(Variable) + ',' + str(Actual) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(' + str(Actual) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'dictionary' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Variable_Code = str(self.Variable.Javascript)
        Value_Code = ""
        Between = ''
        Argument = None
        for Argument in self.Listargs:
            # comment 'debug';
            # comment 'TODO:dictionary arguments come in pairs';
            Value_Code += str(Between) + str(Argument.Javascript)
            Between = ', '
        Code = 'var ' + str(Variable_Code) + '= {' + str(Value_Code) + '};'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Variable_Code = str(self.Variable.Python)
        Value_Code = ""
        Between = ''
        Argument = None
        for Argument in self.Listargs:
            zdebug.zbreak()
            # comment 'TODO:dictionary arguments come in pairs.';
            Value_Code += str(Between) + str(Argument.Python)
            Between = ', '
        Code = str(Variable_Code) + ' = {' + str(Value_Code) + '}'
        self.Python = Code
        return True
class Statement_Dictionary_Assign (Line_Statement):
    Gal_Keyword = 'dict.assign'
    Gs_Keyword = 'dict.assign'
    def __init__(self):
        super().__init__()
        self.Dict = None
        self.Key = None
        self.Value = None
    def Infer_Mumps(self):
        Dict = str(self.Dict.Mumps)
        if str(Dict[0]) == "@":
            Dict = '$name('  +  Dict  +  ')'
        elif str(Dict[0]) == "^" and '(' in Dict:
            Dict = '$name('  +  Dict  +  ')'
        Key = str(self.Key.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set @' + str(Dict) + '@(' + str(Key) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Dict = str(self.Dict.Mumps)
        if str(Dict[0]) == "@":
            Dict = '$name('  +  Dict  +  ')'
        elif str(Dict[0]) == "^" and '(' in Dict:
            Dict = '$name('  +  Dict  +  ')'
        Key = str(self.Key.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set @' + str(Dict) + '@(' + str(Key) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Dict')
        self.Dict = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Key')
        self.Key = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'dict.assign' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Dict = str(self.Dict.Gs)
        Key = str(self.Key.Gs)
        Value = str(self.Value.Gs)
        Code = 'dict ' + str(Dict) + ' ' + str(Key) + ' = ' + str(Value) + ';'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Gen = str(self.Dict.Javascript) + '[' + str(self.Key.Javascript) + '] = ' + str(self.Value.Javascript) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Dict.Python) + '[' + str(self.Key.Python) + '] = ' + str(self.Value.Python)
        self.Python = Gen
        return True
class Statement_Diff (Line_Statement):
    Gal_Keyword = 'diff'
    Gs_Keyword = 'diff'
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Name = None
        self.From = None
        self.To = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument From')
        self.From = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument To')
        self.To = self.Listargs.pop(0)
class Statement_Dispatcher (Line_Statement):
    Gal_Keyword = 'dispatcher'
    Gs_Keyword = 'dispatcher'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Method = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Python(self):
        Name = str(self.Name.Python)
        Method = str(self.Method.Python)
        Code = str(Name) + ' = getattr(self, ' + str(Method) + ')'
        self.Python = Code
        return True
class Statement_Dispatchers (Line_Statement):
    Gal_Keyword = 'dispatchers'
    Gs_Keyword = 'dispatchers'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Python(self):
        Name = str(self.Name.Python)
        Args = ''
        Between = ''
        Argument = None
        for Argument in self.Listargs:
            Args += str(Between) + "'" + str(Argument.Python) + "'"
            Between = ', '
        Code = str(Name) + ' = [' + str(Args) + ']'
        self.Python = Code
        return True
class Statement_Distribute (Line_Statement):
    Gal_Keyword = 'distribute'
    Gs_Keyword = 'distribute'
    def __init__(self):
        super().__init__()
        self.List = None
        self.Function = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Function')
        self.Function = self.Listargs.pop(0)
    def Infer_Javascript(self):
        List = str(self.List.Javascript)
        Function = str(self.Function.Javascript)
        Code = 'var distribute = new parallel(' + str(List) + ');' + str('\n') + 'distribute.map(' + str(Function) + ');'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        List = str(self.List.Python)
        Function = str(self.Function.Python)
        Code = 'mp.Pool(mp.cpu_count()).map(' + str(Function) + ', ' + str(List) + ')'
        self.Python = Code
        return True
class Statement_Divide (Line_Statement):
    Gal_Keyword = '/='
    Gs_Keyword = '/='
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' /= ' + str(self.Python_Args(' / '))
        self.Python = Gen
        return True
class Statement_Do (Line_Statement):
    Gal_Keyword = 'do'
    Gs_Keyword = 'do'
    def __init__(self):
        super().__init__()
        self.Doarg = None
    def Infer_Mumps(self):
        Verbose = False
        Doarg = str(self.Doarg.Mumps)
        Code = str("    ") + 'do @' + str(Doarg) + str('\n')
        if Verbose:
            print("    do @ ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Doarg = str(self.Doarg.Mumps)
        Code = str("    ") + 'do @' + str(Doarg) + str('\n')
        if Verbose:
            print("    do @ ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Doarg')
        self.Doarg = self.Listargs.pop(0)
class Statement_Either (Line_Statement):
    Gal_Keyword = 'either'
    Gs_Keyword = 'either'
    def __init__(self):
        super().__init__()
        self.Rule_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rule_Name')
        self.Rule_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Verbose = False
        Rule_Name = str(self.Rule_Name.Fallback)
        Declarations = ''
        Quoted_Input = str(self.Enquote(self.Get_Input()))
        Block = 'comment ' + str(Quoted_Input) + ';' + str('\n')
        if Verbose:
            Block += 'verbosity [true];' + str('\n') + 'verbose "Parse " ' + str(Quoted_Input) + ';' + str('\n')
        Argument = None
        for Argument in self.Listargs:
            if Verbose:
                Block += 'verbose [indent] ' + str(self.Enquote('Either '  +  Rule_Name  +  ' trying '  +  Argument.Get_Input())) + ';' + str('\n')
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            if isinstance(Argument, Token_Quote) or isinstance(Argument, Syntax_Line):
                Block += 'quit : (i Parse_Token Parent_Elements ' + str(Argument.Fallback) + ') [true];' + str('\n')
            elif isinstance(Argument, Token):
                Block += 'quit : (i Parse_' + str(Argument.Fallback) + ' Parent_Elements) [true];' + str('\n')
            else:
                Block += str(Argument.Fallback)
        if Verbose:
            Block += 'verbose "FAILED " ' + str(Quoted_Input) + ';' + str('\n')
        Block = self.Indent(Block)
        Code = 'method flag Parse_' + str(Rule_Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str(Block) + str("    ") + 'return [false];' + str('\n') + '}'
        self.Fallback_Declaration = Declarations
        self.Fallback = Code
        return True
    def Infer_Parse(self):
        Declarations = ''
        Block = 'comment ' + str(self.Enquote(self.Get_Input())) + ';' + str('\n')
        Argument = None
        for Argument in self.Listargs:
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            if isinstance(Argument, Token_Quote) or isinstance(Argument, Syntax_Line):
                Block += 'returnif (i Parse_Token Parent_Elements ' + str(Argument.Fallback) + ') [true];' + str('\n')
            elif isinstance(Argument, Token):
                Block += 'returnif (i Parse_' + str(Argument.Fallback) + ' Parent_Elements) [true];' + str('\n')
            else:
                Block += str(Argument.Fallback)
        Block = self.Indent(Block)
        Code = 'method flag Parse_' + str(self.Rule_Name.Fallback) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str(Block) + str("    ") + 'return [false];' + str('\n') + '}'
        self.Fallback_Declaration = Declarations
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Statement_Element (Line_Statement):
    Gal_Keyword = 'element'
    Gs_Keyword = 'element'
    def __init__(self):
        super().__init__()
        self.Id = None
        self.Class_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Id')
        self.Id = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Gs(self):
        Code = 'element' + str(self.Gs_Arguments()) + ';'
        self.Gs = Code
        return True
    def Infer_Fallback(self):
        Verbose = False
        Id = str(self.Id.Fallback)
        Class_Name = str(self.Class_Name.Fallback)
        Tail = None
        Elem = None
        Elems = []
        Code = "Elem = (new " + str(Class_Name) + ");" + str('\n') + "Elem.Id = " + str(self.Enquote(Id)) + ";" + str('\n')
        if Verbose:
            print("Code: ", '\n', Code, sep='')
        Level = None
        Property = None
        Pargs = None
        Arg_Code = None
        Between = None
        for Tail in self.Listargs:
            Level = 0
            Property = ""
            Pargs = ""
            for Elem in Tail.Elements:
                if Level == 1:
                    Property = Elem.Fallback
                elif Level > 1:
                    Pargs += ' ' + str(Elem.Fallback)
                Level += 1
            if Level > 3:
                Pargs = ' (append'  +  Pargs  +  ')'
            Arg_Code = "Elem."  +  Property  +  " ="  +  Pargs  +  ";"  +  '\n'
            if Verbose:
                print(Arg_Code)
            Code += str(Arg_Code)
        Code += "push [my Cases] Elem;" + str('\n')
        if Verbose:
            print("element statement voila")
        self.Fallback = Code
        return True
class Statement_Else (Conditional_Statement):
    Gal_Keyword = 'else'
    Gs_Keyword = 'else'
    def Infer_Mumps(self):
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str(Block) + str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str(Block) + str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'else' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'else' + str(self.Python_Block())
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'else' + str(self.C_Block())
        self.C = Gen
        return True
class Statement_Else_If (Conditional_Statement):
    Gal_Keyword = 'else.if'
    Gs_Keyword = 'else.if'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Infer_Mumps(self):
        Arguments = str(self.Mumps_Arguments())
        Else_Label = str(Mumps.Get_Label())
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'if ' + str(Arguments) + str('\n') + str("    ") + 'else  goto ' + str(Else_Label) + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Else_Label) + ' ; else-if-else' + str('\n')
        if self.Is_Last:
            Code += str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Arguments = str(self.Mumps_Arguments())
        Else_Label = str(Mumps.Get_Label())
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'if ' + str(Arguments) + str('\n') + str("    ") + 'else  goto ' + str(Else_Label) + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Else_Label) + ' ; else-if-else' + str('\n')
        if self.Is_Last:
            Code += str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'else.if' + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'else if' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'else if (' + str(self.Condition.Javascript) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'elif ' + str(self.Condition.Python) + str(self.Python_Block())
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'else if (' + str(self.Condition.C) + ')' + str(self.C_Block())
        self.C = Gen
        return True
class Statement_English (Scoped_Statement):
    Gal_Keyword = 'english'
    Gs_Keyword = 'english'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Gen = 'comment English' + str(self.Fallback_Arguments()) + ';'
        self.Fallback = Gen
        return True
class Statement_Entity (Class_Statement):
    Gal_Keyword = 'entity'
    Gs_Keyword = 'entity'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Parent_Class = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Parent_Class = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = 'Entity_' + str(self.Name.Fallback)
        Parent_Class = "Entity"
        if self.Parent_Class is not None:
            Parent_Class = self.Parent_Class.Fallback
        Declaration = ''
        Statement = None
        try:
            for Statement in self.Block.Statements:
                if Statement.Fallback_Declaration is not None:
                    Declaration += str(Statement.Fallback_Declaration)
        except Exception:
            pass
        Code = str(Declaration) + str('\n') + 'class ' + str(Name) + ' [is ' + str(Parent_Class) + ']' + str(self.Fallback_Block())
        self.Fallback = Code
        return True
class Statement_Entities (Line_Statement):
    Gal_Keyword = 'entities'
    Gs_Keyword = 'entities'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
class Statement_Entity_New (Line_Statement):
    Gal_Keyword = 'entity.new'
    Gs_Keyword = 'entity.new'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Class = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
    def Infer_Fallback(self):
        zdebug.zbreak()
        Variable = str(self.Variable.Fallback)
        Class = str(self.Class.Fallback)
        Code = 'object ' + str(Variable) + ' (new ' + str(Class) + str(self.Fallback_Args()) + ');'
        self.Fallback = Code
        return True
class Statement_Error (Line_Statement):
    Gal_Keyword = 'error'
    Gs_Keyword = 'error'
    def Infer_Mumps(self):
        Error_Code = '"U:"_' + str(self.Mumps_Arguments('_'))
        Code = str("    ") + 'set $ecode=' + str(Error_Code) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Error_Code = '"U:"_' + str(self.Mumps_Arguments('_'))
        Code = str("    ") + 'set $ecode=' + str(Error_Code) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'throw ' + str(self.Javascript_Args(' + ')) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'raise Exception(' + str(self.Python_String_Args(' + ')) + ')'
        self.Python = Gen
        return True
class Statement_Execute (Line_Statement):
    Gal_Keyword = 'execute'
    Gs_Keyword = 'execute'
    def __init__(self):
        super().__init__()
        self.Target = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Target')
        self.Target = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'eval(' + str(self.Target.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'exec(' + str(self.Target.Python) + ', globals())'
        self.Python = Gen
        return True
class Statement_Expect_String (Line_Statement):
    Gal_Keyword = 'expect.string'
    Gs_Keyword = 'expect.string'
    def __init__(self):
        super().__init__()
        self.Expected = None
        self.Actual = None
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Expected')
        self.Expected = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Actual')
        self.Actual = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Expected = str(self.Expected.Fallback)
        Actual = str(self.Actual.Fallback)
        Name = str(self.Name.Fallback)
        Code = 'increment Test_Count;' + str('\n') + 'if (' + str(Expected) + ' s= ' + str(Actual) + ')' + str('\n') + '{' + str('\n') + str("    ") + 'increment Test_Success;' + str('\n') + '}' + str('\n') + 'else' + str('\n') + '{' + str('\n') + str("    ") + '''verbose "''' + str(Name) + ''' expected {" ''' + str(Expected) + ''' "} s= actual {" ''' + str(Actual) + ''' "}";''' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Expect_Equal (Line_Statement):
    Gal_Keyword = 'expect.='
    Gs_Keyword = 'expect.='
    def __init__(self):
        super().__init__()
        self.Expected = None
        self.Actual = None
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Expected')
        self.Expected = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Actual')
        self.Actual = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Expected = str(self.Expected.Fallback)
        Actual = str(self.Actual.Fallback)
        Name = str(self.Name.Fallback)
        Code = 'increment Test_Count;' + str('\n') + 'if (' + str(Expected) + ' = ' + str(Actual) + ')' + str('\n') + '{' + str('\n') + str("    ") + 'increment Test_Success;' + str('\n') + '}' + str('\n') + 'else' + str('\n') + '{' + str('\n') + str("    ") + '''verbose "''' + str(Name) + ''' expected {" ''' + str(Expected) + ''' "} = actual {" ''' + str(Actual) + ''' "}";''' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Expected_Output (Line_Statement):
    Gal_Keyword = 'expected.output'
    Gs_Keyword = 'expected.output'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Arguments = str(self.Fallback_Arguments())
        Code = 'method flag Test' + str('\n') + '{' + str('\n') + str("    ") + 'string Expected_Output ' + str(Arguments) + ';' + str('\n') + str("    ") + 'return ([output] s= Expected_Output);' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Experience (Line_Statement):
    Gal_Keyword = 'experience'
    Gs_Keyword = 'experience'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
        self.Code = None
        self.Performance = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Code')
        self.Code = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Performance')
        self.Performance = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Class_Name = str(self.Class_Name.Fallback)
        My_Code = str(self.Code.Fallback)
        Performance = str(self.Performance.Fallback)
        Arg = None
        Code = 'Item = (new Experience ' + str(self.Enquote(Class_Name)) + ' ' + str(My_Code) + ' ' + str(Performance) + ');' + str('\n') + 'push Experiences Item;'
        for Arg in self.Listargs:
            Code += str('\n') + 'push [Item.Dials] ' + str(Arg.Fallback) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Export_Memory (Line_Statement):
    Gal_Keyword = 'export.memory'
    Gs_Keyword = 'export.memory'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'comment "Export Memory";'
        Argument = None
        for Argument in self.Listargs:
            Code += str('\n') + "Runtime:Export_Memory " + str(self.Enquote(Argument.Fallback)) + ';'
        self.Fallback = Code
        return True
class Statement_Fallback (Method_Statement):
    Gal_Keyword = 'fallback'
    Gs_Keyword = 'fallback'
    def Get_Language_Name(self):
        return 'Fallback'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'method void Infer_Fallback' + str('\n') + '{' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        else:
            Argument = None
            Args_Code = ''
            for Argument in self.Arguments:
                if isinstance(Argument, Token_Name):
                    Args_Code += ' ' + str('[my '  +  Argument.Fallback  +  ' Reference]')
                else:
                    Args_Code += ' ' + str(Argument.Fallback)
            Code += str("    ") + 'string Code' + str(Args_Code) + ';' + str('\n') + str("    ") + 'my= Fallback Code;' + str('\n')
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Fallback_Equal (Line_Statement):
    Gal_Keyword = 'fallback='
    Gs_Keyword = 'fallback='
    def Get_Language_Name(self):
        return 'Fallback'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Code = ''
        if len(self.Arguments) > 1:
            Code += 'Case.Fallback = (append' + str(Args) + ');'
        else:
            Code += 'Case.Fallback = ' + str(Args) + ';'
        self.Fallback = Code
        return True
class Statement_Feature (Feature_Statement):
    Gal_Keyword = 'feature'
    Gs_Keyword = 'feature'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Keyword = None
        self.Symbol_Class = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Symbol_Class')
        self.Symbol_Class = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'feature ' + str(self.Type.Gal) + ' ' + str(self.Name.Gal) + ' ' + str(self.Keyword.Gal) + ' ' + str(self.Symbol_Class.Gal) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'feature ' + str(self.Type.Gs) + ' ' + str(self.Name.Gs) + ' ' + str(self.Keyword.Gs) + ' ' + str(self.Symbol_Class.Gs) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Type = str(self.Type.Fallback)
        Name = str(self.Name.Fallback)
        Keyword = str(self.Keyword.Fallback)
        Symbol_Class = "Symbol"
        if self.Symbol_Class is not None:
            Symbol_Class = self.Symbol_Class.Fallback
        Declaration = 'symbol ' + str(Type) + ' ' + str(Name) + ' ' + str(Symbol_Class) + str(self.Fallback_Block()) + str('\n') + 'statement ' + str(Name) + ' ' + str(Keyword) + ' Feature' + str('\n') + '{' + str('\n') + str("    ") + 'property string Property_Name ' + str(self.Enquote(Name)) + ';' + str('\n') + str("    ") + 'argument Value;' + str('\n') + '}' + str('\n')
        self.Fallback = Declaration
        return True
class Statement_File_Append (Line_Statement):
    Gal_Keyword = 'file.append'
    Gs_Keyword = 'file.append'
    def __init__(self):
        super().__init__()
        self.File_Text = None
        self.File_Name = None
    def Infer_Mumps(self):
        Verbose = False
        File_Text = str(self.File_Text.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'use ' + str(File_Name) + ' write ' + str(File_Text)
        if Verbose:
            print("    file append ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        File_Text = str(self.File_Text.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'use ' + str(File_Name) + ' write ' + str(File_Text)
        if Verbose:
            print("    file append ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Text')
        self.File_Text = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'gal.file_reader.writeFileSync(' + str(self.File_Name.Javascript) + ', ' + str(self.File_Text.Javascript) + ', "a");'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = '_FH = open(' + str(self.File_Name.Python) + ', "a")' + str('\n') + '_FH.write(' + str(self.File_Text.Python) + ')' + str('\n') + '_FH.close()'
        self.Python = Gen
        return True
class Statement_File_Delete (Line_Statement):
    Gal_Keyword = 'file.delete'
    Gs_Keyword = 'file.delete'
    def __init__(self):
        super().__init__()
        self.File_Name = None
    def Infer_Mumps(self):
        Path = str(self.Path.Mumps)
        Code = str('\n') + 'do filedelete^gal(' + str(Path) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Path = str(self.Path.Mumps)
        Code = str('\n') + 'do filedelete^gal(' + str(Path) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'fs.unlinkSync(' + str(self.File_Name.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'os.remove(' + str(self.File_Name.Python) + ')'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'Runtime:File_Delete ' + str(self.File_Name.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_File_Dump (Line_Statement):
    Gal_Keyword = 'file.dump'
    Gs_Keyword = 'file.dump'
    def __init__(self):
        super().__init__()
        self.File_Text = None
        self.File_Name = None
    def Infer_Mumps(self):
        File_Text = str(self.File_Text.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'do filedump^gal(' + str(File_Text) + ',' + str(File_Name) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        File_Text = str(self.File_Text.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'do filedump^gal(' + str(File_Text) + ',' + str(File_Name) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Text')
        self.File_Text = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'file.dump' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'file dump' + str(self.Gs_Arguments()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'gal.file_reader.writeFileSync(' + str(self.File_Name.Javascript) + ', ' + str(self.File_Text.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'gal.file_reader.writeFileSync(' + str(self.File_Name.Javascript) + ', ' + str(self.File_Text.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = '_FH = open(' + str(self.File_Name.Python) + ', "w")' + str('\n') + '_FH.write(' + str(self.File_Text.Python) + ')' + str('\n') + '_FH.close()'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'Runtime:File_Dump ' + str(self.File_Text.Fallback) + ' ' + str(self.File_Name.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_File_Readall (Line_Statement):
    Gal_Keyword = 'file.readall'
    Gs_Keyword = 'file.readall'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.File_Name = None
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$$filereadall^gal(' + str(File_Name) + ')' + str('\n')
        if Verbose:
            print('mumps file readall')
        if Verbose:
            print(Code)
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$$filereadall^gal(' + str(File_Name) + ')' + str('\n')
        if Verbose:
            print('mumps file readall')
        if Verbose:
            print(Code)
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'file.readall' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'file read all' + str(self.Gs_Arguments()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Varname = str(self.Variable.Javascript)
        File_Name = str(self.File_Name.Javascript)
        Code = str(Varname) + ' = gal.file_reader.readFileSync(' + str(File_Name) + ",'utf8');"
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = '_FH = open(' + str(self.File_Name.Python) + ', "r", encoding="utf8")' + str('\n') + str(self.Variable.Python) + ' = _FH.read()' + str('\n') + '_FH.close()'
        self.Python = Gen
        return True
class Statement_File_Read_Line (Line_Statement):
    Gal_Keyword = 'file.readline'
    Gs_Keyword = 'file.readline'
    def __init__(self):
        super().__init__()
        self.File_Name = None
        self.Variable = None
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$$filereadline^gal(' + str(File_Name) + ')' + str('\n')
        if Verbose:
            print('mumps file readline')
        if Verbose:
            print(Code)
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        File_Name = str(self.File_Name.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$$filereadline^gal(' + str(File_Name) + ')' + str('\n')
        if Verbose:
            print('mumps file readline')
        if Verbose:
            print(Code)
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
class Statement_File_Read_List (Line_Statement):
    Gal_Keyword = 'file.readlist'
    Gs_Keyword = 'file.readlist'
    def __init__(self):
        super().__init__()
        self.File = None
        self.Text = None
        self.List = None
    def Infer_Mumps(self):
        Verbose = False
        Text = str(self.Text.Mumps)
        File = str(self.File.Mumps)
        List = str(self.List.Mumps)
        LC = str(List[0])
        if str(LC) == '@' or str(LC) == '^':
            List = '$name('  +  List  +  ')'
        Code = str("    ") + 'set ' + str(Text) + '=$$filereadlist^gal(' + str(File) + ',' + str(List) + ')' + str('\n')
        if Verbose:
            print('mumps file readline')
        if Verbose:
            print(Code)
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Text = str(self.Text.Mumps)
        File = str(self.File.Mumps)
        List = str(self.List.Mumps)
        LC = str(List[0])
        if str(LC) == '@' or str(LC) == '^':
            List = '$name('  +  List  +  ')'
        Code = str("    ") + 'set ' + str(Text) + '=$$filereadlist^gal(' + str(File) + ',' + str(List) + ')' + str('\n')
        if Verbose:
            print('mumps file readline')
        if Verbose:
            print(Code)
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File')
        self.File = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Text')
        self.Text = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
class Statement_Flag (Declaration_Statement):
    Gal_Keyword = 'flag'
    Gs_Keyword = 'flag'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'flag' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Variable = str(self.Variable.Gs)
        Code = 'flag ' + str(Variable)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.Gs)
        Code += ';'
        self.Gs = Code
        return True
    def Infer_C(self):
        Code = 'bool ' + str(self.Variable.C)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.C)
        Code += ';'
        self.C = Code
        return True
class Statement_Flags (Line_Statement):
    Gal_Keyword = 'flags'
    Gs_Keyword = 'flags'
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'flag ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Flowerbox (Comment_Statement):
    Gal_Keyword = 'flowerbox'
    Gs_Keyword = 'flowerbox'
    def Attributes(self):
        pass
    def Infer_Gal(self):
        Gen = 'flowerbox' + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'flower box' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Comment_Text = ''
        Argument = None
        for Argument in self.Arguments:
            Arg_Text = str(Argument.Fallback)
            if isinstance(Argument, Token_Quote):
                Arg_Text = Argument.Unquoted()
            Comment_Text += str(Arg_Text)
        Lines = Comment_Text.split('\n')
        Comment_Text = ''
        Line = None
        Full = None
        Width = 0
        for Line in Lines:
            if len(Line) > Width:
                Width = len(Line)
        for Line in Lines:
            Full = Line  +  '                                                                                                          '
            Full = Full[0:(0)+(Width)]
            Full = '* '  +  Full  +  ' *'
            Comment_Text += ' ' + str(self.Enquote(Full)) + ' [line]'
        Width += 4
        Stars = '"' + str("****************************************************************************************************************"[0:(0)+(Width)]) + '"'
        Comment_Text = Stars  +  ' [line] '  +  Comment_Text  +  ' '  +  Stars
        Code = 'comment ' + str(Comment_Text) + ';'
        self.Fallback = Code
        return True
    def Infer_Data_Types(self):
        self.Argument_Types('string')
        return True
class Statement_For_Down (Iterative_Statement):
    Gal_Keyword = 'for.down'
    Gs_Keyword = 'for.down'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Start = None
        self.End = None
        self.Decrement = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Start')
        self.Start = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument End')
        self.End = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Decrement = self.Listargs.pop(0)
    def Infer_C(self):
        Variable = str(self.Variable.C)
        Start = str(self.Start.C)
        End = str(self.End.C)
        Increment = str(Variable) + '--'
        if self.Decrement is not None:
            Increment = Variable  +  '-='  +  self.Decrement.C
        Block = str(self.C_Statements())
        Code = 'for (' + str(Variable) + '=' + str(Start) + '; ' + str(Variable) + '>=' + str(End) + '; ' + str(Increment) + ')' + str('\n') + '{' + str('\n') + str(Block) + '}'
        self.C = Code
        return True
class Statement_Foreach (Iterative_Statement):
    Gal_Keyword = 'foreach'
    Gs_Keyword = 'foreach'
    def __init__(self):
        super().__init__()
        self.List = None
        self.Variable = None
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('foreach ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Variable = str(self.Variable.Mumps)
        Index = str(Mumps.Get_Variable())
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each ' + str(Variable) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '))' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Variable) + '=@' + str(List) + '@(' + str(Index) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each ' + str(Variable) + ' break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('foreach ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Variable = str(self.Variable.Mumps)
        Index = str(Mumps.Get_Variable())
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each ' + str(Variable) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '))' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Variable) + '=@' + str(List) + '@(' + str(Index) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each ' + str(Variable) + ' break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'foreach' + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'for (' + str(self.Variable.Javascript) + ' of ' + str(self.List.Javascript) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'for ' + str(self.Variable.Python) + ' in ' + str(self.List.Python) + str(self.Python_Block())
        self.Python = Gen
        return True
    def Infer_C(self):
        List = str(self.List.C)
        Variable = str(self.Variable.C)
        Loop_Var = str(C.Get_Variable())
        Statements = str(self.C_Statements())
        Code = 'for (int ' + str(Loop_Var) + '=0; ' + str(Loop_Var) + ' < top_' + str(List) + '; ' + str(Loop_Var) + '++)' + str('\n') + '{' + str('\n') + str("    ") + str(Variable) + ' = ' + str(List) + '[' + str(Loop_Var) + '];' + str('\n') + str(Statements) + '}'
        self.C = Code
        return True
class Statement_For_Each_Key (Iterative_Statement):
    Gal_Keyword = 'foreachkey'
    Gs_Keyword = 'foreachkey'
    def __init__(self):
        super().__init__()
        self.List = None
        self.Variable = None
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('for each key ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Index = str(self.Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each key ' + str(Index) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '))' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each key ' + str(Index) + ' break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('for each key ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Index = str(self.Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each key ' + str(Index) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '))' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each key ' + str(Index) + ' break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
class Statement_For_Each_In (Iterative_Statement):
    Gal_Keyword = 'for.each.in'
    Gs_Keyword = 'for.each.in'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.List = None
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('for each in ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Variable = str(self.Variable.Mumps)
        Index = str(Mumps.Get_Variable())
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each in ' + str(Variable) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '))' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Variable) + '=@' + str(List) + '@(' + str(Index) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each in ' + str(Variable) + ' break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('for each in ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Variable = str(self.Variable.Mumps)
        Index = str(Mumps.Get_Variable())
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each in ' + str(Variable) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '))' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Variable) + '=@' + str(List) + '@(' + str(Index) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each in ' + str(Variable) + ' break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
    def Infer_Gs(self):
        Variable = str(self.Variable.Gs)
        List = str(self.List.Gs)
        Code = 'for each ' + str(Variable) + ' in ' + str(List) + str(self.Gs_Block())
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Gen = "for (" + str(self.Variable.Javascript) + " of " + str(self.List.Javascript) + ")" + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'for each ' + str(self.List.Fallback) + ' ' + str(self.Variable.Fallback) + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Statement_For_Prev_Key (Iterative_Statement):
    Gal_Keyword = 'forprevkey'
    Gs_Keyword = 'forprevkey'
    def __init__(self):
        super().__init__()
        self.List = None
        self.Variable = None
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('for each prev key ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Index = str(self.Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each key ' + str(Index) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '),-1)' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each prev key ' + str(Index) + ' break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Type = ''
        Meth_Context = self.Method_Context()
        if List in Meth_Context.Variables.keys():
            Type = Meth_Context.Variables[List]
            if Verbose:
                print('for each prev key ', List, ' is a ', Type, sep='')
        if str(Type) != 'list':
            List = '$name('  +  List  +  ')'
        Index = str(self.Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Index) + '=""' + str('\n') + str(Continue_Label) + ' ; for each key ' + str(Index) + ' continue' + str('\n') + str("    ") + 'set ' + str(Index) + '=$order(@' + str(List) + '@(' + str(Index) + '),-1)' + str('\n') + str("    ") + 'goto:' + str(Index) + '="" ' + str(Break_Label) + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; for each prev key ' + str(Index) + ' break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
class Statement_Forever (Iterative_Statement):
    Gal_Keyword = 'forever'
    Gs_Keyword = 'forever'
    def Infer_Mumps(self):
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str(Continue_Label) + ' ; forever continue' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; forever break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str(Continue_Label) + ' ; forever continue' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; forever break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'while (true)' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'while True' + str(self.Python_Block())
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'while (true)' + str(self.C_Block())
        self.C = Gen
        return True
class Statement_Forgive (Scoped_Statement):
    Gal_Keyword = 'forgive'
    Gs_Keyword = 'forgive'
    def Infer_Mumps(self):
        Catch_Label = str(Mumps.Get_Label())
        Statements = str(self.Mumps_Block())
        Code = str("    ") + 'new $etrap,$estack' + str('\n') + str("    ") + 'set $etrap="quit:$estack  goto ' + str(Catch_Label) + '"' + str('\n') + str(Statements) + str(Catch_Label) + ' ; Error handler.' + str('\n') + str("    ") + 'set %ecode=$zstatus,$ecode="",$zstatus=""' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Catch_Label = str(Mumps.Get_Label())
        Statements = str(self.Mumps_Block())
        Code = str("    ") + 'new $etrap,$estack' + str('\n') + str("    ") + 'set $etrap="quit:$estack  goto ' + str(Catch_Label) + '"' + str('\n') + str(Statements) + str(Catch_Label) + ' ; Error handler.' + str('\n') + str("    ") + 'set %ecode=$zstatus,$ecode="",$zstatus=""' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'try' + str(self.Javascript_Block()) + str('\n') + 'catch' + str('\n') + '{' + str('\n') + '}'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'try' + str(self.Python_Block()) + str('\n') + 'except Exception:' + str('\n') + str("    ") + 'pass'
        self.Python = Gen
        return True
class Statement_For_Range (Iterative_Statement):
    Gal_Keyword = 'for.range'
    Gs_Keyword = 'for.range'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Start = None
        self.End = None
        self.Increment = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Start = str(self.Start.Mumps)
        End = str(self.End.Mumps)
        Increment = '1'
        Continue = str(self.Continue_Label())
        Break = str(self.Break_Label())
        Begin = str(Mumps.Get_Label())
        if self.Increment is not None:
            Increment = self.Increment.Mumps
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Start) + str('\n') + str("    ") + 'goto:$select(' + str(Increment) + '<0:' + str(Variable) + '<' + str(End) + ',1:' + str(Variable) + '>' + str(End) + ') ' + str(Break) + str('\n') + str("    ") + 'goto ' + str(Begin) + str('\n') + str(Continue) + ' ; for range continue' + str('\n') + str("    ") + 'goto:$select(' + str(Increment) + '<0:' + str(Variable) + '+' + str(Increment) + '<' + str(End) + ',1:' + str(Variable) + '+' + str(Increment) + '>' + str(End) + ') ' + str(Break) + str('\n') + str("    ") + 'set ' + str(Variable) + '=' + str(Variable) + '+' + str(Increment) + str('\n') + str(Begin) + ' ; for ' + str(Variable) + ' range begin' + str('\n') + str(Block) + str("    ") + 'goto ' + str(Continue) + str('\n') + str(Break) + ' ; for ' + str(Variable) + ' range break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Start = str(self.Start.Mumps)
        End = str(self.End.Mumps)
        Increment = '1'
        Continue = str(self.Continue_Label())
        Break = str(self.Break_Label())
        Begin = str(Mumps.Get_Label())
        if self.Increment is not None:
            Increment = self.Increment.Mumps
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Start) + str('\n') + str("    ") + 'goto:$select(' + str(Increment) + '<0:' + str(Variable) + '<' + str(End) + ',1:' + str(Variable) + '>' + str(End) + ') ' + str(Break) + str('\n') + str("    ") + 'goto ' + str(Begin) + str('\n') + str(Continue) + ' ; for range continue' + str('\n') + str("    ") + 'goto:$select(' + str(Increment) + '<0:' + str(Variable) + '+' + str(Increment) + '<' + str(End) + ',1:' + str(Variable) + '+' + str(Increment) + '>' + str(End) + ') ' + str(Break) + str('\n') + str("    ") + 'set ' + str(Variable) + '=' + str(Variable) + '+' + str(Increment) + str('\n') + str(Begin) + ' ; for ' + str(Variable) + ' range begin' + str('\n') + str(Block) + str("    ") + 'goto ' + str(Continue) + str('\n') + str(Break) + ' ; for ' + str(Variable) + ' range break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Start')
        self.Start = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument End')
        self.End = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Increment = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'for.range' + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '''for range''' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Variable = str(self.Variable.Javascript)
        Start = str(self.Start.Javascript)
        End = str(self.End.Javascript)
        Increment = ''
        if self.Increment is not None:
            Increment += ' += ' + str(self.Increment.Javascript)
        else:
            Increment += '++'
        Code = 'for (' + str(Variable) + '=' + str(Start) + '; ' + str(Variable) + '<=' + str(End) + '; ' + str(Variable) + str(Increment) + ')' + str(self.Javascript_Block())
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Variable = str(self.Variable.Python)
        Start = str(self.Start.Python)
        End = str(self.End.Python)
        Increment = ''
        if self.Increment is not None:
            Increment += ', ' + str(self.Increment.Python)
        Code = 'for ' + str(Variable) + ' in range(' + str(Start) + ',(' + str(End) + ')+1' + str(Increment) + ')' + str(self.Python_Block())
        self.Python = Code
        return True
    def Infer_C(self):
        Variable = str(self.Variable.C)
        Start = str(self.Start.C)
        End = str(self.End.C)
        Increment = str(Variable) + '++'
        if self.Increment is not None:
            Increment = Variable  +  '+='  +  self.Increment.C
        Block = str(self.C_Statements())
        Code = 'for (' + str(Variable) + '=' + str(Start) + '; ' + str(Variable) + '<=' + str(End) + '; ' + str(Increment) + ')' + str('\n') + '{' + str('\n') + str(Block) + '}'
        self.C = Code
        return True
class Statement_Function_Invoke (Line_Statement):
    Gal_Keyword = 'invoke'
    Gs_Keyword = 'invoke'
    def __init__(self):
        super().__init__()
        self.Function = None
    def Infer_Mumps(self):
        Function = str(self.Function.Mumps)
        Arguments = str(self.Mumps_Listargs())
        Code = str("    ") + 'do ' + str(Function) + '(' + str(Arguments) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Function = str(self.Function.Mumps)
        Arguments = str(self.Mumps_Listargs())
        Code = str("    ") + 'do ' + str(Function) + '(' + str(Arguments) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Function')
        self.Function = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Function.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Function.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Function = str(self.Function.C)
        Arguments = str(self.C_Args(', '))
        Code = str(Function) + '(' + str(Arguments) + ');'
        self.C = Code
        return True
    def Infer_Data_Types(self):
        self.Function.Data_Type = 'method'
        self.Function.Usage = 'method'
        return True
class Statement_Gal (Method_Statement):
    Gal_Keyword = 'gal'
    Gs_Keyword = 'gal'
    def Attributes(self):
        pass
class Statement_Gal_Equal (Line_Statement):
    Gal_Keyword = 'gal='
    Gs_Keyword = 'gal='
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Expr = ''
        if len(self.Arguments) > 1:
            Expr += ' (append' + str(Args) + ')'
        else:
            Expr += str(Args)
        Code = 'Case = (Cases:Lookup_Case' + str(Args) + ');'
        self.Fallback = Code
        return True
class Statement_Generate (Statement):
    Gal_Keyword = 'generate'
    Gs_Keyword = 'generate'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
        self.Variables = {}
    def Method_Context(self):
        return self
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Class_Name = None
        Property_Name = None
        if self.Second is not None:
            Class_Name = self.First.Javascript
            Property_Name = self.Second.Javascript
        else:
            Class_Name = 'this.constructor'
            Context = self.Method_Context()
            if Context and isinstance(Context, Class_Method_Statement):
                Class_Name = 'this'
            Property_Name = self.First.Javascript
        Code = str(Class_Name) + '.' + str(Property_Name)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Class_Name = None
        Property_Name = None
        if self.Second is not None:
            Class_Name = self.First.Python
            Property_Name = self.Second.Python
        else:
            Class_Name = 'this.constructor'
            if self.Method_Context is not None and isinstance(self.Method_Context, Class_Method_Statement):
                Class_Name = 'this'
            Property_Name = self.First.Python
        Code = str(Class_Name) + '.' + str(Property_Name)
        self.Python = Code
        return True
    def Infer_Fallback(self):
        if (self.Get_Language_Name() in (None, "")):
            zdebug.zbreak()
            # comment "can't find the language name Class_Name";
        Language = str(self.Get_Language_Name())
        Class_Name = str(self.Class_Name.Fallback)
        Method_Prefix = ''
        Method_Suffix = ''
        if len(self.Listargs) > 0:
            Method_Prefix += str("    ") + 'string Code = '
            Argument = None
            for Argument in self.Listargs:
                if isinstance(Argument, Name_Token):
                    Method_Prefix += ' [my ' + str(Argument.Fallback) + ' ' + str(Language) + ']'
                else:
                    Method_Prefix += ' ' + str(Argument.Fallback)
            Method_Prefix += ';' + str('\n')
            Method_Suffix += str("    ") + 'my ' + str(Language) + ' = Code;' + str('\n')
        Method_Statements = str(Method_Prefix) + str(self.Fallback_Statements()) + str(Method_Suffix)
        Method_Code = 'method flag Infer_' + str(Language) + str('\n') + '{' + str('\n') + str(Method_Statements) + '}'
        Code = 'class set ' + str(Class_Name) + str('\n') + '{' + str('\n') + str(self.Indent(Method_Code)) + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Generate_Gal (Statement):
    Gal_Keyword = 'generate.gal'
    Gs_Keyword = 'generate.gal'
    def Method_Context(self):
        return self
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Verbose = False
        if Verbose:
            print("Generate_Gal")
        Code = "comment 'generate gal statement';" + str('\n') + "string Output '';" + str('\n')
        Argument = None
        Arg_Code = None
        for Argument in self.Arguments:
            Arg_Code = 'append Output '  +  Argument.Fallback  +  ';'  +  '\n'
            Code += str(Arg_Code)
        Code += 'my= Gal Output;' + str('\n')
        if Verbose:
            print(Code)
        self.Fallback = Code
        return True
class Statement_Generator (Scoped_Statement):
    Gal_Keyword = 'generator'
    Gs_Keyword = 'generator'
    def __init__(self):
        super().__init__()
        self.Language = None
    def Get_Language_Name(self):
        return self.Language.Get_Input()
    def Get_Property_Name(self):
        return self.Language.Get_Input()
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Language')
        self.Language = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Fallback_Statements = ''
        Fallback_Declaration = ''
        Statement = None
        for Statement in self.Block.Statements:
            Statement_Fb = str(Statement.Fallback)
            Statement_Dec = str(Statement.Fallback_Declaration)
            if isinstance(Statement, Statement_Generate):
                if (Statement_Dec is not None and str(Statement_Dec) > ""):
                    Fallback_Declaration += str(Statement_Dec)
                if (Statement_Fb is not None and str(Statement_Fb) > ""):
                    Fallback_Declaration += str(Statement_Fb)
            elif isinstance(Statement, Statement_Infers):
                if (Statement_Dec is not None and str(Statement_Dec) > ""):
                    Fallback_Declaration += str(Statement_Dec)
                if (Statement_Fb is not None and str(Statement_Fb) > ""):
                    Fallback_Declaration += str(Statement_Fb)
            elif isinstance(Statement, Statement_Inferences):
                if (Statement_Dec is not None and str(Statement_Dec) > ""):
                    Fallback_Declaration += str(Statement_Dec)
                if (Statement_Fb is not None and str(Statement_Fb) > ""):
                    Fallback_Declaration += str(Statement_Fb)
            else:
                if (Statement_Dec is not None and str(Statement_Dec) > ""):
                    Fallback_Declaration += str(Statement_Dec)
                if (Statement_Fb is not None and str(Statement_Fb) > ""):
                    Fallback_Declaration += str(Statement_Fb)
        Language = str(self.Language.Fallback)
        Class = str(Language) + '_Generator'
        Class_Definition = '''class ''' + str(Class) + str(''' [is Generator]'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    infers ''') + str(Language) + str(''';'''  +  '\n'  +  '''    property string Language_Name ''') + str(self.Enquote(Language)) + str(''';'''  +  '\n'  +  '''    property string Property_Name ''') + str(self.Enquote(Language)) + str(''';'''  +  '\n'  +  '''    attribute list Elements;'''  +  '\n'  +  '''    attribute list Inferences;'''  +  '\n'  +  '''    constructor [entity Owner]'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        my= Owner Owner;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    method flag Initialize'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        verbosity;'''  +  '\n'  +  '''        verbose [class.name] ' Inits';'''  +  '\n'  +  '''        infer.inits;'''  +  '\n'  +  '''        return [true];'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    method flag Infer_''') + str(Language) + str(''''''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        verbosity;'''  +  '\n'  +  '''        object Elem;'''  +  '\n'  +  '''        object I;'''  +  '\n'  +  '''        integer Number 0;'''  +  '\n'  +  '''        variant Error;'''  +  '\n'  +  '''        foreach [my Elements ~] Elem'''  +  '\n'  +  '''        {'''  +  '\n'  +  '''            try'''  +  '\n'  +  '''            {'''  +  '\n'  +  '''                I = [Elem.Classification];'''  +  '\n'  +  '''                I.Infer_''') + str(Language) + str(''';'''  +  '\n'  +  '''                Elem.''') + str(Language) + ''' = [I.''' + str(Language) + str('''];'''  +  '\n'  +  '''                Number++;'''  +  '\n'  +  '''            }'''  +  '\n'  +  '''            catch Error'''  +  '\n'  +  '''            {'''  +  '\n'  +  '''                my Status = [false];'''  +  '\n'  +  '''                Elem.Error = Error;'''  +  '\n'  +  '''                verbose 'Error ''') + str(Language) + str('''element ' Number ': ' [classname I] ', <' Error '>, source ' (. I Get_Input);'''  +  '\n'  +  '''            }'''  +  '\n'  +  '''        }'''  +  '\n'  +  '''        returnif (not [my Status]) [false];'''  +  '\n'  +  '''        object Top = (list last [my Elements ~]);'''  +  '\n'  +  '''        Top.Infer_''') + str(Language) + str(''';'''  +  '\n'  +  '''        string Code [Top.''') + str(Language) + str('''];'''  +  '\n'  +  '''        my ''') + str(Language) + str(''' = Code;'''  +  '\n'  +  '''        my Code = Code;'''  +  '\n'  +  '''        return [true];'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''}'''  +  '\n'  +  '''''')
        Statements_Code = str('''class set Statements'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    method flag Infer_''') + str(Language) + str(''''''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        string Code '';'''  +  '\n'  +  '''        object Statement;'''  +  '\n'  +  '''        foreach [my Elements] Statement'''  +  '\n'  +  '''        {'''  +  '\n'  +  '''            Code s+ [. Statement ''') + str(Language) + str('''] [line];'''  +  '\n'  +  '''        }'''  +  '\n'  +  '''        my ''') + str(Language) + str(''' = Code;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''}''') + str('\n')
        Inference = '''inference string ''' + str(Language) + str('\n') + '''{''' + str('\n') + '}' + str('\n') + str(Statements_Code) + str(Fallback_Statements)
        Code = str(Fallback_Declaration) + str(Class_Definition) + str(Inference)
        self.Fallback = Code
        return True
class Statement_Given_An_In (Iterative_Statement):
    Gal_Keyword = 'given.an.in'
    Gs_Keyword = 'given.an.in'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.List = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Variable = str(self.Variable.Fallback)
        List = str(self.List.Fallback)
        Code = 'for each ' + str(Variable) + ' in ' + str(List) + str(self.Fallback_Block())
        self.Fallback = Code
        return True
class Statement_Global_List (Line_Statement):
    Gal_Keyword = 'glist'
    Gs_Keyword = 'glist'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Code = str("    ") + 'new ' + str(Variable) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(@%matrix@($increment(@%matrix))),' + '@' + str(Variable) + '=' + str(len(self.Listargs)) + str('\n')
        Arg = None
        Item = 0
        for Arg in self.Listargs:
            Item += 1
            Value = str(Arg.Mumps)
            Code += str("    ") + 'set @' + str(Variable) + '@(' + str(Item) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Code = str("    ") + 'new ' + str(Variable) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(@%matrix@($increment(@%matrix))),' + '@' + str(Variable) + '=' + str(len(self.Listargs)) + str('\n')
        Arg = None
        Item = 0
        for Arg in self.Listargs:
            Item += 1
            Value = str(Arg.Mumps)
            Code += str("    ") + 'set @' + str(Variable) + '@(' + str(Item) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
class Statement_Glvn (Line_Statement):
    Gal_Keyword = 'glvn'
    Gs_Keyword = 'glvn'
    def __init__(self):
        super().__init__()
        self.Root = None
        self.Value = None
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Code = str("    ") + 'new ' + str(Root) + str('\n')
        if self.Value is not None:
            Value = str(self.Value.Mumps)
            Code += str("    ") + 'set ' + str(Root) + '=' + str(Value) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Code = str("    ") + 'new ' + str(Root) + str('\n')
        if self.Value is not None:
            Value = str(self.Value.Mumps)
            Code += str("    ") + 'set ' + str(Root) + '=' + str(Value) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
class Statement_Glvn_Global (Line_Statement):
    Gal_Keyword = 'glvn^'
    Gs_Keyword = 'glvn^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Statement_Gpu_Function (Scoped_Statement):
    Gal_Keyword = 'gf'
    Gs_Keyword = 'gf'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_C(self):
        # comment 'TODO:the gpu function needs to accept array pointers as arguments';
        Name = str(self.Name.C)
        Args = str(self.C_Args(', '))
        Code = '__global__ void ' + str(Name) + '(' + str(Args) + ')' + str(self.C_Block())
        self.C = Code
        return True
class Statement_Gpu_Invoke (Scoped_Statement):
    Gal_Keyword = 'gi'
    Gs_Keyword = 'gi'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Blocks = None
        self.Threads = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Blocks')
        self.Blocks = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Threads')
        self.Threads = self.Listargs.pop(0)
    def Infer_C(self):
        # comment 'TODO:the gpu function needs to accept array pointers as arguments';
        Name = str(self.Name.C)
        Blocks = str(self.Blocks.C)
        Threads = str(self.Threads.C)
        Args = str(self.C_Args(', '))
        Code = str(Name) + '<<<' + str(Blocks) + ', ' + str(Threads) + '>>>(' + str(Args) + ');'
        self.C = Code
        return True
class Statement_Gpu_Invoke_Method (Scoped_Statement):
    Gal_Keyword = 'gim'
    Gs_Keyword = 'gim'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Name = None
        self.Blocks = None
        self.Threads = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Blocks')
        self.Blocks = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Threads')
        self.Threads = self.Listargs.pop(0)
    def Infer_C(self):
        # comment 'TODO:the gpu method needs to accept property array pointers as arguments';
        Name = str(self.Name.C)
        Class_Name = str(self.Class.C)
        Blocks = str(self.Blocks.C)
        Threads = str(self.Threads.C)
        Args = str(self.C_Args(', '))
        Code = str(Class_Name) + '<<<' + str(Blocks) + ', ' + str(Threads) + '>>>(' + str(Args) + ');'
        self.C = Code
        return True
class Statement_Gpu_Method (Scoped_Statement):
    Gal_Keyword = 'gm'
    Gs_Keyword = 'gm'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_C(self):
        # comment 'TODO:the gpu method needs to accept property array pointers as arguments';
        Name = str(self.Name.C)
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C) + '_gm_' + str(Name)
        Args = str(self.C_Args(', '))
        Statements = str(self.C_Statements())
        Code = '__global__ void ' + str(Class_Name) + '(' + str(Args) + ')' + str('\n') + '{' + str('\n') + str("    ") + 'int self = blockIdx.x * blockDim.x + threadIdx.x;' + str('\n') + str(Statements) + '}'
        self.C = Code
        return True
class Statement_Gpu_Property (Line_Statement):
    Gal_Keyword = 'gp'
    Gs_Keyword = 'gp'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Value = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_C(self):
        # comment 'TODO:the gpu property requires cuda malloc and cuda free and cuda memcpy';
        Type = str(self.C_Type(self.Type.C))
        Name = str(self.Name.C)
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C)
        Index = '[' + str(Class_Name) + '_Capacity]'
        Initializer = ''
        if self.Value is not None:
            Declaration = str(Class_Name) + '_prop_' + str(Name) + '[self]' + ' = ' + str(self.Value.C) + ';'
            C.Inits.extend([Declaration])
        Code = str(Type) + ' ' + str(Class_Name) + '_prop_' + str(Name) + str(Index) + ';'
        self.C = Code
        return True
class Statement_Goal (Scoped_Statement):
    Gal_Keyword = 'goal'
    Gs_Keyword = 'goal'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Description = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Description = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Full_Name = 'Goal_' + str(Name)
        Fallback_Lines = ''
        Fallback_Declarations = ''
        Statement = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                Fallback_Lines += str(Statement.Fallback) + str('\n')
                if Statement.Fallback_Declaration is not None:
                    # comment 'append Fallback_Declarations [. Statement Fallback_Declaration] [line]';
                    pass
        Fallback_Block = str('\n') + '{' + str('\n') + str(self.Indent(Fallback_Declarations)) + '}'
        Code = 'class ' + str(Full_Name) + ' [is Goal]' + str(Fallback_Block)
        Code += str(Fallback_Lines)
        self.Fallback = Code
        return True
class Statement_Goal_Spell (Scoped_Statement):
    Gal_Keyword = 'goal.spell'
    Gs_Keyword = 'goal.spell'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Description = None
    def Infer_Mumps(self):
        # comment 'Statement_Goal_Spell';
        Name = str(self.Name.Mumps)
        Code = str("    ") + '; goal spell ' + str(Name) + str('\n')
        if self.Description is not None:
            Description = str(self.Description.Mumps)
            Code += str("    ") + '; ' + str(Description) + str('\n')
        Code += str(self.Mumps_Statements())
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Statement_Goal_Spell';
        Name = str(self.Name.Mumps)
        Code = str("    ") + '; goal spell ' + str(Name) + str('\n')
        if self.Description is not None:
            Description = str(self.Description.Mumps)
            Code += str("    ") + '; ' + str(Description) + str('\n')
        Code += str(self.Mumps_Statements())
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Description = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Goal_Code = 'goal ' + str(Name)
        if self.Description is not None:
            Goal_Code += ' ' + str(self.Description.Fallback)
        Goal_Code += ';' + str('\n')
        Spell_Code = 'spell ' + str(Name) + str(self.Fallback_Block())
        Code = str(Goal_Code) + str(Spell_Code)
        self.Fallback = Code
        return True
class Statement_Gs (Scoped_Statement):
    Gal_Keyword = 'gs'
    Gs_Keyword = 'gs'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
    def Get_Language_Name(self):
        return 'Gs'
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'method void Infer_Gs' + str('\n') + '{' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        else:
            Argument = None
            Args_Code = ''
            for Argument in self.Arguments:
                if isinstance(Argument, Token_Name):
                    Args_Code += ' ' + str('[my '  +  Argument.Fallback  +  ' Reference]')
                else:
                    Args_Code += ' ' + str(Argument.Fallback)
            Code += str("    ") + 'string Code' + str(Args_Code) + ';' + str('\n') + str("    ") + 'my= Gs Code;' + str('\n')
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Gs_Equal (Scoped_Statement):
    Gal_Keyword = 'gs='
    Gs_Keyword = 'gs='
    def __init__(self):
        super().__init__()
        self.Class_Name = None
    def Get_Language_Name(self):
        return 'Gs'
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Code = ''
        if len(self.Arguments) > 1:
            Code += 'Case.Gs = (append' + str(Args) + ');'
        else:
            Code += 'Case.Gs = ' + str(Args) + ';'
        self.Fallback = Code
        return True
class Statement_Hope (Scoped_Statement):
    Gal_Keyword = 'hope'
    Gs_Keyword = 'hope'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        # comment 'TODO:theory of hope';
        # comment "whatever you put in here, it's just going to keep doing it.";
        Verbose = False
        Arguments = str(self.Fallback_Arguments())
        Name = 'Hope ' + str(Arguments)
        Name = Name.replace(' ', '_')
        Block = str(self.Fallback_Block())
        Main = 'main' + str('\n') + '{' + str('\n') + str("    ") + 'object M = (new ' + str(Name) + ');' + str('\n') + str("    ") + 'M.Run;' + str('\n') + '}' + str('\n')
        Code = 'class ' + str(Name) + ' [is Hope]' + str(Block) + str(Main)
        self.Fallback = Code
        return True
class Statement_Html (Method_Statement):
    Gal_Keyword = 'html'
    Gs_Keyword = 'html'
    def Get_Language_Name(self):
        return 'Html'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'method void Infer_Html' + str('\n') + '{' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        else:
            Argument = None
            Args_Code = ''
            for Argument in self.Arguments:
                if isinstance(Argument, Token_Name):
                    Args_Code += ' ' + str('[my '  +  Argument.Fallback  +  ' Html]')
                else:
                    Args_Code += ' ' + str(Argument.Fallback)
            Code += str("    ") + 'string Code' + str(Args_Code) + ';' + str('\n') + str("    ") + 'my= Html Code;' + str('\n')
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Dom_Object (Class_Statement):
    Gal_Keyword = 'dom.object'
    Gs_Keyword = 'dom.object'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Class_Name = str(self.Class_Name.Fallback)
        Block = str(self.Fallback_Block())
        Code = "class " + str(Class_Name) + " [is Dom_Object]" + str(Block)
        self.Fallback = Code
        return True
class Statement_Human_Being (Class_Statement):
    Gal_Keyword = 'human.being'
    Gs_Keyword = 'human.being'
    def Attributes(self):
        pass
class Statement_I_Equal (Line_Statement):
    Gal_Keyword = 'i='
    Gs_Keyword = 'i='
    def __init__(self):
        super().__init__()
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'i=' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Fallback(self):
        Property_Name = str(self.Get_Property_Name())
        if (Property_Name in (None, "")):
            Property_Name = self.Get_Language_Name()
        if (Property_Name in (None, "")):
            zdebug.zbreak()
        Code = 'my ' + str(Property_Name) + ' = ' + str(self.Value.Fallback) + ';'
        self.Fallback = Code
        return True
class Statement_If (Iffy_Statement):
    Gal_Keyword = 'if'
    Gs_Keyword = 'if'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Infer_Mumps(self):
        Arguments = str(self.Mumps_Arguments())
        Else_Label = str(Mumps.Get_Label())
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'if ' + str(Arguments) + str('\n') + str("    ") + 'else  goto ' + str(Else_Label) + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Else_Label) + ' ; if-else' + str('\n')
        if self.Is_Last:
            Code += str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Arguments = str(self.Mumps_Arguments())
        Else_Label = str(Mumps.Get_Label())
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'if ' + str(Arguments) + str('\n') + str("    ") + 'else  goto ' + str(Else_Label) + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Else_Label) + ' ; if-else' + str('\n')
        if self.Is_Last:
            Code += str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'if (' + str(self.Condition.Javascript) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'if ' + str(self.Condition.Python) + str(self.Python_Block())
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'if (' + str(self.Condition.C) + ')' + str(self.C_Block())
        self.C = Gen
        return True
    def Infer_Data_Types(self):
        self.Condition.Data_Type = 'flag'
        return True
class Statement_Ifdef (Scoped_Statement):
    Gal_Keyword = 'ifdef'
    Gs_Keyword = 'ifdef'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Ifargs = ""
        Between = ""
        Argument = None
        for Argument in self.Listargs:
            Ifargs += str(Between) + str(Argument.Javascript) + "!= null"
            Between = " && "
        Block = str(self.Javascript_Block())
        Code = "if (" + str(Ifargs) + ")" + str(Block)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Ifargs = ""
        Argument = None
        for Argument in self.Arguments:
            Ifargs += "if " + str(Argument.Python) + ' is None:' + str('\n') + str("    ") + 'raise ValueError' + str('\n')
        Ifargs = self.Py_Indent(Ifargs)
        Block = str(self.Python_Statements())
        Code = "try:" + str('\n') + str(Ifargs) + str(Block)
        Code += "except ValueError, AttributeError:" + str('\n') + str("    ") + "pass"
        self.Python = Code
        return True
class Statement_I (Line_Statement):
    Gal_Keyword = 'i'
    Gs_Keyword = 'i'
    def __init__(self):
        super().__init__()
        self.Method = None
    def Infer_Mumps(self):
        Method = str(self.Method.Mumps)
        Args = str(self.Mumps_Listargs())
        Code = str("    ") + 'do ' + str(Method) + '(' + str(Args) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Method = str(self.Method.Mumps)
        Args = str(self.Mumps_Listargs())
        Code = str("    ") + 'do ' + str(Method) + '(' + str(Args) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '[self].' + str(self.Method.Fallback) + str(self.Fallback_Args()) + ';'
        self.Fallback = Gen
        return True
class Statement_I_Generate (Line_Statement):
    Gal_Keyword = 'i.generate'
    Gs_Keyword = 'i.generate'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = len(self.Arguments)
        Value = ''
        if Args == 0:
            Value = "''"
        elif Args == 1:
            Value = self.Fallback_Arguments()
        else:
            Value += '(append' + str(self.Fallback_Arguments()) + ')'
        Code = "push [my Code] (new Element " + str(Value) + ");"
        self.Fallback = Code
        return True
class Statement_Imagine_Statement (Scoped_Statement):
    Gal_Keyword = 'imagine.statement'
    Gs_Keyword = 'imagine.statement'
    def __init__(self):
        super().__init__()
        self.Data_Type = None
        self.Name = None
        self.Keyword = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Data_Type')
        self.Data_Type = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
class Statement_Imagine_Operation (Scoped_Statement):
    Gal_Keyword = 'imagine.operation'
    Gs_Keyword = 'imagine.operation'
    def __init__(self):
        super().__init__()
        self.Data_Type = None
        self.Name = None
        self.Keyword = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Data_Type')
        self.Data_Type = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
class Statement_Implement (Line_Statement):
    Gal_Keyword = 'implement'
    Gs_Keyword = 'implement'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'eval(Implementer);'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Assigns = ''
        Tests = ''
        Between = ''
        Argument = None
        for Argument in self.Arguments:
            Argpy = str(Argument.Python)
            Qarg = str(Argument.Py_Enquote())
            Assigns += str(Between) + str(Qarg) + ':' + str(Argpy)
            Between = ', '
            Tests += str('\n') + str(Argpy) + ' = loc[' + str(Qarg) + ']'
        Code = 'exec(Implementer, {}, {' + str(Assigns) + '})' + str(Tests)
        self.Python = Code
        return True
class Statement_Implementer (Line_Statement):
    Gal_Keyword = 'implementer'
    Gs_Keyword = 'implementer'
    def __init__(self):
        super().__init__()
        self.Function = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " = ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " = ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Function')
        self.Function = self.Listargs.pop(0)
    def Infer_C(self):
        Function = str(self.Function.C)
        Redirect = str(C.Behavior)
        Code = str(Redirect) + '_Implementer = Implementers[' + str(Function) + '];' + str('\n') + 'Implementer_Name = Implementer_Names[' + str(Function) + '];' + str('\n')
        self.C = Code
        return True
class Statement_Implementers (Scoped_Statement):
    Gal_Keyword = 'implementers'
    Gs_Keyword = 'implementers'
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        pass
    def Infer_C(self):
        Verbose = False
        Arg = None
        Args = ''
        Names = ''
        Between = None
        Word = None
        Arglist = ''
        Rtype = ''
        Argc = None
        for Word in self.Gs_Keywords:
            if ' '  +  Word  +  ' ' in ' implementers fptr ':
                continue
            Word = self.C_Type(Word)
            if (Rtype in (None, "")):
                Rtype = Word
            else:
                Arglist += str(Between) + str(Word)
                Between = ', '
        Arg_Count = 0
        Between = ''
        Count = 0
        for Arg in self.Arguments:
            Argc = Arg.C
            Arg_Count += 1
            Args += str(Between) + str(Argc)
            Names += str(Between) + '"' + str(Argc) + '"'
            Between = ', '
            Count += 1
            if Count > 8:
                Between += str('\n') + str("    ")
                Count = 0
        Code = '#define top_Implementers ' + str(Arg_Count) + str('\n') + str(Rtype) + '(*Implementers[top_Implementers])(' + str(Arglist) + ') = {' + str('\n') + str(Args) + '};' + str('\n') + 'char *Implementer_Names[top_Implementers] = {' + str('\n') + str(Names) + '};' + str('\n')
        if Verbose:
            print(Code)
        self.C = Code
        return True
class Statement_Implements_Class (Line_Statement):
    Gal_Keyword = 'implements:'
    Gs_Keyword = 'implements:'
    def __init__(self):
        super().__init__()
        self.Implementer = None
        self.Class = None
        self.Method = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Implementer')
        self.Implementer = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
class Statement_Implements_Instance (Line_Statement):
    Gal_Keyword = 'implements.'
    Gs_Keyword = 'implements.'
    def __init__(self):
        super().__init__()
        self.Implementer = None
        self.Object = None
        self.Method = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Implementer')
        self.Implementer = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
class Statement_Import (Line_Statement):
    Gal_Keyword = 'import'
    Gs_Keyword = 'import'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Alias = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Alias')
        self.Alias = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Verbose = False
        zdebug.zbreak()
        if Verbose:
            print('Statement_Import in Javascript')
        return True
    def Infer_Python(self):
        Gen = 'sys.modules["' + str(self.Alias.Python) + '"] = importlib.import_module(' + str(self.Name.Python) + ')' + str('\n') + 'import ' + str(self.Alias.Python)
        self.Python = Gen
        return True
class Statement_Improve (Line_Statement):
    Gal_Keyword = 'improve'
    Gs_Keyword = 'improve'
    def Attributes(self):
        pass
class Statement_Include_Implementers (Line_Statement):
    Gal_Keyword = 'include.implementers'
    Gs_Keyword = 'include.implementers'
    def Attributes(self):
        pass
    def Infer_C(self):
        Map = str(C.Map)
        Map = Map.replace('"', '')
        Code = '#include "Implementers_' + str(Map) + '.c"'
        self.C = Code
        return True
class Statement_Increment (Line_Statement):
    Gal_Keyword = '++'
    Gs_Keyword = '++'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str("    ") + 'set ' + str(Op1) + '=' + str(Op1) + '+1' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str("    ") + 'set ' + str(Op1) + '=' + str(Op1) + '+1' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'increment' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = str(self.Op1.Gs) + '++;'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Op1.Javascript) + "++;"
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Op1.Python) + ' += 1'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Op1.C) + "++;"
        self.C = Gen
        return True
class Statement_In_Goalspell (Line_Statement):
    Gal_Keyword = 'in.goalspell'
    Gs_Keyword = 'in.goalspell'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        zdebug.zbreak()
        Parent_Name = str(self.Parent.Name.Fallback)
        Code = 'class set Goalspell_Tests' + str('\n') + '{' + str('\n') + str("    ") + 'tests append ' + str(Parent_Name) + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + 'yes' + str(self.Fallback_Args()) + ';' + str('\n') + str("    ") + '}' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_In (Line_Statement):
    Gal_Keyword = 'in'
    Gs_Keyword = 'in'
    def __init__(self):
        super().__init__()
        self.Language = None
        self.Language_Code = None
        self.Dialect_Code = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Language')
        self.Language = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Language_Code')
        self.Language_Code = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Dialect_Code = self.Listargs.pop(0)
    def Infer_Fallback(self):
        zdebug.zbreak()
        Parent_Name = str(self.Parent.Name.Fallback)
        Code = 'class set ' + str(self.Language.Fallback) + '_Tests' + str('\n') + '{' + str('\n') + str("    ") + 'tests append ' + str(Parent_Name) + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + 'yes' + str(self.Fallback_Args()) + ';' + str('\n') + str("    ") + '}' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Infer (Line_Statement):
    Gal_Keyword = 'infer'
    Gs_Keyword = 'infer'
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Inference = None
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Object = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Inference')
        self.Inference = self.Keywords.pop(0)
    def Infer_Fallback(self):
        Object = 'i '
        if self.Object is not None:
            Object = self.Object.Fallback
        Inference = "Infer_" + str(self.Inference.Fallback.title())
        Code = str(Object) + str(Inference) + str(self.Fallback_Args()) + ';'
        self.Fallback = Code
        return True
class Statement_Inference (Scoped_Statement):
    Gal_Keyword = 'inference'
    Gs_Keyword = 'inference'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
class Statement_Infer_Inits (Line_Statement):
    Gal_Keyword = 'infer.inits'
    Gs_Keyword = 'infer.inits'
    def Attributes(self):
        pass
    def Infer_Gs(self):
        Gen = 'infer inits'
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Owner_Class = self.Get_Class_Context()
        if (Owner_Class in (None, "")):
            self.Fallback = 'infer inits;'
        else:
            self.Fallback = Owner_Class.Infer_Inits
        return True
class Statement_Inferences (Line_Statement):
    Gal_Keyword = 'inferences'
    Gs_Keyword = 'inferences'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        Between = ''
        for Argument in self.Arguments:
            Code += str(Between) + 'infers ' + str(Argument.Fallback) + ';'
            Between = '\n'
        self.Fallback = ''
        self.Fallback_Declaration = Code
        return True
class Statement_Infers (Line_Statement):
    Gal_Keyword = 'infers'
    Gs_Keyword = 'infers'
    def __init__(self):
        super().__init__()
        self.Inference = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Inference')
        self.Inference = self.Listargs.pop(0)
class Statement_Initialize (Line_Statement):
    Gal_Keyword = 'initialize'
    Gs_Keyword = 'initialize'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'do @("%init^"_' + str(Variable) + '_"("""_' + str(Variable) + '_""")")' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'do @("%init^"_' + str(Variable) + '_"("""_' + str(Variable) + '_""")")' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
class Statement_Integer (Declaration_Statement):
    Gal_Keyword = 'integer'
    Gs_Keyword = 'integer'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'integer' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Variable = str(self.Variable.Gs)
        Code = 'integer ' + str(Variable)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.Gs)
        Code += ';'
        self.Gs = Code
        return True
    def Infer_C(self):
        Code = 'int ' + str(self.Variable.C)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.C)
        Code += ';'
        self.C = Code
        return True
class Statement_Integers (Line_Statement):
    Gal_Keyword = 'integers'
    Gs_Keyword = 'integers'
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'integer ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Interface (Line_Statement):
    Gal_Keyword = 'interface'
    Gs_Keyword = 'interface'
    def __init__(self):
        super().__init__()
        self.Return_Type = None
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Return_Type')
        self.Return_Type = self.Keywords.pop(0)
    def Infer_Fallback(self):
        Return_Type = str(self.Return_Type.Fallback)
        Code = str('''Int = (new Interface);'''  +  '\n'  +  '''Int.Return_Type = ''') + str(self.Enquote(Return_Type)) + str(''';'''  +  '\n'  +  '''Ros.Interface = Int;''')
        Arg_Code = None
        Arg = None
        for Arg in self.Listargs:
            Arg_Code = Arg.Fallback
            Code += str('\n') + 'push [Int.Arguments] ' + str(self.Enquote(Arg_Code)) + ';'
        self.Fallback = Code
        return True
class Statement_Is_A (Method_Statement):
    Gal_Keyword = 'isa'
    Gs_Keyword = 'isa'
    def __init__(self):
        super().__init__()
        self.Class = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
class Statement_It_Equals (Line_Statement):
    Gal_Keyword = 'it='
    Gs_Keyword = 'it='
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Gen = 'i=' + str(self.Fallback_Arguments()) + ';'
        self.Fallback = Gen
        return True
class Statement_Iterate (Iterative_Statement):
    Gal_Keyword = 'iterate'
    Gs_Keyword = 'iterate'
    def __init__(self):
        super().__init__()
        self.Dictionary = None
        self.Key_Variable = None
        self.Value_Variable = None
    def Infer_Mumps(self):
        Dictionary = '$name(' + str(self.Dictionary.Mumps) + ')'
        Key_Variable = str(self.Key_Variable.Mumps)
        Value_Variable = str(self.Value_Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Key_Variable) + '=""' + str('\n') + str(Continue_Label) + ' ; iterate continue' + str('\n') + str("    ") + 'set ' + str(Key_Variable) + '=$order(@' + str(Dictionary) + '@(' + str(Key_Variable) + '))' + str('\n') + str("    ") + 'goto:' + str(Key_Variable) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Value_Variable) + '=@' + str(Dictionary) + '@(' + str(Key_Variable) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; iterate break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Dictionary = '$name(' + str(self.Dictionary.Mumps) + ')'
        Key_Variable = str(self.Key_Variable.Mumps)
        Value_Variable = str(self.Value_Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Key_Variable) + '=""' + str('\n') + str(Continue_Label) + ' ; iterate continue' + str('\n') + str("    ") + 'set ' + str(Key_Variable) + '=$order(@' + str(Dictionary) + '@(' + str(Key_Variable) + '))' + str('\n') + str("    ") + 'goto:' + str(Key_Variable) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Value_Variable) + '=@' + str(Dictionary) + '@(' + str(Key_Variable) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; iterate break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Dictionary')
        self.Dictionary = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Key_Variable')
        self.Key_Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value_Variable')
        self.Value_Variable = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'for ([' + str(self.Key_Variable.Javascript) + ', ' + str(self.Value_Variable.Javascript) + '] of Object.entries(' + str(self.Dictionary.Javascript) + '))' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'for ' + str(self.Key_Variable.Python) + ', ' + str(self.Value_Variable.Python) + ' in ' + str(self.Dictionary.Python) + '.items()' + str(self.Python_Block())
        self.Python = Gen
        return True
class Statement_Reverse_Iterate (Iterative_Statement):
    Gal_Keyword = 'reverse.iterate'
    Gs_Keyword = 'reverse.iterate'
    def __init__(self):
        super().__init__()
        self.Dictionary = None
        self.Key_Variable = None
        self.Value_Variable = None
    def Infer_Mumps(self):
        Dictionary = '$name(' + str(self.Dictionary.Mumps) + ')'
        Key_Variable = str(self.Key_Variable.Mumps)
        Value_Variable = str(self.Value_Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Key_Variable) + '=""' + str('\n') + str(Continue_Label) + ' ; iterate continue' + str('\n') + str("    ") + 'set ' + str(Key_Variable) + '=$order(@' + str(Dictionary) + '@(' + str(Key_Variable) + '),-1)' + str('\n') + str("    ") + 'goto:' + str(Key_Variable) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Value_Variable) + '=@' + str(Dictionary) + '@(' + str(Key_Variable) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; iterate break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Dictionary = '$name(' + str(self.Dictionary.Mumps) + ')'
        Key_Variable = str(self.Key_Variable.Mumps)
        Value_Variable = str(self.Value_Variable.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str("    ") + 'set ' + str(Key_Variable) + '=""' + str('\n') + str(Continue_Label) + ' ; iterate continue' + str('\n') + str("    ") + 'set ' + str(Key_Variable) + '=$order(@' + str(Dictionary) + '@(' + str(Key_Variable) + '),-1)' + str('\n') + str("    ") + 'goto:' + str(Key_Variable) + '="" ' + str(Break_Label) + str('\n') + str("    ") + 'set ' + str(Value_Variable) + '=@' + str(Dictionary) + '@(' + str(Key_Variable) + ')' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; iterate break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Dictionary')
        self.Dictionary = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Key_Variable')
        self.Key_Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value_Variable')
        self.Value_Variable = self.Listargs.pop(0)
class Statement_Javascript (Method_Statement):
    Gal_Keyword = 'javascript'
    Gs_Keyword = 'javascript'
    def Get_Language_Name(self):
        return 'Javascript'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'method void Infer_Javascript' + str('\n') + '{' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        else:
            Argument = None
            Args_Code = ''
            for Argument in self.Arguments:
                if isinstance(Argument, Token_Name):
                    Args_Code += ' ' + str('[my '  +  Argument.Fallback  +  ' Reference]')
                else:
                    Args_Code += ' ' + str(Argument.Fallback)
            Code += str("    ") + 'string Code' + str(Args_Code) + ';' + str('\n') + str("    ") + 'my= Javascript Code;' + str('\n')
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Javascript_Equal (Line_Statement):
    Gal_Keyword = 'javascript='
    Gs_Keyword = 'javascript='
    def Get_Language_Name(self):
        return 'Javascript'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Code = ''
        if len(self.Arguments) > 1:
            Code += 'Case.Javascript = (append' + str(Args) + ');'
        else:
            Code += 'Case.Javascript = ' + str(Args) + ';'
        self.Fallback = Code
        return True
class Statement_Job (Line_Statement):
    Gal_Keyword = 'job'
    Gs_Keyword = 'job'
    def __init__(self):
        super().__init__()
        self.Method = None
        self.Class = None
    def Infer_Mumps(self):
        Verbose = False
        Method = str(self.Method.Mumps)
        Class = str(self.Class.Mumps)
        Arg = None
        Args = ''
        for Arg in self.Listargs:
            Args += ',' + str(Arg.Mumps)
        Code = str("    ") + 'job ' + str(Method) + '^' + str(Class) + '("' + str(Class) + '"' + str(Args) + ')' + str('\n')
        if Verbose:
            print("    job ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Method = str(self.Method.Mumps)
        Class = str(self.Class.Mumps)
        Arg = None
        Args = ''
        for Arg in self.Listargs:
            Args += ',' + str(Arg.Mumps)
        Code = str("    ") + 'job ' + str(Method) + '^' + str(Class) + '("' + str(Class) + '"' + str(Args) + ')' + str('\n')
        if Verbose:
            print("    job ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
class Statement_Join (Line_Statement):
    Gal_Keyword = 'join'
    Gs_Keyword = 'join'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.List = None
        self.Delimiter = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Delimiter')
        self.Delimiter = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' = ' + str(self.List.Javascript) + '.join(' + str(self.Delimiter.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' = ' + str(self.Delimiter.Python) + '.join(' + str(self.List.Python) + ')'
        self.Python = Gen
        return True
class Statement_Kill (Line_Statement):
    Gal_Keyword = 'kill'
    Gs_Keyword = 'kill'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Node = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node = '@$name('  +  Node  +  ')@('  +  Args  +  ')'
        Code = str("    ") + 'kill ' + str(Node) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Node = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node = '@$name('  +  Node  +  ')@('  +  Args  +  ')'
        Code = str("    ") + 'kill ' + str(Node) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Statement_Kill_Global (Line_Statement):
    Gal_Keyword = 'kill^'
    Gs_Keyword = 'kill^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Node = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node += '(' + str(Args) + ')'
        Code = str("    ") + 'kill ^' + str(Node) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Node = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node += '(' + str(Args) + ')'
        Code = str("    ") + 'kill ^' + str(Node) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Statement_Keyword (Line_Statement):
    Gal_Keyword = 'keyword'
    Gs_Keyword = 'keyword'
    def __init__(self):
        super().__init__()
        self.Argument_Name = None
        self.Type_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Argument_Name')
        self.Argument_Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Type_Value = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Argument_Name = str(self.Argument_Name.Fallback)
        Code = 'property object ' + str(Argument_Name) + ';'
        Declaration = "if (= (llength [my Keywords]) 0)" + str('\n') + "{" + str('\n') + str("    ") + "error 'missing required keyword " + str(Argument_Name) + "';" + str('\n') + "}" + str('\n')
        Declaration += '[my ' + str(Argument_Name) + ' Symbol_Value] = (shift [my Keywords]);' + str('\n')
        if self.Type_Value is not None:
            Declaration += '[my ' + str(Argument_Name) + ' Usage] = ' + str(self.Type_Value.Fallback) + ';' + str('\n')
        self.Fallback_Declaration = Declaration
        self.Fallback = Code
        return True
class Statement_Know (Line_Statement):
    Gal_Keyword = 'know'
    Gs_Keyword = 'know'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Directory = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Directory')
        self.Directory = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Input = str(self.Get_Input())
        Code = "comment " + str(self.Enquote(Input)) + ";"
        self.Fallback = Code
        return True
class Statement_Language (Scoped_Statement):
    Gal_Keyword = 'language'
    Gs_Keyword = 'language'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Get_Language_Name(self):
        return self.Name.Get_Input()
    def Get_Property_Name(self):
        return self.Name.Get_Input()
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = 'Gal'
        if self.Name is not None:
            Name = self.Name.Fallback
        Declarations = ''
        Statement = None
        if self.Block is not None and self.Block.Statements is not None:
            for Statement in self.Block.Statements:
                Dec = str(Statement.Fallback_Declaration)
                if str(Dec) > '':
                    Declarations += str(Dec) + str('\n')
        if str(Declarations) > '':
            Declarations = self.Indent(Declarations)
        Code = str(Declarations) + 'class Language_' + str(Name) + ' [is Language]' + str(self.Fallback_Block())
        self.Fallback = Code
        return True
class Statement_Language_Behavior (Behavior_Statement):
    Gal_Keyword = 'language.behavior'
    Gs_Keyword = 'language.behavior'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Behavior_Name = None
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Behavior_Name')
        self.Behavior_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Class_Context = self.Get_Class_Context()
        Class_Name = str(Class_Context.Name.Get_Input())
        Behavior_Name = str(self.Behavior_Name.Get_Input())
        Entity_Behavior_Class = "Behavior_" + str(Class_Name) + '_' + str(Behavior_Name)
        Type = str(self.Gs_Keywords[-1])
        Ancestor = 'Behavior'
        Args = str(self.Fallback_Args())
        Call_Args = ''
        Arg = None
        ArgArg = None
        for Arg in self.Listargs:
            ArgArg = Arg.Arguments[0]
            Call_Args += ' ' + str(ArgArg.Fallback)
        Entity_Return = str(Entity_Behavior_Class) + ':Execute [self]' + str(Call_Args)
        Behavior_Return = '[our Implementer].Execute Owner' + str(Call_Args)
        if str(Type) == 'void':
            Entity_Return += ";"
            Behavior_Return += ";"
        else:
            Entity_Return = 'return ('  +  Entity_Return  +  ');'
            Behavior_Return = 'return ('  +  Behavior_Return  +  ');'
        Behavior_Statements = str("    ") + 'if (defined [our Implementer])' + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + str(Behavior_Return) + str('\n') + str("    ") + '}' + str('\n')
        if self.Block is not None and self.Block.Fallback_Statements is not None:
            Behavior_Statements += str(self.Block.Fallback_Statements)
        else:
            Behavior_Statements += str("    ") + 'error "' + str(Behavior_Name) + ' implementer not defined.";' + str('\n')
        Method = 'method ' + str(Type) + ' ' + str(Behavior_Name) + str(self.Fallback_Args()) + str('\n') + '{' + str('\n') + str("    ") + str(Entity_Return) + str('\n') + '}'
        Behavior_Code = 'class ' + str(Entity_Behavior_Class) + ' [is Language_Behavior]' + str('\n') + '{' + str('\n') + str("    ") + 'class property object Implementer;' + str('\n') + str("    ") + 'class method ' + str(Type) + ' Execute [object Owner]' + str(self.Fallback_Args()) + str('\n') + str("    ") + '{' + str('\n') + str(self.Indent(Behavior_Statements)) + str("    ") + '}' + str('\n') + '}' + str('\n')
        Code = str(Method)
        self.Fallback = Code
        self.Fallback_Declaration = Behavior_Code
        return True
class Statement_Language_Machine_Architecture (Scoped_Statement):
    Gal_Keyword = 'language.machine.architecture'
    Gs_Keyword = 'language.machine.architecture'
    def Attributes(self):
        pass
class Statement_Lexical (Statement):
    Gal_Keyword = 'lexical'
    Gs_Keyword = 'lexical'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Literal = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Literal')
        self.Literal = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Literal = str(self.Literal.Fallback)
        Code = 'method flag Parse_' + str(Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str("    ") + 'integer Start_Char [my Char_Pos];' + str('\n') + str("    ") + 'integer Start_Token [my Token_Pos];' + str('\n') + str("    ") + 'if (not (i Parse_Token Parent_Elements ' + str(Literal) + ')) { i Rollback Start_Char Start_Token ' + str(self.Enquote('Lexical '  +  Name  +  ' expected '  +  Literal  +  '.')) + '; return [false]; }' + str('\n') + str("    ") + 'return [true];' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Lock (Line_Statement):
    Gal_Keyword = 'lock'
    Gs_Keyword = 'lock'
    def __init__(self):
        super().__init__()
        self.Reference = None
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock +' + str(Ref) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock +' + str(Ref) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Reference')
        self.Reference = self.Listargs.pop(0)
class Statement_Global_Lock (Line_Statement):
    Gal_Keyword = 'lock^'
    Gs_Keyword = 'lock^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock +^' + str(Ref) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock +^' + str(Ref) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Statement_List_Append (Statement):
    Gal_Keyword = 'list.append'
    Gs_Keyword = 'list.append'
    def __init__(self):
        super().__init__()
        self.List = None
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        if Verbose:
            print('mumps push ', List, sep='')
        Variable = str(List)
        if str(Variable[0]) == '@':
            Variable = '$name('  +  Variable  +  ')'
        Arg = None
        Code = ''
        Argc = None
        for Arg in self.Listargs:
            Argc = Arg.Mumps
            Code += str("    ") + 'set @' + str(Variable) + '@($order(@' + str(Variable) + '@(""),-1)+1)=' + str(Argc) + str('\n') + str("    ") + 'set @' + str(Variable) + '=$increment(@' + str(Variable) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        if Verbose:
            print('mumps push ', List, sep='')
        Variable = str(List)
        if str(Variable[0]) == '@':
            Variable = '$name('  +  Variable  +  ')'
        Arg = None
        Code = ''
        Argc = None
        for Arg in self.Listargs:
            Argc = Arg.Mumps
            Code += str("    ") + 'set @' + str(Variable) + '@($order(@' + str(Variable) + '@(""),-1)+1)=' + str(Argc) + str('\n') + str("    ") + 'set @' + str(Variable) + '=$increment(@' + str(Variable) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'push' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'push ' + str(self.List.Gs) + str(self.Gs_Listargs()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Code = ''
        Arg = None
        Between = ''
        for Arg in self.Listargs:
            Code += str(Between) + str(self.List.Javascript) + '.push(' + str(Arg.Javascript) + ');'
            Between = '\n'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = str(self.List.Python) + '.extend([' + str(self.Python_Args(', ')) + '])'
        self.Python = Gen
        return True
    def Infer_C(self):
        List = str(self.List.C)
        List_Top = 'top_' + str(List)
        Code = '// ' + str(self.Get_Input())
        Arg = None
        for Arg in self.Listargs:
            Code += str('\n') + str(List) + '[' + str(List_Top) + '] = ' + str(Arg.C) + ';' + str('\n') + str(List_Top) + '++;'
        self.C = Code
        return True
class Statement_List_Assign (Line_Statement):
    Gal_Keyword = 'list.assign'
    Gs_Keyword = 'list.assign'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Index = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Index')
        self.Index = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + '[' + str(self.Index.Javascript) + '] = ' + str(self.Value.Javascript) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + '[' + str(self.Index.Python) + '] = ' + str(self.Value.Python)
        self.Python = Gen
        return True
class Statement_List_Clear (Line_Statement):
    Gal_Keyword = 'list.clear'
    Gs_Keyword = 'list.clear'
    def __init__(self):
        super().__init__()
        self.List = None
    def Infer_Mumps(self):
        List = str(self.List.Mumps)
        Code = str("    ") + 'kill ' + str(List) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        List = str(self.List.Mumps)
        Code = str("    ") + 'kill ' + str(List) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.List.Javascript) + ' = [];'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.List.Python) + '.clear()'
        self.Python = Gen
        return True
class Statement_List_Copy (Line_Statement):
    Gal_Keyword = 'list.copy'
    Gs_Keyword = 'list.copy'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Value = str(self.Value.Matom())
        if '$' == str(Value[0]):
            Value = '@'  +  Value
        Code = str("    ") + 'new ' + str(Variable) + ',' + str(Actual) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(' + str(Actual) + ')' + str('\n') + str("    ") + 'merge ' + str(Actual) + '=' + str(Value) + str('\n')
        Arg = None
        Item = 0
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Value = str(self.Value.Matom())
        if '$' == str(Value[0]):
            Value = '@'  +  Value
        Code = str("    ") + 'new ' + str(Variable) + ',' + str(Actual) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(' + str(Actual) + ')' + str('\n') + str("    ") + 'merge ' + str(Actual) + '=' + str(Value) + str('\n')
        Arg = None
        Item = 0
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'list.copy' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Variable = str(self.Variable.Javascript)
        Value = '[]'
        if self.Value is not None:
            Value = self.Value.Javascript
        Code = 'var ' + str(Variable) + ' = ' + str(Value) + ';'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Variable = str(self.Variable.Python)
        Value = '[]'
        if self.Value is not None:
            Value = self.Value.Python  +  '.copy()'
        Code = str(Variable) + ' = ' + str(Value)
        self.Python = Code
        return True
    def Infer_Structure(self):
        Verbose = True
        Variable = str(self.Variable.Input)
        Type = 'list'
        Context = self.Method_Context()
        if (Context in (None, "")):
            if Verbose:
                print('missing variable context in declaration statement, encountered ', self.Enquote(self.Get_Input()), sep='')
        else:
            # comment 'verboselist copy statement noted  Variable as  Type';
            Context.Variables[Variable] = Type;
        return True
class Statement_List_Insert (Line_Statement):
    Gal_Keyword = 'list.insert'
    Gs_Keyword = 'list.insert'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Index = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Index')
        self.Index = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + '.splice(' + str(self.Index.Javascript) + ', 0, ' + str(self.Value.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + '.insert(' + str(self.Index.Python) + ', ' + str(self.Value.Python) + ')'
        self.Python = Gen
        return True
class Statement_List_Split (Line_Statement):
    Gal_Keyword = 'list.split'
    Gs_Keyword = 'list.split'
    def __init__(self):
        super().__init__()
        self.List = None
        self.String = None
        self.Delimiter = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String')
        self.String = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Delimiter')
        self.Delimiter = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.String.Javascript) + '.split(' + str(self.Delimiter.Javascript) + ')'
        self.Javascript = Gen
        return True
class Statement_List (Line_Statement):
    Gal_Keyword = 'list'
    Gs_Keyword = 'list'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Code = str("    ") + 'new ' + str(Variable) + ',' + str(Actual) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(' + str(Actual) + '),' + str(Actual) + '=' + str(len(self.Listargs)) + str('\n')
        Arg = None
        Item = 0
        for Arg in self.Listargs:
            Item += 1
            Value = str(Arg.Mumps)
            Code += str("    ") + 'set ' + str(Actual) + '(' + str(Item) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Actual = str(Variable.lower())
        Code = str("    ") + 'new ' + str(Variable) + ',' + str(Actual) + str('\n') + str("    ") + 'set ' + str(Variable) + '=$name(' + str(Actual) + '),' + str(Actual) + '=' + str(len(self.Listargs)) + str('\n')
        Arg = None
        Item = 0
        for Arg in self.Listargs:
            Item += 1
            Value = str(Arg.Mumps)
            Code += str("    ") + 'set ' + str(Actual) + '(' + str(Item) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'list' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Variable = str(self.Variable.Javascript)
        Args = str(self.Javascript_Args(', '))
        Code = 'var ' + str(Variable) + ' = [' + str(Args) + '];'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Variable = str(self.Variable.Python)
        Args = str(self.Python_Args(', '))
        Code = str(Variable) + ' = [' + str(Args) + ']'
        self.Python = Code
        return True
class Statement_Lists (Line_Statement):
    Gal_Keyword = 'lists'
    Gs_Keyword = 'lists'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'list ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_List_Property_Insert (Line_Statement):
    Gal_Keyword = 'list.property.insert'
    Gs_Keyword = 'list.property.insert'
    def __init__(self):
        super().__init__()
        self.List = None
        self.Property_Name = None
        self.Inserted_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property_Name')
        self.Property_Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Inserted_Value')
        self.Inserted_Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        List = str(self.List.Javascript)
        Property_Name = str(self.Property_Name.Javascript)
        Inserted_Value = str(self.Inserted_Value.Javascript)
        Code = 'var idx,rec;' + str('\n') + str(List) + '.push(' + str(Inserted_Value) + ');' + str('\n') + 'for (idx=' + str(List) + '.length-1; idx--; idx>=0)' + str('\n') + '{' + str('\n') + str("    ") + 'if (' + str(List) + '[idx].' + str(Property_Name) + ' > ' + str(List) + '[idx+1].' + str(Property_Name) + ')' + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + 'rec=' + str(List) + '[idx];' + str('\n') + str("    "*2) + str(List) + '[idx] = ' + str(List) + '[idx+1];' + str('\n') + str("    "*2) + str(List) + '[idx+1] = rec;' + str('\n') + str("    ") + '}' + str('\n') + '}' + str('\n')
        self.Javascript = Code
        return True
    def Infer_Python(self):
        List = str(self.List.Python)
        Property_Name = str(self.Property_Name.Python)
        Inserted_Value = str(self.Inserted_Value.Python)
        Code = str(List) + ' += [' + str(Inserted_Value) + ']'
        self.Python = Code
        return True
class Statement_Main (Scoped_Statement):
    Gal_Keyword = 'main'
    Gs_Keyword = 'main'
    def __init__(self):
        super().__init__()
        self.Variables = {}
    def Method_Context(self):
        return self
    def Infer_Mumps(self):
        Code = 'main(' + str(self.Mumps_Arguments()) + ') ; main program' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = 'main(' + str(self.Mumps_Arguments()) + ') ; main program' + str('\n') + str(self.Mumps_Block()) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Jargs = ''
        Jarg = None
        Jname = None
        Jvalue = None
        Jcode = None
        Sub = 1
        for Jarg in self.Arguments:
            Sub += 1
            Jname = Jarg.Variable.Javascript
            Jcode = 'let '  +  Jname  +  ' = process.argv['  +  str(Sub)  +  ']'
            if Jarg.Default_Value is not None:
                Jvalue = Jarg.Default_Value
                Jcode += ' || ' + str(Jvalue)
            Jargs += str(Jcode) + ';' + str('\n')
        Statement = None
        Statements_Code = ''
        for Statement in self.Block.Statements:
            Statements_Code += str(Statement.Javascript) + str('\n')
        Code = '/* Main Program Body */' + str('\n') + str(Jargs) + str(Statements_Code)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = 'if __name__ == "__main__"'
        if len(self.Arguments) > 0:
            Sub = 0
            Args = ''
            Argument = None
            for Argument in self.Arguments:
                Sub += 1
                Arg_Name = str(Argument.Variable.Python)
                Arg_Code = str("    "*2) + str(Arg_Name) + ' = sys.argv[' + str(Sub) + ']' + str('\n')
                if Argument.Default_Value is not None:
                    Arg_Code = "    "*2  +  'try:'  +  '\n'  +  "    "  +  Arg_Code  +  "    "*2  +  'except:'  +  '\n'  +  "    "*3  +  Arg_Name  +  ' = '  +  Argument.Default_Value.Python  +  '\n'
                Args += str(Arg_Code)
            Code += ':' + str('\n') + str("    ") + 'try:' + str('\n') + str(Args) + str("    ") + 'except:' + str('\n') + str("    "*2) + 'print("Usage: ", sys.argv[0], "' + str(self.Python_Args(' ')) + '")' + str('\n') + str("    "*2) + 'sys.exit()' + str('\n')
            Code += str(self.Python_Statements())
        else:
            Code += str(self.Python_Block())
        self.Python = Code
        return True
    def Infer_C(self):
        Inits = ''
        Init = None
        for Init in C.Inits:
            Inits += str(Init) + str('\n')
        if (Inits is not None and str(Inits) > ""):
            Inits = self.Indent(Inits)
        Code = 'int main(int argc, char *argv[])' + str('\n') + '{' + str('\n') + str("    ") + 'srand(time(NULL)); // random seed' + str('\n') + str(Inits) + str(self.C_Statements()) + '}'
        self.C = Code
        return True
class Statement_Maximize (Scoped_Statement):
    Gal_Keyword = 'maximize'
    Gs_Keyword = 'maximize'
    def Attributes(self):
        pass
class Statement_Member (Scoped_Statement):
    Gal_Keyword = 'member'
    Gs_Keyword = 'member'
    def __init__(self):
        super().__init__()
        self.Identifier = None
        self.Performance = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Identifier')
        self.Identifier = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Performance')
        self.Performance = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Identifier = str(self.Identifier.Fallback)
        Performance = str(self.Performance.Fallback)
        Code = '''Mem = (Member:Lookup ''' + str(Identifier) + str(''');'''  +  '\n'  +  '''Mem.Performance = ''') + str(Performance) + str(''';'''  +  '\n'  +  '''push [Ros.Members] Mem;''')
        self.Fallback = Code
        return True
class Statement_Merge_From (Line_Statement):
    Gal_Keyword = 'merge.from'
    Gs_Keyword = 'merge.from'
    def __init__(self):
        super().__init__()
        self.Target = None
        self.Source = None
    def Infer_Mumps(self):
        Source = str(self.Source.Mumps)
        Target = str(self.Target.Mumps)
        Code = str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Source = str(self.Source.Mumps)
        Target = str(self.Target.Mumps)
        Code = str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Target = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Source')
        self.Source = self.Listargs.pop(0)
class Statement_Merge_To (Line_Statement):
    Gal_Keyword = 'merge.to'
    Gs_Keyword = 'merge.to'
    def __init__(self):
        super().__init__()
        self.Source = None
        self.Target = None
    def Infer_Mumps(self):
        Target = str(self.Target.Mumps)
        Source = str(self.Source.Mumps)
        Code = str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Target = str(self.Target.Mumps)
        Source = str(self.Source.Mumps)
        Code = str("    ") + 'merge ' + str(Source) + '=' + str(Target) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Source')
        self.Source = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Target = self.Listargs.pop(0)
class Statement_Method (Method_Statement):
    Gal_Keyword = 'method'
    Gs_Keyword = 'method'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
    def Infer_Mumps(self):
        Method_Name = str(self.Name.Mumps)
        Args = str(self.Mumps_Listargs())
        if (Args in (None, "")):
            Args = '%self'
        else:
            Args = '%self,'  +  Args
        Declaration = ''
        Arg = None
        for Arg in self.Listargs:
            if Arg.Mumps_Declaration is not None:
                Declaration += str(Arg.Mumps_Declaration)
        Type = str(self.Type.Mumps)
        Block = str(self.Mumps_Block())
        Code = str(Method_Name) + '(' + str(Args) + ') ; method ' + str(Type) + ' ' + str(Method_Name) + str('\n') + str("    ") + 'new %' + str('\n') + str(Declaration) + str(Block) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Method_Name = str(self.Name.Mumps)
        Args = str(self.Mumps_Listargs())
        if (Args in (None, "")):
            Args = '%self'
        else:
            Args = '%self,'  +  Args
        Declaration = ''
        Arg = None
        for Arg in self.Listargs:
            if Arg.Mumps_Declaration is not None:
                Declaration += str(Arg.Mumps_Declaration)
        Type = str(self.Type.Mumps)
        Block = str(self.Mumps_Block())
        Code = str(Method_Name) + '(' + str(Args) + ') ; method ' + str(Type) + ' ' + str(Method_Name) + str('\n') + str("    ") + 'new %' + str('\n') + str(Declaration) + str(Block) + str("    ") + 'quit' + str('\n')
        self.Mumps = Code
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary void ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'method ' + str(self.Gal_Keywords[-1]) + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Name.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Code = 'def ' + str(self.Name.Python) + '(self'
        Args = str(self.Python_Args(', '))
        Block = str(self.Python_Block())
        if str(Args) > '':
            Code += ', ' + str(Args)
        Code += ')' + str(Block)
        self.Python = Code
        return True
    def Infer_C(self):
        Type = str(self.Type.C)
        Return = str(self.C_Type(Type))
        Name = str(self.Name.C)
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C) + '_meth_' + str(Name)
        Args = ''
        Arg = None
        for Arg in self.Listargs:
            Args += ', ' + str(Arg.C)
        Block = str(self.C_Block())
        Code = str(Return) + ' ' + str(Class_Name) + '(int self' + str(Args) + ')' + str(Block)
        self.C = Code
        return True
    def Infer_Fallback(self):
        Code = 'method ' + str(self.Type.Fallback) + str(self.Fallback_Arguments()) + str(self.Fallback_Block())
        self.Fallback = Code
        return True
class Statement_Migrate (Line_Statement):
    Gal_Keyword = 'migrate'
    Gs_Keyword = 'migrate'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Map = None
        self.Deferral = None
        self.Code = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Map')
        self.Map = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Deferral')
        self.Deferral = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Code')
        self.Code = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Map = str(self.Map.Fallback)
        Deferral = str(self.Deferral.Fallback)
        My_Code = str(self.Code.Fallback)
        Code = '''E = (new Element ''' + str(self.Enquote(Name)) + ''' ''' + str(Map) + ''' ''' + str(Deferral) + ''' ''' + str(My_Code) + ''');''' + str('\n') + '''push Migration E;'''
        self.Fallback = Code
        return True
class Statement_Minimize (Scoped_Statement):
    Gal_Keyword = 'minimize'
    Gs_Keyword = 'minimize'
    def Attributes(self):
        pass
class Statement_Multiply (Line_Statement):
    Gal_Keyword = '*='
    Gs_Keyword = '*='
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' *= ' + str(self.Python_Args(' * '))
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Variable.C) + " *= " + str(self.C_Args(' * ')) + ';'
        self.C = Gen
        return True
class Statement_Mumps (Method_Statement):
    Gal_Keyword = 'mumps'
    Gs_Keyword = 'mumps'
    def Get_Language_Name(self):
        return 'Mumps'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'method void Infer_Mumps' + str('\n') + '{' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        else:
            Argument = None
            Args_Code = ''
            for Argument in self.Arguments:
                if isinstance(Argument, Token_Name):
                    Args_Code += ' ' + str('[my '  +  Argument.Fallback  +  ' Reference]')
                else:
                    Args_Code += ' ' + str(Argument.Fallback)
            Code += str("    ") + 'string Code' + str(Args_Code) + ';' + str('\n') + str("    ") + 'my= Mumps Code;' + str('\n')
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Mumps_Equal (Line_Statement):
    Gal_Keyword = 'mumps='
    Gs_Keyword = 'mumps='
    def Get_Language_Name(self):
        return 'Mumps'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Code = ''
        if len(self.Arguments) > 1:
            Code += 'Case.Mumps = (append' + str(Args) + ');' + str('\n')
        else:
            Code += 'Case.Mumps = ' + str(Args) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_My_Equal (Line_Statement):
    Gal_Keyword = 'my='
    Gs_Keyword = 'my='
    def __init__(self):
        super().__init__()
        self.Property = None
        self.Value = None
    def Infer_Mumps(self):
        Property = str(self.Property.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set @%self@(' + str(self.Mq(Property)) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Property = str(self.Property.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set @%self@(' + str(self.Mq(Property)) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property')
        self.Property = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'my=' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'my ' + str(self.Property.Gs) + ' = ' + str(self.Value.Gs) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'this.' + str(self.Property.Javascript) + ' = ' + str(self.Value.Javascript) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'self.' + str(self.Property.Python) + ' = ' + str(self.Value.Python)
        self.Python = Gen
        return True
    def Infer_C(self):
        Property = str(self.Property.C)
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C)
        Value = str(self.Value.C)
        Code = str(Class_Name) + '_prop_' + str(Property) + '[self] = ' + str(Value) + ';'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Gen = 'my ' + str(self.Property.Fallback) + ' = ' + str(self.Value.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_My_Attribute_Equal (Line_Statement):
    Gal_Keyword = 'my~='
    Gs_Keyword = 'my~='
    def __init__(self):
        super().__init__()
        self.Attribute = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Attribute')
        self.Attribute = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '[my ' + str(self.Attribute.Fallback) + ' Symbol_Value] = ' + str(self.Value.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_No (Line_Statement):
    Gal_Keyword = 'no'
    Gs_Keyword = 'no'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Arguments = str(self.Fallback_Arguments())
        if len(self.Arguments) > 1:
            Arguments = '(append '  +  Arguments  +  ')'
        Code = 'quit : (i Succeed ' + str(Arguments) + ') [false];'
        self.Fallback = Code
        return True
class Statement_New_Token (Line_Statement):
    Gal_Keyword = 'new.token'
    Gs_Keyword = 'new.token'
    def __init__(self):
        super().__init__()
        self.Token_Entity = None
        self.Class = None
        self.Mode = None
        self.Character = None
        self.Start = None
        self.End = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Token_Entity')
        self.Token_Entity = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Mode')
        self.Mode = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Character')
        self.Character = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Start')
        self.Start = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument End')
        self.End = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '= ' + str(self.Token_Entity.Fallback) + ' (new Token_' + str(self.Class.Fallback) + ' [self] ' + str(self.Character.Fallback) + ' ' + str(self.Start.Fallback) + ' ' + str(self.End.Fallback) + ');' + str('\n') + 'push [my Tokens Symbol_Value] ' + str(self.Token_Entity.Fallback) + ';' + str('\n') + '= Mode ' + str(self.Enquote(self.Mode.Fallback)) + ';'
        self.Fallback = Gen
        return True
class Statement_Not (Line_Statement):
    Gal_Keyword = 'not'
    Gs_Keyword = 'not'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = str(self.Op1.Fallback) + ' = (not ' + str(self.Op1.Fallback) + ');'
        self.Fallback = Gen
        return True
class Statement_Nsl_Module (Scoped_Statement):
    Gal_Keyword = 'nsl.module'
    Gs_Keyword = 'nsl.module'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Get_Module_Name(self):
        return self.Name.Get_Input()
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Preamble = str(''''''  +  '\n'  +  '''var parallel = require('paralleljs');'''  +  '\n'  +  '''var fs = require("fs");'''  +  '\n'  +  '''var file_reader = require("fs");'''  +  '\n'  +  '''var read_file = function(File_Name) '''  +  '\n'  +  '''{'''  +  '\n'  +  '''    gal.file_reader.readFileSync(File_Name, 'utf8');'''  +  '\n'  +  '''};'''  +  '\n'  +  '''var write_file = function(File_Name, File_Text) '''  +  '\n'  +  '''{'''  +  '\n'  +  '''    gal.file_reader.writeFileSunc(File_Name, File_Text);'''  +  '\n'  +  '''}'''  +  '\n'  +  '''''')
        Code = str(Preamble)
        Statement = None
        for Statement in self.Block.Statements:
            Code += str(Statement.Javascript)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Preamble = '#!/usr/bin/python' + str('\n') + '# nsl module ' + str(self.Name.Python) + str('\n') + 'import zdebug' + str('\n') + 'import bisect' + str('\n') + 'from gsruntime import *' + str('\n') + str('\n') + 'INPUT = []' + str('\n') + 'OUTPUT = ""' + str('\n') + str('\n')
        Code = str(Preamble)
        Statement = None
        for Statement in self.Block.Statements:
            Code += str(Statement.Python) + str('\n')
        self.Python = Code
        return True
class Statement_Number (Declaration_Statement):
    Gal_Keyword = 'number'
    Gs_Keyword = 'number'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'number' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Variable = str(self.Variable.Gs)
        Code = 'number ' + str(Variable)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.Gs)
        Code += ';'
        self.Gs = Code
        return True
    def Infer_C(self):
        Code = 'float ' + str(self.Variable.C)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.C)
        Code += ';'
        self.C = Code
        return True
class Statement_Numbers (Line_Statement):
    Gal_Keyword = 'numbers'
    Gs_Keyword = 'numbers'
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'number ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Obj (Line_Statement):
    Gal_Keyword = 'obj'
    Gs_Keyword = 'obj'
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " = ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " = ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        pass
    def Infer_C(self):
        Arg = None
        Arg_Code = ''
        Between = '.'
        Odd = True
        for Arg in self.Arguments:
            if isinstance(Arg, Statement_Tail):
                Arg_Code += ', .' + str(Arg.C)
            else:
                Arg_Code += str(Between) + str(Arg.C)
                Odd = not Odd
                if Odd:
                    Between = ', .'
                else:
                    Between = ' = '
        Code = '{' + str(Arg_Code) + '}'
        self.C = Code
        return True
class Statement_Object (Declaration_Statement):
    Gal_Keyword = 'object'
    Gs_Keyword = 'object'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'entity' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Variable = str(self.Variable.Gs)
        Code = 'object ' + str(Variable)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.Gs)
        Code += ';'
        self.Gs = Code
        return True
    def Infer_C(self):
        # comment "The property names don't make much sense in C.";
        Class = str(self.Variable.C)
        Variable = str(self.Value.C)
        Code = str(Class) + ' ' + str(Variable) + ';'
        self.C = Code
        return True
    def Infer_C(self):
        Code = 'unsigned int ' + str(self.Variable.C)
        if self.Value is not None:
            Code += ' = ' + str(self.Value.C)
        Code += ';'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Code = 'object' + str(self.Fallback_Arguments()) + ';'
        self.Fallback = Code
        return True
class Statement_Objects (Line_Statement):
    Gal_Keyword = 'objects'
    Gs_Keyword = 'objects'
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'object ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Object_New (Line_Statement):
    Gal_Keyword = 'entity.new'
    Gs_Keyword = 'entity.new'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Class = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Class = str(self.Class.Mumps)
        Margs = str(self.Mumps_Listargs())
        Code = '$$new^' + str(Class) + '(' + str(Margs) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Class = str(self.Class.Mumps)
        Margs = str(self.Mumps_Listargs())
        Code = '$$new^' + str(Class) + '(' + str(Margs) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'entity.new' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'object ' + str(self.Variable.Gs) + ' new ' + str(self.Class.Gs) + str(self.Gs_Listargs()) + ';'
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'object ' + str(self.Variable.Fallback) + ' (new ' + str(self.Class.Fallback) + str(self.Fallback_Args()) + ');'
        self.Fallback = Gen
        return True
class Statement_Ohlc (Line_Statement):
    Gal_Keyword = 'ohlc'
    Gs_Keyword = 'ohlc'
    def __init__(self):
        super().__init__()
        self.Trading_Pair = None
        self.Epoch = None
        self.Open = None
        self.High = None
        self.Low = None
        self.Close = None
        self.Vwap = None
        self.Volume = None
        self.Count = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Trading_Pair')
        self.Trading_Pair = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Epoch')
        self.Epoch = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Open')
        self.Open = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument High')
        self.High = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Low')
        self.Low = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Close')
        self.Close = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Vwap')
        self.Vwap = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Volume')
        self.Volume = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Count')
        self.Count = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Trading_Pair = str(self.Trading_Pair.Fallback)
        Epoch = str(self.Epoch.Fallback)
        Open = str(self.Open.Fallback)
        High = str(self.High.Fallback)
        Low = str(self.Low.Fallback)
        Close = str(self.Close.Fallback)
        Vwap = str(self.Vwap.Fallback)
        Volume = str(self.Volume.Fallback)
        Count = str(self.Count.Fallback)
        Code = 'i Ohlc ' + str(Trading_Pair) + ' ' + str(Epoch) + ' ' + str(Open) + ' ' + str(High) + ' ' + str(Low) + ' ' + str(Close) + ' ' + str(Vwap) + ' ' + str(Volume) + ' ' + str(Count) + ';'
        self.Fallback = Code
        return True
class Statement_Open (Line_Statement):
    Gal_Keyword = 'open'
    Gs_Keyword = 'open'
    def __init__(self):
        super().__init__()
        self.Device = None
        self.Timeout = None
    def Infer_Mumps(self):
        Verbose = False
        Code = str("    ") + 'open ' + str(self.Device.Mumps) + ':(recordsize=1048576)'
        if self.Timeout is not None:
            Code += ':' + str(self.Timeout.Mumps)
        Code += str('\n')
        if Verbose:
            print("    open ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Code = str("    ") + 'open ' + str(self.Device.Mumps) + ':(recordsize=1048576)'
        if self.Timeout is not None:
            Code += ':' + str(self.Timeout.Mumps)
        Code += str('\n')
        if Verbose:
            print("    open ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Device')
        self.Device = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Timeout = self.Listargs.pop(0)
class Statement_Operations (Dialect_Statement):
    Gal_Keyword = 'operations'
    Gs_Keyword = 'operations'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Arg = None
        Tail = None
        Operation = 'ERROR_UNKNOWN_OPERATION'
        Keyword = 'ERROR_UNKNOWN_KEYWORD'
        Code = ''
        for Tail in self.Arguments:
            for Arg in Tail.Elements:
                if isinstance(Arg, Token_Comma):
                    Operation = 'ERROR_UNKNOWN_STATEMENT'
                    Keyword = 'ERROR_UNKNOWN_KEYWORD'
                    continue
                if isinstance(Arg, Token_Quote):
                    Keyword = Arg.Fallback
                    Code += 'dict [my Operations] ' + str(Keyword) + ' = Element;' + str('\n')
                elif isinstance(Arg, Token_Name):
                    Operation = Arg.Fallback
                    Keyword = Operation
                    Code += 'Element =  (new ' + str(Operation) + ');' + str('\n') + 'list [my Elements] append Element;' + str('\n')
                else:
                    raise Exception('unexpected statements argument ' + str(Arg.Enquote(Arg.Get_Input())))
        self.Fallback = Code
        return True
class Statement_Optimize (Scoped_Statement):
    Gal_Keyword = 'optimize'
    Gs_Keyword = 'optimize'
    def Attributes(self):
        pass
class Statement_Optimize_Equal (Line_Statement):
    Gal_Keyword = 'optimize='
    Gs_Keyword = 'optimize='
    def Attributes(self):
        pass
class Statement_Optional (Argument_Statement):
    Gal_Keyword = 'optional'
    Gs_Keyword = 'optional'
    def __init__(self):
        super().__init__()
        self.Argument_Name = None
        self.Type_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Argument_Name')
        self.Argument_Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Type_Value = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Argument_Name = str(self.Argument_Name.Fallback)
        Code = 'property object ' + str(Argument_Name) + ';'
        Declaration = 'if (gt (list [my Listargs] length) 0)' + str('\n') + '{' + str('\n')
        Declaration += str("    ") + 'my ' + str(Argument_Name) + ' = (shift [my Listargs]);' + str('\n')
        if self.Type_Value is not None:
            Declaration += str("    ") + '.= [my ' + str(Argument_Name) + '] Usage ' + str(self.Type_Value.Fallback) + ';' + str('\n')
        Declaration += '}' + str('\n')
        self.Fallback_Declaration = Declaration
        self.Fallback = Code
        return True
class Statement_Outcome (Line_Statement):
    Gal_Keyword = 'outcome'
    Gs_Keyword = 'outcome'
    def __init__(self):
        super().__init__()
        self.Result = None
        self.Implementer = None
        self.Behavior = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Result')
        self.Result = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Implementer')
        self.Implementer = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Behavior')
        self.Behavior = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Result = str(self.Result.Fallback)
        Implementer = str(self.Enquote(self.Implementer.Fallback))
        Behavior = str(self.Behavior.Fallback)
        Code = '[' + str(Behavior) + '.Roster].Insert ' + str(Implementer) + ' ' + str(Result)
        Arg = None
        for Arg in self.Listargs:
            Code += ' ' + str(Arg.Fallback)
        Code += ';'
        self.Fallback = Code
        return True
class Statement_Parser (Class_Statement):
    Gal_Keyword = 'parser'
    Gs_Keyword = 'parser'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Verbose = True
        Declarations = ''
        Statement = None
        for Statement in self.Block.Statements:
            if Statement.Fallback_Declaration is not None:
                Declarations += str(Statement.Fallback_Declaration)
            if isinstance(Statement, Statement_Infers):
                zdebug.zbreak()
                # comment 'TODO:handle parser infers statement';
            elif isinstance(Statement, Statement_Inferences):
                zdebug.zbreak()
                # comment 'TODO:handle parser inferences statement';
        Code = 'class ' + str(self.Class_Name.Fallback) + '_Parser [is Parser]' + str(self.Fallback_Args()) + str(self.Fallback_Block()) + str(Declarations)
        self.Fallback_Declaration = Declarations
        self.Fallback = Code
        return True
class Statement_Pay_Gratitude (Line_Statement):
    Gal_Keyword = 'pay.gratitude'
    Gs_Keyword = 'pay.gratitude'
    def __init__(self):
        super().__init__()
        self.Supporter = None
        self.Amount = None
    def Infer_Mumps(self):
        # comment 'Statement_Pay_Gratitude';
        Supporter = str(self.Supporter.Mumps)
        Amount = str(self.Amount.Mumps)
        Code = str("    ") + 'set %("gratitude")=$increment(@' + str(Supporter) + '@("Gratitude"),' + str(Amount) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Statement_Pay_Gratitude';
        Supporter = str(self.Supporter.Mumps)
        Amount = str(self.Amount.Mumps)
        Code = str("    ") + 'set %("gratitude")=$increment(@' + str(Supporter) + '@("Gratitude"),' + str(Amount) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Supporter')
        self.Supporter = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
class Statement_Person (Thing_Statement):
    Gal_Keyword = 'person'
    Gs_Keyword = 'person'
    Gal_Keyword = 'person'
    Gs_Keyword = 'person'
    def __init__(self):
        super().__init__()
        self.Thing_Type = 'Thing_Person'
        self.Name = None
        self.Text = None
    def Attributes(self):
        pass
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
class Statement_Plist (Line_Statement):
    Gal_Keyword = 'plist'
    Gs_Keyword = 'plist'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Name = None
        self.Count = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Count')
        self.Count = self.Listargs.pop(0)
    def Infer_C(self):
        Verbose = False
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C)
        Class = str(self.Class.C)
        Name = str(self.Name.C)
        Count = str(self.Count.C)
        List = str(Class_Name) + '_prop_' + str(Name)
        Top = 'top_' + str(List)
        if Verbose:
            print('plist class ', Class, ' name ', Name, ' count ', Count, ' class name ', Class_Name, sep='')
        Code = 'int ' + str(Top) + '[' + str(Class_Name) + '_Capacity];' + str('\n') + 'int ' + str(List) + '[' + str(Class_Name) + '_Capacity][' + str(Count) + ']; // pointer to ' + str(Class)
        Declaration = 'memset(' + str(Top) + ", '\\0', sizeof(" + str(Top) + '));' + str('\n') + 'memset(' + str(List) + ", '\\0', sizeof(" + str(List) + '));'
        C.Inits.extend([Declaration])
        self.C = Code
        return True
class Statement_Pobj (Line_Statement):
    Gal_Keyword = 'pobj'
    Gs_Keyword = 'pobj'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Name = None
        self.Initializer = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Initializer = self.Listargs.pop(0)
    def Infer_C(self):
        Object_Class = str(self.Class.C)
        Name = str(self.Name.C)
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C)
        Index = '[' + str(Object_Class) + '_Capacity]'
        Prop_Name = str(Class_Name) + '_prop_' + str(Name)
        Code = 'int ' + str(Prop_Name) + str(Index) + '; // pointer to ' + str(Object_Class)
        self.C = Code
        if self.Initializer is not None:
            Declaration = str(Prop_Name) + '[self] = ' + str(self.Initializer.C) + ';'
            self.C_Declaration = Declaration
        Initializer = 'memset(' + str(Prop_Name) + ", '\\0', sizeof(" + str(Prop_Name) + '));'
        C.Inits.extend([Initializer])
        return True
class Statement_Process (Class_Statement):
    Gal_Keyword = 'process'
    Gs_Keyword = 'process'
    def Infer_Mumps(self):
        # comment 'Statement_Process';
        Process_Name = str(self.Gs_Keywords[-1].title())
        Code = str("    ") + '; TODO process ' + str(Process_Name) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Statement_Process';
        Process_Name = str(self.Gs_Keywords[-1].title())
        Code = str("    ") + '; TODO process ' + str(Process_Name) + str('\n')
        self.Mumps = Code
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        pass
class Statement_Prompt (Scoped_Statement):
    Gal_Keyword = 'prompt'
    Gs_Keyword = 'prompt'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        global INPUT
        global OUTPUT
        Temp = []
        INPUT = Temp
        OUTPUT = '$ goalspell'
        Argument = None
        Unquoted = None
        for Argument in self.Arguments:
            INPUT.extend([Argument.Unquoted()])
        Verbose = False
        RT = Runtime_Translator()
        Input = None
        Statement = None
        for Statement in self.Block.Statements:
            Input = Statement.Get_Input()
            Compiled = str(RT.Compile(Input))
            Input = Input.replace('saay', 'say')
            Input = Input.replace('wriite', 'write')
            Input = Input.replace('reaad', 'read')
            if str(OUTPUT) > '' and str(OUTPUT[-1]) != str('\n'):
                OUTPUT += str('\n')
            OUTPUT += '~ ' + str(Input) + str('\n')
            try:
                exec(Compiled, globals())
            except Exception as Error:
                OUTPUT += str('\n') + "ERROR: " + str(Error) + str('\n')
        OUTPUT += '~ '
        Code = 'code box Prompt_' + str(Fallback_Generator.Next_Example()) + str('\n') + '{' + str('\n') + 'pane "prompt"' + str('\n') + str(self.Enquote(OUTPUT)) + ';' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Prompt_Context (Line_Statement):
    Gal_Keyword = 'prompt.context'
    Gs_Keyword = 'prompt.context'
    def Attributes(self):
        pass
    def Infer_Python(self):
        Gen = 'global INPUT' + str('\n') + 'global OUTPUT'
        self.Python = Gen
        return True
class Statement_Prop_Obj (Line_Statement):
    Gal_Keyword = 'prop.obj'
    Gs_Keyword = 'prop.obj'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Type')
        self.Type = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_C(self):
        Type = str(self.C_Type(self.Type.C))
        Name = str(self.Name.C)
        if self.Value is not None:
            zdebug.zbreak()
        Code = str(Type) + ' ' + str(Name) + ';'
        self.C = Code
        return True
class Statement_Property (Line_Statement):
    Gal_Keyword = 'property'
    Gs_Keyword = 'property'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Value = None
    def Infer_Mumps(self):
        Verbose = True
        Type = str(self.Type.Mumps)
        Name = str(self.Name.Mumps)
        Qname = str(self.Mq(Name))
        Reference = '@%self@(' + str(Qname) + ')'
        Declaration = ''
        if str(Type) == 'list':
            # comment 'append Declaration [indent]set @%self@( Qname)=0 [line]';
            Declaration += str("    ") + '; sparse property list ' + str(Name) + str('\n')
        elif str(Type) == 'dictionary':
            Declaration += str("    ") + '; sparse property dictionary ' + str(Name) + str('\n')
        elif self.Value is not None:
            Declaration += str("    ") + "set " + str(Reference) + "=" + str(self.Value.Mumps) + str('\n')
        else:
            Declaration += str("    ") + '; sparse property ' + str(Type) + ' ' + str(Name) + str('\n')
        self.Mumps_Declaration = Declaration
        self.Mumps = ''
    def Infer_Mumps(self):
        Verbose = True
        Type = str(self.Type.Mumps)
        Name = str(self.Name.Mumps)
        Qname = str(self.Mq(Name))
        Reference = '@%self@(' + str(Qname) + ')'
        Declaration = ''
        if str(Type) == 'list':
            # comment 'append Declaration [indent]set @%self@( Qname)=0 [line]';
            Declaration += str("    ") + '; sparse property list ' + str(Name) + str('\n')
        elif str(Type) == 'dictionary':
            Declaration += str("    ") + '; sparse property dictionary ' + str(Name) + str('\n')
        elif self.Value is not None:
            Declaration += str("    ") + "set " + str(Reference) + "=" + str(self.Value.Mumps) + str('\n')
        else:
            Declaration += str("    ") + '; sparse property ' + str(Type) + ' ' + str(Name) + str('\n')
        self.Mumps_Declaration = Declaration
        self.Mumps = ''
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Gs(self):
        Type = str(self.Type.Gs)
        Name = str(self.Name.Gs)
        Code = 'property ' + str(Type) + ' ' + str(Name)
        if self.Value is not None:
            Code += ' ' + str(self.Value.Gs)
        Arg = None
        for Arg in self.Listargs:
            Code += ' ' + str(Arg.Gs)
        Code += ';'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Name_Code = str(self.Name.Javascript)
        Value_Code = ''
        DT = str(self.Type.Input)
        DT = ' '  +  DT  +  ' '
        if DT in ' dict dictionary hash ':
            Value_Code = '{}'
        elif DT in ' list array ':
            Value_Code = '[]'
        # comment 'writelineproperty before defined';
        if self.Value is not None:
            Value_Code = self.Value.Javascript
        Code = 'this.' + str(Name_Code) + ' = ' + str(Value_Code) + ';'
        if str(Value_Code) == '':
            Code = '// this.'  +  Name_Code  +  ' = null;'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Name_Code = str(self.Name.Python)
        Value_Code = 'None'
        DT = str(self.Type.Input)
        DT = ' '  +  DT  +  ' '
        if DT in ' dict dictionary hash ':
            Value_Code = '{}'
        elif DT in ' list array ':
            List_Contents = ""
            if self.Value is not None:
                List_Contents += str(self.Value.Python)
                Arg = None
                for Arg in self.Listargs:
                    List_Contents += ', ' + str(Arg.Python)
            Value_Code = '['  +  List_Contents  +  ']'
        elif self.Value is not None:
            Value_Code = self.Value.Python
        # comment 'writelineproperty after defined';
        Code = 'self.' + str(Name_Code) + ' = ' + str(Value_Code)
        # comment 'writelineProperty Code  Code';
        self.Python = Code
        return True
    def Infer_C(self):
        Type = str(self.C_Type(self.Type.C))
        Name = str(self.Name.C)
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C)
        Index = '[' + str(Class_Name) + '_Capacity]'
        Prop_Name = str(Class_Name) + '_prop_' + str(Name)
        if self.Value is not None:
            Declaration = str(Class_Name) + '_prop_' + str(Name) + '[self]' + ' = ' + str(self.Value.C) + ';'
            self.C_Declaration = Declaration
        Code = str(Type) + ' ' + str(Prop_Name) + str(Index) + ';'
        Initializer = 'memset(' + str(Prop_Name) + ", '\\0', sizeof(" + str(Prop_Name) + '));'
        C.Inits.extend([Initializer])
        self.C = Code
        return True
    def Infer_Fallback(self):
        Code = 'property ' + str(self.Type.Fallback) + str(self.Fallback_Arguments()) + ';'
        self.Fallback = Code
        return True
class Statement_Propset (Assignment_Statement):
    Gal_Keyword = '.='
    Gs_Keyword = '.='
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Property = None
        self.Value = None
    def Infer_Mumps(self):
        # comment 'Statement_Propset';
        Object = str(self.Object.Mumps)
        Property = str(self.Property.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set @' + str(Object) + '@(' + str(self.Mq(Property)) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Statement_Propset';
        Object = str(self.Object.Mumps)
        Property = str(self.Property.Mumps)
        Value = str(self.Value.Mumps)
        Code = str("    ") + 'set @' + str(Object) + '@(' + str(self.Mq(Property)) + ')=' + str(Value) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property')
        self.Property = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '.=' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = str(self.Object.Gs) + '.' + str(self.Property.Gs) + ' = ' + str(self.Value.Gs) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Object.Javascript) + '.' + str(self.Property.Javascript) + ' = ' + str(self.Value.Javascript) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Object.Python) + '.' + str(self.Property.Python) + ' = ' + str(self.Value.Python)
        self.Python = Gen
        return True
    def Infer_C(self):
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C)
        Object = str(self.Object.C)
        Property = str(self.Property.C)
        Value = str(self.Value.C)
        Code = str(Class_Name) + '_prop_' + str(Property) + '[' + str(Object) + '] = ' + str(Value) + ';'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Gen = str(self.Object.Fallback) + '.' + str(self.Property.Fallback) + ' = ' + str(self.Value.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_Python (Method_Statement):
    Gal_Keyword = 'python'
    Gs_Keyword = 'python'
    def Get_Language_Name(self):
        return 'Python'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'method void Infer_Python' + str('\n') + '{' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        else:
            Argument = None
            Args_Code = ''
            for Argument in self.Arguments:
                if isinstance(Argument, Token_Name):
                    Args_Code += ' ' + str('[my '  +  Argument.Fallback  +  ' Reference]')
                else:
                    Args_Code += ' ' + str(Argument.Fallback)
            Code += str("    ") + 'string Code' + str(Args_Code) + ';' + str('\n') + str("    ") + 'my= Python Code;' + str('\n')
        Code += '}' + str('\n')
        self.Fallback = Code
        return True
class Statement_Python_Equal (Line_Statement):
    Gal_Keyword = 'python='
    Gs_Keyword = 'python='
    def Get_Language_Name(self):
        return 'Python'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Code = ''
        if len(self.Arguments) > 1:
            Code += 'Case.Python = (append' + str(Args) + ');'
        else:
            Code += 'Case.Python = ' + str(Args) + ';'
        self.Fallback = Code
        return True
class Statement_Queue (Line_Statement):
    Gal_Keyword = 'queue'
    Gs_Keyword = 'queue'
    def __init__(self):
        super().__init__()
        self.Method = None
    def Infer_Mumps(self):
        Doarg = str(self.Method.Mumps) + '^Evolver'
        Largs = str(self.Mumps_Listargs())
        Args = 'E'
        if str(Largs) > '':
            Args += ',' + str(Largs)
        Doarg += '(' + str(Args) + ')'
        Qarg = str(self.Mq(Doarg))
        Code = str("    ") + 'do %Insert^Queue("Queue",' + str(Qarg) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Doarg = str(self.Method.Mumps) + '^Evolver'
        Largs = str(self.Mumps_Listargs())
        Args = 'E'
        if str(Largs) > '':
            Args += ',' + str(Largs)
        Doarg += '(' + str(Args) + ')'
        Qarg = str(self.Mq(Doarg))
        Code = str("    ") + 'do %Insert^Queue("Queue",' + str(Qarg) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
class Statement_Quest (Class_Statement):
    Gal_Keyword = 'quest'
    Gs_Keyword = 'quest'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Infer_Mumps(self):
        # comment 'Statement_Quest';
        Name = str(self.Name.Mumps)
        Code = str("    ") + '; quest ' + str(Name) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Statement_Quest';
        Name = str(self.Name.Mumps)
        Code = str("    ") + '; quest ' + str(Name) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
class Statement_Quit_Colon (Line_Statement):
    Gal_Keyword = 'quit:'
    Gs_Keyword = 'quit:'
    def __init__(self):
        super().__init__()
        self.Condition = None
        self.Return_Value = None
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Code = str("    ") + 'quit:' + str(Condition)
        try:
            Code += ' ' + str(self.Value.Mumps)
        except Exception:
            pass
        Code += str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Code = str("    ") + 'quit:' + str(Condition)
        try:
            Code += ' ' + str(self.Value.Mumps)
        except Exception:
            pass
        Code += str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Return_Value = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Condition = str(self.Condition.Fallback)
        Return_Value = ""
        if self.Return_Value is not None:
            Return_Value += ' ' + str(self.Return_Value.Fallback)
        Code = 'if' + str(Condition) + '{' + 'return ' + str(Return_Value) + ';' + '}'
        self.Fallback = Code
        return True
class Statement_Raku (Line_Statement):
    Gal_Keyword = 'raku'
    Gs_Keyword = 'raku'
    def Get_Language_Name(self):
        return 'Raku'
    def Attributes(self):
        pass
class Statement_Raku_Equal (Line_Statement):
    Gal_Keyword = 'raku='
    Gs_Keyword = 'raku='
    def Get_Language_Name(self):
        return 'Raku'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Code = ''
        if len(self.Arguments) > 1:
            Code += 'Case.Raku = (append' + str(Args) + ');'
        else:
            Code += 'Case.Raku = ' + str(Args) + ';'
        self.Fallback = Code
        return True
class Statement_Read_Character (Line_Statement):
    Gal_Keyword = 'read.char'
    Gs_Keyword = 'read.char'
    def Attributes(self):
        pass
class Statement_Reaadline (Line_Statement):
    Gal_Keyword = 'reaadline'
    Gs_Keyword = 'reaadline'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = ''
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Token_Name):
                Code += 'append OUTPUT (list INPUT get 0);' + str('\n') + str(Argument.Fallback) + ' = (list INPUT shift);' + str('\n')
            else:
                Code += 'append OUTPUT ' + str(Argument.Fallback) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Readline (Line_Statement):
    Gal_Keyword = 'readline'
    Gs_Keyword = 'readline'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = 'read' + str(self.Gs_Arguments()) + ' line;'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' = prompt();'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' = input()'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Code = ""
        Writes = ""
        Between = ""
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Token_Name):
                if str(Writes) > "":
                    Code += str(Between) + "write " + str(Writes) + ";"
                    Between = '\n'
                    Writes = ""
                Code += str(Between) + "read " + str(Argument.Fallback) + " line;"
                Between = '\n'
            else:
                if str(Writes) > "":
                    Writes += " "
                Writes += str(Argument.Fallback)
        if str(Writes) > "":
            Code += str(Between) + "write " + str(Writes) + ";"
        self.Fallback = Code
        return True
    def Infer_Fallback(self):
        Code = ''
        Between = ''
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Token_Name):
                Code += str(Between) + str(Argument.Fallback) + ' = (Runtime:Readline);'
            else:
                Code += str(Between) + 'write ' + str(Argument.Fallback) + ';'
            Between = '\n'
        self.Fallback = Code
        return True
class Statement_Remember (Scoped_Statement):
    Gal_Keyword = 'remember'
    Gs_Keyword = 'remember'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Enquote(self.Name.Fallback))
        Variable = None
        Argument = None
        Names = ""
        for Argument in self.Listargs:
            Variable = Argument.Fallback
            Names += " " + str(Variable)
        if str(Names) > '':
            Names = ' [new list'  +  Names  +  ']'
        Statements = str(self.Block.Fallback_Statements)
        Fallback_Generator.Example_Number += 1
        Offset = Fallback_Generator.Example_Number
        Code = 'Runtime:Remember_Before ' + str(Name) + str(Names) + ';' + str('\n') + str(Statements) + 'Runtime:Remember_After ' + str(Name) + str(Names) + ';'
        self.Fallback = Code
        return True
class Statement_Rename (Line_Statement):
    Gal_Keyword = 'rename'
    Gs_Keyword = 'rename'
    def __init__(self):
        super().__init__()
        self.From = None
        self.To = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument From')
        self.From = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument To')
        self.To = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'fs.renameSync(' + str(self.From.Javascript) + ', ' + str(self.To.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'os.rename(' + str(self.From.Python) + ', ' + str(self.To.Python) + ')'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'Runtime:Rename ' + str(self.From.Fallback) + ' ' + str(self.To.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_Replace (Line_Statement):
    Gal_Keyword = 'replace'
    Gs_Keyword = 'replace'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Search_Text = None
        self.Replace_Text = None
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        Search_Text = str(self.Search_Text.Mumps)
        Replace_Text = str(self.Replace_Text.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$$Replace^%debug(' + str(Variable) + ',' + str(Search_Text) + ',' + str(Replace_Text) + ')' + str('\n')
        if Verbose:
            print("    replace ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        Search_Text = str(self.Search_Text.Mumps)
        Replace_Text = str(self.Replace_Text.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=$$Replace^%debug(' + str(Variable) + ',' + str(Search_Text) + ',' + str(Replace_Text) + ')' + str('\n')
        if Verbose:
            print("    replace ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Search_Text')
        self.Search_Text = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Replace_Text')
        self.Replace_Text = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' = ' + str(self.Variable.Javascript) + '.replaceAll(' + str(self.Search_Text.Javascript) + ', ' + str(self.Replace_Text.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' = ' + str(self.Variable.Python) + '.replace(' + str(self.Search_Text.Python) + ', ' + str(self.Replace_Text.Python) + ')'
        self.Python = Gen
        return True
class Statement_Report_Outcome (Line_Statement):
    Gal_Keyword = 'report.outcome'
    Gs_Keyword = 'report.outcome'
    def __init__(self):
        super().__init__()
        self.Result = None
        self.Implementer = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Result')
        self.Result = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Implementer')
        self.Implementer = self.Listargs.pop(0)
    def Infer_C(self):
        Result = str(self.Result.C)
        Name = str(self.Implementer.C)
        Fstring = 'outcome %f %s ' + str(C.Behavior)
        Vars = ''
        Arg = None
        Var = len(self.Listargs)
        Names = ['Zz', 'Yy', 'Xx', 'Ww', 'Vv', 'Uu']
        N = None
        for Arg in self.Listargs:
            Var += -1
            Fstring += ' %f'
            N = Names[Var]
            Vars += ', ' + str(N)
        Code = '''printf("''' + str(Fstring) + ''';\\n", ''' + str(Result) + ''', ''' + str(Name) + str(Vars) + ''');''' + str('\n')
        self.C = Code
        return True
class Statement_Require_That_I (Line_Statement):
    Gal_Keyword = 'require.that.i'
    Gs_Keyword = 'require.that.i'
    def __init__(self):
        super().__init__()
        self.Self_Method = None
    def Infer_Mumps(self):
        Self_Method = str(self.Self_Method.Mumps)
        Code = "if '$$" + str(Self_Method) + '(' + str(self.Mumps_Listargs()) + ') quit:$quit [false] quit' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Self_Method = str(self.Self_Method.Mumps)
        Code = "if '$$" + str(Self_Method) + '(' + str(self.Mumps_Listargs()) + ') quit:$quit [false] quit' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Self_Method')
        self.Self_Method = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'require.that.i' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'require that i' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'if (not (i' + str(self.Fallback_Arguments()) + '))' + '{' + 'return [false];' + '}'
        self.Fallback = Gen
        return True
class Statement_Require_That (Line_Statement):
    Gal_Keyword = 'require.that'
    Gs_Keyword = 'require.that'
    def Attributes(self):
        pass
    def Infer_Gal(self):
        Gen = 'require.that' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'require that' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Gen = 'if (not ' + str(self.Fallback_Arguments()) + ')' + '{' + 'return [false];' + '}'
        self.Fallback = Gen
        return True
class Statement_Retain (Line_Statement):
    Gal_Keyword = 'retain'
    Gs_Keyword = 'retain'
    def __init__(self):
        super().__init__()
        self.Element = None
    def Infer_Mumps(self):
        Verbose = True
        Element = str(self.Element.Mumps)
        Bias = str(self.Bias.Mumps)
        zdebug.zbreak()
        Code = 'todo'
        if Verbose:
            print("    retain ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        Element = str(self.Element.Mumps)
        Bias = str(self.Bias.Mumps)
        zdebug.zbreak()
        Code = 'todo'
        if Verbose:
            print("    retain ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Element')
        self.Element = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Elem = str(self.Element.Fallback)
        QE = str(self.Enquote(Elem))
        # comment 'TODO:include name, predecessors, map, code';
        zdebug.zbreak()
        Code = '''comment ''' + str(self.Enquote('migrate '  +  Elem)) + str(''';'''  +  '\n'  +  '''Name = [''') + str(Elem) + str('''.Name];'''  +  '\n'  +  '''Map = [''') + str(Elem) + str('''.Map];'''  +  '\n'  +  '''Supporters = [''') + str(Elem) + str('''.Supporters];'''  +  '\n'  +  '''Code = [''') + str(Elem) + str('''.Code];'''  +  '\n'  +  '''debug;'''  +  '\n'  +  '''todo "export the code here.";'''  +  '\n'  +  '''''')
        self.Fallback = Code
        return True
class Statement_Return (Line_Statement):
    Gal_Keyword = 'return'
    Gs_Keyword = 'return'
    def __init__(self):
        super().__init__()
        self.Value = None
    def Infer_Mumps(self):
        Value = '""'
        if self.Value is not None:
            Value = self.Value.Mumps
        Code = str("    ") + 'set %("return")=' + str(Value) + str('\n') + str("    ") + 'quit:$quit %("return") quit' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Value = '""'
        if self.Value is not None:
            Value = self.Value.Mumps
        Code = str("    ") + 'set %("return")=' + str(Value) + str('\n') + str("    ") + 'quit:$quit %("return") quit' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Value_Javascript = ''
        if self.Value is not None:
            Value_Javascript += ' ' + str(self.Value.Javascript)
        Code = 'return' + str(Value_Javascript) + ';'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Value_Python = ''
        if self.Value is not None:
            Value_Python += ' ' + str(self.Value.Python)
        Code = 'return' + str(Value_Python)
        self.Python = Code
        return True
    def Infer_C(self):
        Value_C = ''
        if self.Value is not None:
            Value_C += ' ' + str(self.Value.C)
        Code = 'return' + str(Value_C) + ';'
        self.C = Code
        return True
class Statement_Return_If (Line_Statement):
    Gal_Keyword = 'returnif'
    Gs_Keyword = 'returnif'
    def __init__(self):
        super().__init__()
        self.Return_Value = None
        self.Condition = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Return_Value')
        self.Return_Value = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Condition = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'returnif' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'quit :' + str(self.Gs_Arguments()) + ';'
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Condition = str(self.Condition.Fallback)
        Return_Value = ''
        if self.Return_Value is not None:
            Return_Value += ' ' + str(self.Return_Value.Fallback)
        Code = 'if ' + str(Condition) + str('\n') + '{' + str('\n') + str("    ") + 'return ' + str(Return_Value) + ';' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Return_If_Gs (Line_Statement):
    Gal_Keyword = 'return.if.gs'
    Gs_Keyword = 'return.if.gs'
    def __init__(self):
        super().__init__()
        self.Arg1 = None
        self.Arg2 = None
    def Infer_Mumps(self):
        Verbose = True
        Code = ''
        Arg1 = str(self.Arg1.Mumps)
        if self.Arg2 is not None:
            Code += str("    ") + 'if ' + str(Arg1) + ' set %("return")=' + str(self.Arg2.Mumps) + ' quit:$quit %("return") quit' + str('\n')
        else:
            Code += str("    ") + 'quit:' + str(Arg1) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        Code = ''
        Arg1 = str(self.Arg1.Mumps)
        if self.Arg2 is not None:
            Code += str("    ") + 'if ' + str(Arg1) + ' set %("return")=' + str(self.Arg2.Mumps) + ' quit:$quit %("return") quit' + str('\n')
        else:
            Code += str("    ") + 'quit:' + str(Arg1) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Arg1')
        self.Arg1 = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Arg2 = self.Listargs.pop(0)
    def Infer_C(self):
        Verbose = True
        Code = ''
        Arg1 = str(self.Arg1.C)
        if self.Arg2 is not None:
            Code += 'if (' + str(self.Arg2.C) + ') return ' + str(Arg1) + ';'
        else:
            Code += 'if (' + str(Arg1) + ') return;'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Return_Code = 'return'
        Condition = None
        if self.Arg2 is not None:
            Condition = self.Arg2.Fallback
            Return_Code += ' ' + str(self.Arg1.Fallback)
        else:
            Condition = self.Arg1.Fallback
        Code = 'if ' + str(Condition) + str('\n') + '{' + str('\n') + str("    ") + str(Return_Code) + ';' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Result (Line_Statement):
    Gal_Keyword = 'result'
    Gs_Keyword = 'result'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Roster (Statement):
    Gal_Keyword = 'roster'
    Gs_Keyword = 'roster'
    def __init__(self):
        super().__init__()
        self.Capacity = None
        self.Floor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Capacity')
        self.Capacity = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Floor')
        self.Floor = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Capacity = str(self.Capacity.Fallback)
        Floor = str(self.Floor.Fallback)
        Code = str('''Ros = (new Roster);'''  +  '\n'  +  '''Ros.Capacity = ''') + str(Capacity) + str(''';'''  +  '\n'  +  '''Ros.Floor = ''') + str(Floor) + str(''';'''  +  '\n'  +  '''Red.Roster = Ros;''')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        self.Fallback = Code
        return True
class Statement_Roster_Floor (Statement):
    Gal_Keyword = 'roster.floor'
    Gs_Keyword = 'roster.floor'
    def __init__(self):
        super().__init__()
        self.Floor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Floor')
        self.Floor = self.Listargs.pop(0)
    def Infer_C(self):
        Floor = str(self.Floor.C)
        C.Floor = Floor
        Code = '// roster floor ' + str(Floor) + str('\n')
        self.C = Code
        return True
class Statement_Run_Queue (Statement):
    Gal_Keyword = 'run.queue'
    Gs_Keyword = 'run.queue'
    def Infer_Mumps(self):
        Code = str("    ") + 'do %Run^Queue("Queue")' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str("    ") + 'do %Run^Queue("Queue")' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
class Statement_Send_File (Line_Statement):
    Gal_Keyword = 'send.file'
    Gs_Keyword = 'send.file'
    def __init__(self):
        super().__init__()
        self.File_Text = None
        self.File_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Text')
        self.File_Text = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument File_Name')
        self.File_Name = self.Listargs.pop(0)
class Statement_Sequence (Line_Statement):
    Gal_Keyword = 'sequence'
    Gs_Keyword = 'sequence'
    def __init__(self):
        super().__init__()
        self.Rule_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rule_Name')
        self.Rule_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Verbose = False
        Rule_Name = str(self.Rule_Name.Fallback)
        Declarations = ''
        First = False
        Block = 'comment ' + str(self.Enquote(self.Get_Input())) + ';' + str('\n') + 'integer Start_Char [my Char_Pos];' + str('\n') + 'integer Start_Token [my Token_Pos];' + str('\n') + 'global list My_Elements;' + str('\n')
        if Verbose:
            Block += 'verbosity [true];' + str('\n')
            Block += 'verbose "Parsing sequence ' + str(Rule_Name) + '.";' + str('\n')
        Argument = None
        Excludes = False
        for Argument in self.Listargs:
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            if isinstance(Argument, Token_Quote) or isinstance(Argument, Syntax_Line):
                Text = str(Argument.Fallback)
                Block += 'if (not (i Parse_Token My_Elements ' + str(Text) + ')) { iRollback Start_Char Start_Token (append "' + str(self.Rule_Name.Fallback) + ' expected "' + str(Text) + '"."); return [false]; }' + str('\n')
                if Verbose:
                    Block += 'verbose [indent] "Sequence ' + str(Rule_Name) + ' parsed literal: ' + str(Text) + '";' + str('\n')
            elif isinstance(Argument, Token):
                Name = str(Argument.Fallback)
                Block += 'if (not (i Parse_' + str(Name) + ' My_Elements)) { i Rollback Start_Char Start_Token "' + str(self.Rule_Name.Fallback) + ' expected ' + str(Name) + '."; return [false]; }' + str('\n')
                if Verbose:
                    Block += 'verbose [indent] "Sequence ' + str(Rule_Name) + ' parsed token ' + str(Name) + '";' + str('\n')
            elif isinstance(Argument, Syntax_Exclude):
                Excludes = True
                Block += str(Argument.Fallback) + str('\n')
                if Verbose:
                    Block += 'verbose [indent] "Sequence ' + str(Rule_Name) + ' parsed exclude: ' + str(Argument.Rule_Name.Input) + '";' + str('\n')
            else:
                Block += str(Argument.Fallback) + str('\n')
                if Verbose:
                    Block += 'verbose [indent] "Sequence ' + str(Rule_Name) + ' parsed rule: ' + str(Argument.Rule_Name.Fallback) + '";' + str('\n')
        if Verbose:
            Block += 'verbose "Sequence ' + str(Rule_Name) + ' success, start " Start_Char;' + str('\n')
        Block += 'integer End [my Char_Pos];' + str('\n') + 'object Element (new ' + str(Rule_Name) + ');' + str('\n') + 'object First_Child (lget [my Tokens] Start_Token);' + str('\n') + 'Start_Char = [First_Child.Start_Position];' + str('\n') + '.= Element Start_Position Start_Char;' + str('\n') + '.= Element End_Position End;' + str('\n') + '.= Element Document [self];' + str('\n') + 'copy [Element.Elements] = My_Elements;' + str('\n') + 'i Add_Element Element;' + str('\n') + 'push Parent_Elements Element;' + str('\n') + 'return [true];' + str('\n')
        if Excludes:
            Block = 'list Excluded;'  +  '\n'  +  Block
        Block = self.Indent(Block)
        Code = 'method flag Parse_' + str(Rule_Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str(Block) + '}'
        self.Fallback_Declarations = Declarations
        self.Fallback = Code
        return True
    def Infer_Parse(self):
        Declarations = ''
        Block = 'comment ' + str(self.Enquote(self.Get_Input())) + ';' + str('\n') + 'integer Start [my Position];' + str('\n') + 'list My_Elements;' + str('\n')
        Argument = None
        Excludes = False
        for Argument in self.Listargs:
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            if isinstance(Argument, Token_Quote) or isinstance(Argument, Syntax_Line):
                Text = str(Argument.Fallback)
                Block += 'if (not (i Parse_Token My_Elements ' + str(Text) + ')) { i Rollback Start (append "' + str(self.Rule_Name.Fallback) + ' expected "' + str(Text) + '"."); return [false]; }' + str('\n')
            elif isinstance(Argument, Token):
                Name = str(Argument.Fallback)
                Block += 'if (not (i Parse_' + str(Name) + ' My_Elements)) { debug; i Rollback Start "' + str(self.Rule_Name.Fallback) + ' expected ' + str(Name) + '."; return [false]; }' + str('\n')
            elif isinstance(Argument, Syntax_Exclude):
                Excludes = True
                Block += str(Argument.Fallback) + str('\n')
            else:
                Block += str(Argument.Fallback) + str('\n')
        Block += 'integer End [my Position];' + str('\n') + 'object Element (new ' + str(self.Rule_Name.Fallback) + ');' + str('\n') + '.= Element Start_Position Start;' + str('\n') + '.= Element End_Position End;' + str('\n') + '.= Element Document [self];' + str('\n') + '.= Element Elements My_Elements;' + str('\n') + 'i Add_Element Element;' + str('\n') + 'list.append Parent_Elements Element;' + str('\n') + 'return [true];' + str('\n')
        if Excludes:
            Block = 'list Excluded;'  +  '\n'  +  Block
        Block = self.Indent(Block)
        Code = 'method flag Parse_' + str(self.Rule_Name.Fallback) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str(Block) + '}'
        self.Fallback_Declarations = Declarations
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Statement_Saay (Line_Statement):
    Gal_Keyword = 'say'
    Gs_Keyword = 'say'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = ''
        Argument = None
        for Argument in self.Arguments:
            Args += ' (string ' + str(Argument.Fallback) + ')'
        Code = 'append OUTPUT' + str(Args) + ' [line];'
        self.Fallback = Code
        return True
class Statement_Shell (Line_Statement):
    Gal_Keyword = 'shell'
    Gs_Keyword = 'shell'
    def Infer_Mumps(self):
        Code = str("    ") + 'zsystem ' + str(self.Mumps_Arguments('_')) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str("    ") + 'zsystem ' + str(self.Mumps_Arguments('_')) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Python(self):
        Args = str(self.Python_Arguments(' + '))
        Pyargs = '(' + str(Args) + ').split()'
        Code = 'import subprocess; ' + '_shell = subprocess.run(' + str(Pyargs) + ')'
        self.Python = Code
        return True
class Statement_Skip_Token (Line_Statement):
    Gal_Keyword = 'skiptoken'
    Gs_Keyword = 'skiptoken'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Mode = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Mode')
        self.Mode = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Class = str(self.Class.Fallback)
        Mode = str(self.Mode.Fallback)
        # comment 'string Codenew token T  Class  Mode Char Position Position;';
        Code = 'T = (new Token_' + str(Class) + ' [self] Char Position Position);' + str('\n') + 'comment `' + str(Class) + ' tokens are not appended to the token list.`;' + str('\n') + 'Mode = ' + str(self.Enquote(Mode)) + ';'
        self.Fallback = Code
        return True
class Statement_Spell (Scoped_Statement):
    Gal_Keyword = 'spell'
    Gs_Keyword = 'spell'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Full_Name = str(Name)
        Fallback_Lines = ''
        Fallback_Declarations = ''
        if self.Block is not None:
            Statement = None
            for Statement in self.Block.Statements:
                Fallback_Lines += str(Statement.Fallback) + str('\n')
                if Statement.Fallback_Declaration is not None:
                    # comment 'append Fallback_Declarations [. Statement Fallback_Declaration] [line]';
                    pass
        Fallback_Block = str('\n') + '{' + str('\n') + str(self.Indent(Fallback_Declarations)) + '}'
        Code = 'class ' + str(Full_Name) + ' [is Spell]' + str(Fallback_Block)
        Code += str(Fallback_Lines)
        self.Fallback = Code
        return True
class Statement_Statements (Dialect_Statement):
    Gal_Keyword = 'statements'
    Gs_Keyword = 'statements'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Arg = None
        Tail = None
        Statement = 'ERROR_UNKNOWN_STATEMENT'
        Keyword = 'ERROR_UNKNOWN_KEYWORD'
        Code = ''
        for Tail in self.Arguments:
            for Arg in Tail.Elements:
                if isinstance(Arg, Token_Comma):
                    Statement = 'ERROR_UNKNOWN_STATEMENT'
                    Keyword = 'ERROR_UNKNOWN_KEYWORD'
                    continue
                if isinstance(Arg, Token_Quote):
                    Keyword = Arg.Fallback
                    Code += 'dict [my Statements] ' + str(Keyword) + ' = Element;' + str('\n')
                elif isinstance(Arg, Token_Name):
                    Statement = Arg.Fallback
                    Code += 'Element =  (new ' + str(Statement) + ');' + str('\n') + 'list [my Elements] append Element;' + str('\n')
                else:
                    raise Exception('unexpected statements argument ' + str(Arg.Enquote(Arg.Get_Input())))
        self.Fallback = Code
        return True
class Statement_Strings (Line_Statement):
    Gal_Keyword = 'strings'
    Gs_Keyword = 'strings'
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Args = str(self.Mumps_Arguments())
        Code = ""
        if str(Args) > "":
            Code += str("    ") + 'new ' + str(Args) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'string ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_String (Declaration_Statement):
    Gal_Keyword = 'string'
    Gs_Keyword = 'string'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Values = ''
        Arg = None
        for Arg in self.Listargs:
            if (Arg.Mumps in (None, "")):
                continue
            if str(Values) == '':
                Values += ' set ' + str(Variable) + '=' + str(Arg.Mumps)
            else:
                Values += '_' + str(Arg.Matom())
        Code = str("    ") + 'new ' + str(Variable) + str(Values) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Values = ''
        Arg = None
        for Arg in self.Listargs:
            if (Arg.Mumps in (None, "")):
                continue
            if str(Values) == '':
                Values += ' set ' + str(Variable) + '=' + str(Arg.Mumps)
            else:
                Values += '_' + str(Arg.Matom())
        Code = str("    ") + 'new ' + str(Variable) + str(Values) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'string' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Var_Code = str(self.Variable.Javascript)
        Val_Code = None
        if len(self.Listargs) > 0:
            Val_Code = ' = '  +  self.Javascript_Args(' + ')
        else:
            Val_Code = ""
        Code = 'var ' + str(Var_Code) + str(Val_Code) + ';'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Var_Code = str(self.Variable.Python)
        Val_Code = None
        if len(self.Listargs) > 0:
            Val_Code = self.Python_String_Args(' + ')
        else:
            Val_Code = "None"
        Code = str(Var_Code) + ' = ' + str(Val_Code)
        self.Python = Code
        return True
    def Infer_C(self):
        Var = str(self.Variable.C)
        Code = "char* " + str(Var) + ";"
        self.C = Code
        return True
class Statement_Subtract (Line_Statement):
    Gal_Keyword = '*='
    Gs_Keyword = '*='
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Variable)
        Arg = None
        for Arg in self.Listargs:
            Code += '-' + str(Arg.Matom())
        Code += str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str("    ") + 'set ' + str(Variable) + '=' + str(Variable)
        Arg = None
        for Arg in self.Listargs:
            Code += '-' + str(Arg.Matom())
        Code += str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' -= ' + str(self.Python_Args(' - '))
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = str(self.Variable.C) + " -= " + str(self.C_Args(' - ')) + ';'
        self.C = Gen
        return True
class Statement_Supporter (Line_Statement):
    Gal_Keyword = 'supporter'
    Gs_Keyword = 'supporter'
    def __init__(self):
        super().__init__()
        self.Person = None
        self.Supporter = None
        self.Weight = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Person')
        self.Person = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Supporter')
        self.Supporter = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Weight')
        self.Weight = self.Listargs.pop(0)
class Statement_Symbol (Class_Statement):
    Gal_Keyword = 'symbol'
    Gs_Keyword = 'symbol'
    def __init__(self):
        super().__init__()
        self.Type = None
        self.Name = None
        self.Parent_Class = None
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " variant flag integer percent certainty outcome number time string glvn object entity list dict dictionary ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
    def Attributes(self):
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Type')
        self.Type = self.Keywords.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Parent_Class = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = 'symbol ' + str(self.Type.Gs) + ' ' + str(self.Name.Gs) + str(self.Gs_Listargs()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Type = str(self.Type.Fallback)
        Name = str(self.Name.Fallback)
        Parent_Class = "Symbol"
        if self.Parent_Class is not None:
            Parent_Class = self.Parent_Class.Fallback
        Block = ''
        Declaration = ""
        if self.Block is not None:
            Block = self.Block.Fallback_Statements
            for Statement in self.Block.Statements:
                if Statement.Fallback_Declaration is not None:
                    Declaration += str(Statement.Fallback_Declaration)
        Default_Value = ', ' + str(Type) + ' Value [null]'
        Initializer = 'if (defined Value) {' + str('\n') + str("    "*3) + 'my Symbol_Value = Value;' + str('\n') + str("    "*2) + '}' + str('\n') + str("    ")
        if ' '  +  Type  +  ' ' in " list dictionary object glvn dict ":
            Default_Value = ""
            Initializer = ""
        Code = str(Declaration) + str('\n') + 'class ' + str(Name) + ' [is ' + str(Parent_Class) + ']' + str('\n') + '{' + str('\n') + str("    ") + 'property object Symbol_Object;' + str('\n') + str("    ") + 'property ' + str(Type) + ' Symbol_Value;' + str('\n') + str("    ") + 'constructor [object Object' + str(Default_Value) + ']' + str('\n') + str("    ") + '{' + str('\n') + str("    "*2) + 'my Symbol_Object = Object;' + str('\n') + str("    ") + str(Initializer) + '}' + str('\n') + str(Block) + '}'
        self.Fallback = Code
        return True
class Statement_Syntaxes (Dialect_Statement):
    Gal_Keyword = 'syntaxes'
    Gs_Keyword = 'syntaxes'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Arg = None
        Tail = None
        Syntax = 'ERROR_UNKNOWN_SYNTAX'
        Keyword = 'ERROR_UNKNOWN_KEYWORD'
        Code = ''
        for Tail in self.Arguments:
            for Arg in Tail.Elements:
                if isinstance(Arg, Token_Comma):
                    Syntax = 'ERROR_UNKNOWN_STATEMENT'
                    Keyword = 'ERROR_UNKNOWN_KEYWORD'
                    continue
                if isinstance(Arg, Token_Quote):
                    Keyword = Arg.Fallback
                    Code += 'dict [my Syntaxes] ' + str(Keyword) + ' = Element;' + str('\n')
                elif isinstance(Arg, Token_Name):
                    Syntax = Arg.Fallback
                    Code += 'Element =  (new ' + str(Syntax) + ');' + str('\n') + 'list [my Elements] append Element;' + str('\n')
                else:
                    raise Exception('unexpected statements argument ' + str(Arg.Enquote(Arg.Get_Input())))
        self.Fallback = Code
        return True
class Statement_Synthesis (Scoped_Statement):
    Gal_Keyword = 'synthesis'
    Gs_Keyword = 'synthesis'
    def Attributes(self):
        pass
class Statement_Synthesize (Scoped_Statement):
    Gal_Keyword = 'synthesize'
    Gs_Keyword = 'synthesize'
    def __init__(self):
        super().__init__()
        self.Predecessor = None
        self.Dialect = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Predecessor')
        self.Predecessor = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Dialect')
        self.Dialect = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = 'method void Synthesize [object ' + str(self.Predecessor.Fallback) + ', object ' + str(self.Dialect.Fallback) + ']' + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Statement_Target_Includes (Line_Statement):
    Gal_Keyword = 'target.includes'
    Gs_Keyword = 'target.includes'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = str(''''''  +  '\n'  +  '''var parallel = require('paralleljs');'''  +  '\n'  +  '''var fs = require("fs");'''  +  '\n'  +  '''var file_reader = require("fs");'''  +  '\n'  +  '''var read_file = function(File_Name)'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    gal.file_reader.readFileSync(File_Name, 'utf8');'''  +  '\n'  +  '''};'''  +  '\n'  +  '''var write_file = function(File_Name, File_Text)'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    gal.file_reader.writeFileSunc(File_Name, File_Text);'''  +  '\n'  +  '''}'''  +  '\n'  +  '''''')
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str('''import os'''  +  '\n'  +  '''import datetime'''  +  '\n'  +  '''import re'''  +  '\n'  +  '''import sys'''  +  '\n'  +  '''import os.path'''  +  '\n'  +  '''import uuid'''  +  '\n'  +  '''import random'''  +  '\n'  +  '''import zdebug'''  +  '\n'  +  '''''')
        self.Python = Gen
        return True
class Statement_Test (Scoped_Statement):
    Gal_Keyword = 'test'
    Gs_Keyword = 'test'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Variables = {}
    def Method_Context(self):
        return self
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = 'Test_' + str(self.Name.Fallback)
        Block = str('\n') + '{' + str('\n') + str("    ") + 'verbosity [true];' + str('\n') + str("    ") + 'number Test_Count 0;' + str('\n') + str("    ") + 'number Test_Success 0;' + str('\n') + str(self.Block.Fallback_Statements) + str("    ") + 'number Test_Outcome 0;' + str('\n') + str("    ") + 'if (Test_Count > 0) { Test_Outcome = (Test_Success / Test_Count); }' + str('\n') + str("    ") + 'return Test_Outcome;' + str('\n') + '}'
        Code = 'method object ' + str(Name) + str(Block)
        self.Fallback = Code
        return True
class Statement_Test_Case (Scoped_Statement):
    Gal_Keyword = 'testcase'
    Gs_Keyword = 'testcase'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Class_Name = str(self.Class_Name.Fallback)
        Class_Name = self.Enquote(Class_Name)
        Code = 'Cases = (Test_Case:Lookup_Class ' + str(Class_Name) + ');' + str('\n')
        if self.Block is not None:
            Code += str(self.Block.Fallback_Statements)
        # comment 'append Codei Append Case; [line]';
        self.Fallback = Code
        return True
class Statement_Tests (Scoped_Statement):
    Gal_Keyword = 'tests'
    Gs_Keyword = 'tests'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Lines = ''
        Statement = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                Lines += str(Statement.Fallback) + str('\n')
            Lines = self.Indent(Lines)
        Code = 'method flag Test_' + str(Name) + str('\n') + '{' + str('\n') + str(Lines) + str("    ") + 'return [true];' + str('\n') + '}'
        self.Fallback = Code
        return True
class Statement_Tests_Append (Scoped_Statement):
    Gal_Keyword = 'tests.append'
    Gs_Keyword = 'tests.append'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        zdebug.zbreak()
        # comment 'TODO:How to append these tests to any existing tests by that name??';
        self.Fallback = ''
        return True
    def Infer_Structure(self):
        Name = str(self.Parent.Name.Get_Input())
        Class = Statement_Class.Names[Name]
        zdebug.zbreak()
        # comment 'TODO:There are many issues still left here to resolve!!!';
        Statement = None
        for Statement in self.Block.Statements:
            Class.Appended_Statements.extend([Statement])
        return True
class Statement_Thing (Thing_Statement):
    Gal_Keyword = 'thing'
    Gs_Keyword = 'thing'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Keyword = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Keyword')
        self.Keyword = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = 'thing ' + str(self.Name.Gal) + ' ' + str(self.Keyword.Gal) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'thing ' + str(self.Name.Gs) + ' ' + str(self.Keyword.Gs) + str(self.Gs_Block())
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Class_Name = 'Thing_' + str(Name)
        Quote_Name = str(self.Enquote(Class_Name))
        Keyword = str(self.Keyword.Fallback)
        Class_Block = ''
        Statement_Block = ''
        Statement = None
        if self.Block is not None:
            for Statement in self.Block.Statements:
                # comment 'arguments to statement, all else to thing class.';
                if isinstance(Statement, Argument_Statement):
                    Statement_Block += str(Statement.Fallback) + str('\n')
                else:
                    Class_Block += str(Statement.Fallback) + str('\n')
            if str(Statement_Block) > '':
                Statement_Block = self.Indent(Statement_Block)
            if str(Class_Block) > '':
                Class_Block = self.Indent(Class_Block)
        Code = 'class ' + str(Class_Name) + ' [is Thing]' + str('\n') + '{' + str('\n') + str(Class_Block) + '}' + 'statement ' + str(Name) + " " + str(Keyword) + " Thing" + str('\n') + '{' + str('\n') + str("    ") + 'property string Thing_Type ' + str(Quote_Name) + ';' + str('\n') + str(Statement_Block) + '}'
        self.Fallback = Code
        return True
class Statement_Tilda (Statement):
    Gal_Keyword = 'tilda'
    Gs_Keyword = 'tilda'
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Verbose = True
        Keywords = None
        Keywords = ' '.join(self.Gs_Keywords)
        Keywords = Keywords.replace('~', 'tilda')
        Args = str(self.Fallback_Arguments())
        Title = str(Keywords.title())
        Name = str(Title)
        Name = Name.replace(' ', '_')
        Code = ''
        if isinstance(self.Parent, Statement_Tilda) or isinstance(self.Parent, Method_Statement):
            Code += 'i ' + str(Name) + str(Args) + ';'
        else:
            Code += 'method void ' + str(Name) + str(Args) + str(self.Fallback_Block())
        if Verbose:
            print(Code)
        self.Fallback = Code
        return True
class Statement_To_Analyze (Scoped_Statement):
    Gal_Keyword = 'to.analyze'
    Gs_Keyword = 'to.analyze'
    def __init__(self):
        super().__init__()
        self.Goal_Name = None
        self.Test = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Goal_Name')
        self.Goal_Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Test')
        self.Test = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Goal_Name = str(self.Goal_Name.Fallback)
        Test = str(self.Test.Fallback)
        Block = str(self.Fallback_Block())
        Code = 'method flag Analyze ' + str(Goal_Name) + ' ' + str(Test) + str(Block)
        self.Fallback = Code
        return True
class Statement_Tokenization (Scoped_Statement):
    Gal_Keyword = 'tokenization'
    Gs_Keyword = 'tokenization'
    def __init__(self):
        super().__init__()
        self.Language_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Language_Name')
        self.Language_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Parser = str(self.Language_Name.Fallback) + '_Parser'
        Statement = None
        Defs = str('''object O [self];'''  +  '\n'  +  '''verbosity [true];'''  +  '\n'  +  '''string Ignore;'''  +  '\n'  +  '''strings Mode C Next;'''  +  '\n'  +  '''string Q '';'''  +  '\n'  +  '''integer Position;'''  +  '\n'  +  '''string Input [my.attribute Input];'''  +  '\n'  +  '''verbose "Input: " Input;'''  +  '\n'  +  '''integer Last ((length Input) - 1);'''  +  '\n'  +  '''tokenmode Initial;'''  +  '\n'  +  '''object T;'''  +  '\n'  +  '''''')
        Handlers = str('''= Next (substring Input Position 2);'''  +  '\n'  +  '''= C (firstchar Next);'''  +  '\n'  +  '''verbose Mode ' [' C ']';'''  +  '\n'  +  '''if (Position = Last)'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    Next = '';'''  +  '\n'  +  '''}'''  +  '\n'  +  '''else'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    Next = (lastchar Next);'''  +  '\n'  +  '''}'''  +  '\n'  +  '''if (Mode s= 'Initial')'''  +  '\n'  +  '''{'''  +  '\n'  +  '''    comment 'skip other handlers';'''  +  '\n'  +  '''}'''  +  '\n'  +  '''''')
        for Statement in self.Block.Statements:
            Statement_Fallback = str(Statement.Fallback)
            Statement_Declaration = str(Statement.Fallback_Declaration)
            if str(Statement_Fallback) > '':
                Defs += str(Statement_Fallback) + str('\n')
            if str(Statement_Declaration) > '':
                Handlers += str(Statement_Declaration) + str('\n')
        Loop = 'for range Position 0 Last 1' + str('\n') + '{' + str('\n') + str(self.Indent(Handlers)) + '}' + str('\n')
        Display = 'integer Position 0;' + str('\n') + 'foreach [my.attribute Tokens] T' + str('\n') + '{' + str('\n') + str("    ") + "verbose Position ' ' [class name T] ' ' [. T Input];" + str('\n') + str("    ") + 'Position ++;' + str('\n') + '}' + str('\n')
        Display = 'if Verbose'  +  '\n'  +  '{'  +  '\n'  +  self.Indent(Display)  +  '}'  +  '\n'
        Block = str(self.Indent(Defs)) + str(self.Indent(Loop)) + str(self.Indent(Display))
        Method = 'method flag Infer_Tokens' + str('\n') + '{' + str('\n') + str(Block) + '}' + str('\n')
        Code = 'class set ' + str(Parser) + str('\n') + '{' + str('\n') + str(self.Indent(Method)) + '}'
        self.Fallback = Code
        return True
class Statement_Token_Handler (Scoped_Statement):
    Gal_Keyword = 'token.handler'
    Gs_Keyword = 'token.handler'
    def __init__(self):
        super().__init__()
        self.Mode = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Mode')
        self.Mode = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Mode = str(self.Enquote(self.Mode.Fallback))
        Code = 'else.if (Mode s= ' + str(Mode) + ')' + str(self.Fallback_Block())
        self.Fallback = ''
        self.Fallback_Declaration = Code
        return True
class Statement_Token_Initial (Scoped_Statement):
    Gal_Keyword = 'token.initial'
    Gs_Keyword = 'token.initial'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Code = 'else' + str('\n') + '{' + str('\n') + str("    ") + 'debug;' + str('\n') + str("    ") + "error 'Unknown Token Mode ' Mode;" + str('\n') + '}' + str('\n') + "comment 'this must go at the end to allow other handlers to delegate to Initial mode.';" + str('\n') + "if (Mode s= 'Initial')" + str(self.Fallback_Block())
        self.Fallback = ''
        self.Fallback_Declaration = Code
        return True
class Statement_Token_Test (Line_Statement):
    Gal_Keyword = 'token.test'
    Gs_Keyword = 'token.test'
    def __init__(self):
        super().__init__()
        self.Code_Text = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Code_Text')
        self.Code_Text = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code_Text = str(self.Code_Text.Fallback)
        Token_Code = ""
        Arg = None
        Tnum = 0
        Arg_Count = len(self.Listargs)
        for Arg in self.Listargs:
            Arg_Code = str(Arg.Fallback)
            Token_Code += "Tok = (lget [D~Tokens] " + str(Tnum) + ");" + str('\n') + "if ((Tok.Get_Text) sne " + str(Arg_Code) + ")" + str('\n') + "{" + str('\n') + str("    ") + "Deviation += 1.0;" + str('\n') + "}" + str('\n')
            Tnum += 1
        Initial_Dev = "Deviation += (abs ((llength [D~Tokens]) - " + str(Arg_Count) + "));" + str('\n')
        Code = "D = (new Document);" + str('\n') + "[D~Text] = " + str(Code_Text) + ";" + str('\n') + "Status = (D.Characterize);" + str('\n') + "Status = (D.Tokenize);" + str('\n') + "if Status" + str('\n') + "{" + str('\n') + str("    ") + "try" + str('\n') + "{" + str('\n') + str("    ") + str(Initial_Dev) + str(Token_Code) + "}" + str('\n') + "catch" + str('\n') + "{" + str('\n') + str("    ") + "Deviation += " + str(Arg_Count * 10) + ";" + str('\n') + "}" + str('\n') + "}" + str('\n') + "else" + str('\n') + "{" + str('\n') + str("    ") + "Deviation += " + str(Arg_Count * 2) + ";" + str('\n') + "}" + str('\n')
        self.Fallback = Code
        return True
class Statement_Todo (Comment_Statement):
    Gal_Keyword = 'todo'
    Gs_Keyword = 'todo'
    def Attributes(self):
        pass
    def Infer_C(self):
        Code = str(self.Gal_Key_Suffix)
        Argument = None
        for Argument in self.Arguments:
            if isinstance(Argument, Syntax_Line):
                Code += str('\n')
            elif isinstance(Argument, Syntax_Indent):
                Code += str("    ")
            elif isinstance(Argument, Token_Quote):
                Code += ' ' + str(Argument.Unquoted())
            else:
                Code += ' ' + str(Argument.C)
        if '\n' in Code:
            Code = '/* TODO:'  +  '\n'  +  Code  +  '\n'  +  '*/'
        else:
            Code = '// TODO: '  +  Code
        self.C = Code
        return True
    def Infer_Fallback(self):
        Text = 'TODO:' + str(self.Gal_Key_Suffix) + str(self.Fallback_Arguments())
        Code = 'comment ' + str(self.Enquote(Text)) + ';'
        self.Fallback = Code
        return True
class Statement_Token_Append (Line_Statement):
    Gal_Keyword = 'token.append'
    Gs_Keyword = 'token.append'
    def __init__(self):
        super().__init__()
        self.Token_Entity = None
        self.Character = None
        self.Position = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Token_Entity')
        self.Token_Entity = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Character')
        self.Character = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Position')
        self.Position = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = 'append [' + str(self.Token_Entity.Fallback) + '.Input] ' + str(self.Character.Fallback) + ';' + str('\n') + '[' + str(self.Token_Entity.Fallback) + '.Location End_Position] = ' + str(self.Position.Fallback) + ';'
        self.Fallback = Gen
        return True
class Statement_Token_Mode (Line_Statement):
    Gal_Keyword = 'token.mode'
    Gs_Keyword = 'token.mode'
    def __init__(self):
        super().__init__()
        self.Mode_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Mode_Name')
        self.Mode_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = 'Mode = ' + str(self.Enquote(self.Mode_Name.Fallback)) + ';'
        self.Fallback = Gen
        return True
class Statement_Tokens (Line_Statement):
    Gal_Keyword = 'tokens'
    Gs_Keyword = 'tokens'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Verbose = False
        Code = ''
        Argument = None
        Between = ''
        Declaration = ''
        D = None
        for Argument in self.Arguments:
            Name = str(Argument.Fallback)
            Code += str(Between) + 'method flag Parse_' + str(Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str("    ") + 'object Top_Token (i Top_Token);' + str('\n') + str("    ") + 'quit : (isnull Top_Token) [false];' + str('\n') + str("    ") + 'if (not (isa Top_Token ' + str(Name) + ')) { ' + 'Top_Token.Error = "Expected ' + str(Name) + '";' + str('\n') + 'return [false]; }' + str('\n') + str("    ") + 'push Parent_Elements Top_Token;' + str('\n') + str("    ") + 'Top_Token.Error = [null];' + str('\n') + str("    ") + 'i Consume_Token;' + str('\n') + str("    ") + 'return [true];' + str('\n') + '}'
            Between = '\n'
        self.Fallback = Code
        # comment "(append `` [line] `            string Declaration` [line] `                'class set ' Name ' { property flag Isa_' Name ' [true]; }' [line];` [line] `            verbose 'token declaration: ' Declaration;` [line] `            my= Fallback_Declaration Declaration;` [line] `            `)";
        return True
    def Infer_Parse(self):
        Code = ''
        Argument = None
        Between = ''
        for Argument in self.Arguments:
            Name = str(Argument.Fallback)
            Code += str(Between) + 'method flag Parse_' + str(Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str("    ") + 'object Top_Token (. [self] Top_Token);' + str('\n') + str("    ") + 'returnif (not (isa Top_Token ' + str(Name) + ')) [false];' + str('\n') + str("    ") + 'list.append Parent_Elements Top_Token;' + str('\n') + str("    ") + 'i Consume_Token;' + str('\n') + str("    ") + 'return [true];' + str('\n') + '}'
            Between = '\n'
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Statement_Token (Line_Statement):
    Gal_Keyword = 'token'
    Gs_Keyword = 'token'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Verbose = False
        Name = str(self.Class_Name.Fallback)
        Code = 'method flag Parse_' + str(Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str("    ") + 'object Top_Token (i Top_Token);' + str('\n') + str("    ") + 'quit : (isnull Top_Token) [false];' + str('\n') + str("    ") + 'if (not (isa Top_Token ' + str(Name) + ')) { ' + 'Top_Token.Error = "Expected ' + str(Name) + '";' + str('\n') + 'return [false]; }' + str('\n') + str("    ") + 'push Parent_Elements Top_Token;' + str('\n') + str("    ") + 'Top_Token.Error = [null];' + str('\n') + str("    ") + 'i Consume_Token;' + str('\n') + str("    ") + 'return [true];' + str('\n') + '}'
        self.Fallback = Code
        Declaration = 'class set ' + str(Name) + ' { property flag Isa_' + str(Name) + ' [true]; }' + str('\n')
        if Verbose:
            print('token declaration: ', Declaration, sep='')
        self.Fallback_Declaration = Declaration
        return True
    def Infer_Parse(self):
        Name = str(self.Class_Name.Fallback)
        Code = 'method flag Parse_' + str(Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str("    ") + 'object Top_Token (. [self] Top_Token);' + str('\n') + str("    ") + 'returnif (not (isa Top_Token ' + str(Name) + ')) [false];' + str('\n') + str("    ") + 'list.append Parent_Elements Top_Token;' + str('\n') + str("    ") + 'i Consume_Token;' + str('\n') + str("    ") + 'return [true];' + str('\n') + '}'
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Statement_Token_New (Line_Statement):
    Gal_Keyword = 'token.new'
    Gs_Keyword = 'token.new'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Mode = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Mode')
        self.Mode = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Class = str(self.Class.Fallback)
        Mode = str(self.Mode.Fallback)
        # comment 'string Codenew token T  Class  Mode Char Position Position;';
        Code = 'T = (new Token_' + str(Class) + ' [self] Char Position Position);' + str('\n') + 'list append [my Tokens Symbol_Value] T;' + str('\n') + 'Mode = ' + str(self.Enquote(Mode)) + ';'
        self.Fallback = Code
        return True
class Statement_Translation_Tests (Scoped_Statement):
    Gal_Keyword = 'translation.tests'
    Gs_Keyword = 'translation.tests'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
class Statement_Try (Error_Handling_Statement):
    Gal_Keyword = 'try'
    Gs_Keyword = 'try'
    def Infer_Mumps(self):
        # comment 'Statement_Try';
        End_Label = str(self.End_Label)
        Catch_Label = str(Mumps.Get_Label())
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'new $etrap,$estack' + str('\n') + str("    ") + 'set $etrap="quit:$estack  goto ' + str(Catch_Label) + '"' + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Catch_Label) + ' ; try catch label.' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Statement_Try';
        End_Label = str(self.End_Label)
        Catch_Label = str(Mumps.Get_Label())
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'new $etrap,$estack' + str('\n') + str("    ") + 'set $etrap="quit:$estack  goto ' + str(Catch_Label) + '"' + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Catch_Label) + ' ; try catch label.' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'try' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'try' + str(self.Python_Block())
        self.Python = Gen
        return True
class Statement_Try_At_Of (Line_Statement):
    Gal_Keyword = 'try.at.of'
    Gs_Keyword = 'try.at.of'
    def __init__(self):
        super().__init__()
        self.Implementer = None
        self.Test = None
        self.Goal_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Implementer')
        self.Implementer = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Test')
        self.Test = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Goal_Name')
        self.Goal_Name = self.Listargs.pop(0)
class Statement_Undefined (Scoped_Statement):
    Gal_Keyword = 'undefined'
    Gs_Keyword = 'undefined'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Ifargs = ""
        Between = ''
        Argument = None
        for Argument in self.Arguments:
            Ifargs += str(Between) + str(Argument.Javascript) + ' == null'
            Between = ' && '
        Block = str(self.Javascript_Block())
        Code = "if (" + str(Ifargs) + ')' + str(Block)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Ifargs = ""
        Argument = None
        for Argument in self.Arguments:
            Ifargs += "if " + str(Argument.Python) + ' is None:' + str('\n') + str("    ") + 'raise ValueError' + str('\n')
        Ifargs = self.Py_Indent(Ifargs)
        Block = str(self.Python_Block())
        Code = "try:" + str('\n') + str(Ifargs)
        Code += "except (ValueError, AttributeError)" + str(Block)
        self.Python = Code
        return True
class Statement_Unlock (Line_Statement):
    Gal_Keyword = 'unlock'
    Gs_Keyword = 'unlock'
    def __init__(self):
        super().__init__()
        self.Reference = None
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock -' + str(Ref) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock -' + str(Ref) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Reference')
        self.Reference = self.Listargs.pop(0)
class Statement_Global_Unlock (Line_Statement):
    Gal_Keyword = 'unlock^'
    Gs_Keyword = 'unlock^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock -^' + str(Ref) + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Ref = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > '':
            Ref += '(' + str(Args) + ')'
        Code = str("    ") + 'lock -^' + str(Ref) + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Statement_Unless (Iffy_Statement):
    Gal_Keyword = 'unless'
    Gs_Keyword = 'unless'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Infer_Mumps(self):
        Arguments = str(self.Mumps_Arguments())
        Else_Label = str(Mumps.Get_Label())
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'if ' + str(Arguments) + ' goto ' + str(Else_Label) + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Else_Label) + ' ; if-else' + str('\n')
        if self.Is_Last:
            Code += str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Arguments = str(self.Mumps_Arguments())
        Else_Label = str(Mumps.Get_Label())
        End_Label = str(self.End_Label)
        Block = str(self.Mumps_Block())
        Code = str("    ") + 'if ' + str(Arguments) + ' goto ' + str(Else_Label) + str('\n') + str(Block) + str("    ") + 'goto ' + str(End_Label) + str('\n') + str(Else_Label) + ' ; if-else' + str('\n')
        if self.Is_Last:
            Code += str(End_Label) + ' ; end if' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
class Statement_Uuid (Line_Statement):
    Gal_Keyword = 'uuid'
    Gs_Keyword = 'uuid'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'var ' + str(self.Variable.Javascript) + ' = self.crypto.randomUUID();'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' = uuid.uuid4().hex'
        self.Python = Gen
        return True
class Statement_Values (Scoped_Statement):
    Gal_Keyword = 'values'
    Gs_Keyword = 'values'
    def Attributes(self):
        pass
class Statement_Variants (Line_Statement):
    Gal_Keyword = 'variants'
    Gs_Keyword = 'variants'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Argument = None
        Code = ''
        for Argument in self.Arguments:
            Variable = str(Argument.Fallback)
            Code += 'variant ' + str(Variable) + ';' + str('\n')
        self.Fallback = Code
        return True
class Statement_Variant (Declaration_Statement):
    Gal_Keyword = 'variant'
    Gs_Keyword = 'variant'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Value = self.Listargs.pop(0)
class Statement_Variations (Scoped_Statement):
    Gal_Keyword = 'variations'
    Gs_Keyword = 'variations'
    def Attributes(self):
        pass
class Statement_Vernacular (Scoped_Statement):
    Gal_Keyword = 'vernacular'
    Gs_Keyword = 'vernacular'
    def Attributes(self):
        pass
class Statement_Verbose (Append_Args_Statement):
    Gal_Keyword = 'verbose'
    Gs_Keyword = 'verbose'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Gen = 'if Verbose' + str('\n') + '{' + str('\n') + str("    ") + 'write' + str(self.Fallback_Arguments()) + ' line;' + str('\n') + '}'
        self.Fallback = Gen
        return True
class Statement_Verbosity (Statement):
    Gal_Keyword = 'line'
    Gs_Keyword = 'line'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Condition = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Condition = '[false]'
        if self.Condition is not None:
            Condition = self.Condition.Fallback
        Code = 'flag Verbose ' + str(Condition) + ';'
        self.Fallback = Code
        return True
class Statement_We (Line_Statement):
    Gal_Keyword = 'we'
    Gs_Keyword = 'we'
    def __init__(self):
        super().__init__()
        self.Method = None
    def Infer_Mumps(self):
        Method = str(self.Method.Mumps)
        Args = str(self.Mumps_Listargs())
        My_Class = self.Mumps_Class()
        Class_Name = str(My_Class.Name.Mumps)
        Code = str("    ") + 'do %' + str(Method) + '(' + str(self.Mq(Class_Name)) + ',' + str(Args) + ')' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Method = str(self.Method.Mumps)
        Args = str(self.Mumps_Listargs())
        My_Class = self.Mumps_Class()
        Class_Name = str(My_Class.Name.Mumps)
        Code = str("    ") + 'do %' + str(Method) + '(' + str(self.Mq(Class_Name)) + ',' + str(Args) + ')' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Class_Name = 'this.constructor'
        Context = self.Method_Context()
        if Context and isinstance(Context, Class_Method_Statement):
            Class_Name = 'this'
        Code = str(Class_Name) + '.' + str(self.Method.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'self.__class__.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
    def Infer_Python(self):
        Gen = 'cls.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
class Statement_Web_App (Method_Statement):
    Gal_Keyword = 'web.app'
    Gs_Keyword = 'web.app'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Name = str(self.Name.Javascript)
        Block = ''
        Statement = None
        try:
            for Statement in self.Block.Statements:
                Block += str(Statement.Javascript) + str('\n')
        except Exception:
            pass
        Code = '// Web application: ' + str(Name) + str('\n') + str(Block)
        self.Javascript = Code
        return True
class Statement_While (Iterative_Statement):
    Gal_Keyword = 'while'
    Gs_Keyword = 'while'
    def __init__(self):
        super().__init__()
        self.Condition = None
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str(Continue_Label) + ' ; while continue' + str('\n') + str("    ") + 'if ' + str(Condition) + str('\n') + str("    ") + 'else  goto ' + str(Break_Label) + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; while break' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Condition = str(self.Condition.Mumps)
        Break_Label = str(self.Break_Label())
        Continue_Label = str(self.Continue_Label())
        Code = str(Continue_Label) + ' ; while continue' + str('\n') + str("    ") + 'if ' + str(Condition) + str('\n') + str("    ") + 'else  goto ' + str(Break_Label) + str('\n') + str(self.Mumps_Block()) + str("    ") + 'goto ' + str(Continue_Label) + str('\n') + str(Break_Label) + ' ; while break' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'while (' + str(self.Condition.Javascript) + ')' + str(self.Javascript_Block())
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'while ' + str(self.Condition.Python) + str(self.Python_Block())
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'while (' + str(self.Condition.C) + ')' + str(self.C_Block())
        self.C = Gen
        return True
class Statement_Wriite (Line_Statement):
    Gal_Keyword = 'write'
    Gs_Keyword = 'write'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = ''
        Argument = None
        for Argument in self.Arguments:
            Args += ' (string ' + str(Argument.Fallback) + ')'
        Code = ''
        if str(Args) > '':
            Code += 'append OUTPUT' + str(Args) + ';'
        self.Fallback = Code
        return True
class Statement_Write (Append_Args_Statement):
    Gal_Keyword = 'write'
    Gs_Keyword = 'write'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'process.stdout.write(' + str(self.Javascript_Args(', ')) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Code = 'print(' + str(self.Python_Args(', '))
        if len(self.Listargs) > 1:
            Code += ", sep=''"
        Code += ", end='')"
        self.Python = Code
        return True
    def Infer_C(self):
        Verbose = True
        Format_String = ''
        Args = ''
        Arg = None
        for Arg in self.Arguments:
            if isinstance(Arg, Token_Quote):
                Format_String += str(Arg.Unquoted())
            elif isinstance(Arg, Syntax_Node):
                Format_String += '%f'
                Args += ', ' + str(Arg.C)
            elif isinstance(Arg, Syntax):
                Format_String += '%s'
                Args += ', ' + str(Arg.C)
            else:
                Context = self.Method_Context()
                Variable = str(Arg.C)
                FT = '%f'
                if Variable in Context.Variables.keys():
                    Type = str(Context.Variables[Variable])
                    FT = self.C_Format_Code(Type)
                Format_String += str(FT)
                Args += ', ' + str(Variable)
        Code = 'printf("' + str(Format_String) + '"' + str(Args) + ');'
        self.C = Code
        return True
class Statement_Write_Line (Append_Args_Statement):
    Gal_Keyword = 'writeline'
    Gs_Keyword = 'writeline'
    def Infer_Mumps(self):
        Code = str("    ") + 'use $principal write ' + str(self.Mumps_Arguments()) + ',!' + str('\n')
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str("    ") + 'use $principal write ' + str(self.Mumps_Arguments()) + ',!' + str('\n')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Gal(self):
        Gen = 'writeline' + str(self.Gal_Arguments()) + ';'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'say' + str(self.Gs_Arguments()) + ';'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'console.log(' + str(self.Javascript_Args(', ')) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Code = 'print(' + str(self.Python_Args(', '))
        if len(self.Listargs) > 1:
            Code += ", sep=''"
        Code += ")"
        self.Python = Code
        return True
    def Infer_C(self):
        Verbose = True
        Format_String = ''
        Args = ''
        Arg = None
        for Arg in self.Arguments:
            if isinstance(Arg, Token_Quote):
                Format_String += str(Arg.Unquoted())
            elif isinstance(Arg, Syntax_Node):
                Format_String += '%f'
                Args += ', ' + str(Arg.C)
            elif isinstance(Arg, Syntax):
                Format_String += '%s'
                Args += ', ' + str(Arg.C)
            else:
                Context = self.Method_Context()
                Variable = str(Arg.C)
                FT = '%f'
                if Variable in Context.Variables.keys():
                    Type = str(Context.Variables[Variable])
                    FT = self.C_Format_Code(Type)
                Format_String += str(FT)
                Args += ', ' + str(Variable)
        Code = 'printf("' + str(Format_String) + '\\n"' + str(Args) + ');'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Gen = 'say' + str(self.Fallback_Arguments()) + ';'
        self.Fallback = Gen
        return True
class Statement_Yes (Line_Statement):
    Gal_Keyword = 'yes'
    Gs_Keyword = 'yes'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Arguments = str(self.Fallback_Arguments())
        if len(self.Arguments) > 1:
            Arguments = '(append '  +  Arguments  +  ')'
        Code = 'quit : (i Fail ' + str(Arguments) + ') [false];'
        self.Fallback = Code
        return True
class Operation_Absolute (Operation):
    Gal_Keyword = 'absolute'
    Gs_Keyword = 'absolute'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = '$fnumber(' + str(Op1) + ',"-")'
        self.Mumps = Code
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = '$fnumber(' + str(Op1) + ',"-")'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'Math.abs(' + str(self.Op1.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'abs(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Op1 = str(self.Op1.C)
        Code = 'fabs(' + str(Op1) + ')'
        self.C = Code
        return True
class Operation_Add (Repeating_Operation):
    Gal_Keyword = '+'
    Gs_Keyword = '+'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '+'
        self.Javascript_Operator = '+'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '+'
        self.Python_Operator = '+'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '+'
        self.C_Operator = '+'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        self.Mrepeating('+')
    def Infer_Mumps(self):
        self.Mrepeating('+')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' + ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_And (Repeating_Operation):
    Gal_Keyword = '&'
    Gs_Keyword = '&'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '&&'
        self.Javascript_Operator = '&&'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = 'and'
        self.Python_Operator = 'and'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '&&'
        self.C_Operator = '&&'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "&", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "&", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('&')
    def Infer_Mumps(self):
        self.Mrepeating('&')
    def Infer_Mumps(self):
        self.Mrepeating('&')
    def Infer_Mumps(self):
        self.Mrepeating('&')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(and' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' and ' + str(self.Op2.Gs) + str(self.Gs_Listargs()) + ')'
        self.Gs = Gen
        return True
class Operation_Begins (Operation):
    Gal_Keyword = 'begins'
    Gs_Keyword = 'begins'
    def __init__(self):
        super().__init__()
        self.String_Value = None
        self.Begin_Value = None
    def Infer_Mumps(self):
        String_Value = str(self.String_Value.Mumps)
        Code = '$extract(' + str(String_Value) + ',1,$length(' + str(self.Begin_Value.Mumps) + '))=' + str(self.Begin_Value.Matom())
        self.Mumps = Code
    def Infer_Mumps(self):
        String_Value = str(self.String_Value.Mumps)
        Code = '$extract(' + str(String_Value) + ',1,$length(' + str(self.Begin_Value.Mumps) + '))=' + str(self.Begin_Value.Matom())
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String_Value')
        self.String_Value = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Begin_Value')
        self.Begin_Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.String_Value.Javascript) + '.substr(0,' + str(self.Begin_Value.Javascript) + '.length) == ' + str(self.Begin_Value.Javascript)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.String_Value.Python) + '[:len(' + str(self.Begin_Value.Python) + ')] == ' + str(self.Begin_Value.Python)
        self.Python = Gen
        return True
class Operation_Call (Operation):
    Gal_Keyword = '.'
    Gs_Keyword = '.'
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Method = None
    def Infer_Mumps(self):
        Object = str(self.Object.Mumps)
        Method = str(self.Mq(self.Method.Mumps))
        Method = Method.replace('_', '')
        Margs = ''
        Arg = None
        for Arg in self.Listargs:
            Margs += ',' + str(Arg.Mumps)
        Code = "$$dispatch" + str(len(self.Listargs)) + "^gal(" + str(Object) + "," + str(Method) + str(Margs) + ")"
        self.Mumps = Code
    def Infer_Mumps(self):
        Object = str(self.Object.Mumps)
        Method = str(self.Mq(self.Method.Mumps))
        Method = Method.replace('_', '')
        Margs = ''
        Arg = None
        for Arg in self.Listargs:
            Margs += ',' + str(Arg.Mumps)
        Code = "$$dispatch" + str(len(self.Listargs)) + "^gal(" + str(Object) + "," + str(Method) + str(Margs) + ")"
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '(' + str(self.Object.Gs) + '.' + str(self.Method.Gs) + str(self.Gs_Listargs()) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Object.Javascript) + '.' + str(self.Method.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Object.Python) + '.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Object = str(self.Object.C)
        Method = str(self.Method.C)
        Arguments = str(self.C_Args(', '))
        Code = '(' + str(Object) + '->' + str(Method) + ')(' + str(Arguments) + ')'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Gen = '(' + str(self.Object.Fallback) + '.' + str(self.Method.Fallback) + str(self.Fallback_Args()) + ')'
        self.Fallback = Gen
        return True
class Operation_Can (Operation):
    Gal_Keyword = 'can'
    Gs_Keyword = 'can'
    def __init__(self):
        super().__init__()
        self.Predecessor = None
        self.Successor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Predecessor')
        self.Predecessor = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Successor')
        self.Successor = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '(' + str(self.Successor.Fallback) + '.Can ' + str(self.Predecessor.Fallback) + ')'
        self.Fallback = Gen
        return True
class Operation_Char2int (Operation):
    Gal_Keyword = 'char2int'
    Gs_Keyword = 'char2int'
    def __init__(self):
        super().__init__()
        self.Character = None
    def Infer_Mumps(self):
        Code = '$ascii(' + str(self.Character.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$ascii(' + str(self.Character.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Character')
        self.Character = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Integer.Javascript) + '.charCodeAt()'
        self.Javascript = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.Character.Javascript) + '.charCodeAt(0)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'ord(' + str(self.Character.Python) + ')'
        self.Python = Gen
        return True
class Operation_Classpropget (Operation):
    Gal_Keyword = 'classproget'
    Gs_Keyword = 'classproget'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Class_Name = None
        Property_Name = None
        if self.Second is not None:
            Class_Name = self.First.Javascript
            Property_Name = self.Second.Javascript
        else:
            Class_Name = 'this.constructor'
            Context = self.Method_Context()
            if Context and isinstance(Context, Class_Method_Statement):
                Class_Name = 'this'
            Property_Name = self.First.Javascript
        Code = str(Class_Name) + '.' + str(Property_Name)
        self.Javascript = Code
        return True
    def Infer_Javascript(self):
        Gen = str(self.Javascript_Arguments('.'))
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Class_Name = None
        Property_Name = None
        if self.Second is not None:
            Class_Name = self.First.Python
            Property_Name = self.Second.Python
        else:
            Class_Name = 'self.__class__'
            Property_Name = self.First.Python
        Code = str(Class_Name) + '.' + str(Property_Name)
        self.Python = Code
        return True
    def Infer_Python(self):
        Gen = str(self.Python_Arguments('.'))
        self.Python = Gen
        return True
class Operation_Colon (Operation):
    Gal_Keyword = ':'
    Gs_Keyword = ':'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Method = None
    def Infer_Mumps(self):
        # comment 'Operation_Colon';
        Class = str(self.Class.Mumps)
        Class = Class.replace('_', '')
        Method = str(self.Method.Mumps)
        Method = Method.replace('_', '')
        Margs = str(self.Mq(Class))
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = '$$%' + str(Method) + '^' + str(Class) + '(' + str(Margs) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Operation_Colon';
        Class = str(self.Class.Mumps)
        Class = Class.replace('_', '')
        Method = str(self.Method.Mumps)
        Method = Method.replace('_', '')
        Margs = str(self.Mq(Class))
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = '$$%' + str(Method) + '^' + str(Class) + '(' + str(Margs) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Class.Javascript) + '.' + str(self.Method.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Class.Python) + '.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
class Operation_Contains (Binary_Operation):
    Gal_Keyword = 'contains'
    Gs_Keyword = 'contains'
    def __init__(self):
        super().__init__()
        self.String = None
        self.Search = None
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.String, "[", self.Search))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.String, "[", self.Search))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('[')
    def Infer_Mumps(self):
        self.Mrepeating('[')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String')
        self.String = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Search')
        self.Search = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.String.Javascript) + '.includes(' + str(self.Search.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Search.Python) + ' in ' + str(self.String.Python)
        self.Python = Gen
        return True
    def Infer_C(self):
        String = str(self.String.C)
        Search = str(self.Search.C)
        Code = 'strstr(' + str(String) + ', ' + str(Search) + ') != NULL'
        self.C = Code
        return True
class Operation_Create_Element (Operation):
    Gal_Keyword = 'create.element'
    Gs_Keyword = 'create.element'
    def __init__(self):
        super().__init__()
        self.Tag = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Tag')
        self.Tag = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Tag = str(self.Tag.Javascript)
        Code = 'document.createElement(' + str(Tag) + ')'
        self.Javascript = Code
        return True
class Operation_Csv_String (Operation):
    Gal_Keyword = 'csv.string'
    Gs_Keyword = 'csv.string'
    def __init__(self):
        super().__init__()
        self.Columns = None
        self.Rows = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Columns')
        self.Columns = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rows')
        self.Rows = self.Listargs.pop(0)
class Operation_Default (Operation):
    Gal_Keyword = 'default'
    Gs_Keyword = 'default'
    def __init__(self):
        super().__init__()
        self.Value = None
        self.Root = None
    def Infer_Mumps(self):
        Value = str(self.Value.Mumps)
        Node = '@$name(' + str(self.Root.Mumps) + ')'
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node += '@(' + str(Args) + ')'
        Code = '$get(' + str(Node) + ',' + str(Value) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Value = str(self.Value.Mumps)
        Node = '@$name(' + str(self.Root.Mumps) + ')'
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node += '@(' + str(Args) + ')'
        Code = '$get(' + str(Node) + ',' + str(Value) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Default_Global (Operation):
    Gal_Keyword = 'default^'
    Gs_Keyword = 'default^'
    def __init__(self):
        super().__init__()
        self.Value = None
        self.Root = None
    def Infer_Mumps(self):
        Value = str(self.Value.Mumps)
        Node = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node += '(' + str(Args) + ')'
        Code = '$get(^' + str(Node) + ',' + str(Value) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Value = str(self.Value.Mumps)
        Node = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Args) > "":
            Node += '(' + str(Args) + ')'
        Code = '$get(^' + str(Node) + ',' + str(Value) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Exists (Operation):
    Gal_Keyword = 'exists'
    Gs_Keyword = 'exists'
    Gal_Keyword = 'exists'
    Gs_Keyword = 'exists'
    def __init__(self):
        super().__init__()
        self.Root = None
        self.Root = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Defined (Operation):
    Gal_Keyword = 'defined'
    Gs_Keyword = 'defined'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        First = str(self.First.Mumps)
        First = Mumps.Glvn(First)
        Code = '$data(' + str(First) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        First = str(self.First.Mumps)
        First = Mumps.Glvn(First)
        Code = '$data(' + str(First) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + ' != null'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + ' is not None'
        self.Python = Gen
        return True
class Operation_Dict_Exists (Operation):
    Gal_Keyword = 'dict.exists'
    Gs_Keyword = 'dict.exists'
    def __init__(self):
        super().__init__()
        self.Dictionary = None
        self.Key = None
    def Infer_Mumps(self):
        Dictionary = str(self.Dictionary.Mumps)
        Dictionary = Mumps.String(Dictionary)
        Key = str(self.Key.Mumps)
        Code = '$data(@' + str(Dictionary) + '@(' + str(Key) + '))'
        self.Mumps = Code
    def Infer_Mumps(self):
        Dictionary = str(self.Dictionary.Mumps)
        Dictionary = Mumps.String(Dictionary)
        Key = str(self.Key.Mumps)
        Code = '$data(@' + str(Dictionary) + '@(' + str(Key) + '))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Dictionary')
        self.Dictionary = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Key')
        self.Key = self.Listargs.pop(0)
    def Infer_Gs(self):
        Dictionary = str(self.Dictionary.Gs)
        Key = str(self.Key.Gs)
        Code = '(dict ' + str(Dictionary) + ' exists ' + str(Key) + ')'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Gen = '(' + str(self.Dictionary.Javascript) + '[' + str(self.Key.Javascript) + '] != null)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Key.Python) + ' in ' + str(self.Dictionary.Python) + '.keys()'
        self.Python = Gen
        return True
class Operation_Dict_Get (Operation):
    Gal_Keyword = 'dict.get'
    Gs_Keyword = 'dict.get'
    def __init__(self):
        super().__init__()
        self.Dictionary = None
        self.Key = None
    def Infer_Mumps(self):
        Dictionary = str(self.Dictionary.Matom())
        if str(Dictionary[0]) == '@':
            Dictionary = '$name('  +  Dictionary  +  ')'
        elif str(Dictionary[0]) == "^" and '(' in Dictionary:
            Dictionary = '$name('  +  Dictionary  +  ')'
        Key = str(self.Key.Mumps)
        Code = '@' + str(Dictionary) + '@(' + str(Key) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Dictionary = str(self.Dictionary.Matom())
        if str(Dictionary[0]) == '@':
            Dictionary = '$name('  +  Dictionary  +  ')'
        elif str(Dictionary[0]) == "^" and '(' in Dictionary:
            Dictionary = '$name('  +  Dictionary  +  ')'
        Key = str(self.Key.Mumps)
        Code = '@' + str(Dictionary) + '@(' + str(Key) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Dictionary')
        self.Dictionary = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Key')
        self.Key = self.Listargs.pop(0)
    def Infer_Gs(self):
        Dictionary = str(self.Dictionary.Gs)
        Key = str(self.Key.Gs)
        Code = '(dict ' + str(Dictionary) + ' get ' + str(Key) + ')'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Gen = str(self.Dictionary.Javascript) + '[' + str(self.Key.Javascript) + ']'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Dictionary.Python) + '[' + str(self.Key.Python) + ']'
        self.Python = Gen
        return True
class Operation_Dispatch (Operation):
    Gal_Keyword = 'dispatch'
    Gs_Keyword = 'dispatch'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = str(self.Name.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
class Operation_Distribute (Operation):
    Gal_Keyword = 'distribute'
    Gs_Keyword = 'distribute'
    def __init__(self):
        super().__init__()
        self.List = None
        self.Function = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Function')
        self.Function = self.Listargs.pop(0)
    def Infer_Python(self):
        List = str(self.List.Python)
        Function = str(self.Function.Python)
        Code = 'mp.Pool(mp.cpu_count()).map(' + str(Function) + ', ' + str(List) + ')'
        self.Python = Code
        return True
class Operation_Divide (Repeating_Operation):
    Gal_Keyword = '/'
    Gs_Keyword = '/'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '/'
        self.Javascript_Operator = '/'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '/'
        self.Python_Operator = '/'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '/'
        self.C_Operator = '/'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_C(self):
        Op1 = str(self.Op1.C)
        Op2 = str(self.Op2.C)
        Code = '(' + str(Op2) + ' == 0 ? 0 : ' + str(Op1) + ' / ' + str(Op2) + ')'
        self.C = Code
    def Infer_C(self):
        Op1 = str(self.Op1.C)
        Op2 = str(self.Op2.C)
        Code = '(' + str(Op2) + ' == 0 ? 0 : ' + str(Op1) + ' / ' + str(Op2) + ')'
        self.C = Code
    def Infer_Mumps(self):
        self.Mrepeating('/')
    def Infer_Mumps(self):
        self.Mrepeating('/')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' / ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_Dequote (Operation):
    Gal_Keyword = 'dequote'
    Gs_Keyword = 'dequote'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
class Operation_Enquote (Operation):
    Gal_Keyword = 'enquote'
    Gs_Keyword = 'enquote'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'gal.enquote(' + str(self.Op1.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'Runtime.Enquote(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = '(Runtime:Enquote ' + str(self.Op1.Fallback) + ')'
        self.Fallback = Gen
        return True
class Operation_Equal (Binary_Operation):
    Gal_Keyword = '='
    Gs_Keyword = '='
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '=='
        self.Javascript_Operator = '=='
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '=='
        self.Python_Operator = '=='
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '=='
        self.C_Operator = '=='
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "=", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "=", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('=')
    def Infer_Mumps(self):
        self.Mrepeating('=')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' = ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_Environment (Operation):
    Gal_Keyword = 'env'
    Gs_Keyword = 'env'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str(self.Mq(os.environ[Variable]))
        self.Mumps = Code
    def Infer_Mumps(self):
        Variable = str(self.Variable.Mumps)
        Code = str(self.Mq(os.environ[Variable]))
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'process.env.' + str(self.Variable.Javascript)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'os.environ[' + str(self.Variable.Python) + ']'
        self.Python = Gen
        return True
class Operation_Evaluate (Operation):
    Gal_Keyword = 'evaluate'
    Gs_Keyword = 'evaluate'
    def __init__(self):
        super().__init__()
        self.Target = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Target')
        self.Target = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'evaluate(' + str(self.Javascript_Arguments(' + ')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Code = 'eval(' + str(self.Target.Python) + ')'
        self.Python = Code
        return True
class Operation_Not_Equal (Binary_Operation):
    Gal_Keyword = '!='
    Gs_Keyword = '!='
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '!='
        self.Javascript_Operator = '!='
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '!='
        self.Python_Operator = '!='
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '!='
        self.C_Operator = '!='
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'=", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'=", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating("'=")
    def Infer_Mumps(self):
        self.Mrepeating("'=")
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
class Operation_Exists_Global (Operation):
    Gal_Keyword = 'exists^'
    Gs_Keyword = 'exists^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_File_Exists (Operation):
    Gal_Keyword = 'file.exists'
    Gs_Keyword = 'file.exists'
    def __init__(self):
        super().__init__()
        self.Path = None
    def Infer_Mumps(self):
        Path = str(self.Path.Mumps)
        Code = '$$fileexists^gal(' + str(Path) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Path = str(self.Path.Mumps)
        Code = '$$fileexists^gal(' + str(Path) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Path')
        self.Path = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'gal.fs.readFileSync(' + str(self.Path.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'Runtime.File_Exists(' + str(self.Path.Python) + ')'
        self.Python = Gen
        return True
class Operation_Files (Operation):
    Gal_Keyword = 'files'
    Gs_Keyword = 'files'
    def __init__(self):
        super().__init__()
        self.Filespec = None
    # comment 'TODO:return a list of matching fully-qualified file names.';
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Filespec')
        self.Filespec = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'fs.readDirSync(' + str(self.Filespec.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'os.listdir(' + str(self.Filespec.Python) + ')'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = '(Runtime:Files ' + str(self.Filespec.Fallback) + ')'
        self.Fallback = Gen
        return True
class Operation_First_Char (Operation):
    Gal_Keyword = 'firstchar'
    Gs_Keyword = 'firstchar'
    def __init__(self):
        super().__init__()
        self.String_Value = None
    def Infer_Mumps(self):
        Code = '$extract(' + str(self.String_Value.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$extract(' + str(self.String_Value.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String_Value')
        self.String_Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.String_Value.Javascript) + '.substring(0,1)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.String_Value.Python) + '[0]'
        self.Python = Gen
        return True
class Operation_Flowerbox (Operation):
    Gal_Keyword = 'flowerbox'
    Gs_Keyword = 'flowerbox'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Comment_Text = ''
        Argument = None
        for Argument in self.Arguments:
            Arg_Text = str(Argument.Fallback)
            if isinstance(Argument, Token_Quote):
                Arg_Text = Argument.Unquoted()
            Comment_Text += str(Arg_Text)
        Lines = Comment_Text.split('\n')
        Comment_Text = ''
        Line = None
        Full = None
        Width = 0
        for Line in Lines:
            if len(Line) > Width:
                Width = len(Line)
        for Line in Lines:
            Full = Line  +  '                                                                                                          '
            Full = Full[0:(0)+(Width)]
            Full = '* '  +  Full  +  ' *'
            Comment_Text += str(self.Enquote(Full)) + ' [line]'
        Width += 4
        Stars = '"' + str("****************************************************************************************************************"[0:(0)+(Width)]) + '"'
        Comment_Text = Stars  +  ' [line] '  +  Comment_Text  +  ' '  +  Stars
        Code = '(append' + str(Comment_Text) + ')'
        self.Fallback = Code
        return True
class Operation_From_Json (Operation):
    Gal_Keyword = 'from.json'
    Gs_Keyword = 'from.json'
    def __init__(self):
        super().__init__()
        self.Object = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'JSON.parse(' + str(self.Object.Javascript) + ')'
        self.Javascript = Gen
        return True
class Operation_Get (Operation):
    Gal_Keyword = 'get'
    Gs_Keyword = 'get'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Glvn = str(self.Root.Mumps)
        Args = ''
        Between = ''
        Arg = None
        for Arg in self.Listargs:
            Args += str(Between) + str(Arg.Mumps)
            Between = ','
        if str(Args) > '':
            Glvn = '@$name('  +  Glvn  +  ')@('  +  Args  +  ')'
        Code = '$get(' + str(Glvn) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Glvn = str(self.Root.Mumps)
        Args = ''
        Between = ''
        Arg = None
        for Arg in self.Listargs:
            Args += str(Between) + str(Arg.Mumps)
            Between = ','
        if str(Args) > '':
            Glvn = '@$name('  +  Glvn  +  ')@('  +  Args  +  ')'
        Code = '$get(' + str(Glvn) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
    def Infer_Python(self):
        Root = str(self.Root.Python)
        Code = str(Root)
        Arg = None
        for Arg in self.Listargs:
            zdebug.zbreak()
            # comment 'TODO:figure out how this works in python';
        self.Python = Code
        return True
class Operation_Get_Element_By_Id (Operation):
    Gal_Keyword = 'get.element.by.id'
    Gs_Keyword = 'get.element.by.id'
    def __init__(self):
        super().__init__()
        self.Id = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Id')
        self.Id = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'document.getElementById(' + str(self.Id.Javascript) + ')'
        self.Javascript = Gen
        return True
class Operation_Get_Global (Operation):
    Gal_Keyword = 'get^'
    Gs_Keyword = 'get^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Glvn = '^' + str(self.Root.Mumps)
        Args = ''
        Between = ''
        Arg = None
        for Arg in self.Listargs:
            Args += str(Between) + str(Arg.Mumps)
            Between = ','
        if str(Args) > '':
            Glvn += '(' + str(Args) + ')'
        Code = '$get(' + str(Glvn) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Glvn = '^' + str(self.Root.Mumps)
        Args = ''
        Between = ''
        Arg = None
        for Arg in self.Listargs:
            Args += str(Between) + str(Arg.Mumps)
            Between = ','
        if str(Args) > '':
            Glvn += '(' + str(Args) + ')'
        Code = '$get(' + str(Glvn) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Glvn (Operation):
    Gal_Keyword = 'glvn'
    Gs_Keyword = 'glvn'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Code = str(self.Variable.Mumps)
        Next = '('
        Subscripts = str(self.Mumps_Listargs())
        if str(self.Gs_Keywords[-1]) == '^':
            Code = '^'  +  Code
        if str(Subscripts) > '':
            if '$name' in Code:
                zdebug.zbreak()
            # comment "this doesn't handle $name yet";
            if str(Code[-1]) == ')':
                Code = Code[0:(0)+(len(Code) - 1)]
                Next = ','
            Code += str(Next) + str(Subscripts) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Variable.Mumps)
        Next = '('
        Subscripts = str(self.Mumps_Listargs())
        if str(self.Gs_Keywords[-1]) == '^':
            Code = '^'  +  Code
        if str(Subscripts) > '':
            if '$name' in Code:
                zdebug.zbreak()
            # comment "this doesn't handle $name yet";
            if str(Code[-1]) == ')':
                Code = Code[0:(0)+(len(Code) - 1)]
                Next = ','
            Code += str(Next) + str(Subscripts) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
class Operation_Greater_Equal (Binary_Operation):
    Gal_Keyword = 'ge'
    Gs_Keyword = 'ge'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '<='
        self.Javascript_Operator = '<='
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '>='
        self.Python_Operator = '>='
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '>='
        self.C_Operator = '>='
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'<", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'<", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating(''''<''')
    def Infer_Mumps(self):
        self.Mrepeating(''''<''')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(ge' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' ge ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_Greater_Than (Binary_Operation):
    Gal_Keyword = 'gt'
    Gs_Keyword = 'gt'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '<'
        self.Javascript_Operator = '<'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '>'
        self.Python_Operator = '>'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '>'
        self.C_Operator = '>'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, ">", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, ">", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('>')
    def Infer_Mumps(self):
        self.Mrepeating('>')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(gt' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' gt ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_Http_Fetch (Operation):
    Gal_Keyword = 'http.fetch'
    Gs_Keyword = 'http.fetch'
    def __init__(self):
        super().__init__()
        self.Url = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Url')
        self.Url = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'await fetch(' + str(self.Javascript_Arguments(", ")) + ')'
        self.Javascript = Gen
        return True
class Operation_I (Operation):
    Gal_Keyword = 'i'
    Gs_Keyword = 'i'
    def __init__(self):
        super().__init__()
        self.Method = None
    def Infer_Mumps(self):
        Method = str(self.Mq(self.Method.Mumps))
        Margs = ""
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = "$$dispatch" + str(len(self.Listargs)) + "^gal(%self," + str(Method) + str(Margs) + ")"
        self.Mumps = Code
    def Infer_Mumps(self):
        Method = str(self.Mq(self.Method.Mumps))
        Margs = ""
        Arg = None
        for Arg in self.Listargs:
            Margs += "," + str(Arg.Mumps)
        Code = "$$dispatch" + str(len(self.Listargs)) + "^gal(%self," + str(Method) + str(Margs) + ")"
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'this.' + str(self.Method.Javascript) + '(' + str(self.Javascript_Args(',')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'self.' + str(self.Method.Python) + '(' + str(self.Python_Args(',')) + ')'
        self.Python = Gen
        return True
class Operation_If (Operation):
    Gal_Keyword = 'if'
    Gs_Keyword = 'if'
    def __init__(self):
        super().__init__()
        self.Condition = None
        self.If_Value = None
        self.Else_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument If_Value')
        self.If_Value = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Else_Value')
        self.Else_Value = self.Listargs.pop(0)
    def Infer_Data_Types(self):
        self.Condition.Data_Type = 'flag'
        self.Data_Type = self.If_Value.Data_Type
        return True
class Operation_Implement (Operation):
    Gal_Keyword = 'implement'
    Gs_Keyword = 'implement'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'eval(Implementer)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Assigns = ''
        Between = ''
        Argument = None
        for Argument in self.Arguments:
            Argpy = str(Argument.Python)
            Qarg = str(Argument.Py_Enquote())
            Assigns += str(Between) + str(Qarg) + ':' + str(Argpy)
            Between = ', '
        Code = 'eval(Implementer, {}, {' + str(Assigns) + '})'
        self.Python = Code
        return True
class Operation_Int2char (Operation):
    Gal_Keyword = 'int2char'
    Gs_Keyword = 'int2char'
    def __init__(self):
        super().__init__()
        self.Integer = None
    def Infer_Mumps(self):
        Code = '$char(' + str(self.Integer.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$char(' + str(self.Integer.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Integer')
        self.Integer = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'String.fromCharCode(' + str(self.Javascript_Arguments(',')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'String.fromCharCode(' + str(self.Integer.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Integer = str(self.Integer.Python)
        Code = 'chr(' + str(Integer) + ')'
        self.Python = Code
        return True
class Operation_Integer (Unary_Operation):
    Gal_Keyword = 'integer'
    Gs_Keyword = 'integer'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps) + '\\1'
        Code = str(Op1)
        self.Mumps = Code
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps) + '\\1'
        Code = str(Op1)
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'parseInt(' + str(self.Op1.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'int(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
class Operation_Flag (Unary_Operation):
    Gal_Keyword = 'flag'
    Gs_Keyword = 'flag'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str(Op1) + '&1'
        self.Mumps = Code
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str(Op1) + '&1'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = 'bool(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
class Operation_Number (Unary_Operation):
    Gal_Keyword = 'number'
    Gs_Keyword = 'number'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str(Op1) + '+0'
        self.Mumps = Code
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str(Op1) + '+0'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = 'float(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
class Operation_String (Unary_Operation):
    Gal_Keyword = 'string'
    Gs_Keyword = 'string'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str(Op1)
        self.Mumps = Code
    def Infer_Mumps(self):
        Op1 = str(self.Op1.Mumps)
        Code = str(Op1)
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Op1.Javascript) + '.toString()'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
class Operation_Invoke (Operation):
    Gal_Keyword = 'invoke'
    Gs_Keyword = 'invoke'
    def __init__(self):
        super().__init__()
        self.Function = None
    def Infer_Mumps(self):
        Function = str(self.Function.Mumps)
        Arguments = str(self.Mumps_Listargs())
        Code = '$$' + str(Function) + '(' + str(Arguments) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Function = str(self.Function.Mumps)
        Arguments = str(self.Mumps_Listargs())
        Code = '$$' + str(Function) + '(' + str(Arguments) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Function')
        self.Function = self.Listargs.pop(0)
    def Infer_C(self):
        Gen = str(self.Function.C) + '(' + str(self.C_Args(', ')) + ')'
        self.C = Gen
        return True
class Operation_Integer_Divide (Operation):
    Gal_Keyword = 'intdiv'
    Gs_Keyword = 'intdiv'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
    def Infer_Mumps(self):
        self.Mrepeating('\\')
    def Infer_Mumps(self):
        self.Mrepeating('\\')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
class Operation_Is_A (Operation):
    Gal_Keyword = 'isa'
    Gs_Keyword = 'isa'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Class_Name = None
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        Class_Name = str(self.Class_Name.Mumps)
        Class_Name = Class_Name.replace('_', '')
        Qname = str(self.Mq(Class_Name))
        Code = '$data(@("^%"_@(' + str(Variable) + '))@("Ancestors",' + str(Qname) + '))'
        if Verbose:
            print("!!! isa mumps ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Variable = str(self.Variable.Mumps)
        Class_Name = str(self.Class_Name.Mumps)
        Class_Name = Class_Name.replace('_', '')
        Qname = str(self.Mq(Class_Name))
        Code = '$data(@("^%"_@(' + str(Variable) + '))@("Ancestors",' + str(Qname) + '))'
        if Verbose:
            print("!!! isa mumps ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(isa ' + str(self.Variable.Gal) + ' ' + str(self.Class_Name.Gal) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Verbose = False
        # comment 'string Variable [my Variable Mumps]';
        # comment 'string Class_Name [my Class_Name Mumps]';
        Variable = str(self.Variable.Gs)
        Class_Name = str(self.Class_Name.Gs)
        Isa_Name = 'Isa_' + str(Class_Name)
        Declaration = 'class set Element { property flag ' + str(Isa_Name) + ' [false]; }' + str('\n') + 'class set ' + str(Class_Name) + ' { property flag ' + str(Isa_Name) + ' [true]; }' + str('\n')
        # comment 'my= Mumps_Outer_Declaration Declaration';
        # comment 'verboseIs_A outer declaration created:  [line] Declaration';
        Code = '(isa ' + str(self.Variable.Gs) + ' ' + str(self.Class_Name.Gs) + ')'
        self.Gs = Code
        return True
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' instanceof ' + str(self.Class_Name.Javascript)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'isinstance(' + str(self.Variable.Python) + ', ' + str(self.Class_Name.Python) + ')'
        self.Python = Gen
        return True
class Operation_Is_Ident (Operation):
    Gal_Keyword = 'is.ident'
    Gs_Keyword = 'is.ident'
    def __init__(self):
        super().__init__()
        self.Character = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Character')
        self.Character = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = '"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789".includes(' + str(self.Character.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = '(' + str(self.Character.Python) + ' in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789")'
        self.Python = Gen
        return True
class Operation_Is_Lowercase (Operation):
    Gal_Keyword = 'is.lowercase'
    Gs_Keyword = 'is.lowercase'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        Code = '$$islowercase^gal(' + str(self.First.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$islowercase^gal(' + str(self.First.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.match(/[a-z]/)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.islower()'
        self.Python = Gen
        return True
class Operation_Is_Uppercase (Operation):
    Gal_Keyword = 'is.uppercase'
    Gs_Keyword = 'is.uppercase'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        Code = '$$isuppercase^gal(' + str(self.First.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$isuppercase^gal(' + str(self.First.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.match(/[A-Z]/)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.isupper()'
        self.Python = Gen
        return True
class Operation_Is_Whitespace (Operation):
    Gal_Keyword = 'is.whitespace'
    Gs_Keyword = 'is.whitespace'
    def __init__(self):
        super().__init__()
        self.Character = None
    def Infer_Mumps(self):
        Code = '$$isws^gal(' + str(self.Character.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$isws^gal(' + str(self.Character.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Character')
        self.Character = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(is.whitespace' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Gen = '" \\t\\n\\r".includes(' + str(self.Character.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = '(' + str(self.Character.Python) + ' in " \\n\\r\\t")'
        self.Python = Gen
        return True
class Operation_Is_Digit (Operation):
    Gal_Keyword = 'is.digit'
    Gs_Keyword = 'is.digit'
    def __init__(self):
        super().__init__()
        self.Character = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Character')
        self.Character = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = str(self.Character.Python) + ' in string.digits'
        self.Python = Gen
        return True
class Operation_Is_Punct (Operation):
    Gal_Keyword = 'is.punct'
    Gs_Keyword = 'is.punct'
    def __init__(self):
        super().__init__()
        self.Character = None
    def Infer_Mumps(self):
        Code = '$$ispunct^gal(' + str(self.Character.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$ispunct^gal(' + str(self.Character.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Character')
        self.Character = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = str(self.Character.Python) + ' in string.punctuation'
        self.Python = Gen
        return True
class Operation_Is_Number (Operation):
    Gal_Keyword = 'is.number'
    Gs_Keyword = 'is.number'
    def __init__(self):
        super().__init__()
        self.Value = None
    def Infer_Mumps(self):
        Code = '$$isnumber^gal(' + str(self.Value.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$isnumber^gal(' + str(self.Value.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = '(typeof ' + str(self.Value.Javascript) + " === 'number')"
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'isinstance(' + str(self.Value.Python) + ', (int, float, complex))'
        self.Python = Gen
        return True
class Operation_Is_String (Operation):
    Gal_Keyword = 'is.string'
    Gs_Keyword = 'is.string'
    def __init__(self):
        super().__init__()
        self.Value = None
    def Infer_Mumps(self):
        Code = '$$isstring^gal(' + str(self.Value.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$isstring^gal(' + str(self.Value.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = '(typeof ' + str(self.Value.Javascript) + " === 'string')"
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'isinstance(' + str(self.Value.Python) + ', str)'
        self.Python = Gen
        return True
class Operation_Last_Char (Operation):
    Gal_Keyword = 'last.char'
    Gs_Keyword = 'last.char'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        Code = '$extract(' + str(self.First.Mumps) + ',$length(' + str(self.First.Mumps) + '))'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$extract(' + str(self.First.Mumps) + ',$length(' + str(self.First.Mumps) + '))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.slice(-1)'
        self.Javascript = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.slice(-1)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '[-1]'
        self.Python = Gen
        return True
class Operation_Length (Operation):
    Gal_Keyword = 'length'
    Gs_Keyword = 'length'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        Code = '$length(' + str(self.First.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$length(' + str(self.First.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(length' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.length'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'len(' + str(self.First.Python) + ')'
        self.Python = Gen
        return True
class Operation_Less_Equal (Binary_Operation):
    Gal_Keyword = 'le'
    Gs_Keyword = 'le'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '<='
        self.Javascript_Operator = '<='
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '<='
        self.Python_Operator = '<='
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '<='
        self.C_Operator = '<='
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'>", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'>", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating(''''>''')
    def Infer_Mumps(self):
        self.Mrepeating(''''>''')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(le' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' le ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_Less_Than (Binary_Operation):
    Gal_Keyword = 'lt'
    Gs_Keyword = 'lt'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '<'
        self.Javascript_Operator = '<'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '<'
        self.Python_Operator = '<'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '<'
        self.C_Operator = '<'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "<", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "<", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('<')
    def Infer_Mumps(self):
        self.Mrepeating('<')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(lt' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' lt ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_List_Get (Operation):
    Gal_Keyword = 'list.get'
    Gs_Keyword = 'list.get'
    def __init__(self):
        super().__init__()
        self.List = None
        self.Offset = None
    def Infer_Mumps(self):
        List = str(self.List.Mumps)
        if str(List[0]) == '@':
            List = '$name('  +  List  +  ')'
        Code = '$get(@' + str(List) + '@(' + str(self.Offset.Mumps) + '+1))'
        self.Mumps = Code
    def Infer_Mumps(self):
        List = str(self.List.Mumps)
        if str(List[0]) == '@':
            List = '$name('  +  List  +  ')'
        Code = '$get(@' + str(List) + '@(' + str(self.Offset.Mumps) + '+1))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Offset')
        self.Offset = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(list.get' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(list ' + str(self.List.Gs) + ' get ' + str(self.Offset.Gs) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        if not self.List.Javascript is not None:
            raise Exception(str(self.Failure_Message('List Javascript missing')))
        if not self.Offset.Javascript is not None:
            raise Exception(str(self.Failure_Message('Offset Javascript missing')))
        Code = str(self.List.Javascript) + '[' + str(self.Offset.Javascript) + ']'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        if not self.List.Python is not None:
            raise Exception(str(self.Failure_Message('List Python missing')))
        if not self.Offset.Python is not None:
            raise Exception(str(self.Failure_Message('Offset Python missing')))
        Code = str(self.List.Python) + '[' + str(self.Offset.Python) + ']'
        self.Python = Code
        return True
    def Infer_C(self):
        Gen = str(self.List.C) + '[' + str(self.Offset.C) + ']'
        self.C = Gen
        return True
class Operation_List_Last (Operation):
    Gal_Keyword = 'list.last'
    Gs_Keyword = 'list.last'
    def __init__(self):
        super().__init__()
        self.List = None
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Code = '$$listlast^gal($name(' + str(List) + '))'
        if Verbose:
            print("    ", 'list last ', List, ' --> ', Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        List = str(self.List.Mumps)
        Code = '$$listlast^gal($name(' + str(List) + '))'
        if Verbose:
            print("    ", 'list last ', List, ' --> ', Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument List')
        self.List = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(list.last' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(list ' + str(self.List.Gs) + ' last )'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Code = str(self.List.Javascript) + '.slice(-1)'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        if not self.List.Python is not None:
            raise Exception(str(self.Failure_Message('List Python missing')))
        Code = str(self.List.Python) + '[-1]'
        self.Python = Code
        return True
class Operation_List_Length (Operation):
    Gal_Keyword = 'list.length'
    Gs_Keyword = 'list.length'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        Verbose = True
        First = str(self.First.Matom())
        if str(First[0]) != '@':
            First = '@('  +  First  +  ')'
        Code = '$get(' + str(First) + ',0)'
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        First = str(self.First.Matom())
        if str(First[0]) != '@':
            First = '@('  +  First  +  ')'
        Code = '$get(' + str(First) + ',0)'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(list.length' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(list' + str(self.Gs_Arguments()) + ' length)'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.length'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'len(' + str(self.First.Python) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = 'top_' + str(self.First.C)
        self.C = Gen
        return True
class Operation_Lowercase (Operation):
    Gal_Keyword = 'lowercase'
    Gs_Keyword = 'lowercase'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        Code = '$translate(' + str(self.First.Mumps) + ',"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$translate(' + str(self.First.Mumps) + ',"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.toLowerCase()'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.lower()'
        self.Python = Gen
        return True
class Operation_Module_Class_Name_New (Operation):
    Gal_Keyword = 'module.class.name.new'
    Gs_Keyword = 'module.class.name.new'
    def __init__(self):
        super().__init__()
        self.Module = None
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Module')
        self.Module = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = 'getattr(sys.modules["' + str(self.Module.Python) + '"], ' + str(self.Name.Python) + ')()'
        self.Python = Gen
        return True
class Operation_Modulo (Binary_Operation):
    Gal_Keyword = 'mod'
    Gs_Keyword = 'mod'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '%'
        self.Javascript_Operator = '%'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '%'
        self.Python_Operator = '%'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '%'
        self.C_Operator = '%'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        self.Mrepeating('#')
    def Infer_Mumps(self):
        self.Mrepeating('#')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
class Operation_Multiply (Repeating_Operation):
    Gal_Keyword = '*'
    Gs_Keyword = '*'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '*'
        self.Javascript_Operator = '*'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '*'
        self.Python_Operator = '*'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '*'
        self.C_Operator = '*'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        self.Mrepeating('*')
    def Infer_Mumps(self):
        self.Mrepeating('*')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' * ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
class Operation_Name (Operation):
    Gal_Keyword = 'name'
    Gs_Keyword = 'name'
    def __init__(self):
        super().__init__()
        self.Glvn = None
    def Infer_Mumps(self):
        # comment 'Operation_Name';
        Glvn = str(self.Glvn.Mumps)
        if str(self.Gs_Keywords[-1]) == '^':
            Glvn = '^'  +  Glvn
        Subscripts = str(self.Mumps_Listargs())
        if str(Subscripts) > '':
            Glvn += '(' + str(Subscripts) + ')'
        Code = '$name(' + str(Glvn) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Operation_Name';
        Glvn = str(self.Glvn.Mumps)
        if str(self.Gs_Keywords[-1]) == '^':
            Glvn = '^'  +  Glvn
        Subscripts = str(self.Mumps_Listargs())
        if str(Subscripts) > '':
            Glvn += '(' + str(Subscripts) + ')'
        Code = '$name(' + str(Glvn) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Glvn')
        self.Glvn = self.Listargs.pop(0)
class Operation_New (Operation):
    Gal_Keyword = 'new'
    Gs_Keyword = 'new'
    def __init__(self):
        super().__init__()
        self.Class_Name = None
    def Infer_Mumps(self):
        Class_Name = str(self.Class_Name.Mumps)
        Margs = ""
        Arg = None
        Between = ''
        for Arg in self.Listargs:
            Margs += str(Between) + str(Arg.Mumps)
            Between = ','
        Code = "$$new^" + str(Class_Name) + '(' + str(Margs) + ")"
        self.Mumps = Code
    def Infer_Mumps(self):
        Class_Name = str(self.Class_Name.Mumps)
        Margs = ""
        Arg = None
        Between = ''
        for Arg in self.Listargs:
            Margs += str(Between) + str(Arg.Mumps)
            Between = ','
        Code = "$$new^" + str(Class_Name) + '(' + str(Margs) + ")"
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'new ' + str(self.Class_Name.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Class_Name.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Class_Name = str(self.Class_Name.C)
        Args = str(self.C_Args(', '))
        Code = str(Class_Name) + '_constructor(' + str(Args) + ')'
        self.C = Code
        return True
    def Infer_Data_Types(self):
        self.Data_Type = 'object'
        self.Class_Name.Data_Type = 'class'
        self.Class_Name.Usage = 'class'
        return True
class Operation_New_My_Class (Operation):
    Gal_Keyword = 'new.my.class'
    Gs_Keyword = 'new.my.class'
    def Infer_Mumps(self):
        Verbose = False
        Args = str(self.Mumps_Arguments())
        Code = '$$new(' + str(Args) + ')'
        if Verbose:
            print("    new my class ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Args = str(self.Mumps_Arguments())
        Code = '$$new(' + str(Args) + ')'
        if Verbose:
            print("    new my class ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        pass
class Operation_New_Our_Class (Operation):
    Gal_Keyword = 'new.our.class'
    Gs_Keyword = 'new.our.class'
    def Infer_Mumps(self):
        Verbose = False
        Args = str(self.Mumps_Arguments())
        Code = '$$new(' + str(Args) + ')'
        if Verbose:
            print("    new our class ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Args = str(self.Mumps_Arguments())
        Code = '$$new(' + str(Args) + ')'
        if Verbose:
            print("    new our class ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        pass
class Operation_Not (Unary_Operation):
    Gal_Keyword = 'not'
    Gs_Keyword = 'not'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Javascript_Operator = '!'
        self.Javascript_Operator = '!'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = 'not'
        self.Python_Operator = 'not'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '!'
        self.C_Operator = '!'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = "'" + str(self.Op1.Matom())
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = "'" + str(self.Op1.Matom())
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(not' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(!' + str(self.Gs_Arguments()) + ')'
        self.Gs = Gen
        return True
class Operation_Is_Null (Unary_Operation):
    Gal_Keyword = 'isnull'
    Gs_Keyword = 'isnull'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Code = str(self.Op1.Mumps) + '''=""'''
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Op1.Mumps) + '''=""'''
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = '(' + str(self.Variable.Javascript) + ' == null || ' + str(self.Variable.Javascript) + ' == "")'
        self.Javascript = Gen
        return True
    def Infer_Javascript(self):
        Gen = '!(' + str(self.Op1.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = '(' + str(self.Op1.Python) + ' in (None, ""))'
        self.Python = Gen
        return True
class Operation_Next (Operation):
    Gal_Keyword = 'next'
    Gs_Keyword = 'next'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        if str(Root[0]) == '@':
            Root = '$name('  +  Root  +  ')'
        Args = str(self.Mumps_Listargs())
        Code = '$order(@' + str(Root) + '@(' + str(Args) + '))'
        self.Mumps = Code
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        if str(Root[0]) == '@':
            Root = '$name('  +  Root  +  ')'
        Args = str(self.Mumps_Listargs())
        Code = '$order(@' + str(Root) + '@(' + str(Args) + '))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Next_Global (Operation):
    Gal_Keyword = 'next^'
    Gs_Keyword = 'next^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        Code = '$order(^' + str(Root) + '(' + str(Args) + '))'
        self.Mumps = Code
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        Code = '$order(^' + str(Root) + '(' + str(Args) + '))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Not_Null (Unary_Operation):
    Gal_Keyword = 'notnull'
    Gs_Keyword = 'notnull'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Infer_Mumps(self):
        Code = str(self.Op1.Mumps) + ''''=""'''
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Op1.Mumps) + ''''=""'''
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = '(' + str(self.Op1.Javascript) + ' != null && ' + str(self.Op1.Javascript) + '.toString() > "")'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Op1.Python) + ' > ""'
        self.Python = Gen
        return True
class Operation_Or (Repeating_Operation):
    Gal_Keyword = 'or'
    Gs_Keyword = 'or'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '||'
        self.Javascript_Operator = '||'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = 'or'
        self.Python_Operator = 'or'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '||'
        self.C_Operator = '||'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "!", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "!", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('!')
    def Infer_Mumps(self):
        self.Mrepeating('!')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(or' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' or ' + str(self.Op2.Gs) + str(self.Gs_Listargs()) + ')'
        self.Gs = Gen
        return True
class Operation_Outcome (Operation):
    Gal_Keyword = 'outcome'
    Gs_Keyword = 'outcome'
    def __init__(self):
        super().__init__()
        self.Amount = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Amount = str(self.Amount.Fallback)
        Code = '(new Outcome ' + str(Amount) + ')'
        self.Fallback = Code
        return True
class Operation_Power (Binary_Operation):
    Gal_Keyword = 'power'
    Gs_Keyword = 'power'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '**'
        self.Javascript_Operator = '**'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.C_Operator = '**'
        self.C_Operator = '**'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Python(self):
        Gen = 'pow(' + str(self.Op1.Python) + ',' + str(self.Op2.Python) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Op1 = str(self.Op1.C)
        Op2 = str(self.Op2.C)
        Code = "pow(" + str(Op1) + ", " + str(Op2) + ")"
        self.C = Code
        return True
class Operation_List_Pop (Operation):
    Gal_Keyword = 'pop'
    Gs_Keyword = 'pop'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        List = str(self.First.Mumps)
        Code = '$$pop^gal($name(' + str(List) + '))'
        self.Mumps = Code
    def Infer_Mumps(self):
        List = str(self.First.Mumps)
        Code = '$$pop^gal($name(' + str(List) + '))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.pop()'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.pop()'
        self.Python = Gen
        return True
class Operation_Prev (Operation):
    Gal_Keyword = 'prev'
    Gs_Keyword = 'prev'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Root[0]) == '@':
            Root = '$name('  +  Root  +  ')'
        Code = '$order(@' + str(Root) + '@(' + str(Args) + '),-1)'
        self.Mumps = Code
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        if str(Root[0]) == '@':
            Root = '$name('  +  Root  +  ')'
        Code = '$order(@' + str(Root) + '@(' + str(Args) + '),-1)'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Prev_Global (Operation):
    Gal_Keyword = 'prev^'
    Gs_Keyword = 'prev^'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        Code = '$order(^' + str(Root) + '(' + str(Args) + '),-1)'
        self.Mumps = Code
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Args = str(self.Mumps_Listargs())
        Code = '$order(^' + str(Root) + '(' + str(Args) + '),-1)'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Operation_Processes (Operation):
    Gal_Keyword = 'processes'
    Gs_Keyword = 'processes'
    def Attributes(self):
        pass
class Operation_QLength (Operation):
    Gal_Keyword = 'qlength'
    Gs_Keyword = 'qlength'
    def __init__(self):
        super().__init__()
        self.Glvn = None
    def Infer_Mumps(self):
        Verbose = False
        Glvn = str(self.Glvn.Mumps)
        Code = '$qlength(' + str(Glvn) + ')'
        if Verbose:
            print("    qlength ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Glvn = str(self.Glvn.Mumps)
        Code = '$qlength(' + str(Glvn) + ')'
        if Verbose:
            print("    qlength ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Glvn')
        self.Glvn = self.Listargs.pop(0)
class Operation_QSubscript (Operation):
    Gal_Keyword = 'qsubscript'
    Gs_Keyword = 'qsubscript'
    def __init__(self):
        super().__init__()
        self.Glvn = None
        self.Subscript = None
    def Infer_Mumps(self):
        Verbose = False
        Glvn = str(self.Glvn.Mumps)
        Subscript = str(self.Subscript.Mumps)
        Code = '$qsubscript(' + str(Glvn) + ',' + str(Subscript) + ')'
        if Verbose:
            print("    qsubscript ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Glvn = str(self.Glvn.Mumps)
        Subscript = str(self.Subscript.Mumps)
        Code = '$qsubscript(' + str(Glvn) + ',' + str(Subscript) + ')'
        if Verbose:
            print("    qsubscript ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Glvn')
        self.Glvn = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Subscript')
        self.Subscript = self.Listargs.pop(0)
class Operation_Random_Integer (Operation):
    Gal_Keyword = 'randint'
    Gs_Keyword = 'randint'
    def __init__(self):
        super().__init__()
        self.Values = None
    def Infer_Mumps(self):
        Values = str(self.Values.Mumps)
        Code = '$random(' + str(Values) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Values = str(self.Values.Mumps)
        Code = '$random(' + str(Values) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Values')
        self.Values = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'Math.floor(Math.random() * ' + str(self.Values.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'random.randrange(' + str(self.Values.Python) + ')'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = '(Runtime:Random_Integer ' + str(self.Values.Fallback) + ')'
        self.Fallback = Gen
        return True
class Operation_Random_Percent (Operation):
    Gal_Keyword = 'random.percent'
    Gs_Keyword = 'random.percent'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'Math.random()'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'random.random()'
        self.Python = Gen
        return True
    def Infer_C(self):
        Code = "(rand()/(float)RAND_MAX)"
        self.C = Code
        return True
class Operation_Round (Operation):
    Gal_Keyword = 'round'
    Gs_Keyword = 'round'
    def __init__(self):
        super().__init__()
        self.Number = None
        self.Decimals = None
    def Infer_Mumps(self):
        Verbose = True
        Number = str(self.Number.Mumps)
        Decimals = str(self.Decimals.Mumps)
        Code = '$justify(' + str(Number) + ',0,' + str(Decimals) + ')'
        if Verbose:
            print("    Operation_Round ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        Number = str(self.Number.Mumps)
        Decimals = str(self.Decimals.Mumps)
        Code = '$justify(' + str(Number) + ',0,' + str(Decimals) + ')'
        if Verbose:
            print("    Operation_Round ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Number')
        self.Number = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Decimals = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Number.Javascript) + '.toFixed(' + str(self.Decimals.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Javascript(self):
        Number = str(self.Number.Javascript)
        Code = str(Number) + '.toFixed('
        if self.Decimals is not None:
            Code += ', ' + str(self.Decimals.Javascript)
        Code += ')'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'round(' + str(self.Number.Python) + ', ' + str(self.Decimals.Python) + ')'
        self.Python = Gen
        return True
    def Infer_Python(self):
        Number = str(self.Number.Python)
        Code = 'round(' + str(Number)
        if self.Decimals is not None:
            Code += ', ' + str(self.Decimals.Python)
        Code += ')'
        self.Python = Code
        return True
class Operation_Shift (Operation):
    Gal_Keyword = 'shift'
    Gs_Keyword = 'shift'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        List = str(self.First.Mumps)
        Code = '$$shift^gal($name(' + str(List) + '))'
        self.Mumps = Code
    def Infer_Mumps(self):
        List = str(self.First.Mumps)
        Code = '$$shift^gal($name(' + str(List) + '))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(shift' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(shift ' + str(self.Gs_Arguments()) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.shift()'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.pop(0)'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = '(shift ' + str(self.Fallback_Arguments()) + ')'
        self.Fallback = Gen
        return True
class Operation_Split (Operation):
    Gal_Keyword = 'split'
    Gs_Keyword = 'split'
    def __init__(self):
        super().__init__()
        self.String = None
        self.Delimiter = None
    def Infer_Mumps(self):
        String = str(self.String.Mumps)
        Delimiter = str(self.Delimiter.Mumps)
        Code = '$$split^gal(' + str(String) + ',' + str(Delimiter) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        String = str(self.String.Mumps)
        Delimiter = str(self.Delimiter.Mumps)
        Code = '$$split^gal(' + str(String) + ',' + str(Delimiter) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String')
        self.String = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Delimiter')
        self.Delimiter = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.String.Javascript) + '.split(' + str(self.Delimiter.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.String.Python) + '.split(' + str(self.Delimiter.Python) + ')'
        self.Python = Gen
        return True
class Operation_Sql_Array (Operation):
    Gal_Keyword = 'sql.array'
    Gs_Keyword = 'sql.array'
    def __init__(self):
        super().__init__()
        self.Query = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Query')
        self.Query = self.Listargs.pop(0)
class Operation_Sql_Object (Operation):
    Gal_Keyword = 'sql.object'
    Gs_Keyword = 'sql.object'
    def __init__(self):
        super().__init__()
        self.Query = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Query')
        self.Query = self.Listargs.pop(0)
class Operation_Square_Root (Operation):
    Gal_Keyword = 'sqrt'
    Gs_Keyword = 'sqrt'
    def __init__(self):
        super().__init__()
        self.Op1 = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'Math.sqrt(' + str(self.Op1.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'math.sqrt(' + str(self.Op1.Python) + ')'
        self.Python = Gen
        return True
class Operation_String_Append (Repeating_Operation):
    Gal_Keyword = 's+'
    Gs_Keyword = 's+'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '+'
        self.Javascript_Operator = '+'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '+'
        self.Python_Operator = '+'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '+'
        self.C_Operator = '+'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = ''
        Arg = None
        for Arg in self.Listargs:
            if str(Code) == '':
                Code += str(Arg.Mumps)
            else:
                Code += '_' + str(Arg.Matom())
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = ''
        Arg = None
        for Arg in self.Listargs:
            if str(Code) == '':
                Code += str(Arg.Mumps)
            else:
                Code += '_' + str(Arg.Matom())
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = ''
        Arg = None
        for Arg in self.Arguments:
            if str(Code) == '':
                Code = Arg.Mumps
            else:
                Code += '_' + str(Arg.Matom())
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = ''
        Arg = None
        for Arg in self.Arguments:
            if str(Code) == '':
                Code = Arg.Mumps
            else:
                Code += '_' + str(Arg.Matom())
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('_')
    def Infer_Mumps(self):
        self.Mrepeating('_')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(append' + str(self.Gal_Arguments()) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(s+' + str(self.Gs_Arguments()) + ')'
        self.Gs = Gen
        return True
class Operation_String_Equal (Binary_Operation):
    Gal_Keyword = 's='
    Gs_Keyword = 's='
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "=", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "=", self.Op2))
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' s= ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Op1 = str(self.Op1.Javascript)
        Op2 = str(self.Op2.Javascript)
        if not isinstance(self.Op1, Token_Quote):
            Op1 += '.toString()'
        if not isinstance(self.Op2, Token_Quote):
            Op2 += '.toString()'
        Code = str(Op1) + ' == ' + str(Op2)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ') == str(' + str(self.Op2.Python) + ')'
        self.Python = Gen
        return True
class Operation_String_Not_Equal (Binary_Operation):
    Gal_Keyword = 'sne'
    Gs_Keyword = 'sne'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'=", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "'=", self.Op2))
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' s!= ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Op1 = str(self.Op1.Javascript)
        Op2 = str(self.Op2.Javascript)
        if not isinstance(self.Op1, Token_Quote):
            Op1 += '.toString()'
        if not isinstance(self.Op2, Token_Quote):
            Op2 += '.toString()'
        Code = str(Op1) + ' != ' + str(Op2)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ') != str(' + str(self.Op2.Python) + ')'
        self.Python = Gen
        return True
class Operation_String_Greater_Equal (Binary_Operation):
    Gal_Keyword = 'sge'
    Gs_Keyword = 'sge'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op2, "']", self.Op1))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op2, "']", self.Op1))
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(sge ' + str(self.Op1.Gal) + ' ' + str(self.Op2.Gal) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' sge ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Op1 = str(self.Op1.Javascript)
        Op2 = str(self.Op2.Javascript)
        if not isinstance(self.Op1, Token_Quote):
            Op1 += '.toString()'
        if not isinstance(self.Op2, Token_Quote):
            Op2 += '.toString()'
        Code = str(Op1) + ' >= ' + str(Op2)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ') >= str(' + str(self.Op2.Python) + ')'
        self.Python = Gen
        return True
class Operation_String_Greater (Binary_Operation):
    Gal_Keyword = 'sgt'
    Gs_Keyword = 'sgt'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "]", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "]", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating(']')
    def Infer_Mumps(self):
        self.Mrepeating(']')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(sgt ' + str(self.Op1.Gal) + ' ' + str(self.Op2.Gal) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' sgt ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Op1 = str(self.Op1.Javascript)
        Op2 = str(self.Op2.Javascript)
        if not isinstance(self.Op1, Token_Quote):
            Op1 += '.toString()'
        if not isinstance(self.Op2, Token_Quote):
            Op2 += '.toString()'
        Code = str(Op1) + ' > ' + str(Op2)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ') > str(' + str(self.Op2.Python) + ')'
        self.Python = Gen
        return True
class Operation_String_Less_Equal (Binary_Operation):
    Gal_Keyword = 'sle'
    Gs_Keyword = 'sle'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "']", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "']", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating("']")
    def Infer_Mumps(self):
        self.Mrepeating("']")
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(sle ' + str(self.Op1.Gal) + ' ' + str(self.Op2.Gal) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' sle ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Op1 = str(self.Op1.Javascript)
        Op2 = str(self.Op2.Javascript)
        if not isinstance(self.Op1, Token_Quote):
            Op1 += '.toString()'
        if not isinstance(self.Op2, Token_Quote):
            Op2 += '.toString()'
        Code = str(Op1) + ' <= ' + str(Op2)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ') <= str(' + str(self.Op2.Python) + ')'
        self.Python = Gen
        return True
class Operation_String_Less (Binary_Operation):
    Gal_Keyword = 'slt'
    Gs_Keyword = 'slt'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op2, "]", self.Op1))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op2, "]", self.Op1))
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '(slt ' + str(self.Op1.Gal) + ' ' + str(self.Op2.Gal) + ')'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = '(' + str(self.Op1.Gs) + ' sgt ' + str(self.Op2.Gs) + ')'
        self.Gs = Gen
        return True
    def Infer_Javascript(self):
        Op1 = str(self.Op1.Javascript)
        Op2 = str(self.Op2.Javascript)
        if not isinstance(self.Op1, Token_Quote):
            Op1 += '.toString()'
        if not isinstance(self.Op2, Token_Quote):
            Op2 += '.toString()'
        Code = str(Op1) + ' < ' + str(Op2)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'str(' + str(self.Op1.Python) + ') < str(' + str(self.Op2.Python) + ')'
        self.Python = Gen
        return True
class Operation_Substring (Operation):
    Gal_Keyword = 'substring'
    Gs_Keyword = 'substring'
    def __init__(self):
        super().__init__()
        self.String_Value = None
        self.Start_Index = None
        self.Length = None
    def Infer_Mumps(self):
        Value = str(self.String_Value.Mumps)
        Start_Index = str(self.Start_Index.Mumps)
        End = '$length(' + str(Value) + ')'
        Code = None
        if self.Length is not None:
            Length = str(self.Length.Mumps)
            Code = '$$substring3^gal('  +  Value  +  ','  +  Start_Index  +  ','  +  Length  +  ')'
        else:
            Code = '$extract('  +  Value  +  ','  +  Start_Index  +  '+1,$length('  +  Value  +  '))'
        self.Mumps = Code
    def Infer_Mumps(self):
        Value = str(self.String_Value.Mumps)
        Start_Index = str(self.Start_Index.Mumps)
        End = '$length(' + str(Value) + ')'
        Code = None
        if self.Length is not None:
            Length = str(self.Length.Mumps)
            Code = '$$substring3^gal('  +  Value  +  ','  +  Start_Index  +  ','  +  Length  +  ')'
        else:
            Code = '$extract('  +  Value  +  ','  +  Start_Index  +  '+1,$length('  +  Value  +  '))'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String_Value')
        self.String_Value = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Start_Index')
        self.Start_Index = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Length = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Code = str(self.String_Value.Javascript) + '.substr(' + str(self.Start_Index.Javascript)
        if self.Length is not None:
            Code += ', ' + str(self.Length.Javascript)
        Code += ')'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        SVal = str(self.String_Value.Python)
        Start = str(self.Start_Index.Python)
        Code = None
        if self.Length is not None:
            Len = str(self.Length.Python)
            if str(Len) == '1':
                Code = SVal  +  '['  +  Start  +  ']'
            else:
                Code = SVal  +  '['  +  Start  +  ':('  +  Start  +  ')+('  +  Len  +  ')]'
        else:
            Code = SVal  +  '['  +  Start  +  ':]'
        self.Python = Code
        return True
class Operation_Subtract (Repeating_Operation):
    Gal_Keyword = '-'
    Gs_Keyword = '-'
    def __init__(self):
        super().__init__()
        self.Op1 = None
        self.Op2 = None
        self.Javascript_Operator = '-'
        self.Javascript_Operator = '-'
        self.Javascript_Precedence = 6
        self.Javascript_Precedence = 6
        self.Python_Operator = '-'
        self.Python_Operator = '-'
        self.Python_Precedence = 6
        self.Python_Precedence = 6
        self.C_Operator = '-'
        self.C_Operator = '-'
        self.C_Precedence = 6
        self.C_Precedence = 6
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "-", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = str(self.Mbinop(self.Op1, "-", self.Op2))
        self.Mumps = Code
    def Infer_Mumps(self):
        self.Mrepeating('-')
    def Infer_Mumps(self):
        self.Mrepeating('-')
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Op2 = self.Listargs.pop(0)
    def Infer_Gs(self):
        Code = ''
        if self.Op2 is not None:
            Code += '(' + str(self.Op1.Gs) + ' - ' + str(self.Op2.Gs) + str(self.Gs_Listargs()) + ')'
        else:
            Code += '(- ' + str(self.Op1.Gs) + ')'
        self.Gs = Code
        return True
    def Infer_Python(self):
        if self.Op2 is not None:
            self.Python = self.Python_Arguments('-')
        else:
            self.Python = '-('  +  self.Op1.Python  +  ')'
        return True
class Operation_Ternary (Operation):
    Gal_Keyword = '?'
    Gs_Keyword = '?'
    def __init__(self):
        super().__init__()
        self.Condition = None
        self.If = None
        self.Else = None
    def Infer_Mumps(self):
        Verbose = False
        Condition = str(self.Condition.Mumps)
        If = str(self.If.Mumps)
        Else = str(self.Else.Mumps)
        Code = '$select(' + str(Condition) + ':' + str(If) + ',1:' + str(Else) + ')'
        if Verbose:
            print("    operation ternary ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Condition = str(self.Condition.Mumps)
        If = str(self.If.Mumps)
        Else = str(self.Else.Mumps)
        Code = '$select(' + str(Condition) + ':' + str(If) + ',1:' + str(Else) + ')'
        if Verbose:
            print("    operation ternary ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Condition')
        self.Condition = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument If')
        self.If = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Else')
        self.Else = self.Listargs.pop(0)
    def Infer_C(self):
        Condition = str(self.Condition.C)
        If = str(self.If.C)
        Else = str(self.Else.C)
        Code = str(Condition) + ' ? ' + str(If) + ' : ' + str(Else)
        self.C = Code
        return True
class Operation_Test (Operation):
    Gal_Keyword = 'test'
    Gs_Keyword = 'test'
    def Attributes(self):
        pass
    def Infer_C(self):
        Test = str(C.Test)
        if not 'Test' in Test:
            Test = 'Test_'  +  Test
        Code = str(Test) + '()'
        self.C = Code
        return True
class Operation_Then (Operation):
    Gal_Keyword = 'then'
    Gs_Keyword = 'then'
    def __init__(self):
        super().__init__()
        self.Predecessor = None
        self.Successor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Predecessor')
        self.Predecessor = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Successor')
        self.Successor = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '(' + str(self.Successor.Fallback) + '.Then ' + str(self.Predecessor.Fallback) + ')'
        self.Fallback = Gen
        return True
class Operation_Tilda (Operation):
    Gal_Keyword = 'tilda'
    Gs_Keyword = 'tilda'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Verbose = True
        Keywords = None
        Keywords = ' '.join(self.Gs_Keywords)
        Keywords = Keywords.replace('~', 'tilda')
        Args = str(self.Fallback_Arguments())
        Title = str(Keywords.title())
        Name = str(Title)
        Name = Name.replace(' ', '_')
        Code = str(Keywords) + ' / ' + str(Args) + ' / ' + str(Title)
        zdebug.zbreak()
        if Verbose:
            print(Code)
        self.Fallback = Code
        return True
class Operation_Time_String (Operation):
    Gal_Keyword = 'now.string'
    Gs_Keyword = 'now.string'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = '(new Date().toISOString())'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")'
        self.Python = Gen
        return True
    def Infer_Fallback(self):
        Gen = '(Runtime:Time_String)'
        self.Fallback = Gen
        return True
class Operation_Titlecase (Operation):
    Gal_Keyword = 'titlecase'
    Gs_Keyword = 'titlecase'
    def __init__(self):
        super().__init__()
        self.String = None
    def Infer_Mumps(self):
        Code = '$$titlecase^gal(' + str(self.String.Mumps) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$titlecase^gal(' + str(self.String.Mumps) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String')
        self.String = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'goalspell.titlecase(' + str(self.String.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.String.Python) + '.title()'
        self.Python = Gen
        return True
class Operation_To_Json (Operation):
    Gal_Keyword = 'to.json'
    Gs_Keyword = 'to.json'
    def __init__(self):
        super().__init__()
        self.Object = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'JSON.stringify(' + str(self.Object.Javascript) + ')'
        self.Javascript = Gen
        return True
class Operation_Token_Mode (Operation):
    Gal_Keyword = 'token.mode'
    Gs_Keyword = 'token.mode'
    def __init__(self):
        super().__init__()
        self.Mode_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Mode_Name')
        self.Mode_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '(Mode s= ' + str(self.Enquote(self.Mode_Name.Fallback)) + ')'
        self.Fallback = Gen
        return True
class Operation_Uppercase (Operation):
    Gal_Keyword = 'uppercase'
    Gs_Keyword = 'uppercase'
    def __init__(self):
        super().__init__()
        self.First = None
    def Infer_Mumps(self):
        Code = '$translate(' + str(self.First.Mumps) + ',"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$translate(' + str(self.First.Mumps) + ',"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.toUpperCase()'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.upper()'
        self.Python = Gen
        return True
class Operation_Uuid (Operation):
    Gal_Keyword = 'uuid'
    Gs_Keyword = 'uuid'
    def Infer_Mumps(self):
        Code = '$$guid^gal'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$$guid^gal'
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Python(self):
        Gen = 'uuid.uuid4().hex'
        self.Python = Gen
        return True
class Operation_We (Operation):
    Gal_Keyword = 'we'
    Gs_Keyword = 'we'
    def __init__(self):
        super().__init__()
        self.Method = None
    def Infer_Mumps(self):
        Method = str(self.Method.Mumps)
        Args = str(self.Mumps_Listargs())
        My_Class = self.Mumps_Class()
        Class_Name = str(My_Class.Name.Mumps)
        Code = '$$%' + str(Method) + '(' + str(self.Mq(Class_Name))
        if str(Args) > '':
            Code += ','
        Code += str(Args) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Method = str(self.Method.Mumps)
        Args = str(self.Mumps_Listargs())
        My_Class = self.Mumps_Class()
        Class_Name = str(My_Class.Name.Mumps)
        Code = '$$%' + str(Method) + '(' + str(self.Mq(Class_Name))
        if str(Args) > '':
            Code += ','
        Code += str(Args) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Method')
        self.Method = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Class_Name = 'this'
        try:
            Context = self.Method_Context()
            if Context and isinstance(Context, Method_Statement):
                Class_Name = 'this.constructor'
        except Exception:
            pass
        Code = str(Class_Name) + '.' + str(self.Method.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Gen = 'cls.' + str(self.Method.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
class Syntax_Array (Syntax):
    Gal_Keyword = 'array'
    Gs_Keyword = 'array'
    def Attributes(self):
        pass
    def Infer_C(self):
        Args = ''
        Between = ''
        Arg = None
        for Arg in self.Arguments:
            Args += str(Between) + str(Arg.C)
            Between = ', '
        Code = '{ ' + str(Args) + ' }'
        self.C = Code
        return True
class Syntax_Attribute (Syntax):
    Gal_Keyword = 'attribute'
    Gs_Keyword = 'attribute'
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Attribute = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Attribute')
        self.Attribute = self.Listargs.pop(0)
    def Infer_Gs(self):
        Code = str(self.Gs_Arguments()) + ' ~'
        self.Gs = self.Syntax_Gs(Code)
        return True
    def Infer_Fallback(self):
        Gen = '[' + str(self.Object.Fallback) + '.' + str(self.Attribute.Fallback) + str(self.Fallback_Args()) + ' Symbol_Value]'
        self.Fallback = Gen
        return True
class Syntax_Await (Syntax):
    Gal_Keyword = 'await'
    Gs_Keyword = 'await'
    def __init__(self):
        super().__init__()
        self.Invocation = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Invocation')
        self.Invocation = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'await ' + str(self.Invocation.Javascript)
        self.Javascript = Gen
        return True
class Syntax_Behavior (Syntax):
    Gal_Keyword = 'behavior'
    Gs_Keyword = 'behavior'
    def Attributes(self):
        pass
    def Infer_C(self):
        Code = str(C.Behavior)
        self.C = Code
        return True
class Syntax_Bold (Syntax):
    Gal_Keyword = 'bold'
    Gs_Keyword = 'bold'
    def Attributes(self):
        pass
class Syntax_Class (Syntax):
    Gal_Keyword = 'class'
    Gs_Keyword = 'class'
    def __init__(self):
        super().__init__()
        self.Object = None
    def Infer_Mumps(self):
        Verbose = True
        Code = '%self'
        if self.Object is not None:
            Code = '@'  +  self.Object.Mumps
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        Code = '%self'
        if self.Object is not None:
            Code = '@'  +  self.Object.Mumps
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Object = 'this'
        if self.Expression is not None:
            Object = self.Expression.Javascript
        Code = str(Object) + '.constructor'
        Argument = None
        for Argument in self.Listargs:
            Code += '.' + str(Argument.Javascript)
        self.Javascript = Code
        return True
    def Infer_Javascript(self):
        Gen = "(" + str(self.Object.Javascript) + '.constructor)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Object = 'self.__class__'
        Context = self.Method_Context()
        if Context and isinstance(Context, Class_Method_Statement):
            Object = 'cls'
        if self.Expression is not None:
            Object = self.Expression.Python  +  '.__class__'
        Code = str(Object)
        Argument = None
        for Argument in self.Listargs:
            Code += '.' + str(Argument.Python)
        self.Python = Code
        return True
    def Infer_Python(self):
        Gen = '(' + str(self.Object.Python) + '.__class__)'
        self.Python = Gen
        return True
class Syntax_Class_Attribute (Syntax):
    Gal_Keyword = 'class.attribute'
    Gs_Keyword = 'class.attribute'
    def __init__(self):
        super().__init__()
        self.Class = None
        self.Attribute = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class')
        self.Class = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Attribute')
        self.Attribute = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '[' + str(self.Class.Fallback) + ':' + str(self.Attribute.Fallback) + str(self.Fallback_Args()) + ' Symbol_Value]'
        self.Fallback = Gen
        return True
class Syntax_Class_Name (Syntax):
    Gal_Keyword = 'class.name'
    Gs_Keyword = 'class.name'
    def __init__(self):
        super().__init__()
        self.Object = None
    def Infer_Mumps(self):
        Verbose = False
        Code = '%self'
        if self.Object is not None:
            Code = '@'  +  self.Object.Mumps
        if Verbose:
            print('syntax class name ', Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Code = '%self'
        if self.Object is not None:
            Code = '@'  +  self.Object.Mumps
        if Verbose:
            print('syntax class name ', Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Object = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Object_Code = 'this'
        if self.Object is not None:
            Object_Code = self.Object.Javascript
        Code = str(Object_Code) + '.constructor.name'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Object_Code = 'self'
        if self.Object is not None:
            Object_Code = self.Object.Python
        Code = str(Object_Code) + '.__name__'
        self.Python = Code
        return True
class Syntax_Class_Property (Syntax):
    Gal_Keyword = ':'
    Gs_Keyword = ':'
    def __init__(self):
        super().__init__()
        self.First = None
        self.Second = None
    def Infer_Mumps(self):
        Class_Name = str(self.First.Mumps)
        Property_Name = str(self.Second.Mumps)
        Code = '^%' + str(Class_Name) + '(0,' + str(self.Mq(Property_Name)) + ')'
        Arg = None
        for Arg in self.Listargs:
            Code = '@('  +  Reference  +  ')@('  +  self.Mq(Arg.Mumps)  +  ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Class_Name = str(self.First.Mumps)
        Property_Name = str(self.Second.Mumps)
        Code = '^%' + str(Class_Name) + '(0,' + str(self.Mq(Property_Name)) + ')'
        Arg = None
        for Arg in self.Listargs:
            Code = '@('  +  Reference  +  ')@('  +  self.Mq(Arg.Mumps)  +  ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument First')
        self.First = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Second = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Class_Name = None
        Property_Name = None
        if self.Second is not None:
            Class_Name = self.First.Javascript
            Property_Name = self.Second.Javascript
        else:
            Class_Name = 'this.constructor'
            Context = self.Method_Context()
            if Context and isinstance(Context, Class_Method_Statement):
                Class_Name = 'this'
            Property_Name = self.First.Javascript
        Code = str(Class_Name) + '.' + str(Property_Name)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Class_Name = str(self.First.Python)
        Code = str(Class_Name)
        Property_Name = None
        if self.Second is not None:
            Property_Name = self.Second.Python
            Code += '.' + str(Property_Name)
        self.Python = Code
        return True
class Syntax_Classes (Syntax):
    Gal_Keyword = 'classes'
    Gs_Keyword = 'classes'
    def Infer_Mumps(self):
        Code = '^Classes'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '^Classes'
        self.Mumps = Code
    def Attributes(self):
        pass
class Syntax_Code (Syntax):
    Gal_Keyword = 'code'
    Gs_Keyword = 'code'
    def Attributes(self):
        pass
class Syntax_Count (Syntax):
    Gal_Keyword = 'count'
    Gs_Keyword = 'count'
    def __init__(self):
        super().__init__()
        self.Minimum = None
        self.Maximum = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Minimum')
        self.Minimum = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Maximum')
        self.Maximum = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Minimum = str(self.Minimum.Fallback)
        Maximum = str(self.Maximum.Fallback)
        zdebug.zbreak()
        Verbose = True
        return True
    def Infer_Parse(self):
        Minimum = str(self.Minimum.Parse)
        Maximum = str(self.Maximum.Parse)
        zdebug.zbreak()
        Verbose = True
        return True
    def Infer_Parse(self):
        Minimum = str(self.Minimum.Fallback)
        Maximum = str(self.Maximum.Fallback)
        zdebug.zbreak()
        Verbose = True
        return True
    def Infer_Generate(self):
        Minimum = str(self.Minimum.Generate)
        Maximum = str(self.Maximum.Generate)
        zdebug.zbreak()
        Verbose = True
        self.Generate = Code
        return True
    def Infer_Generate(self):
        Minimum = str(self.Minimum.Fallback)
        Maximum = str(self.Maximum.Fallback)
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Syntax_Dictionary (Argument_Syntax):
    Gal_Keyword = 'dict'
    Gs_Keyword = 'dict'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python)
        self.Python = Gen
        return True
class Syntax_Dictionary_Key (Syntax):
    Gal_Keyword = 'dict.key'
    Gs_Keyword = 'dict.key'
    def Attributes(self):
        pass
class Syntax_Object (Argument_Syntax):
    Gal_Keyword = 'entity'
    Gs_Keyword = 'entity'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Default_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Default_Value = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = '[entity' + str(self.Gal_Arguments()) + ']'
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Interior = 'object' + str(self.Gs_Arguments())
        Code = str(self.Syntax_Gs(Interior))
        self.Gs = Code
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python)
        self.Python = Gen
        return True
    def Infer_C(self):
        Code = "void *" + str(self.Variable.C)
        if self.Default_Value is not None:
            Code += "=" + str(self.Default_Value.C)
        self.C = Code
        return True
class Syntax_Either (Syntax):
    Gal_Keyword = 'either'
    Gs_Keyword = 'either'
    # comment 'TODO:';
    def Attributes(self):
        pass
class Syntax_Exclude (Syntax):
    Gal_Keyword = 'exclude'
    Gs_Keyword = 'exclude'
    def __init__(self):
        super().__init__()
        self.Rule_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rule_Name')
        self.Rule_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Declarations = ''
        Args = str(self.Fallback_Args())
        Code = 'comment "[exclude ' + str(Args) + ']";' + str('\n')
        Argument = None
        for Argument in self.Arguments:
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            # comment 'rule name tokens are required here, right?';
            Code += 'return if (i Parse_' + str(Argument.Fallback) + ' Excluded) [false];' + str('\n')
        self.Fallback_Declaration = Declarations
        self.Fallback = Code
        return True
    def Infer_Fallback(self):
        Declarations = ''
        Rule = str(self.Rule.Fallback)
        Self_Call = 'quit : (i Parse_' + str(Rule) + ' My_Elements) [false];'
        if isinstance(self.Rule, Token_Quote) or isinstance(self.Rule, Syntax_Line):
            Self_Call = 'quit : (i Parse_Token My_Elements '  +  Rule  +  ') [false];'
            if self.Rule.Fallback_Declaration is not None:
                Declarations += str(self.Rule.Fallback_Declaration)
        Code = 'comment `exclude ' + str(Rule) + '`;' + str('\n') + str(Self_Call)
        self.Fallback_Declaration = Declarations
        self.Fallback = Code
        return True
    def Infer_Parse(self):
        Declarations = ''
        Args = str(self.Fallback_Args())
        Code = 'comment "[exclude ' + str(Args) + ']";' + str('\n')
        Argument = None
        for Argument in self.Arguments:
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            # comment 'rule name tokens are required here, right?';
            Code += 'return if ([self].Parse_' + str(Argument.Fallback) + ' Excluded) [false];' + str('\n')
        self.Fallback_Declaration = Declarations
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Syntax_False (Syntax):
    Gal_Keyword = 'false'
    Gs_Keyword = 'false'
    def Infer_Mumps(self):
        Code = '0'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '0'
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'false'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'False'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = "0"
        self.C = Gen
        return True
    def Infer_Data_Types(self):
        self.Data_Type = 'flag'
        return True
class Syntax_Flag (Argument_Syntax):
    Gal_Keyword = 'flag'
    Gs_Keyword = 'flag'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Default_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Default_Value = self.Listargs.pop(0)
    def Infer_C(self):
        Code = 'bool ' + str(self.Variable.C)
        if self.Default_Value is not None:
            Code += '=' + str(self.Default_Value.C)
        self.C = Code
        return True
class Syntax_Function_Pointer (Syntax):
    Gal_Keyword = 'fptr'
    Gs_Keyword = 'fptr'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Allow_Suffix(self, Suffix):
        return True
    def Allow_Suffix(self, Suffix):
        return True
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
    def Infer_C(self):
        Verbose = True
        Between = ''
        Word = None
        Arglist = ''
        Rtype = ''
        for Word in self.Gs_Keywords:
            if ' '  +  Word  +  ' ' in ' implementers fptr ':
                continue
            Word = self.C_Type(Word)
            if (Rtype in (None, "")):
                Rtype = Word
            else:
                Arglist += str(Between) + str(Word)
                Between = ', '
        Name = str(self.Name.C)
        Code = str(Rtype) + '(*' + str(Name) + ')(' + str(Arglist) + ')'
        self.C = Code
        return True
class Syntax_Future (Syntax):
    Gal_Keyword = 'future'
    Gs_Keyword = 'future'
    def Infer_Mumps(self):
        Verbose = True
        Code = '$name(^F)'
        if Verbose:
            print("    Syntax_Future ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = True
        Code = '$name(^F)'
        if Verbose:
            print("    Syntax_Future ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        pass
class Syntax_Generator (Syntax):
    Gal_Keyword = 'generator'
    Gs_Keyword = 'generator'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'Javascript_Generator'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'Python_Generator'
        self.Python = Gen
        return True
class Syntax_Glvn (Syntax):
    Gal_Keyword = 'glvn'
    Gs_Keyword = 'glvn'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Code = str(Root)
        self.Mumps = Code
    def Infer_Mumps(self):
        Root = str(self.Root.Mumps)
        Code = str(Root)
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
class Syntax_Italic (Syntax):
    Gal_Keyword = 'italic'
    Gs_Keyword = 'italic'
    def Attributes(self):
        pass
class Syntax_Implementers_Of (Syntax):
    Gal_Keyword = 'implementers.of'
    Gs_Keyword = 'implementers.of'
    def __init__(self):
        super().__init__()
        self.Goal_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Goal_Name')
        self.Goal_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = '[' + str(self.Goal_Name.Fallback) + ':Implementers]'
        self.Fallback = Code
        return True
class Syntax_Indent (Syntax):
    Gal_Keyword = 'indent'
    Gs_Keyword = 'indent'
    def __init__(self):
        super().__init__()
        self.Count = None
    def Infer_Mumps(self):
        Code = '"    "'
        if self.Count is not None:
            Count = str(self.Count.Mumps)
            Code = '$$repeat^gal('  +  Code  +  ','  +  Count  +  ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '"    "'
        if self.Count is not None:
            Count = str(self.Count.Mumps)
            Code = '$$repeat^gal('  +  Code  +  ','  +  Count  +  ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Count = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Code = '"    "'
        if self.Count is not None:
            Code += '.repeat(' + str(self.Count.Javascript) + ')'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = '"    "'
        if self.Count is not None:
            Code += '*' + str(self.Count.Python)
        self.Python = Code
        return True
    def Infer_C(self):
        Text = '    '
        if self.Count is not None:
            Text = ''
            Count = str(self.Count.C)
            End = ord(Count) - 48
            This = None
            for This in range(1, End+1):
                Text += '    '
        Code = '"' + str(Text) + '"'
        self.C = Code
        return True
class Syntax_Init (Syntax):
    Gal_Keyword = 'init'
    Gs_Keyword = 'init'
    def Attributes(self):
        pass
class Syntax_Input (Syntax):
    Gal_Keyword = 'input'
    Gs_Keyword = 'input'
    def __init__(self):
        super().__init__()
        self.Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
class Syntax_Integer (Argument_Syntax):
    Gal_Keyword = 'integer'
    Gs_Keyword = 'integer'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Default_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Default_Value = self.Listargs.pop(0)
    def Infer_C(self):
        Code = 'int ' + str(self.Variable.C)
        if self.Default_Value is not None:
            Code += '=' + str(self.Default_Value.C)
        self.C = Code
        return True
class Syntax_Is (Syntax):
    Gal_Keyword = 'is'
    Gs_Keyword = 'is'
    def __init__(self):
        super().__init__()
        self.Superclass = None
    def Infer_Mumps(self):
        self.Mumps = ""
    def Infer_Mumps(self):
        self.Mumps = ""
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Superclass')
        self.Superclass = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'extends ' + str(self.Superclass.Javascript)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = '(' + str(self.Superclass.Python) + ')'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = ""
        self.C = Gen
        return True
    def Infer_Structure(self):
        Cls = self.Get_Class_Context()
        Name = str(Cls.Name.Input)
        Ancestor = str(self.Superclass.Input)
        Cls.Ancestors.extend([Ancestor])
        return True
class Syntax_Is_Main (Syntax):
    Gal_Keyword = 'ismain'
    Gs_Keyword = 'ismain'
    def Attributes(self):
        pass
    def Infer_Data_Types(self):
        self.Data_Type = 'flag'
        return True
class Syntax_Job (Syntax):
    Gal_Keyword = 'job'
    Gs_Keyword = 'job'
    def Infer_Mumps(self):
        Verbose = False
        Code = '$job'
        if Verbose:
            print("    job ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Code = '$job'
        if Verbose:
            print("    job ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        pass
class Syntax_Language_Elements (Syntax):
    Gal_Keyword = 'language.elements'
    Gs_Keyword = 'language.elements'
    def __init__(self):
        super().__init__()
        self.Dialect = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Dialect')
        self.Dialect = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Gen = '[' + str(self.Dialect.Fallback) + '.Elements]'
        self.Fallback = Gen
        return True
class Syntax_Line (Syntax):
    Gal_Keyword = 'line'
    Gs_Keyword = 'line'
    def __init__(self):
        super().__init__()
        self.Count = None
    def Infer_Mumps(self):
        Code = '$char(10)'
        if self.Count is not None:
            Count = str(self.Count.Mumps)
            Code = '$$repeat^gal('  +  Code  +  ','  +  Count  +  ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '$char(10)'
        if self.Count is not None:
            Count = str(self.Count.Mumps)
            Code = '$$repeat^gal('  +  Code  +  ','  +  Count  +  ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Count = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Code = '"\\n"'
        if self.Count is not None:
            Code += '.repeat(' + str(self.Count.Javascript) + ')'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = "'\\n'"
        if self.Count is not None:
            Code += '*' + str(self.Count.Python)
        self.Python = Code
        return True
    def Infer_C(self):
        Gen = '\\n'
        self.C = Gen
        return True
    def Infer_Data_Types(self):
        self.Data_Type = 'string'
        return True
class Syntax_List (Argument_Syntax):
    Gal_Keyword = 'list'
    Gs_Keyword = 'list'
    def __init__(self):
        super().__init__()
        self.Variable = None
    def Infer_Mumps(self):
        Verbose = False
        Code = str(self.Variable.Mumps)
        if Verbose:
            print('     list argument syntax code: ', Code, sep='')
        self.Mumps = Code
        try:
            Value = str(self.Default_Value.Mumps)
            Declaration = str("    ") + 'set ' + str(Code) + '=$get(' + str(Code) + ',' + str(Value) + ')' + str('\n')
            self.Mumps_Declaration = Declaration
            if Verbose:
                print('     list argument syntax declaration: ', Declaration, sep='')
        except Exception:
            pass
    def Infer_Mumps(self):
        Verbose = False
        Code = str(self.Variable.Mumps)
        if Verbose:
            print('     list argument syntax code: ', Code, sep='')
        self.Mumps = Code
        try:
            Value = str(self.Default_Value.Mumps)
            Declaration = str("    ") + 'set ' + str(Code) + '=$get(' + str(Code) + ',' + str(Value) + ')' + str('\n')
            self.Mumps_Declaration = Declaration
            if Verbose:
                print('     list argument syntax declaration: ', Declaration, sep='')
        except Exception:
            pass
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python)
        self.Python = Gen
        return True
class Syntax_Method (Syntax):
    Gal_Keyword = 'method'
    Gs_Keyword = 'method'
    def Attributes(self):
        pass
class Syntax_Mildbeard (Syntax):
    Gal_Keyword = 'mildbeard'
    Gs_Keyword = 'mildbeard'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        self.Fallback = '"Erik Zoltan"'
        return True
class Syntax_Module_Class (Syntax):
    Gal_Keyword = 'module.class'
    Gs_Keyword = 'module.class'
    def __init__(self):
        super().__init__()
        self.Module_Expression = None
        self.Class_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Module_Expression')
        self.Module_Expression = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Class_Name')
        self.Class_Name = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Module_Expression.Javascript) + '.' + str(self.Class_Name.Javascript)
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'eval("sys.modules[' + str(self.Module_Expression.Python) + ']." + ' + str(self.Class_Name.Python) + ")"
        self.Python = Gen
        return True
class Syntax_My_Attribute (Syntax):
    Gal_Keyword = 'my.attribute'
    Gs_Keyword = 'my.attribute'
    def Attributes(self):
        pass
    def Infer_Gal(self):
        Code = 'my.attribute' + str(self.Gal_Arguments())
        self.Gal = self.Syntax_Gal(Code)
        return True
    def Infer_Gs(self):
        Code = 'my' + str(self.Gs_Arguments()) + ' ~'
        self.Gs = self.Syntax_Gs(Code)
        return True
    def Infer_Fallback(self):
        Gen = '[my' + str(self.Fallback_Arguments()) + ' Symbol_Value]'
        self.Fallback = Gen
        return True
class Syntax_My_Class (Syntax):
    Gal_Keyword = 'my.class'
    Gs_Keyword = 'my.class'
    def Infer_Mumps(self):
        Context = self.Mumps_Class()
        Code = str(Context.Name.Mumps)
        self.Mumps = Code
    def Infer_Mumps(self):
        Context = self.Mumps_Class()
        Code = str(Context.Name.Mumps)
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'this.constructor'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'self.__class__'
        self.Python = Gen
        return True
class Syntax_My (Syntax):
    Gal_Keyword = 'my'
    Gs_Keyword = 'my'
    def __init__(self):
        super().__init__()
        self.Property = None
    def Infer_Mumps(self):
        Verbose = False
        Property_Name = str(self.Property.Mumps)
        Arg = None
        Code = '@%self@(' + str(self.Mq(Property_Name)) + ')'
        for Arg in self.Listargs:
            Code = '@('  +  Code  +  ')@('  +  self.Mq(Arg.Mumps)  +  ')'
            Verbosity = True
        if Verbose:
            print('syntax my, object ', Object, ', code: ', Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Property_Name = str(self.Property.Mumps)
        Arg = None
        Code = '@%self@(' + str(self.Mq(Property_Name)) + ')'
        for Arg in self.Listargs:
            Code = '@('  +  Code  +  ')@('  +  self.Mq(Arg.Mumps)  +  ')'
            Verbosity = True
        if Verbose:
            print('syntax my, object ', Object, ', code: ', Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property')
        self.Property = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = 'this.' + str(self.Javascript_Arguments('.'))
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'self.' + str(self.Python_Arguments('.'))
        self.Python = Gen
        return True
    def Infer_C(self):
        Property_Name = str(self.Property.C)
        Context = self.Get_Class_Context()
        Class_Name = str(Context.Name.C)
        Code = str(Class_Name) + '_prop_' + str(Property_Name) + '[self]'
        Arg = None
        for Arg in self.Listargs:
            Code += '[' + str(Arg.C) + ']'
        self.C = Code
        return True
class Syntax_New_List (Syntax):
    Gal_Keyword = 'new.list'
    Gs_Keyword = 'new.list'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = '[' + str(self.Javascript_Arguments(', ')) + ']'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = '[' + str(self.Python_Arguments(', ')) + ']'
        self.Python = Gen
        return True
class Syntax_Node (Syntax):
    Gal_Keyword = 'node'
    Gs_Keyword = 'node'
    def __init__(self):
        super().__init__()
        self.Root = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Root')
        self.Root = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.List.Javascript) + '[' + str(self.Node.Javascript) + ']'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.List.Python) + '[' + str(self.Node.Python) + ']'
        self.Python = Gen
        return True
    def Infer_C(self):
        Code = str(self.Root.C)
        Arg = None
        for Arg in self.Listargs:
            Code += '[' + str(Arg.C) + ']'
        self.C = Code
        return True
class Syntax_Null (Syntax):
    Gal_Keyword = 'null'
    Gs_Keyword = 'null'
    def Infer_Mumps(self):
        self.Mumps = '""'
    def Infer_Mumps(self):
        self.Mumps = '""'
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'null'
        self.Javascript = Gen
        return True
    def Infer_Javascript(self):
        Gen = 'null'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'None'
        self.Python = Gen
        return True
    def Infer_Python(self):
        Gen = 'None'
        self.Python = Gen
        return True
class Syntax_Number (Argument_Syntax):
    Gal_Keyword = 'number'
    Gs_Keyword = 'number'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Default_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Default_Value = self.Listargs.pop(0)
    def Infer_C(self):
        Code = 'float ' + str(self.Variable.C)
        if self.Default_Value is not None:
            Code += '=' + str(self.Default_Value.C)
        self.C = Code
        return True
class Syntax_Optrep (Syntax):
    Gal_Keyword = 'optrep'
    Gs_Keyword = 'optrep'
    def __init__(self):
        super().__init__()
        self.Rule_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rule_Name')
        self.Rule_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Declarations = ''
        Rule = str(self.Rule_Name.Fallback)
        Defines = ''
        Self_Call = '(i Parse_' + str(Rule) + ' My_Elements)'
        if isinstance(self.Rule_Name, Token_Quote) or isinstance(self.Rule_Name, Syntax_Line):
            Self_Call = '(i Parse_Token My_Elements '  +  Rule  +  ')'
            if self.Rule_Name.Fallback_Declaration is not None:
                Declarations += str(self.Rule_Name.Fallback_Declaration)
        Code = 'comment ' + str(self.Enquote(self.Get_Input())) + ';' + str('\n') + 'forever' + str('\n') + '{' + str('\n') + str("    ") + 'breakif (not ' + str(Self_Call) + ');' + str('\n') + '}'
        if self.Rule_Name.Fallback_Declaration is not None:
            self.Fallback_Declaration = self.Rule_Name.Fallback_Declaration
        self.Fallback_Declaration = Declarations
        self.Fallback = Code
        return True
    def Infer_Parse(self):
        Declarations = ''
        Rule = str(self.Rule.Fallback)
        Defines = ''
        Self_Call = '(i Parse_' + str(Rule) + ' My_Elements)'
        if isinstance(self.Rule, Token_Quote) or isinstance(self.Rule, Syntax_Line):
            Self_Call = '(i Parse_Token My_Elements '  +  Rule  +  ')'
            if self.Rule.Fallback_Declaration is not None:
                Declarations += str(self.Rule.Fallback_Declaration)
        Code = 'comment ' + str(self.Enquote(self.Get_Input())) + ';' + str('\n') + 'forever' + str('\n') + '{' + str('\n') + str("    ") + 'breakif (not ' + str(Self_Call) + ');' + str('\n') + '}'
        if self.Rule.Fallback_Declaration is not None:
            self.Fallback_Declaration = self.Rule.Fallback_Declaration
        self.Fallback_Declaration = Declarations
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Syntax_Our (Syntax):
    Gal_Keyword = 'our'
    Gs_Keyword = 'our'
    def __init__(self):
        super().__init__()
        self.Class_Property = None
    def Infer_Mumps(self):
        # comment 'Syntax_Our';
        Class_Context = self.Mumps_Class()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Code = '^%' + str(Class_Name)
        if self.Class_Property is not None:
            Name = str(self.Class_Property.Mumps)
            Code += '(0,' + str(self.Mq(Name)) + ')'
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Syntax_Our';
        Class_Context = self.Mumps_Class()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Code = '^%' + str(Class_Name)
        if self.Class_Property is not None:
            Name = str(self.Class_Property.Mumps)
            Code += '(0,' + str(self.Mq(Name)) + ')'
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Class_Property = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Code = 'this'
        if self.Class_Property is not None:
            Code += '.' + str(self.Javascript_Arguments('.'))
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = 'cls'
        if self.Class_Property is not None:
            Code += '.' + str(self.Python_Arguments('.'))
        self.Python = Code
        return True
class Syntax_Outcomes (Syntax):
    Gal_Keyword = 'outcomes'
    Gs_Keyword = 'outcomes'
    def Infer_Mumps(self):
        Verbose = False
        Code = '^O($job)'
        if Verbose:
            print("    Syntax_Outcomes ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Code = '^O($job)'
        if Verbose:
            print("    Syntax_Outcomes ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        pass
class Syntax_Output (Syntax):
    Gal_Keyword = 'output'
    Gs_Keyword = 'output'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        # comment 'TODO:a test dialect knows how to implement this?';
        Code = '[output]'
        self.Fallback = Code
        return True
class Syntax_Optional (Syntax):
    Gal_Keyword = 'optional'
    Gs_Keyword = 'optional'
    def __init__(self):
        super().__init__()
        self.Rule_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rule_Name')
        self.Rule_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Declarations = ''
        Rule = str(self.Rule_Name.Fallback)
        Self_Call = 'i Parse_' + str(Rule) + ' My_Elements;'
        if isinstance(self.Rule_Name, Token_Quote) or isinstance(self.Rule_Name, Syntax_Line):
            Self_Call = 'i Parse_Token My_Elements '  +  Rule  +  ';'
            if self.Rule_Name.Fallback_Declaration is not None:
                Declarations += str(self.Rule_Name.Fallback_Declaration)
        Code = 'comment `optional ' + str(Rule) + '`;' + str('\n') + str(Self_Call)
        self.Fallback_Declaration = Declarations
        self.Fallback = Code
        return True
    def Infer_Parse(self):
        Declarations = ''
        Rule = str(self.Rule.Fallback)
        Self_Call = 'i Parse_' + str(Rule) + ' My_Elements;'
        if isinstance(self.Rule, Token_Quote) or isinstance(self.Rule, Syntax_Line):
            Self_Call = 'i Parse_Token My_Elements '  +  Rule  +  ';'
            if self.Rule.Fallback_Declaration is not None:
                Declarations += str(self.Rule.Fallback_Declaration)
        Code = 'comment `optional ' + str(Rule) + '`;' + str('\n') + str(Self_Call)
        self.Fallback_Declaration = Declarations
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Syntax_Property (Syntax):
    Gal_Keyword = '.'
    Gs_Keyword = '.'
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Property_Name = None
    def Infer_Mumps(self):
        Verbose = False
        Object = str(self.Object.Mumps)
        Property_Name = str(self.Property_Name.Mumps)
        Property_Name = Property_Name.replace('_', '')
        Arg = None
        Code = '@' + str(Object) + '@(' + str(self.Mq(Property_Name)) + ')'
        for Arg in self.Listargs:
            Code = '@('  +  Code  +  ')@('  +  self.Mq(Arg.Mumps)  +  ')'
            Verbosity = True
        if Verbose:
            print('syntax property, object ', Object, ', code: ', Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Object = str(self.Object.Mumps)
        Property_Name = str(self.Property_Name.Mumps)
        Property_Name = Property_Name.replace('_', '')
        Arg = None
        Code = '@' + str(Object) + '@(' + str(self.Mq(Property_Name)) + ')'
        for Arg in self.Listargs:
            Code = '@('  +  Code  +  ')@('  +  self.Mq(Arg.Mumps)  +  ')'
            Verbosity = True
        if Verbose:
            print('syntax property, object ', Object, ', code: ', Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Property_Name')
        self.Property_Name = self.Listargs.pop(0)
    def Infer_Gal(self):
        Gen = str(self.Syntax_Gal('.'  +  self.Gal_Arguments()))
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Code = str(self.Object.Gs) + '.' + str(self.Property_Name.Gs)
        Argument = None
        for Argument in self.Listargs:
            Code += '.' + str(Argument.Gs)
        if '~' in self.Gal_Key_Suffix:
            Code += ' ~'
        self.Gs = self.Syntax_Gs(Code)
        return True
    def Infer_Javascript(self):
        Gen = str(self.Javascript_Arguments('.'))
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Python_Arguments('.'))
        self.Python = Gen
        return True
    def Infer_C(self):
        Verbose = False
        Object = str(self.Object.C)
        Property_Name = str(self.Property_Name.C)
        Class_Context = self.Get_Class_Context()
        Class_Name = str(Class_Context.Name.C)
        Meth_Context = self.Method_Context()
        if Object in Meth_Context.Variables.keys():
            if Verbose:
                print('NOT ', Class_Name, sep='')
            Class_Name = Meth_Context.Variables[Object]
        if Verbose:
            print(Object, ' is a ', Class_Name, sep='')
        Code = str(Class_Name) + '_prop_' + str(Property_Name) + '[' + str(Object) + ']'
        Arg = None
        for Arg in self.Listargs:
            Code += '[' + str(Arg.C) + ']'
        self.C = Code
        return True
    def Infer_Fallback(self):
        Code = str(self.Object.Fallback) + '.' + str(self.Property_Name.Fallback)
        Argument = None
        for Argument in self.Listargs:
            Code += '.' + str(Argument.Fallback)
        if '~' in self.Gal_Key_Suffix:
            Code += ' Symbol_Value'
        self.Fallback = self.Syntax_Gs(Code)
        return True
class Syntax_Property_Lookup (Syntax):
    Gal_Keyword = 'property.lookup'
    Gs_Keyword = 'property.lookup'
    def __init__(self):
        super().__init__()
        self.Object = None
        self.Name_String = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Object')
        self.Object = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name_String')
        self.Name_String = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Gen = str(self.Object.Javascript) + "[" + str(self.Name_String.Javascript) + "]"
        self.Javascript = Gen
        return True
class Syntax_Repeating (Syntax):
    Gal_Keyword = 'repeating'
    Gs_Keyword = 'repeating'
    def __init__(self):
        super().__init__()
        self.Rule_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rule_Name')
        self.Rule_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Declarations = ''
        Rule = str(self.Rule_Name.Fallback)
        Self_Call = '(i Parse_' + str(Rule) + ' My_Elements)'
        if isinstance(self.Rule_Name, Token_Quote) or isinstance(self.Rule_Name, Syntax_Line):
            Self_Call = '(i Parse_Token My_Elements '  +  Rule  +  ')'
        if self.Rule_Name.Fallback_Declaration is not None:
            Declarations += str(self.Rule_Name.Fallback_Declaration)
        Code = 'comment `repeating ' + str(Rule) + '`;' + str('\n') + 'if (not ' + str(Self_Call) + ')' + str('\n') + '{' + str('\n') + str("    ") + 'i Rollback Start_Char Start_Token `[repeating ' + str(Rule) + '] expected at least one ' + str(Rule) + '.`;' + str('\n') + str("    ") + 'return [false];' + str('\n') + '}' + str('\n') + 'forever' + str('\n') + '{' + str('\n') + str("    ") + 'breakif (not ' + str(Self_Call) + ');' + str('\n') + '}'
        self.Fallback_Declaration = Declarations
        self.Fallback = Code
        return True
    def Infer_Parse(self):
        Declarations = ''
        Rule = str(self.Rule.Fallback)
        Self_Call = '(i Parse_' + str(Rule) + ' My_Elements)'
        if isinstance(self.Rule, Token_Quote) or isinstance(self.Rule, Syntax_Line):
            Self_Call = '(i Parse_Token My_Elements '  +  Rule  +  ')'
            if self.Rule.Fallback_Declaration is not None:
                Declarations += str(self.Rule.Fallback_Declaration)
        Code = 'comment `repeating ' + str(Rule) + '`;' + str('\n') + 'returnif (not ' + str(Self_Call) + ') [false];' + str('\n') + 'forever' + str('\n') + '{' + str('\n') + str("    ") + 'breakif (not ' + str(Self_Call) + ');' + str('\n') + '}'
        self.Fallback_Declaration = Declarations
        self.Parse = Code
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Syntax_Request (Syntax):
    Gal_Keyword = 'request'
    Gs_Keyword = 'request'
    def __init__(self):
        super().__init__()
        self.Key = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Key')
        self.Key = self.Listargs.pop(0)
class Syntax_Roster_Floor (Syntax):
    Gal_Keyword = 'roster.floor'
    Gs_Keyword = 'roster.floor'
    def Infer_Mumps(self):
        Verbose = False
        Code = str(C.Floor)
        if Verbose:
            print("    ", "syntax roster floor ", Code, sep='')
        self.Mumps = Code
    def Infer_Mumps(self):
        Verbose = False
        Code = str(C.Floor)
        if Verbose:
            print("    ", "syntax roster floor ", Code, sep='')
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_C(self):
        self.C = C.Floor
        return True
class Syntax_Session (Syntax):
    Gal_Keyword = 'session'
    Gs_Keyword = 'session'
    def __init__(self):
        super().__init__()
        self.Key = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Key')
        self.Key = self.Listargs.pop(0)
class Syntax_String (Argument_Syntax):
    Gal_Keyword = 'string'
    Gs_Keyword = 'string'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Default_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Default_Value = self.Listargs.pop(0)
class Syntax_Self (Syntax):
    Gal_Keyword = 'self'
    Gs_Keyword = 'self'
    def Infer_Mumps(self):
        self.Mumps = "%self"
    def Infer_Mumps(self):
        self.Mumps = "%self"
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'this'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'self'
        self.Python = Gen
        return True
class Syntax_Sequence (Syntax):
    Gal_Keyword = 'sequence'
    Gs_Keyword = 'sequence'
    def __init__(self):
        super().__init__()
        self.Rule_Name = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Rule_Name')
        self.Rule_Name = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Declarations = ''
        # comment 'TODO:the fallback is a reference to the named rule created by this syntax.';
        # comment 'TODO:the fallback declaration is the sequence function generated by this code.';
        My_Source = str(self.Get_Input())
        Rule_Name = str(self.Rule_Name.Fallback)
        Block = 'comment ' + str(self.Enquote(self.Get_Input())) + ';' + str('\n') + 'integer Start_Char [my Char_Pos];' + str('\n') + 'integer Start_Token [my Token_Pos];' + str('\n') + 'global list My_Elements;' + str('\n')
        Argument = None
        Excludes = False
        for Argument in self.Listargs:
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            if isinstance(Argument, Token_Quote) or isinstance(Argument, Syntax_Line):
                Text = str(Argument.Fallback)
                Block += 'if (not (i Parse_Token My_Elements ' + str(Text) + ')) { i Rollback Start_Char Start_Token (append "' + str(self.Rule_Name.Fallback) + ' expected "' + str(Text) + '"."); return [false]; }' + str('\n')
            elif isinstance(Argument, Token):
                Name = str(Argument.Fallback)
                Block += 'if (not (i Parse_' + str(Name) + ' My_Elements)) { i Rollback Start_Char Start_Token "' + str(self.Rule_Name.Fallback) + ' expected ' + str(Name) + '."; return [false]; }' + str('\n')
            elif isinstance(Argument, Syntax_Exclude):
                Excludes = True
                Block += str(Argument.Fallback) + str('\n')
            else:
                Block += str(Argument.Fallback) + str('\n')
        Block += 'integer End [my Char_Pos];' + str('\n') + 'object Element (new ' + str(self.Rule_Name.Fallback) + ');' + str('\n') + 'object First_Child (lget [my Tokens] Start_Token);' + str('\n') + 'Start_Char = [First_Child.Start_Position];' + str('\n') + '.= Element Start_Position Start_Char;' + str('\n') + '.= Element End_Position End;' + str('\n') + '.= Element Document [self];' + str('\n') + 'copy [Element.Elements] = My_Elements;' + str('\n') + 'i Add_Element Element;' + str('\n') + 'push Parent_Elements Element;' + str('\n') + 'return [true];' + str('\n')
        if Excludes:
            Block = 'list Excluded;'  +  '\n'  +  Block
        Block = self.Indent(Block)
        Code = str(Declarations) + 'method flag Parse_' + str(Rule_Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str(Block) + '}'
        self.Fallback_Declaration = Code
        self.Fallback = Rule_Name
        return True
    def Infer_Parse(self):
        Declarations = ''
        # comment 'TODO:the fallback is a reference to the named rule created by this syntax.';
        # comment 'TODO:the fallback declaration is the sequence function generated by this code.';
        My_Source = str(self.Get_Input())
        Rule_Name = str(self.Rule_Name.Fallback)
        Block = 'comment ' + str(self.Enquote(self.Get_Input())) + ';' + str('\n') + 'integer Start [my Position];' + str('\n') + 'list My_Elements;' + str('\n')
        Argument = None
        Excludes = False
        for Argument in self.Listargs:
            if Argument.Fallback_Declaration is not None:
                Declarations += str(Argument.Fallback_Declaration)
            if isinstance(Argument, Token_Quote) or isinstance(Argument, Syntax_Line):
                Text = str(Argument.Fallback)
                Block += 'if (not (i Parse_Token My_Elements ' + str(Text) + ')) { i Rollback Start (append "' + str(self.Rule_Name.Fallback) + ' expected "' + str(Text) + '"."); return [false]; }' + str('\n')
            elif isinstance(Argument, Token):
                Name = str(Argument.Fallback)
                Block += 'if (not (i Parse_' + str(Name) + ' My_Elements)) { debug; i Rollback Start "' + str(self.Rule_Name.Fallback) + ' expected ' + str(Name) + '."; return [false]; }' + str('\n')
            elif isinstance(Argument, Syntax_Exclude):
                Excludes = True
                Block += str(Argument.Fallback) + str('\n')
            else:
                Block += str(Argument.Fallback) + str('\n')
        Block += 'integer End [my Position];' + str('\n') + 'object Element (new ' + str(self.Rule_Name.Fallback) + ');' + str('\n') + '.= Element Start_Position Start;' + str('\n') + '.= Element End_Position End;' + str('\n') + '.= Element Document [self];' + str('\n') + '.= Element Elements My_Elements;' + str('\n') + 'i Add_Element Element;' + str('\n') + 'list.append Parent_Elements Element;' + str('\n') + 'return [true];' + str('\n')
        if Excludes:
            Block = 'list Excluded;'  +  '\n'  +  Block
        Block = self.Indent(Block)
        Code = str(Declarations) + 'method flag Parse_' + str(Rule_Name) + ' [list Parent_Elements]' + str('\n') + '{' + str('\n') + str(Block) + '}'
        self.Fallback_Declaration = Code
        self.Parse = Rule_Name
        return True
    def Infer_Generate(self):
        zdebug.zbreak()
        Verbose = True
        Code = 'todo'
        self.Generate = Code
        return True
class Syntax_Sql_Connection (Syntax):
    Gal_Keyword = 'sql.connection'
    Gs_Keyword = 'sql.connection'
    def __init__(self):
        super().__init__()
        self.Database = None
        self.Server = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Database')
        self.Database = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Server = self.Listargs.pop(0)
class Syntax_Remember (Syntax):
    Gal_Keyword = 'remember'
    Gs_Keyword = 'remember'
    def __init__(self):
        super().__init__()
        self.Name = None
        self.Expression = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Expression')
        self.Expression = self.Listargs.pop(0)
    def Infer_Gs(self):
        Gen = '[' + str(self.Name.Gs) + ' ' + str(self.Expression.Gs) + ' remember' + str(self.Gs_Listargs()) + ']'
        self.Gs = Gen
        return True
    def Infer_Fallback(self):
        Name = str(self.Enquote(self.Name.Fallback))
        Expression = str(self.Expression.Fallback)
        Variable = None
        Argument = None
        Names = ""
        for Argument in self.Listargs:
            Variable = Argument.Fallback
            Names += " " + str(Variable)
        if str(Names) > '':
            Names = ' [new list'  +  Names  +  ']'
        Fallback_Generator.Example_Number += 1
        Offset = Fallback_Generator.Example_Number
        Code = '(Runtime:Remember_Result ' + str(Name) + ' ' + str(Expression) + str(Names) + ')'
        self.Fallback = Code
        return True
class Syntax_Tab (Syntax):
    Gal_Keyword = 'tab'
    Gs_Keyword = 'tab'
    def __init__(self):
        super().__init__()
        self.Count = None
    def Attributes(self):
        if len(self.Listargs) > 0:
            self.Count = self.Listargs.pop(0)
    def Infer_Javascript(self):
        Code = '"\\t"'
        if self.Count is not None:
            Code += '.repeat(' + str(self.Count.Javascript) + ')'
        self.Javascript = Code
        return True
    def Infer_Javascript(self):
        Code = '"\\t"'
        if self.Count is not None:
            Code += '.repeat(' + str(self.Count.Javascript) + ')'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Code = "'\\t'"
        if self.Count is not None:
            Code += '*' + str(self.Count.Python)
        self.Python = Code
        return True
class Syntax_Tilda (Syntax):
    Gal_Keyword = 'tilda'
    Gs_Keyword = 'tilda'
    def Attributes(self):
        pass
    def Infer_Fallback(self):
        Args = str(self.Fallback_Arguments())
        Code = '[' + str(Args) + '.Symbol_Value]'
        self.Fallback = Code
        return True
class Syntax_True (Syntax):
    Gal_Keyword = 'true'
    Gs_Keyword = 'true'
    def Infer_Mumps(self):
        Code = '1'
        self.Mumps = Code
    def Infer_Mumps(self):
        Code = '1'
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'true'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'True'
        self.Python = Gen
        return True
    def Infer_C(self):
        Gen = "1"
        self.C = Gen
        return True
    def Infer_Data_Types(self):
        self.Data_Type = 'flag'
        return True
class Syntax_Us (Syntax):
    Gal_Keyword = 'us'
    Gs_Keyword = 'us'
    def Infer_Mumps(self):
        # comment 'Syntax_Us';
        Class_Context = self.Mumps_Class()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Code = '^%' + str(Class_Name)
        self.Mumps = Code
    def Infer_Mumps(self):
        # comment 'Syntax_Us';
        Class_Context = self.Mumps_Class()
        Class_Name = str(Class_Context.Name.Get_Input())
        Class_Name = Class_Name.replace('_', '')
        Code = '^%' + str(Class_Name)
        self.Mumps = Code
    def Attributes(self):
        pass
    def Infer_Javascript(self):
        Gen = 'this'
        self.Javascript = Gen
        return True
class Syntax_Variant (Argument_Syntax):
    Gal_Keyword = 'variant'
    Gs_Keyword = 'variant'
    def __init__(self):
        super().__init__()
        self.Variable = None
        self.Default_Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Variable')
        self.Variable = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Default_Value = self.Listargs.pop(0)
class Gal_Parser (Parser):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
        self.Dialect = Dialect_Gal()
    def propinit(self):
        self.Dialect = Dialect_Gal
        self.Inferences = List(self)
        self.Tokens = List(self)
        self.Elements = List(self)
        self.Position = 0
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Dialect.Initialize()
        self.Inferences.Symbol_Value.extend([Inference_Tokens(self)])
        self.Inferences.Symbol_Value.extend([Inference_Elements(self)])
        self.Inferences.Symbol_Value.extend([Inference_Location(self)])
        self.Inferences.Symbol_Value.extend([Inference_Verb(self)])
        self.Inferences.Symbol_Value.extend([Inference_Classification(self)])
        self.Inferences.Symbol_Value.extend([Inference_Components(self)])
        self.Inferences.Symbol_Value.extend([Inference_Attributes(self)])
        self.Inferences.Symbol_Value.extend([Inference_Structure(self)])
        return True
    def Parse_Token_Name(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Name):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Number(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Number):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Quote(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Quote):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Keyword(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Keyword):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Semi(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Semi):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Comma(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Comma):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Operation_Start(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Operation_Start):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Operation_End(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Operation_End):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Syntax_Start(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Syntax_Start):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Syntax_End(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Syntax_End):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Block_Start(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Block_Start):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Block_End(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Block_End):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Name_Token(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Name_Token):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Operation(self, Parent_Elements):
        # comment 'sequence Operation';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Operation_Start(My_Elements):
            self.Rollback(Start, "Sequence Operation expected Token_Operation_Start.")
            return False
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        # comment 'optional.repeating Operation_Tail';
        while True:
            if not self.Parse_Operation_Tail(My_Elements):
                break
        Last = Start
        if not self.Parse_Token_Operation_End(My_Elements):
            self.Rollback(Start, "Sequence Operation expected Token_Operation_End.")
            return False
        End = self.Position
        Element = Operation()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Operation_Tail(self, Parent_Elements):
        # comment 'sequence Operation_Tail';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Comma(My_Elements):
            self.Rollback(Start, "Sequence Operation_Tail expected Token_Comma.")
            return False
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Operation_Tail()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Syntax(self, Parent_Elements):
        # comment 'sequence Syntax';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Syntax_Start(My_Elements):
            self.Rollback(Start, "Sequence Syntax expected Token_Syntax_Start.")
            return False
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        # comment 'optional.repeating Syntax_Tail';
        while True:
            if not self.Parse_Syntax_Tail(My_Elements):
                break
        Last = Start
        if not self.Parse_Token_Syntax_End(My_Elements):
            self.Rollback(Start, "Sequence Syntax expected Token_Syntax_End.")
            return False
        End = self.Position
        Element = Syntax()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Syntax_Tail(self, Parent_Elements):
        # comment 'sequence Syntax_Tail';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Comma(My_Elements):
            self.Rollback(Start, "Sequence Syntax_Tail expected Token_Comma.")
            return False
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Syntax_Tail()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Expression(self, Parent_Elements):
        # comment 'either Expression';
        if self.Parse_Operation(Parent_Elements):
            return True
        if self.Parse_Syntax(Parent_Elements):
            return True
        if self.Parse_Name_Token(Parent_Elements):
            return True
        if self.Parse_Token_Number(Parent_Elements):
            return True
        if self.Parse_Token_Quote(Parent_Elements):
            return True
        return False
    def Parse_Statement_End(self, Parent_Elements):
        # comment 'either Statement_End';
        if self.Parse_Token_Semi(Parent_Elements):
            return True
        if self.Parse_Block(Parent_Elements):
            return True
        return False
    def Parse_Statement_Tail(self, Parent_Elements):
        # comment 'sequence Statement_Tail';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Comma(My_Elements):
            self.Rollback(Start, "Sequence Statement_Tail expected Token_Comma.")
            return False
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Statement_Tail()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Statement(self, Parent_Elements):
        # comment 'sequence Statement';
        Start = self.Position
        My_Elements = []
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        # comment 'optional.repeating Statement_Tail';
        while True:
            if not self.Parse_Statement_Tail(My_Elements):
                break
        Last = Start
        if not self.Parse_Statement_End(My_Elements):
            self.Rollback(Start, "Sequence Statement expected Statement_End.")
            return False
        End = self.Position
        Element = Statement()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Block(self, Parent_Elements):
        # comment 'sequence Block';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Block_Start(My_Elements):
            self.Rollback(Start, "Sequence Block expected Token_Block_Start.")
            return False
        # comment 'optional.repeating Statement';
        while True:
            if not self.Parse_Statement(My_Elements):
                break
        Last = Start
        if not self.Parse_Token_Block_End(My_Elements):
            self.Rollback(Start, "Sequence Block expected Token_Block_End.")
            return False
        End = self.Position
        Element = Block()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Statements(self, Parent_Elements):
        # comment 'sequence Statements';
        Start = self.Position
        My_Elements = []
        # comment 'repeating Statement';
        if not self.Parse_Statement(My_Elements):
            self.Rollback(Start, "Required at least one Statement.")
            return False
        while True:
            if not self.Parse_Statement(My_Elements):
                break
        End = self.Position
        Element = Statements()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Expressions(self, Parent_Elements):
        # comment 'sequence Expressions';
        Start = self.Position
        My_Elements = []
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Expressions()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Program(self, Parent_Elements):
        # comment 'either Program';
        if self.Parse_Statements(Parent_Elements):
            return True
        if self.Parse_Expression(Parent_Elements):
            return True
        return False
    def Infer_Location(self):
        Elem = None
        for Elem in self.Elements.Symbol_Value:
            Elem.Infer_Location()
        return True
        return True
    def Infer_Tokens(self):
        O = self.Owner
        Verbose = False
        Ignore = None
        Mode = None
        C = None
        Next = None
        Q = ''
        Position = None
        Input = str(self.Owner.Input.Symbol_Value)
        if Verbose:
            print("Input: ", Input, sep='')
        Last = len(Input) - 1
        Mode = 'Initial'
        T = None
        for Position in range(0, Last+1):
            Next = Input[Position:(Position)+(2)]
            C = Next[0]
            if Verbose:
                print(Mode, ' [', C, ']', sep='')
            if Position == Last:
                Next = ''
            else:
                Next = Next[-1]
            if str(Mode) == 'Initial':
                pass
            elif str(Mode) == 'Quote':
                T.Input += str(C)
                T.Location.End_Position = Position
                if self.Balanced_Quotes(Q, C):
                    Mode = 'Initial'
                    continue
            elif str(Mode) == 'Whitespace':
                if not(re.match(r"\S",C)):
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                Mode = 'Initial'
            elif str(Mode) == 'Number':
                if C in '0123456789.':
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                Mode = 'Initial'
            elif str(Mode) == 'Name':
                if C.isalpha() or C in "0123456789_":
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                else:
                    Mode = 'Initial'
            elif str(Mode) == 'Keyword':
                if not(re.match(r"\S",C)) or C in "([{<~,;>}])":
                    Mode = 'Initial'
                elif C in '`"' or "'" == str(C):
                    Mode = 'Initial'
                else:
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
            else:
                zdebug.zbreak()
                raise Exception('Unknown Token Mode ' + str(Mode))
            if str(Mode) == 'Initial':
                # comment '«»‘’“”‹›';
                if str(C) == "'" or C in '"`«‘“‹':
                    Q = C
                    T = Token_Quote(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Quote'
                elif str(C) == '(':
                    T = Token_Operation_Start(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ')':
                    T = Token_Operation_End(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == '[':
                    T = Token_Syntax_Start(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ']':
                    T = Token_Syntax_End(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == '{':
                    T = Token_Block_Start(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == '}':
                    T = Token_Block_End(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ',':
                    T = Token_Comma(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ';':
                    T = Token_Semi(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == '~':
                    T = Token_Tilde(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif not(re.match(r"\S",C)):
                    T = Token_Whitespace(self, C, Position, Position)
                    # comment 'Whitespace tokens are not appended to the token list.= ModeWhitespace';
                elif C.isupper():
                    T = Token_Name(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Name'
                elif C in '01234567890' or C in '-.' and Next in '01234567890':
                    T = Token_Number(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Number'
                else:
                    T = Token_Keyword(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Keyword'
        if Verbose:
            Position = 0
            for T in self.Tokens.Symbol_Value:
                print(Position, ' ', T.__class__.__name__, ' ', T.Input, sep='')
                Position += 1
        return True
    def Infer_Verb(self):
        Elem = None
        for Elem in self.Elements.Symbol_Value:
            Elem.Infer_Verb()
            if (Elem.Verb in (None, "")) and isinstance(Elem, Named_Element):
                if isinstance(Elem, Tail):
                    continue
                if isinstance(Elem, Syntax):
                    zdebug.zbreak()
                    Elem.Verb = 'hello'
                else:
                    zdebug.zbreak()
                    Elem.Verb = 'invoke'
        return True
        return True
    def Infer_Classification(self):
        Verbose = True
        Elem = None
        for Elem in self.Elements.Symbol_Value:
            try:
                if not Elem.Infer_Classification():
                    self.Status = False
                    Elem.Error = 'Unable to classify this language element.'
                    if Verbose:
                        print('gal classify: ', Elem.Error, sep='')
            except Exception as Error:
                self.Status = False
                Elem.Error = Error
        return self.Status
        return True
    def Infer_Components(self):
        Elem = None
        for Elem in self.Elements.Symbol_Value:
            Elem.Infer_Components()
        return True
        return True
    def Infer_Attributes(self):
        Verbose = False
        Status = True
        Elem = None
        I = None
        Err = None
        Offset = 0
        Id = None
        for Elem in self.Elements.Symbol_Value:
            Offset += 1
            Id = str(Offset)
            Elem.Id = Id
            try:
                I = Elem.Classification
                I.Id = Id
                I.Attributes()
                I.Infer_Attributes()
            except Exception as Err:
                if Verbose:
                    print("Error: ", Err, sep='')
                if Verbose:
                    print(Elem.Get_Input())
                if Verbose:
                    print()
                Elem.Error = Err
                Status = False
        return Status
        return True
    def Infer_Structure(self):
        if Verbose:
            print()
        Elem = None
        I = None
        Err = None
        Status = True
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Structure()
            except Exception as Err:
                Elem.Error = Err
                if Verbose:
                    print('Structure Error: ', Err, sep='')
                if Verbose:
                    print(Elem.Get_Input())
                if Verbose:
                    print()
                Status = False
        return Status
        return True
    def Infer_Data_Types(self):
        Elem = None
        I = None
        for Elem in self.Elements.Symbol_Value:
            I = Elem.Classification
            I.Infer_Data_Types()
        return True
class Gs_Parser (Parser):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
        self.Dialect = Dialect_Gs()
    def propinit(self):
        self.Dialect = Dialect_Gs
        self.Inferences = List(self)
        self.Tokens = List(self)
        self.Elements = List(self)
        self.Position = 0
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Dialect.Initialize()
        self.Inferences.Symbol_Value.extend([Inference_Tokens(self)])
        self.Inferences.Symbol_Value.extend([Inference_Elements(self)])
        self.Inferences.Symbol_Value.extend([Inference_Location(self)])
        self.Inferences.Symbol_Value.extend([Inference_Verb(self)])
        self.Inferences.Symbol_Value.extend([Inference_Classification(self)])
        self.Inferences.Symbol_Value.extend([Inference_Components(self)])
        self.Inferences.Symbol_Value.extend([Inference_Attributes(self)])
        self.Inferences.Symbol_Value.extend([Inference_Structure(self)])
        self.Inferences.Symbol_Value.extend([Inference_Data_Types(self)])
        return True
    def Parse_Token_Name(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Name):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Number(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Number):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Quote(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Quote):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Keyword(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Keyword):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Semi(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Semi):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Comma(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Comma):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Operation_Start(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Operation_Start):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Operation_End(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Operation_End):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Syntax_Start(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Syntax_Start):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Syntax_End(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Syntax_End):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Block_Start(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Block_Start):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Block_End(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Block_End):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Name_Token(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Name_Token):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Operation(self, Parent_Elements):
        # comment 'sequence Operation';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Operation_Start(My_Elements):
            self.Rollback(Start, "Sequence Operation expected Token_Operation_Start.")
            return False
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        # comment 'optional.repeating Operation_Tail';
        while True:
            if not self.Parse_Operation_Tail(My_Elements):
                break
        Last = Start
        if not self.Parse_Token_Operation_End(My_Elements):
            self.Rollback(Start, "Sequence Operation expected Token_Operation_End.")
            return False
        End = self.Position
        Element = Operation()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Operation_Tail(self, Parent_Elements):
        # comment 'sequence Operation_Tail';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Comma(My_Elements):
            self.Rollback(Start, "Sequence Operation_Tail expected Token_Comma.")
            return False
        # comment 'optional.repeating Expression';
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Operation_Tail()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Syntax(self, Parent_Elements):
        # comment 'sequence Syntax';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Syntax_Start(My_Elements):
            self.Rollback(Start, "Sequence Syntax expected Token_Syntax_Start.")
            return False
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        # comment 'optional.repeating Syntax_Tail';
        while True:
            if not self.Parse_Syntax_Tail(My_Elements):
                break
        Last = Start
        if not self.Parse_Token_Syntax_End(My_Elements):
            self.Rollback(Start, "Sequence Syntax expected Token_Syntax_End.")
            return False
        End = self.Position
        Element = Syntax()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Syntax_Tail(self, Parent_Elements):
        # comment 'sequence Syntax_Tail';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Comma(My_Elements):
            self.Rollback(Start, "Sequence Syntax_Tail expected Token_Comma.")
            return False
        # comment 'optional.repeating Expression';
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Syntax_Tail()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Expression(self, Parent_Elements):
        # comment 'either Expression';
        if self.Parse_Operation(Parent_Elements):
            return True
        if self.Parse_Syntax(Parent_Elements):
            return True
        if self.Parse_Name_Token(Parent_Elements):
            return True
        if self.Parse_Token_Number(Parent_Elements):
            return True
        if self.Parse_Token_Quote(Parent_Elements):
            return True
        return False
    def Parse_Statement_End(self, Parent_Elements):
        # comment 'either Statement_End';
        if self.Parse_Token_Semi(Parent_Elements):
            return True
        if self.Parse_Block(Parent_Elements):
            return True
        return False
    def Parse_Statement_Tail(self, Parent_Elements):
        # comment 'sequence Statement_Tail';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Comma(My_Elements):
            self.Rollback(Start, "Sequence Statement_Tail expected Token_Comma.")
            return False
        # comment 'optional.repeating Expression';
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Statement_Tail()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Statement(self, Parent_Elements):
        # comment 'sequence Statement';
        Start = self.Position
        My_Elements = []
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        # comment 'optional.repeating Statement_Tail';
        while True:
            if not self.Parse_Statement_Tail(My_Elements):
                break
        Last = Start
        if not self.Parse_Statement_End(My_Elements):
            self.Rollback(Start, "Sequence Statement expected Statement_End.")
            return False
        End = self.Position
        Element = Statement()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Block(self, Parent_Elements):
        # comment 'sequence Block';
        Start = self.Position
        My_Elements = []
        Last = Start
        if not self.Parse_Token_Block_Start(My_Elements):
            self.Rollback(Start, "Sequence Block expected Token_Block_Start.")
            return False
        # comment 'optional.repeating Statement';
        while True:
            if not self.Parse_Statement(My_Elements):
                break
        Last = Start
        if not self.Parse_Token_Block_End(My_Elements):
            self.Rollback(Start, "Sequence Block expected Token_Block_End.")
            return False
        End = self.Position
        Element = Block()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Statements(self, Parent_Elements):
        # comment 'sequence Statements';
        Start = self.Position
        My_Elements = []
        # comment 'repeating Statement';
        if not self.Parse_Statement(My_Elements):
            self.Rollback(Start, "Required at least one Statement.")
            return False
        while True:
            if not self.Parse_Statement(My_Elements):
                break
        End = self.Position
        Element = Statements()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Expressions(self, Parent_Elements):
        # comment 'sequence Expressions';
        Start = self.Position
        My_Elements = []
        # comment 'repeating Expression';
        if not self.Parse_Expression(My_Elements):
            self.Rollback(Start, "Required at least one Expression.")
            return False
        while True:
            if not self.Parse_Expression(My_Elements):
                break
        End = self.Position
        Element = Expressions()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Program(self, Parent_Elements):
        # comment 'either Program';
        if self.Parse_Statements(Parent_Elements):
            return True
        if self.Parse_Expression(Parent_Elements):
            return True
        return False
    def Infer_Location(self):
        Elem = None
        for Elem in self.Elements.Symbol_Value:
            Elem.Infer_Location()
        return True
        return True
    def Infer_Tokens(self):
        O = self.Owner
        Verbose = False
        Ignore = None
        Mode = None
        C = None
        Next = None
        Q = ''
        Position = None
        Input = str(self.Owner.Input.Symbol_Value)
        if Verbose:
            print("Input: ", Input, sep='')
        Last = len(Input) - 1
        Mode = 'Initial'
        T = None
        for Position in range(0, Last+1):
            Next = Input[Position:(Position)+(2)]
            C = Next[0]
            if Verbose:
                print(Mode, ' [', C, ']', sep='')
            if Position == Last:
                Next = ''
            else:
                Next = Next[-1]
            if str(Mode) == 'Initial':
                pass
            elif str(Mode) == 'Quote':
                T.Input += str(C)
                T.Location.End_Position = Position
                if self.Balanced_Quotes(Q, C):
                    Mode = 'Initial'
                    continue
            elif str(Mode) == 'Whitespace':
                if not(re.match(r"\S",C)):
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                Mode = 'Initial'
            elif str(Mode) == 'Number':
                if C in '0123456789.':
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                Mode = 'Initial'
            elif str(Mode) == 'Name':
                if C.isalpha() or C in "0123456789_":
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                else:
                    Mode = 'Initial'
            elif str(Mode) == 'Keyword':
                if not(re.match(r"\S",C)) or C in "([{<,;>}])0123456789$":
                    Mode = 'Initial'
                elif C in '`"' or "'" == str(C):
                    Mode = 'Initial'
                elif C.isupper():
                    Mode = 'Initial'
                else:
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
            else:
                zdebug.zbreak()
                raise Exception('Unknown Token Mode ' + str(Mode))
            if str(Mode) == 'Initial':
                if str(C) == "'" or C in '"`«‘“‹':
                    Q = C
                    T = Token_Quote(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Quote'
                elif str(C) == '(':
                    T = Token_Operation_Start(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ')':
                    T = Token_Operation_End(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == '[':
                    T = Token_Syntax_Start(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ']':
                    T = Token_Syntax_End(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == '{':
                    T = Token_Block_Start(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == '}':
                    T = Token_Block_End(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ',':
                    T = Token_Comma(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(C) == ';':
                    T = Token_Semi(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif not(re.match(r"\S",C)):
                    T = Token_Whitespace(self, C, Position, Position)
                    # comment 'Whitespace tokens are not appended to the token list.= ModeWhitespace';
                elif C.isupper() or str(C) == '$':
                    T = Token_Name(self, C, Position, self)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Name'
                elif C in '01234567890' or C in '-.' and Next in '01234567890':
                    T = Token_Number(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Number'
                else:
                    T = Token_Keyword(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Keyword'
        if Verbose:
            Position = 0
            for T in self.Tokens.Symbol_Value:
                print(Position, ' ', T.__class__.__name__, ' ', T.Input, sep='')
                Position += 1
        return True
    def Infer_Verb(self):
        Elem = None
        for Elem in self.Elements.Symbol_Value:
            Elem.Infer_Verb()
            if (Elem.Verb in (None, "")) and isinstance(Elem, Named_Element):
                if isinstance(Elem, Tail):
                    continue
                if isinstance(Elem, Syntax):
                    zdebug.zbreak()
                    Elem.Verb = 'hello'
                else:
                    Elem.Verb = 'invoke'
                    Elem.Verbs.extend(['invoke'])
        return True
        return True
    def Infer_Classification(self):
        Verbose = True
        Elem = None
        for Elem in self.Elements.Symbol_Value:
            try:
                if not Elem.Infer_Classification():
                    self.Status = False
                    Elem.Error = 'Unable to classify this language element.'
                    if Verbose:
                        print('goalspell classify: ', Elem.Error, sep='')
            except Exception as Error:
                self.Status = False
                Elem.Error = Error
        return self.Status
        return True
    def Infer_Components(self):
        Verbose = False
        Elem = None
        Status = True
        for Elem in self.Elements.Symbol_Value:
            if Verbose:
                print(Elem.Classification.__class__.__name__, ' Components', sep='')
            if not Elem.Infer_Components():
                Status = False
        return Status
        return True
    def Infer_Attributes(self):
        Status = True
        Elem = None
        I = None
        Err = None
        Offset = 0
        Id = None
        for Elem in self.Elements.Symbol_Value:
            Offset += 1
            Id = str(Offset)
            Elem.Id = Id
            try:
                I = Elem.Classification
                I.Id = Id
                I.Attributes()
                I.Infer_Attributes()
            except Exception as Err:
                if Verbose:
                    print("Error: ", Err, sep='')
                if Verbose:
                    print(Elem.Get_Input())
                if Verbose:
                    print()
                Elem.Error = Err
                Status = False
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Attributes()
            except Exception as Err:
                if Verbose:
                    print("Error: ", Err, sep='')
                if Verbose:
                    print(Elem.Get_Input())
                if Verbose:
                    print()
                Elem.Error = Err
                Status = False
        return Status
        return True
    def Infer_Structure(self):
        Verbose = True
        # comment 'verbosestructre inference';
        Elem = None
        I = None
        Status = True
        Err = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Structure()
            except Exception as Err:
                Elem.Error = Err
                if Verbose:
                    print('Structure Error: ', Err, sep='')
                if Verbose:
                    print(Elem.Get_Input())
                if Verbose:
                    print()
                Status = False
        return Status
        return True
    def Infer_Data_Types(self):
        Elem = None
        I = None
        for Elem in self.Elements.Symbol_Value:
            I = Elem.Classification
            I.Infer_Data_Types()
        return True
# comment '**** Tasks ****';
class Statement_Created (Feature_Statement):
    Gal_Keyword = 'created'
    Gs_Keyword = 'created'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Created'
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Comments (Feature_Statement):
    Gal_Keyword = 'comments'
    Gs_Keyword = 'comments'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Comments'
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Assignee (Feature_Statement):
    Gal_Keyword = 'assignee'
    Gs_Keyword = 'assignee'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Assignee'
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Completed (Feature_Statement):
    Gal_Keyword = 'completed'
    Gs_Keyword = 'completed'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Completed'
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Expires (Feature_Statement):
    Gal_Keyword = 'expires'
    Gs_Keyword = 'expires'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Expires'
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Status (Feature_Statement):
    Gal_Keyword = 'status'
    Gs_Keyword = 'status'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Status'
        self.Value = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
class Statement_Task (Thing_Statement):
    Gal_Keyword = 'task'
    Gs_Keyword = 'task'
    def __init__(self):
        super().__init__()
        self.Thing_Type = 'Thing_Task'
        self.Name = None
        self.Text = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
class Statement_Task_List (Thing_Statement):
    Gal_Keyword = 'task.list'
    Gs_Keyword = 'task.list'
    def __init__(self):
        super().__init__()
        self.Thing_Type = 'Thing_Task_List'
        self.Name = None
        self.Text = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
class Thing_Food (Thing):
    def __init__(self):
        super().__init__()
        self.Portion = Portion(self)
        self.Fat = Fat(self)
        self.Saturated_Fat = Saturated_Fat(self)
        self.Cholesterol = Cholesterol(self)
        self.Sodium = Sodium(self)
        self.Carbohydrate = Carbohydrate(self)
        self.Fiber = Fiber(self)
        self.Sugar = Sugar(self)
        self.Protein = Protein(self)
        self.Calcium = Calcium(self)
        self.Iron = Iron(self)
        self.Potassium = Potassium(self)
class Statement_Food (Thing_Statement):
    Gal_Keyword = 'food'
    Gs_Keyword = 'food'
    def __init__(self):
        super().__init__()
        self.Thing_Type = 'Thing_Food'
        self.Name = Argument(self)
        self.Text = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
        return True
class Thing_Meal (Thing):
    def __init__(self):
        super().__init__()
        self.Name = String(self)
        self.Foods = List(self)
class Statement_Meal (Thing_Statement):
    Gal_Keyword = 'meal'
    Gs_Keyword = 'meal'
    def __init__(self):
        super().__init__()
        self.Thing_Type = 'Thing_Meal'
        self.Name = Argument(self)
        self.Text = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
        return True
class Thing_Recipe (Thing):
    def __init__(self):
        super().__init__()
        self.Name = String(self)
        self.Ingredients = List(self)
        self.Steps = List(self)
class Thing_Nutrition (Thing):
    pass
class Statement_Nutrition (Thing_Statement):
    Gal_Keyword = 'nutrition'
    Gs_Keyword = 'nutrition'
    def __init__(self):
        super().__init__()
        self.Thing_Type = 'Thing_Nutrition'
        self.Name = Argument(self)
        self.Text = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Text = self.Listargs.pop(0)
        return True
class Statement_Grams (Statement):
    Gal_Keyword = 'g'
    Gs_Keyword = 'g'
    def __init__(self):
        super().__init__()
        self.Food = Argument(self)
        self.Amount = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Food')
        self.Food = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        return True
    def Infer_Gs(self):
        Gen = str(self.Thing.Gs) + ' ' + str(self.Amount.Gs) + ' g;'
        self.Gs = Gen
        return True
class Source (String):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Source (Feature_Statement):
    Gal_Keyword = "'source'"
    Gs_Keyword = "'source'"
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Source'
        self.Value = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
        return True
class Calories (String):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Calories (Feature_Statement):
    Gal_Keyword = "'calories'"
    Gs_Keyword = "'calories'"
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Calories'
        self.Value = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Value')
        self.Value = self.Listargs.pop(0)
        return True
class Portion (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Portion (Amount_Statement):
    Gal_Keyword = 'portion'
    Gs_Keyword = 'portion'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Portion'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Fat (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Fat (Amount_Statement):
    Gal_Keyword = 'fat'
    Gs_Keyword = 'fat'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Fat'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Saturated_Fat (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Saturated_Fat (Amount_Statement):
    Gal_Keyword = 'saturated'
    Gs_Keyword = 'saturated'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Saturated_Fat'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Cholesterol (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Cholesterol (Amount_Statement):
    Gal_Keyword = 'cholesterol'
    Gs_Keyword = 'cholesterol'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Cholesterol'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Sodium (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Sodium (Amount_Statement):
    Gal_Keyword = 'sodium'
    Gs_Keyword = 'sodium'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Sodium'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Carbohydrate (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Carbohydrate (Amount_Statement):
    Gal_Keyword = 'carbohydrate'
    Gs_Keyword = 'carbohydrate'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Carbohydrate'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Fiber (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Fiber (Amount_Statement):
    Gal_Keyword = 'fiber'
    Gs_Keyword = 'fiber'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Fiber'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Sugar (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Sugar (Amount_Statement):
    Gal_Keyword = 'sugar'
    Gs_Keyword = 'sugar'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Sugar'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Protein (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Protein (Amount_Statement):
    Gal_Keyword = 'protein'
    Gs_Keyword = 'protein'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Protein'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Vitamin (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Vitamin (Amount_Statement):
    Gal_Keyword = 'vitamin'
    Gs_Keyword = 'vitamin'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Vitamin'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Calcium (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Calcium (Amount_Statement):
    Gal_Keyword = 'calcium'
    Gs_Keyword = 'calcium'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Calcium'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Iron (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Iron (Amount_Statement):
    Gal_Keyword = 'iron'
    Gs_Keyword = 'iron'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Iron'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Potassium (Amount):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Statement_Potassium (Amount_Statement):
    Gal_Keyword = 'potassium'
    Gs_Keyword = 'potassium'
    def __init__(self):
        super().__init__()
        self.Property_Name = 'Potassium'
        self.Amount = Argument(self)
        self.Unit = Keyword(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Amount')
        self.Amount = self.Listargs.pop(0)
        if len(self.Keywords) == 0:
            raise Exception('missing required keyword Unit')
        self.Unit.Symbol_Value = self.Keywords.pop(0)
        return True
class Statement_For_Each_Human_Being (Scoped_Statement):
    Gal_Keyword = 'for.each.human.being'
    Gs_Keyword = 'for each human being'
    def __init__(self):
        super().__init__()
        self.Human_Entity = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Human_Entity')
        self.Human_Entity = self.Listargs.pop(0)
        return True
    def Infer_Fallback(self):
        Gen = 'object ' + str(self.Human_Entity.Fallback) + ';' + str('\n') + 'for each [: Human_Being Persons] ' + str(self.Human_Entity.Fallback) + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Statement_For_Each_Human_Outcome (Scoped_Statement):
    Gal_Keyword = 'for.each.human.outcome'
    Gs_Keyword = 'for each human outcome'
    def __init__(self):
        super().__init__()
        self.Human_Entity = Argument(self)
        self.Outcome_Entity = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Human_Entity')
        self.Human_Entity = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Outcome_Entity')
        self.Outcome_Entity = self.Listargs.pop(0)
        return True
    def Infer_Fallback(self):
        Gen = 'object ' + str(self.Outcome_Entity.Fallback) + ';' + str('\n') + 'for each [' + str(self.Human_Entity.Fallback) + '.Outcomes] ' + str(self.Outcome_Entity.Fallback) + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Statement_For_Each_Outcome_Support (Scoped_Statement):
    Gal_Keyword = 'for.each.outcome.support'
    Gs_Keyword = 'for each outcome support'
    def __init__(self):
        super().__init__()
        self.Outcome_Entity = Argument(self)
        self.Support_Entity = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Outcome_Entity')
        self.Outcome_Entity = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Support_Entity')
        self.Support_Entity = self.Listargs.pop(0)
        return True
    def Infer_Fallback(self):
        Gen = 'object ' + str(self.Support_Entity.Fallback) + ';' + str('\n') + 'for each [' + str(self.Outcome_Entity.Fallback) + '.Supports] ' + str(self.Support_Entity.Fallback) + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Statement_For_Each_Supporter (Scoped_Statement):
    Gal_Keyword = 'for.each.supporter'
    Gs_Keyword = 'for each supporter'
    def __init__(self):
        super().__init__()
        self.Support_Entity = Argument(self)
        self.Supporter_Entity = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Support_Entity')
        self.Support_Entity = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Supporter_Entity')
        self.Supporter_Entity = self.Listargs.pop(0)
        return True
    def Infer_Fallback(self):
        Gen = 'object ' + str(self.Supporter_Entity.Fallback) + ';' + str('\n') + 'for each [' + str(self.Support_Entity.Fallback) + '.Supporters] ' + str(self.Supporter_Entity.Fallback) + str(self.Fallback_Block())
        self.Fallback = Gen
        return True
class Operation_Human_Outcome_Gratitude (Operation):
    Gal_Keyword = 'human.outcome.gratitude'
    Gs_Keyword = 'human outcome gratitude'
    def __init__(self):
        super().__init__()
        self.Supporter_Entity = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Supporter_Entity')
        self.Supporter_Entity = self.Listargs.pop(0)
        return True
    def Infer_Fallback(self):
        Gen = '(' + str(self.Supporter_Entity.Fallback) + '.Human_Outcome_Gratitude' + str(self.Fallback_Args()) + ')'
        self.Fallback = Gen
        return True
class Statement_Pay (Line_Statement):
    Gal_Keyword = 'pay'
    Gs_Keyword = 'pay'
    def __init__(self):
        super().__init__()
        self.Transaction_Entity = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Transaction_Entity')
        self.Transaction_Entity = self.Listargs.pop(0)
        return True
    def Infer_Fallback(self):
        Gen = str(self.Transaction_Entity.Fallback) + '.Pay' + str(self.Fallback_Args()) + ';'
        self.Fallback = Gen
        return True
class Statement_Cycle (Scoped_Statement):
    Gal_Keyword = 'cycle'
    Gs_Keyword = 'cycle'
    def Attributes(self):
        return True
    def Infer_Fallback(self):
        Gen = 'method flag Cycle' + str(self.Fallback_Arguments()) + str('\n') + '{' + str('\n') + str(self.Fallback_Statements()) + str("    ") + 'return [true];' + str('\n') + '}'
        self.Fallback = Gen
        return True
# comment '**** Gal.gal ****';
class Goal_Gal (Goal):
    pass
class Spell_Gal (Spell):
    pass
class Dialect_Gal (Dialect):
    def Initialize(self):
        self.Statements['add'] = Statement_Add();
        self.Statements['+'] = Statement_Add();
        self.Statements['+='] = Statement_Add();
        self.Statements['and'] = Statement_And();
        self.Statements['&'] = Statement_And();
        self.Statements['and='] = Statement_And();
        self.Statements['&='] = Statement_And();
        self.Statements['append'] = Statement_Append();
        self.Statements['string.append'] = Statement_Append();
        self.Statements['s+'] = Statement_Append();
        self.Statements['argument'] = Statement_Argument();
        self.Statements['assign'] = Statement_Assign();
        self.Statements['='] = Statement_Assign();
        self.Statements['atomic'] = Statement_Atomic();
        self.Statements['attribute'] = Statement_Attribute();
        self.Statements['author'] = Statement_Author();
        self.Statements['behavior'] = Statement_Behavior();
        self.Statements['break'] = Statement_Break();
        self.Statements['breakif'] = Statement_Break_If();
        self.Statements['break.if'] = Statement_Break_If();
        self.Statements['.'] = Statement_Call();
        self.Statements['call'] = Statement_Call();
        self.Statements['catch'] = Statement_Catch();
        self.Statements['class'] = Statement_Class();
        self.Statements['class.append'] = Statement_Class_Append();
        self.Statements['class.attribute'] = Statement_Class_Attribute();
        self.Statements['class.method'] = Statement_Class_Method();
        self.Statements['classmethod'] = Statement_Class_Method();
        self.Statements['class.property'] = Statement_Class_Property();
        self.Statements['classprop'] = Statement_Class_Property();
        self.Statements[':='] = Statement_Classpropset();
        self.Statements['classpropset'] = Statement_Classpropset();
        self.Statements['cp.='] = Statement_Classpropset();
        self.Statements['classify'] = Statement_Classify();
        self.Statements['comment'] = Statement_Comment();
        self.Statements['compile'] = Statement_Compile();
        self.Statements['constructor'] = Statement_Constructor();
        self.Statements['contest'] = Statement_Contest();
        self.Statements['continue'] = Statement_Continue();
        self.Statements['contif'] = Statement_Continue_If();
        self.Statements['continue.if'] = Statement_Continue_If();
        self.Statements['currency'] = Statement_Currency();
        self.Statements['debug'] = Statement_Debug();
        self.Statements['debugger'] = Statement_Debug();
        self.Statements['debugif'] = Statement_Debug_If();
        self.Statements['debug.if'] = Statement_Debug_If();
        self.Statements['decrement'] = Statement_Decrement();
        self.Statements['--'] = Statement_Decrement();
        self.Statements['dialect'] = Statement_Dialect();
        self.Statements['dict'] = Statement_Dictionary();
        self.Statements['dictionary'] = Statement_Dictionary();
        self.Statements['hash'] = Statement_Dictionary();
        self.Statements['dict.assign'] = Statement_Dictionary_Assign();
        self.Statements['dicts'] = Statement_Dictionaries();
        self.Statements['dictionaries'] = Statement_Dictionaries();
        self.Statements['hashes'] = Statement_Dictionaries();
        self.Statements['do'] = Statement_Do();
        self.Statements['do @'] = Statement_Do();
        self.Statements['document_reference'] = Statement_Document_Reference();
        self.Statements['else'] = Statement_Else();
        self.Statements['either'] = Statement_Either();
        self.Statements['expect.string'] = Statement_Expect_String();
        self.Statements['fallback'] = Statement_Fallback();
        self.Statements['forgive'] = Statement_Forgive();
        self.Statements['generate'] = Statement_Generate();
        self.Statements['i='] = Statement_I_Equal();
        self.Statements['i ='] = Statement_I_Equal();
        self.Statements['i equal'] = Statement_I_Equal();
        self.Statements['iterate'] = Statement_Iterate();
        self.Statements['list.copy'] = Statement_List_Copy();
        self.Statements['parser'] = Statement_Parser();
        self.Statements['sequence'] = Statement_Sequence();
        self.Statements['else.if'] = Statement_Else_If();
        self.Statements['english'] = Statement_English();
        self.Statements['entities'] = Statement_Objects();
        self.Statements['objects'] = Statement_Objects();
        self.Statements['entity'] = Statement_Object();
        self.Statements['object'] = Statement_Object();
        self.Statements['entity.new'] = Statement_Object_New();
        self.Statements['object.new'] = Statement_Object_New();
        self.Statements['error'] = Statement_Error();
        self.Statements['throw'] = Statement_Error();
        self.Statements['raise'] = Statement_Error();
        self.Statements['whoops'] = Statement_Error();
        self.Statements['oops'] = Statement_Error();
        self.Statements['execute'] = Statement_Execute();
        self.Statements['feature'] = Statement_Feature();
        self.Statements['file.dump'] = Statement_File_Dump();
        self.Statements['file.readall'] = Statement_File_Readall();
        self.Statements['readall'] = Statement_File_Readall();
        self.Statements['flag'] = Statement_Flag();
        self.Statements['boolean'] = Statement_Flag();
        self.Statements['bool'] = Statement_Flag();
        self.Statements['flags'] = Statement_Flags();
        self.Statements['booleans'] = Statement_Flags();
        self.Statements['bools'] = Statement_Flags();
        self.Statements['flowerbox'] = Statement_Flowerbox();
        self.Statements['for.range'] = Statement_For_Range();
        self.Statements['forever'] = Statement_Forever();
        self.Statements['foreach'] = Statement_Foreach();
        self.Statements['generator'] = Statement_Generator();
        self.Statements['goal'] = Statement_Goal();
        self.Statements['goalspell'] = Statement_Goal_Spell();
        self.Statements['goal.spell'] = Statement_Goal_Spell();
        self.Statements['gs'] = Statement_Gs();
        self.Statements['goalspell'] = Statement_Gs();
        self.Statements['gs='] = Statement_Gs_Equal();
        self.Statements['goalspell='] = Statement_Gs_Equal();
        self.Statements['gs.='] = Statement_Gs_Equal();
        self.Statements['goalspell.='] = Statement_Gs_Equal();
        self.Statements['i'] = Statement_I();
        self.Statements['improve'] = Statement_Improve();
        self.Statements['increment'] = Statement_Increment();
        self.Statements['++'] = Statement_Increment();
        self.Statements['if'] = Statement_If();
        self.Statements['ifdef'] = Statement_Ifdef();
        self.Statements['ifdefined'] = Statement_Ifdef();
        self.Statements['if def'] = Statement_Ifdef();
        self.Statements['if defined'] = Statement_Ifdef();
        self.Statements['infer.inits'] = Statement_Infer_Inits();
        self.Statements['inference'] = Statement_Inference();
        self.Statements['infers'] = Statement_Infers();
        self.Statements['integer'] = Statement_Integer();
        self.Statements['int'] = Statement_Integer();
        self.Statements['integers'] = Statement_Integers();
        self.Statements['ints'] = Statement_Integers();
        self.Statements['isa'] = Statement_Is_A();
        self.Statements['is a'] = Statement_Is_A();
        self.Statements['is.a'] = Statement_Is_A();
        self.Statements['it='] = Statement_It_Equals();
        self.Statements['join'] = Statement_Join();
        self.Statements['list.join'] = Statement_Join();
        self.Statements['keyword'] = Statement_Keyword();
        self.Statements['list'] = Statement_List();
        self.Statements['list.items'] = Statement_List();
        self.Statements['lists'] = Statement_Lists();
        self.Statements['list.append'] = Statement_List_Append();
        self.Statements['list+'] = Statement_List_Append();
        self.Statements['push'] = Statement_List_Append();
        self.Statements['list clear'] = Statement_List_Clear();
        self.Statements['lclear'] = Statement_List_Clear();
        self.Statements['list.clear'] = Statement_List_Clear();
        self.Statements['main'] = Statement_Main();
        self.Statements['menu_item'] = Statement_Menu_Item();
        self.Statements['menu_dropdown'] = Statement_Menu_Dropdown();
        self.Statements['menu_bar'] = Statement_Menu_Bar();
        self.Statements['method'] = Statement_Method();
        self.Statements['my='] = Statement_My_Equal();
        self.Statements['newtoken'] = Statement_New_Token();
        self.Statements['new.token'] = Statement_New_Token();
        self.Statements['number'] = Statement_Number();
        self.Statements['numbers'] = Statement_Numbers();
        self.Statements['operation'] = Statement_Gal_Operation();
        self.Statements['operations'] = Statement_Operations();
        self.Statements['optimize='] = Statement_Optimize_Equal();
        self.Statements['optional'] = Statement_Optional();
        self.Statements['prompt.context'] = Statement_Prompt_Context();
        self.Statements['property'] = Statement_Property();
        self.Statements['.='] = Statement_Propset();
        self.Statements['propset'] = Statement_Propset();
        self.Statements['read.char'] = Statement_Read_Character();
        self.Statements['readline'] = Statement_Readline();
        self.Statements['read.line'] = Statement_Readline();
        self.Statements['replace'] = Statement_Replace();
        self.Statements['return'] = Statement_Return();
        self.Statements['returnif'] = Statement_Return_If();
        self.Statements['return.if'] = Statement_Return_If();
        self.Statements['require.that'] = Statement_Require_That();
        self.Statements['require.that.i'] = Statement_Require_That_I();
        self.Statements['site'] = Statement_Site();
        self.Statements['skiptoken'] = Statement_Skip_Token();
        self.Statements['skip.token'] = Statement_Skip_Token();
        self.Statements['spell'] = Statement_Spell();
        self.Statements['statement'] = Statement_Gal_Statement();
        self.Statements['statements'] = Statement_Statements();
        self.Statements['string'] = Statement_String();
        self.Statements['strings'] = Statement_Strings();
        self.Statements['supporter'] = Statement_Supporter();
        self.Statements['symbol'] = Statement_Symbol();
        self.Statements['syntax'] = Statement_Gal_Syntax();
        self.Statements['syntaxes'] = Statement_Syntaxes();
        self.Statements['thing'] = Statement_Thing();
        self.Statements['todo'] = Statement_Todo();
        self.Statements['token'] = Statement_Token();
        self.Statements['tokens'] = Statement_Tokens();
        self.Statements['token.append'] = Statement_Token_Append();
        self.Statements['tokenappend'] = Statement_Token_Append();
        self.Statements['token.mode'] = Statement_Token_Mode();
        self.Statements['tokenmode'] = Statement_Token_Mode();
        self.Statements['try'] = Statement_Try();
        self.Statements['undef'] = Statement_Undefined();
        self.Statements['undefined'] = Statement_Undefined();
        self.Statements['var'] = Statement_Variant();
        self.Statements['variant'] = Statement_Variant();
        self.Statements['vars'] = Statement_Variants();
        self.Statements['variants'] = Statement_Variants();
        self.Statements['vernacular'] = Statement_Vernacular();
        self.Statements['verbose'] = Statement_Verbose();
        self.Statements['verbosity'] = Statement_Verbosity();
        self.Statements['we'] = Statement_We();
        self.Statements['while'] = Statement_While();
        self.Statements['write'] = Statement_Write();
        self.Statements['writeline'] = Statement_Write_Line();
        self.Statements['write.line'] = Statement_Write_Line();
        self.Statements['say'] = Statement_Write_Line();
        self.Operations['add'] = Operation_Add();
        self.Operations['+'] = Operation_Add();
        self.Operations['plus'] = Operation_Add();
        self.Operations['and'] = Operation_And();
        self.Operations['&'] = Operation_And();
        self.Operations['&&'] = Operation_And();
        self.Operations['startswith'] = Operation_Begins();
        self.Operations['starts.with'] = Operation_Begins();
        self.Operations['starts'] = Operation_Begins();
        self.Operations['begins'] = Operation_Begins();
        self.Operations['beginswith'] = Operation_Begins();
        self.Operations['begins.with'] = Operation_Begins();
        self.Operations['classpropget'] = Operation_Classpropget();
        self.Operations['call'] = Operation_Call();
        self.Operations['.'] = Operation_Call();
        self.Operations['chartoint'] = Operation_Char2int();
        self.Operations['char to int'] = Operation_Char2int();
        self.Operations['charint'] = Operation_Char2int();
        self.Operations['char int'] = Operation_Char2int();
        self.Operations['char2int'] = Operation_Char2int();
        self.Operations['char2num'] = Operation_Char2int();
        self.Operations[':'] = Operation_Colon();
        self.Operations['contains'] = Operation_Contains();
        self.Operations['defined'] = Operation_Defined();
        self.Operations['list.last'] = Operation_List_Last();
        self.Operations['split'] = Operation_Split();
        self.Operations['dict.exists'] = Operation_Dict_Exists();
        self.Operations['key.exists'] = Operation_Dict_Exists();
        self.Operations['dict.get'] = Operation_Dict_Get();
        self.Operations['key.get'] = Operation_Dict_Get();
        self.Operations['divide'] = Operation_Divide();
        self.Operations['/'] = Operation_Divide();
        self.Operations['div'] = Operation_Divide();
        self.Operations['env'] = Operation_Environment();
        self.Operations['environment'] = Operation_Environment();
        self.Operations['='] = Operation_Equal();
        self.Operations['=='] = Operation_Equal();
        self.Operations['eq'] = Operation_Equal();
        self.Operations['equals'] = Operation_Equal();
        self.Operations['equal'] = Operation_Equal();
        self.Operations['firstchar'] = Operation_First_Char();
        self.Operations['first.char'] = Operation_First_Char();
        self.Operations['>='] = Operation_Greater_Equal();
        self.Operations['ge'] = Operation_Greater_Equal();
        self.Operations['>'] = Operation_Greater_Than();
        self.Operations['gt'] = Operation_Greater_Than();
        self.Operations['greater'] = Operation_Greater_Than();
        self.Operations['i'] = Operation_I();
        self.Operations['self'] = Operation_I();
        self.Operations['int char'] = Operation_Int2char();
        self.Operations['intchar'] = Operation_Int2char();
        self.Operations['int2char'] = Operation_Int2char();
        self.Operations['num2char'] = Operation_Int2char();
        self.Operations['isa'] = Operation_Is_A();
        self.Operations['is.a'] = Operation_Is_A();
        self.Operations['isident'] = Operation_Is_Ident();
        self.Operations['is.ident'] = Operation_Is_Ident();
        self.Operations['islowercase'] = Operation_Is_Lowercase();
        self.Operations['is.lowercase'] = Operation_Is_Lowercase();
        self.Operations['islower'] = Operation_Is_Lowercase();
        self.Operations['isuppercase'] = Operation_Is_Uppercase();
        self.Operations['is.uppercase'] = Operation_Is_Uppercase();
        self.Operations['isupper'] = Operation_Is_Uppercase();
        self.Operations['isws'] = Operation_Is_Whitespace();
        self.Operations['is.ws'] = Operation_Is_Whitespace();
        self.Operations['iswhitespace'] = Operation_Is_Whitespace();
        self.Operations['is.whitespace'] = Operation_Is_Whitespace();
        self.Operations['whitespace'] = Operation_Is_Whitespace();
        self.Operations['isnull'] = Operation_Is_Null();
        self.Operations['is.null'] = Operation_Is_Null();
        self.Operations['lastchar'] = Operation_Last_Char();
        self.Operations['last.char'] = Operation_Last_Char();
        self.Operations['length'] = Operation_Length();
        self.Operations['len'] = Operation_Length();
        self.Operations['string.length'] = Operation_Length();
        self.Operations['<='] = Operation_Less_Equal();
        self.Operations['le'] = Operation_Less_Equal();
        self.Operations['<'] = Operation_Less_Than();
        self.Operations['lt'] = Operation_Less_Than();
        self.Operations['less'] = Operation_Less_Than();
        self.Operations['list.get'] = Operation_List_Get();
        self.Operations['list.length'] = Operation_List_Length();
        self.Operations['pop'] = Operation_List_Pop();
        self.Operations['list.pop'] = Operation_List_Pop();
        self.Operations['lpop'] = Operation_List_Pop();
        self.Operations['lowercase'] = Operation_Lowercase();
        self.Operations['lower'] = Operation_Lowercase();
        self.Operations['*'] = Operation_Multiply();
        self.Operations['multiply'] = Operation_Multiply();
        self.Operations['mult'] = Operation_Multiply();
        self.Operations['times'] = Operation_Multiply();
        self.Operations['new'] = Operation_New();
        self.Operations['not'] = Operation_Not();
        self.Operations['!'] = Operation_Not();
        self.Operations['ne'] = Operation_Not_Equal();
        self.Operations['!='] = Operation_Not_Equal();
        self.Operations['<>'] = Operation_Not_Equal();
        self.Operations['notnull'] = Operation_Not_Null();
        self.Operations['or'] = Operation_Or();
        self.Operations['|'] = Operation_Or();
        self.Operations['||'] = Operation_Or();
        self.Operations['title'] = Operation_Titlecase();
        self.Operations['titlecase'] = Operation_Titlecase();
        self.Operations['title.case'] = Operation_Titlecase();
        self.Operations['tokenmode'] = Operation_Token_Mode();
        self.Operations['token.mode'] = Operation_Token_Mode();
        self.Operations['shift'] = Operation_Shift();
        self.Operations['list.shift'] = Operation_Shift();
        self.Operations['string'] = Operation_String();
        self.Operations['subtract'] = Operation_Subtract();
        self.Operations['-'] = Operation_Subtract();
        self.Operations['minus'] = Operation_Subtract();
        self.Operations['substring'] = Operation_Substring();
        self.Operations['append'] = Operation_String_Append();
        self.Operations['s+'] = Operation_String_Append();
        self.Operations['s='] = Operation_String_Equal();
        self.Operations['seq'] = Operation_String_Equal();
        self.Operations['string.eq'] = Operation_String_Equal();
        self.Operations['s!='] = Operation_String_Not_Equal();
        self.Operations['sne'] = Operation_String_Not_Equal();
        self.Operations['string.gt'] = Operation_String_Greater();
        self.Operations['sgt'] = Operation_String_Greater();
        self.Operations['s.gt'] = Operation_String_Greater();
        self.Operations['s>'] = Operation_String_Greater();
        self.Operations['s<'] = Operation_String_Less();
        self.Operations['slt'] = Operation_String_Less();
        self.Operations['s.lt'] = Operation_String_Less();
        self.Operations['string.lt'] = Operation_String_Less();
        self.Operations['s.ge'] = Operation_String_Greater_Equal();
        self.Operations['sge'] = Operation_String_Greater_Equal();
        self.Operations['sle'] = Operation_String_Less_Equal();
        self.Operations['string.le'] = Operation_String_Less_Equal();
        self.Operations['s<='] = Operation_String_Less_Equal();
        self.Operations['uppercase'] = Operation_Uppercase();
        self.Operations['upper'] = Operation_Uppercase();
        self.Operations['we'] = Operation_We();
        self.Syntaxes['attribute'] = Syntax_Attribute();
        self.Syntaxes['att'] = Syntax_Attribute();
        self.Syntaxes['~'] = Syntax_Attribute();
        self.Syntaxes['class.attribute'] = Syntax_Class_Attribute();
        self.Syntaxes['class.att'] = Syntax_Class_Attribute();
        self.Syntaxes['classatt'] = Syntax_Class_Attribute();
        self.Syntaxes['class.name'] = Syntax_Class_Name();
        self.Syntaxes['classname'] = Syntax_Class_Name();
        self.Syntaxes[':'] = Syntax_Class_Property();
        self.Syntaxes['generator'] = Syntax_Generator();
        self.Syntaxes['indent'] = Syntax_Indent();
        self.Syntaxes['line'] = Syntax_Line();
        self.Syntaxes['list'] = Syntax_List();
        self.Syntaxes['optrep'] = Syntax_Optrep();
        self.Syntaxes['repeating'] = Syntax_Repeating();
        self.Syntaxes['entity'] = Syntax_Object();
        self.Syntaxes['object'] = Syntax_Object();
        self.Syntaxes['false'] = Syntax_False();
        self.Syntaxes['integer'] = Syntax_Integer();
        self.Syntaxes['is'] = Syntax_Is();
        self.Syntaxes['my'] = Syntax_My();
        self.Syntaxes['my.attribute'] = Syntax_My_Attribute();
        self.Syntaxes['my.att'] = Syntax_My_Attribute();
        self.Syntaxes['my.class'] = Syntax_My_Class();
        self.Syntaxes['my.class'] = Syntax_My_Class();
        self.Syntaxes['self.class'] = Syntax_My_Class();
        self.Syntaxes['null'] = Syntax_Null();
        self.Syntaxes['.'] = Syntax_Property();
        self.Syntaxes['property'] = Syntax_Property();
        self.Syntaxes['propchain'] = Syntax_Property();
        self.Syntaxes['self'] = Syntax_Self();
        self.Syntaxes['me'] = Syntax_Self();
        self.Syntaxes['string'] = Syntax_String();
        self.Syntaxes['true'] = Syntax_True();
        return True
class Gal_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Gal(self)])
        return True
    def Infer_Gal(self):
        Verbose = False
        Error_Fail = True
        Elem = None
        I = None
        Number = 0
        Error = None
        for Elem in self.Elements.Symbol_Value:
            if Error_Fail:
                I = Elem.Classification
                I.Infer_Gal()
                Elem.Gal = I.Gal
                Number += 1
            else:
                try:
                    I = Elem.Classification
                    I.Infer_Gal()
                    Elem.Gal = I.Gal
                    Number += 1
                except Exception as Error:
                    self.Status = False
                    Elem.Error = Error
                    # comment 'debug';
                    if Verbose:
                        print('Error gal element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        if not self.Status:
            return False
        Top = self.Elements.Symbol_Value[-1]
        # comment 'debug';
        Code = str(Top.Gal)
        self.Gal = Code
        self.Code = Code
        return True
        return True
class Inference_Gal (Inference):
    def Infer(self):
        if not self.Owner.Infer_Gal():
            return False
        return True
class Statement_Goalspell:
    def Infer_Gal(self):
        Gen = 'goal.spell' + str(self.Gal_Arguments()) + str(self.Gal_Block())
        self.Gal = Gen
        return True
    def Infer_Gs(self):
        Gen = 'goal spell' + str(self.Gs_Arguments()) + str(self.Gs_Block())
        self.Gs = Gen
        return True
# comment '**** Goalspell.gal ****';
class Goal_Gs (Goal):
    pass
class Spell_Gs (Spell):
    pass
class Dialect_Gs (Dialect):
    def Initialize(self):
        self.Statements['abstract'] = Statement_Abstract();
        self.Statements['abstract entity'] = Statement_Abstract();
        self.Statements['action'] = Statement_Action();
        self.Statements['add'] = Statement_Add();
        self.Statements['+='] = Statement_Add();
        self.Statements['alert'] = Statement_Alert();
        self.Statements['alpha'] = Statement_Alpha();
        self.Statements['amount'] = Statement_Amount();
        self.Statements['analysis'] = Statement_Analysis();
        self.Statements['analyze'] = Statement_Analyze();
        self.Statements['and'] = Statement_And();
        self.Statements['&'] = Statement_And();
        self.Statements['and='] = Statement_And();
        self.Statements['and ='] = Statement_And();
        self.Statements['&='] = Statement_And();
        self.Statements['append'] = Statement_Append();
        self.Statements['string.append'] = Statement_Append();
        self.Statements['s+'] = Statement_Append();
        self.Statements['s +'] = Statement_Append();
        self.Statements['+'] = Statement_Append();
        self.Statements['append token'] = Statement_Append_Token();
        self.Statements['append.token'] = Statement_Append_Token();
        self.Statements['argument'] = Statement_Argument();
        self.Statements['array'] = Statement_Array();
        self.Statements['array number'] = Statement_Array_Number();
        self.Statements['array of'] = Statement_Array_Of();
        self.Statements['article'] = Statement_Article();
        self.Statements['article reference'] = Statement_Article_Reference();
        self.Statements['article plan'] = Statement_Article_Plan();
        self.Statements['assign'] = Statement_Assign();
        self.Statements['='] = Statement_Assign();
        self.Statements['async.method'] = Statement_Async_Method();
        self.Statements['async method'] = Statement_Async_Method();
        self.Statements['asynchronous method'] = Statement_Async_Method();
        self.Statements['atomic'] = Statement_Atomic();
        self.Statements['attribute'] = Statement_Attribute();
        self.Statements['author'] = Statement_Author();
        self.Statements['behavior'] = Statement_Behavior();
        self.Statements['bias'] = Statement_Bias();
        self.Statements['bind'] = Statement_Bind();
        self.Statements['bind ='] = Statement_Bind();
        self.Statements['bless'] = Statement_Bless();
        self.Statements['break'] = Statement_Break();
        self.Statements['breakif'] = Statement_Break_If();
        self.Statements['break if'] = Statement_Break_If();
        self.Statements['break.if'] = Statement_Break_If();
        self.Statements['build'] = Statement_Build();
        self.Statements['c'] = Statement_C();
        self.Statements['calcium'] = Statement_Calcium();
        self.Statements['.'] = Statement_Call();
        self.Statements['call'] = Statement_Call();
        self.Statements['calories'] = Statement_Calories();
        self.Statements['cal'] = Statement_Calories();
        self.Statements['carb'] = Statement_Carbohydrate();
        self.Statements['carbs'] = Statement_Carbohydrate();
        self.Statements['carbohydrate'] = Statement_Carbohydrate();
        self.Statements['carbohydrates'] = Statement_Carbohydrate();
        self.Statements['catch'] = Statement_Catch();
        self.Statements['cd'] = Statement_Cd();
        self.Statements['chapter'] = Statement_Chapter();
        self.Statements['cholesterol'] = Statement_Cholesterol();
        self.Statements['class'] = Statement_Class();
        self.Statements['class.is'] = Statement_Class_Is();
        self.Statements['class is'] = Statement_Class_Is();
        self.Statements['class extends'] = Statement_Class_Is();
        self.Statements['class is a'] = Statement_Class_Is();
        self.Statements['class is an'] = Statement_Class_Is();
        self.Statements['class.append'] = Statement_Class_Append();
        self.Statements['class append'] = Statement_Class_Append();
        self.Statements['class . append'] = Statement_Class_Append();
        self.Statements['class.set'] = Statement_Class_Set();
        self.Statements['class set'] = Statement_Class_Set();
        self.Statements['class . set'] = Statement_Class_Set();
        self.Statements['class.attribute'] = Statement_Class_Attribute();
        self.Statements['class attribute'] = Statement_Class_Attribute();
        self.Statements['class module'] = Statement_Class_Module();
        self.Statements['classmodule'] = Statement_Class_Module();
        self.Statements['module class'] = Statement_Class_Module();
        self.Statements['moduleclass'] = Statement_Class_Module();
        self.Statements['disabled clas sify'] = Statement_Classify();
        self.Statements['class.method'] = Statement_Class_Method();
        self.Statements['class method'] = Statement_Class_Method();
        self.Statements['class.property'] = Statement_Class_Property();
        self.Statements['class property'] = Statement_Class_Property();
        self.Statements['click'] = Statement_Click();
        self.Statements['close'] = Statement_Close();
        self.Statements['codebox'] = Statement_Codebox();
        self.Statements['code box'] = Statement_Codebox();
        self.Statements['collates'] = Statement_Collates();
        self.Statements['collate'] = Statement_Collates();
        self.Statements[':'] = Statement_Colon();
        self.Statements['comment'] = Statement_Comment();
        self.Statements['#'] = Statement_Comment();
        self.Statements['/.'] = Statement_Comment();
        self.Statements['/ /'] = Statement_Comment();
        self.Statements['compile'] = Statement_Compile();
        self.Statements['compile'] = Statement_Compile();
        self.Statements['copy from'] = Statement_Copy_From();
        self.Statements['copy < -'] = Statement_Copy_From();
        self.Statements['copy to'] = Statement_Copy_To();
        self.Statements['copy - >'] = Statement_Copy_To();
        self.Statements['copy ='] = Statement_Copy_To();
        self.Statements['confirm exit if'] = Statement_Confirm_Exit_If();
        self.Statements['constant'] = Statement_Constant();
        self.Statements['constructor'] = Statement_Constructor();
        self.Statements['contest'] = Statement_Contest();
        self.Statements['continue'] = Statement_Continue();
        self.Statements['contif'] = Statement_Continue_If();
        self.Statements['continue if'] = Statement_Continue_If();
        self.Statements['continue.if'] = Statement_Continue_If();
        self.Statements['create'] = Statement_Create();
        self.Statements['crown'] = Statement_Crown();
        self.Statements['currency'] = Statement_Currency();
        self.Statements['cycle'] = Statement_Cycle();
        self.Statements['date'] = Statement_Date();
        self.Statements['debug'] = Statement_Debug();
        self.Statements['debugger'] = Statement_Debug();
        self.Statements['debugif'] = Statement_Debug_If();
        self.Statements['debug if'] = Statement_Debug_If();
        self.Statements['decrement'] = Statement_Decrement();
        self.Statements['--'] = Statement_Decrement();
        self.Statements['default'] = Statement_Default();
        self.Statements['defined'] = Statement_Defined();
        self.Statements['diagram'] = Statement_Diagram();
        self.Statements['dial'] = Statement_Dial();
        self.Statements['dialect'] = Statement_Dialect();
        self.Statements['dicts'] = Statement_Dictionaries();
        self.Statements['dictionaries'] = Statement_Dictionaries();
        self.Statements['hashes'] = Statement_Dictionaries();
        self.Statements['dict.assign'] = Statement_Dictionary_Assign();
        self.Statements['dict assign'] = Statement_Dictionary_Assign();
        self.Statements['dictionary assign'] = Statement_Dictionary_Assign();
        self.Statements['dict assign'] = Statement_Dictionary_Assign();
        self.Statements['dict ='] = Statement_Dictionary_Assign();
        self.Statements['dictionary ='] = Statement_Dictionary_Assign();
        self.Statements['dict insert'] = Statement_Dictionary_Assign();
        self.Statements['dictionary insert'] = Statement_Dictionary_Assign();
        self.Statements['d ='] = Statement_Dictionary_Assign();
        self.Statements['d='] = Statement_Dictionary_Assign();
        self.Statements['dict'] = Statement_Dictionary();
        self.Statements['dictionary'] = Statement_Dictionary();
        self.Statements['hash'] = Statement_Dictionary();
        self.Statements['dispatcher'] = Statement_Dispatcher();
        self.Statements['dispatchers'] = Statement_Dispatchers();
        self.Statements['distribute'] = Statement_Distribute();
        self.Statements['divide'] = Statement_Divide();
        self.Statements['/='] = Statement_Divide();
        self.Statements['do'] = Statement_Do();
        self.Statements['do @'] = Statement_Do();
        self.Statements['document_reference'] = Statement_Document_Reference();
        self.Statements['document reference'] = Statement_Document_Reference();
        self.Statements['html object'] = Statement_Dom_Object();
        self.Statements['dom object'] = Statement_Dom_Object();
        self.Statements['egg'] = Statement_Egg();
        self.Statements['either'] = Statement_Either();
        self.Statements['element'] = Statement_Element();
        self.Statements['else'] = Statement_Else();
        self.Statements['else.if'] = Statement_Else_If();
        self.Statements['else if'] = Statement_Else_If();
        self.Statements['english'] = Statement_English();
        self.Statements['entities'] = Statement_Entities();
        self.Statements['entity'] = Statement_Entity();
        self.Statements['entity new'] = Statement_Entity_New();
        self.Statements['error'] = Statement_Error();
        self.Statements['throw'] = Statement_Error();
        self.Statements['raise'] = Statement_Error();
        self.Statements['whoops'] = Statement_Error();
        self.Statements['oops'] = Statement_Error();
        self.Statements['example'] = Statement_Example();
        self.Statements['execute'] = Statement_Execute();
        self.Statements['exit'] = Statement_Exit();
        self.Statements['expect ='] = Statement_Expect_Equal();
        self.Statements['expect'] = Statement_Expect_Equal();
        self.Statements['expect.string'] = Statement_Expect_String();
        self.Statements['expect string'] = Statement_Expect_String();
        self.Statements['expected output'] = Statement_Expected_Output();
        self.Statements['experience'] = Statement_Experience();
        self.Statements['export memory'] = Statement_Export_Memory();
        self.Statements['fallback'] = Statement_Fallback();
        self.Statements['fb'] = Statement_Fallback();
        self.Statements['fallback ='] = Statement_Fallback_Equal();
        self.Statements['fb ='] = Statement_Fallback_Equal();
        self.Statements['fat'] = Statement_Fat();
        self.Statements['feature'] = Statement_Feature();
        self.Statements['fiber'] = Statement_Fiber();
        self.Statements['file append'] = Statement_File_Append();
        self.Statements['file delete'] = Statement_File_Delete();
        self.Statements['file.dump'] = Statement_File_Dump();
        self.Statements['file dump'] = Statement_File_Dump();
        self.Statements['fwrite'] = Statement_File_Dump();
        self.Statements['file write'] = Statement_File_Dump();
        self.Statements['write file'] = Statement_File_Dump();
        self.Statements['dump file'] = Statement_File_Dump();
        self.Statements['dump to file'] = Statement_File_Dump();
        self.Statements['write to file'] = Statement_File_Dump();
        self.Statements['save as'] = Statement_File_Dump();
        self.Statements['save as file'] = Statement_File_Dump();
        self.Statements['file.readall'] = Statement_File_Readall();
        self.Statements['file readall'] = Statement_File_Readall();
        self.Statements['file read all'] = Statement_File_Readall();
        self.Statements['file text'] = Statement_File_Readall();
        self.Statements['readall'] = Statement_File_Readall();
        self.Statements['fread'] = Statement_File_Readall();
        self.Statements['file.readline'] = Statement_File_Read_Line();
        self.Statements['file readline'] = Statement_File_Read_Line();
        self.Statements['file read line'] = Statement_File_Read_Line();
        self.Statements['file.readlist'] = Statement_File_Read_List();
        self.Statements['file readlist'] = Statement_File_Read_List();
        self.Statements['file read list'] = Statement_File_Read_List();
        self.Statements['flag'] = Statement_Flag();
        self.Statements['boolean'] = Statement_Flag();
        self.Statements['bool'] = Statement_Flag();
        self.Statements['flags'] = Statement_Flags();
        self.Statements['booleans'] = Statement_Flags();
        self.Statements['bools'] = Statement_Flags();
        self.Statements['flowerbox'] = Statement_Flowerbox();
        self.Statements['flower box'] = Statement_Flowerbox();
        self.Statements['food'] = Statement_Food();
        self.Statements['foreach'] = Statement_Foreach();
        self.Statements['for each'] = Statement_Foreach();
        self.Statements['foreachkey'] = Statement_For_Each_Key();
        self.Statements['for each key'] = Statement_For_Each_Key();
        self.Statements['forprevkey'] = Statement_For_Prev_Key();
        self.Statements['for prev key'] = Statement_For_Prev_Key();
        self.Statements['for each human being'] = Statement_For_Each_Human_Being();
        self.Statements['for each human outcome'] = Statement_For_Each_Human_Outcome();
        self.Statements['for each in'] = Statement_For_Each_In();
        self.Statements['for.each.in'] = Statement_For_Each_In();
        self.Statements['for each outcome support'] = Statement_For_Each_Outcome_Support();
        self.Statements['for each supporter'] = Statement_For_Each_Supporter();
        self.Statements['forever'] = Statement_Forever();
        self.Statements['forgive'] = Statement_Forgive();
        self.Statements['for.down'] = Statement_For_Down();
        self.Statements['for down'] = Statement_For_Down();
        self.Statements['for down to'] = Statement_For_Down();
        self.Statements['for.range'] = Statement_For_Range();
        self.Statements['for range'] = Statement_For_Range();
        self.Statements['function'] = Statement_Function();
        self.Statements['function pointer'] = Statement_Function_Pointer();
        self.Statements['fptr'] = Statement_Function_Pointer();
        self.Statements['invoke'] = Statement_Function_Invoke();
        self.Statements['gal'] = Statement_Gal();
        self.Statements['gal ='] = Statement_Gal_Equal();
        self.Statements['generate'] = Statement_Generate();
        self.Statements['generate gal'] = Statement_Generate_Gal();
        self.Statements['generator'] = Statement_Generator();
        self.Statements['given an in'] = Statement_Given_An_In();
        self.Statements['given a in'] = Statement_Given_An_In();
        self.Statements['global'] = Statement_Global();
        self.Statements['global list'] = Statement_Global_List();
        self.Statements['glist'] = Statement_Global_List();
        self.Statements['lock ^'] = Statement_Global_Lock();
        self.Statements['unlock ^'] = Statement_Global_Unlock();
        self.Statements['glvn'] = Statement_Glvn();
        self.Statements['key'] = Statement_Glvn();
        self.Statements['glvn ^'] = Statement_Glvn_Global();
        self.Statements['key '] = Statement_Glvn_Global();
        self.Statements['goal'] = Statement_Goal();
        self.Statements['goal.spell'] = Statement_Goal_Spell();
        self.Statements['goal spell'] = Statement_Goal_Spell();
        self.Statements['gpu function'] = Statement_Gpu_Function();
        self.Statements['gf'] = Statement_Gpu_Function();
        self.Statements['gpu invoke'] = Statement_Gpu_Invoke();
        self.Statements['gi'] = Statement_Gpu_Invoke();
        self.Statements['gpu invoke method'] = Statement_Gpu_Invoke_Method();
        self.Statements['gim'] = Statement_Gpu_Invoke_Method();
        self.Statements['gpu method'] = Statement_Gpu_Method();
        self.Statements['gm'] = Statement_Gpu_Method();
        self.Statements['gpu property'] = Statement_Gpu_Property();
        self.Statements['gp'] = Statement_Gpu_Property();
        self.Statements['g'] = Statement_Grams();
        self.Statements['gram'] = Statement_Grams();
        self.Statements['grams'] = Statement_Grams();
        self.Statements['operation'] = Statement_Gs_Operation();
        self.Statements['statement'] = Statement_Gs_Statement();
        self.Statements['syntax'] = Statement_Gs_Syntax();
        self.Statements['gs'] = Statement_Gs();
        self.Statements['goalspell'] = Statement_Gs();
        self.Statements['gs ='] = Statement_Gs_Equal();
        self.Statements['goalspell ='] = Statement_Gs_Equal();
        self.Statements['gs='] = Statement_Gs_Equal();
        self.Statements['goalspell='] = Statement_Gs_Equal();
        self.Statements['hope'] = Statement_Hope();
        self.Statements['human being'] = Statement_Human_Being();
        self.Statements['html'] = Statement_Html();
        self.Statements['i='] = Statement_I_Equal();
        self.Statements['i ='] = Statement_I_Equal();
        self.Statements['i equal'] = Statement_I_Equal();
        self.Statements['if'] = Statement_If();
        self.Statements['ifdef'] = Statement_Ifdef();
        self.Statements['ifdefined'] = Statement_Ifdef();
        self.Statements['if def'] = Statement_Ifdef();
        self.Statements['if defined'] = Statement_Ifdef();
        self.Statements['i'] = Statement_I();
        self.Statements['i generate'] = Statement_I_Generate();
        self.Statements['improve'] = Statement_Improve();
        self.Statements['imagine operation'] = Statement_Imagine_Operation();
        self.Statements['imagine statement'] = Statement_Imagine_Statement();
        self.Statements['implement'] = Statement_Implement();
        self.Statements['implementer'] = Statement_Implementer();
        self.Statements['implementor'] = Statement_Implementer();
        self.Statements['implementers'] = Statement_Implementers();
        self.Statements['implementors'] = Statement_Implementers();
        self.Statements['implements .'] = Statement_Implements_Instance();
        self.Statements['implements :'] = Statement_Implements_Class();
        self.Statements['import'] = Statement_Import();
        self.Statements['in'] = Statement_In();
        self.Statements['in goalspell'] = Statement_In_Goalspell();
        self.Statements['include'] = Statement_Include();
        self.Statements['include implementers'] = Statement_Include_Implementers();
        self.Statements['increment'] = Statement_Increment();
        self.Statements['++'] = Statement_Increment();
        self.Statements['infer'] = Statement_Infer();
        self.Statements['inference'] = Statement_Inference();
        self.Statements['inferences'] = Statement_Inferences();
        self.Statements['infer.inits'] = Statement_Infer_Inits();
        self.Statements['infer inits'] = Statement_Infer_Inits();
        self.Statements['infers'] = Statement_Infers();
        self.Statements['ingredients'] = Statement_Ingredients();
        self.Statements['initialize'] = Statement_Initialize();
        self.Statements['interface'] = Statement_Interface();
        self.Statements['iterate'] = Statement_Iterate();
        self.Statements['integer'] = Statement_Integer();
        self.Statements['int'] = Statement_Integer();
        self.Statements['integers'] = Statement_Integers();
        self.Statements['ints'] = Statement_Integers();
        self.Statements['iron'] = Statement_Iron();
        self.Statements['isa'] = Statement_Is_A();
        self.Statements['is a'] = Statement_Is_A();
        self.Statements['is.a'] = Statement_Is_A();
        self.Statements['classify'] = Statement_Is_A();
        self.Statements['it='] = Statement_It_Equals();
        self.Statements['it ='] = Statement_It_Equals();
        self.Statements['it equals'] = Statement_It_Equals();
        self.Statements['javascript'] = Statement_Javascript();
        self.Statements['js'] = Statement_Javascript();
        self.Statements['javascript ='] = Statement_Javascript_Equal();
        self.Statements['js ='] = Statement_Javascript_Equal();
        self.Statements['job'] = Statement_Job();
        self.Statements['join'] = Statement_Join();
        self.Statements['list.join'] = Statement_Join();
        self.Statements['list join'] = Statement_Join();
        self.Statements['keyword'] = Statement_Keyword();
        self.Statements['kill'] = Statement_Kill();
        self.Statements['kill ^'] = Statement_Kill_Global();
        self.Statements['know'] = Statement_Know();
        self.Statements['language'] = Statement_Language();
        self.Statements['language behavior'] = Statement_Language_Behavior();
        self.Statements['language machine architecture'] = Statement_Language_Machine_Architecture();
        self.Statements['lexical'] = Statement_Lexical();
        self.Statements['list.append'] = Statement_List_Append();
        self.Statements['list append'] = Statement_List_Append();
        self.Statements['list+'] = Statement_List_Append();
        self.Statements['list +'] = Statement_List_Append();
        self.Statements['push'] = Statement_List_Append();
        self.Statements['list push'] = Statement_List_Append();
        self.Statements['lpush'] = Statement_List_Append();
        self.Statements['list assign'] = Statement_List_Assign();
        self.Statements['list ='] = Statement_List_Assign();
        self.Statements['l='] = Statement_List_Assign();
        self.Statements['l ='] = Statement_List_Assign();
        self.Statements['lassign'] = Statement_List_Assign();
        self.Statements['list clear'] = Statement_List_Clear();
        self.Statements['lclear'] = Statement_List_Clear();
        self.Statements['list . clear'] = Statement_List_Clear();
        self.Statements['list.copy'] = Statement_List_Copy();
        self.Statements['list copy'] = Statement_List_Copy();
        self.Statements['lcopy'] = Statement_List_Copy();
        self.Statements['list insert'] = Statement_List_Insert();
        self.Statements['insert'] = Statement_List_Insert();
        self.Statements['linsert'] = Statement_List_Insert();
        self.Statements['list item'] = Statement_List_Item();
        self.Statements['li'] = Statement_List_Item();
        self.Statements['list split'] = Statement_List_Split();
        self.Statements['lsplit'] = Statement_List_Split();
        self.Statements['split'] = Statement_List_Split();
        self.Statements['list'] = Statement_List();
        self.Statements['list property insert'] = Statement_List_Property_Insert();
        self.Statements['lists'] = Statement_Lists();
        self.Statements['lock'] = Statement_Lock();
        self.Statements['main'] = Statement_Main();
        self.Statements['maximize'] = Statement_Maximize();
        self.Statements['meal'] = Statement_Meal();
        self.Statements['member'] = Statement_Member();
        self.Statements['menu_bar'] = Statement_Menu_Bar();
        self.Statements['menu bar'] = Statement_Menu_Bar();
        self.Statements['menu_dropdown'] = Statement_Menu_Dropdown();
        self.Statements['menu dropdown'] = Statement_Menu_Dropdown();
        self.Statements['menu_item'] = Statement_Menu_Item();
        self.Statements['menu item'] = Statement_Menu_Item();
        self.Statements['merge from'] = Statement_Merge_From();
        self.Statements['merge < -'] = Statement_Merge_From();
        self.Statements['merge to'] = Statement_Merge_To();
        self.Statements['merge - >'] = Statement_Merge_To();
        self.Statements['merge ='] = Statement_Merge_To();
        self.Statements['method'] = Statement_Method();
        self.Statements['migrate'] = Statement_Migrate();
        self.Statements['minimize'] = Statement_Minimize();
        self.Statements['module'] = Statement_Module();
        self.Statements['multiply'] = Statement_Multiply();
        self.Statements['*='] = Statement_Multiply();
        self.Statements['mumps'] = Statement_Mumps();
        self.Statements['my~='] = Statement_My_Attribute_Equal();
        self.Statements['my ~ ='] = Statement_My_Attribute_Equal();
        self.Statements['my attribute ='] = Statement_My_Attribute_Equal();
        self.Statements['my='] = Statement_My_Equal();
        self.Statements['my ='] = Statement_My_Equal();
        self.Statements['new token'] = Statement_New_Token();
        self.Statements['newtoken'] = Statement_New_Token();
        self.Statements['new.token'] = Statement_New_Token();
        self.Statements['no'] = Statement_No();
        self.Statements['not'] = Statement_Not();
        self.Statements['!'] = Statement_Not();
        self.Statements['note'] = Statement_Note();
        self.Statements['nsl module'] = Statement_Nsl_Module();
        self.Statements['numbered list'] = Statement_Numbered_List();
        self.Statements['numbered.list'] = Statement_Numbered_List();
        self.Statements['numlist'] = Statement_Numbered_List();
        self.Statements['ol'] = Statement_Numbered_List();
        self.Statements['number'] = Statement_Number();
        self.Statements['certainty'] = Statement_Number();
        self.Statements['percent'] = Statement_Number();
        self.Statements['numbers'] = Statement_Numbers();
        self.Statements['certainties'] = Statement_Numbers();
        self.Statements['percents'] = Statement_Numbers();
        self.Statements['nutrition'] = Statement_Nutrition();
        self.Statements['obj'] = Statement_Obj();
        self.Statements['object'] = Statement_Object();
        self.Statements['object new'] = Statement_Object_New();
        self.Statements['objects'] = Statement_Objects();
        self.Statements['ohlc'] = Statement_Ohlc();
        self.Statements['open'] = Statement_Open();
        self.Statements['operations'] = Statement_Operations();
        self.Statements['optimize'] = Statement_Optimize();
        self.Statements['optimize='] = Statement_Optimize_Equal();
        self.Statements['optimize ='] = Statement_Optimize_Equal();
        self.Statements['optional'] = Statement_Optional();
        self.Statements['outcome'] = Statement_Outcome();
        self.Statements['pane'] = Statement_Pane();
        self.Statements['paragraph'] = Statement_Paragraph();
        self.Statements['para'] = Statement_Paragraph();
        self.Statements['p'] = Statement_Paragraph();
        self.Statements['parser'] = Statement_Parser();
        self.Statements['pay gratitude'] = Statement_Pay_Gratitude();
        self.Statements['pay'] = Statement_Pay_Gratitude();
        self.Statements['person'] = Statement_Person();
        self.Statements['human'] = Statement_Person();
        self.Statements['plist'] = Statement_Plist();
        self.Statements['prop list'] = Statement_Plist();
        self.Statements['p list'] = Statement_Plist();
        self.Statements['pobj'] = Statement_Pobj();
        self.Statements['prop object'] = Statement_Pobj();
        self.Statements['p obj'] = Statement_Pobj();
        self.Statements['portion'] = Statement_Portion();
        self.Statements['portion size'] = Statement_Portion();
        self.Statements['potassium'] = Statement_Potassium();
        self.Statements['process'] = Statement_Process();
        self.Statements['prompt'] = Statement_Prompt();
        self.Statements['prompt context'] = Statement_Prompt_Context();
        self.Statements['prompt.context'] = Statement_Prompt_Context();
        self.Statements['prop obj'] = Statement_Prop_Obj();
        self.Statements['property'] = Statement_Property();
        self.Statements['.='] = Statement_Propset();
        self.Statements['propset'] = Statement_Propset();
        self.Statements['. ='] = Statement_Propset();
        self.Statements['protein'] = Statement_Protein();
        self.Statements['prot'] = Statement_Protein();
        self.Statements['python'] = Statement_Python();
        self.Statements['py'] = Statement_Python();
        self.Statements['python ='] = Statement_Python_Equal();
        self.Statements['py ='] = Statement_Python_Equal();
        self.Statements['queue'] = Statement_Queue();
        self.Statements['quest'] = Statement_Quest();
        self.Statements['quit:'] = Statement_Quit_Colon();
        self.Statements['quit :'] = Statement_Quit_Colon();
        self.Statements['returnif'] = Statement_Quit_Colon();
        self.Statements['raku'] = Statement_Raku();
        self.Statements['raku ='] = Statement_Raku_Equal();
        self.Statements['read.char'] = Statement_Read_Character();
        self.Statements['read char'] = Statement_Read_Character();
        self.Statements['read character'] = Statement_Read_Character();
        self.Statements['reaadline'] = Statement_Reaadline();
        self.Statements['reaad line'] = Statement_Reaadline();
        self.Statements['readline'] = Statement_Readline();
        self.Statements['read line'] = Statement_Readline();
        self.Statements['recipe'] = Statement_Recipe();
        self.Statements['redirect'] = Statement_Redirect();
        self.Statements['redirect to'] = Statement_Redirect_To();
        self.Statements['remember'] = Statement_Remember();
        self.Statements['rename'] = Statement_Rename();
        self.Statements['move'] = Statement_Rename();
        self.Statements['replace'] = Statement_Replace();
        self.Statements['report outcome'] = Statement_Report_Outcome();
        self.Statements['require.that.i'] = Statement_Require_That_I();
        self.Statements['require that i'] = Statement_Require_That_I();
        self.Statements['require.that'] = Statement_Require_That();
        self.Statements['require that'] = Statement_Require_That();
        self.Statements['retain'] = Statement_Retain();
        self.Statements['return if'] = Statement_Return_If_Gs();
        self.Statements['return'] = Statement_Return();
        self.Statements['reverse iterate'] = Statement_Reverse_Iterate();
        self.Statements['iterate reverse'] = Statement_Reverse_Iterate();
        self.Statements['roster'] = Statement_Roster();
        self.Statements['roster floor'] = Statement_Roster_Floor();
        self.Statements['run queue'] = Statement_Run_Queue();
        self.Statements['saay'] = Statement_Saay();
        self.Statements['wriiteline'] = Statement_Saay();
        self.Statements['sat'] = Statement_Saturated_Fat();
        self.Statements['sat fat'] = Statement_Saturated_Fat();
        self.Statements['saturated'] = Statement_Saturated_Fat();
        self.Statements['saturated fat'] = Statement_Saturated_Fat();
        self.Statements['section'] = Statement_Section();
        self.Statements['send file'] = Statement_Send_File();
        self.Statements['sequence'] = Statement_Sequence();
        self.Statements['shell'] = Statement_Shell();
        self.Statements['site'] = Statement_Site();
        self.Statements['skiptoken'] = Statement_Skip_Token();
        self.Statements['skip token'] = Statement_Skip_Token();
        self.Statements['skip.token'] = Statement_Skip_Token();
        self.Statements['sodium'] = Statement_Sodium();
        self.Statements['source'] = Statement_Source();
        self.Statements['source site'] = Statement_Source();
        self.Statements['speaking'] = Statement_Speaking();
        self.Statements['spell'] = Statement_Spell();
        self.Statements['statements'] = Statement_Statements();
        self.Statements['steps'] = Statement_Steps();
        self.Statements['strings'] = Statement_Strings();
        self.Statements['string'] = Statement_String();
        self.Statements['subtitle'] = Statement_Subtitle();
        self.Statements['subtract'] = Statement_Subtract();
        self.Statements['-='] = Statement_Subtract();
        self.Statements['sugar'] = Statement_Sugar();
        self.Statements['supporter'] = Statement_Supporter();
        self.Statements['symbol'] = Statement_Symbol();
        self.Statements['syntaxes'] = Statement_Syntaxes();
        self.Statements['synthesis'] = Statement_Synthesis();
        self.Statements['synthesize'] = Statement_Synthesize();
        self.Statements['target includes'] = Statement_Target_Includes();
        self.Statements['terminology'] = Statement_Terminology();
        self.Statements['term'] = Statement_Term();
        self.Statements['test'] = Statement_Test();
        self.Statements['test case'] = Statement_Test_Case();
        self.Statements['testcase'] = Statement_Test_Case();
        self.Statements['tests'] = Statement_Tests();
        self.Statements['tests append'] = Statement_Tests_Append();
        self.Statements['thing'] = Statement_Thing();
        self.Statements['tilde'] = Statement_Tilda();
        self.Statements['tilda'] = Statement_Tilda();
        self.Statements['~'] = Statement_Tilda();
        self.Statements['title'] = Statement_Title();
        self.Statements['to analyze'] = Statement_To_Analyze();
        self.Statements['todo'] = Statement_Todo();
        self.Statements['token.append'] = Statement_Token_Append();
        self.Statements['token append'] = Statement_Token_Append();
        self.Statements['tokenappend'] = Statement_Token_Append();
        self.Statements['token.handler'] = Statement_Token_Handler();
        self.Statements['token handler'] = Statement_Token_Handler();
        self.Statements['token.initial'] = Statement_Token_Initial();
        self.Statements['token initial'] = Statement_Token_Initial();
        self.Statements['tokenization'] = Statement_Tokenization();
        self.Statements['token.mode'] = Statement_Token_Mode();
        self.Statements['token mode'] = Statement_Token_Mode();
        self.Statements['tokenmode'] = Statement_Token_Mode();
        self.Statements['token.new'] = Statement_Token_New();
        self.Statements['token new'] = Statement_Token_New();
        self.Statements['token test'] = Statement_Token_Test();
        self.Statements['tokens'] = Statement_Tokens();
        self.Statements['token'] = Statement_Token();
        self.Statements['translation tests'] = Statement_Translation_Tests();
        self.Statements['trans test'] = Statement_Translation_Tests();
        self.Statements['try'] = Statement_Try();
        self.Statements['try at of'] = Statement_Try_At_Of();
        self.Statements['undef'] = Statement_Undefined();
        self.Statements['undefined'] = Statement_Undefined();
        self.Statements['unless'] = Statement_Unless();
        self.Statements['unlock'] = Statement_Unlock();
        self.Statements['values'] = Statement_Values();
        self.Statements['flag begins'] = Statement_Variable_Begins();
        self.Statements['flag contains'] = Statement_Variable_Contains();
        self.Statements['flag .'] = Statement_Variable_Dot();
        self.Statements['integer .'] = Statement_Variable_Dot();
        self.Statements['percent .'] = Statement_Variable_Dot();
        self.Statements['number .'] = Statement_Variable_Dot();
        self.Statements['list .'] = Statement_Variable_Dot();
        self.Statements['dict .'] = Statement_Variable_Dot();
        self.Statements['dictionary .'] = Statement_Variable_Dot();
        self.Statements['object .'] = Statement_Variable_Dot();
        self.Statements['string .'] = Statement_Variable_Dot();
        self.Statements['flag isnull'] = Statement_Variable_Is_Null();
        self.Statements['flag isnumber'] = Statement_Variable_Is_Number();
        self.Statements['flag ispunct'] = Statement_Variable_Is_Punct();
        self.Statements['flag isstring'] = Statement_Variable_Is_String();
        self.Statements['flag isupper'] = Statement_Variable_Is_Uppercase();
        self.Statements['flag iswhitespace'] = Statement_Variable_Is_Whitespace();
        self.Statements['flag is whitespace'] = Statement_Variable_Is_Whitespace();
        self.Statements['flag notnull'] = Statement_Variable_Not_Null();
        self.Statements['flag s='] = Statement_Variable_String_Equal();
        self.Statements['flag sgt'] = Statement_Variable_String_Greater();
        self.Statements['flag sne'] = Statement_Variable_String_Not_Equal();
        self.Statements['integer char2int'] = Statement_Variable_Char2int();
        self.Statements['integer length'] = Statement_Variable_String_Length();
        self.Statements['flag =='] = Statement_Variable_Equal();
        self.Statements['flag gt'] = Statement_Variable_Greater();
        self.Statements['flag lt'] = Statement_Variable_Less();
        self.Statements['list split'] = Statement_Variable_List_Split();
        self.Statements['variant list get'] = Statement_Variable_List_Get();
        self.Statements['variant list last'] = Statement_Variable_List_Last();
        self.Statements['integer list length'] = Statement_Variable_List_Length();
        self.Statements['flag isa'] = Statement_Variable_Isa();
        self.Statements['string int2char'] = Statement_Variable_Int2char();
        self.Statements['string num2char'] = Statement_Variable_Int2char();
        self.Statements['variations'] = Statement_Variations();
        self.Statements['vars'] = Statement_Variants();
        self.Statements['variants'] = Statement_Variants();
        self.Statements['var'] = Statement_Variant();
        self.Statements['variant'] = Statement_Variant();
        self.Statements['verbose'] = Statement_Verbose();
        self.Statements['verbosity'] = Statement_Verbosity();
        self.Statements['vernacular'] = Statement_Vernacular();
        self.Statements['vitamin'] = Statement_Vitamin();
        self.Statements['vit'] = Statement_Vitamin();
        self.Statements['we'] = Statement_We();
        self.Statements['web app'] = Statement_Web_App();
        self.Statements['webapp'] = Statement_Web_App();
        self.Statements['web application'] = Statement_Web_App();
        self.Statements['while'] = Statement_While();
        self.Statements['wriite'] = Statement_Wriite();
        self.Statements['say'] = Statement_Write_Line();
        self.Statements['writeline'] = Statement_Write_Line();
        self.Statements['write line'] = Statement_Write_Line();
        self.Statements['write.line'] = Statement_Write_Line();
        self.Statements['write'] = Statement_Write();
        self.Statements['yes'] = Statement_Yes();
        self.Statements['title'] = Statement_Title();
        self.Statements['created'] = Statement_Created();
        self.Statements['completed'] = Statement_Completed();
        self.Statements['expires'] = Statement_Expires();
        self.Statements['comments'] = Statement_Comments();
        self.Statements['assignee'] = Statement_Assignee();
        self.Statements['status'] = Statement_Status();
        self.Statements['task'] = Statement_Task();
        self.Statements['task list'] = Statement_Task_List();
        self.Operations['absolute'] = Operation_Absolute();
        self.Operations['abs'] = Operation_Absolute();
        self.Operations['add'] = Operation_Add();
        self.Operations['+'] = Operation_Add();
        self.Operations['plus'] = Operation_Add();
        self.Operations['and'] = Operation_And();
        self.Operations['&'] = Operation_And();
        self.Operations['&&'] = Operation_And();
        self.Operations['startswith'] = Operation_Begins();
        self.Operations['starts.with'] = Operation_Begins();
        self.Operations['starts'] = Operation_Begins();
        self.Operations['begins'] = Operation_Begins();
        self.Operations['beginswith'] = Operation_Begins();
        self.Operations['begins.with'] = Operation_Begins();
        self.Operations['call'] = Operation_Call();
        self.Operations['.'] = Operation_Call();
        self.Operations['can'] = Operation_Can();
        self.Operations['chartoint'] = Operation_Char2int();
        self.Operations['char to int'] = Operation_Char2int();
        self.Operations['charint'] = Operation_Char2int();
        self.Operations['char int'] = Operation_Char2int();
        self.Operations['char2int'] = Operation_Char2int();
        self.Operations['char2num'] = Operation_Char2int();
        self.Operations['classpropget'] = Operation_Classpropget();
        self.Operations[':'] = Operation_Colon();
        self.Operations['contains'] = Operation_Contains();
        self.Operations['string contains'] = Operation_Contains();
        self.Operations['create element'] = Operation_Create_Element();
        self.Operations['csv string'] = Operation_Csv_String();
        self.Operations['defined'] = Operation_Defined();
        self.Operations['exists'] = Operation_Defined();
        self.Operations['default'] = Operation_Default();
        self.Operations['default ^'] = Operation_Default_Global();
        self.Operations['dict.exists'] = Operation_Dict_Exists();
        self.Operations['dict exists'] = Operation_Dict_Exists();
        self.Operations['key.exists'] = Operation_Dict_Exists();
        self.Operations['key exists'] = Operation_Dict_Exists();
        self.Operations['dictionary exists'] = Operation_Dict_Exists();
        self.Operations['dexists'] = Operation_Dict_Exists();
        self.Operations['dict.get'] = Operation_Dict_Get();
        self.Operations['dict get'] = Operation_Dict_Get();
        self.Operations['key.get'] = Operation_Dict_Get();
        self.Operations['key get'] = Operation_Dict_Get();
        self.Operations['dictionary get'] = Operation_Dict_Get();
        self.Operations['dispatch'] = Operation_Dispatch();
        self.Operations['distribute'] = Operation_Distribute();
        self.Operations['divide'] = Operation_Divide();
        self.Operations['/'] = Operation_Divide();
        self.Operations['div'] = Operation_Divide();
        self.Operations['dequote'] = Operation_Dequote();
        self.Operations['enquote'] = Operation_Enquote();
        self.Operations['quote'] = Operation_Enquote();
        self.Operations['env'] = Operation_Environment();
        self.Operations['environment'] = Operation_Environment();
        self.Operations['='] = Operation_Equal();
        self.Operations['=='] = Operation_Equal();
        self.Operations['eq'] = Operation_Equal();
        self.Operations['equals'] = Operation_Equal();
        self.Operations['equal'] = Operation_Equal();
        self.Operations['evaluate'] = Operation_Evaluate();
        self.Operations['eval'] = Operation_Evaluate();
        self.Operations['file exists'] = Operation_File_Exists();
        self.Operations['files'] = Operation_Files();
        self.Operations['firstchar'] = Operation_First_Char();
        self.Operations['first.char'] = Operation_First_Char();
        self.Operations['first char'] = Operation_First_Char();
        self.Operations['flag'] = Operation_Flag();
        self.Operations['boolean'] = Operation_Flag();
        self.Operations['bool'] = Operation_Flag();
        self.Operations['flowerbox'] = Operation_Flowerbox();
        self.Operations['flower'] = Operation_Flowerbox();
        self.Operations['blossom'] = Operation_Flowerbox();
        self.Operations['lotus'] = Operation_Flowerbox();
        self.Operations['from json'] = Operation_From_Json();
        self.Operations['get'] = Operation_Get();
        self.Operations['dget'] = Operation_Get();
        self.Operations['get element by id'] = Operation_Get_Element_By_Id();
        self.Operations['get ^'] = Operation_Get_Global();
        self.Operations['dget ^'] = Operation_Get_Global();
        self.Operations['glvn'] = Operation_Glvn();
        self.Operations['key'] = Operation_Glvn();
        self.Operations['>='] = Operation_Greater_Equal();
        self.Operations['ge'] = Operation_Greater_Equal();
        self.Operations['>'] = Operation_Greater_Than();
        self.Operations['gt'] = Operation_Greater_Than();
        self.Operations['human outcome gratitude'] = Operation_Human_Outcome_Gratitude();
        self.Operations['http fetch'] = Operation_Http_Fetch();
        self.Operations['i'] = Operation_I();
        self.Operations['self'] = Operation_I();
        self.Operations['if'] = Operation_If();
        self.Operations['implement'] = Operation_Implement();
        self.Operations['int char'] = Operation_Int2char();
        self.Operations['intchar'] = Operation_Int2char();
        self.Operations['int2char'] = Operation_Int2char();
        self.Operations['num2char'] = Operation_Int2char();
        self.Operations['integer'] = Operation_Integer();
        self.Operations['intdiv'] = Operation_Integer_Divide();
        self.Operations['invoke'] = Operation_Invoke();
        self.Operations['isa'] = Operation_Is_A();
        self.Operations['is a'] = Operation_Is_A();
        self.Operations['is.a'] = Operation_Is_A();
        self.Operations['is an'] = Operation_Is_A();
        self.Operations['isan'] = Operation_Is_A();
        self.Operations['is.an'] = Operation_Is_A();
        self.Operations['is digit'] = Operation_Is_Digit();
        self.Operations['isident'] = Operation_Is_Ident();
        self.Operations['is.ident'] = Operation_Is_Ident();
        self.Operations['is ident'] = Operation_Is_Ident();
        self.Operations['islowercase'] = Operation_Is_Lowercase();
        self.Operations['is.lowercase'] = Operation_Is_Lowercase();
        self.Operations['is lowercase'] = Operation_Is_Lowercase();
        self.Operations['islower'] = Operation_Is_Lowercase();
        self.Operations['isnull'] = Operation_Is_Null();
        self.Operations['is null'] = Operation_Is_Null();
        self.Operations['is_number'] = Operation_Is_Number();
        self.Operations['isnumber'] = Operation_Is_Number();
        self.Operations['is number'] = Operation_Is_Number();
        self.Operations['is numeric'] = Operation_Is_Number();
        self.Operations['is punct'] = Operation_Is_Punct();
        self.Operations['is punctuation'] = Operation_Is_Punct();
        self.Operations['ispunct'] = Operation_Is_Punct();
        self.Operations['is_string'] = Operation_Is_String();
        self.Operations['isstring'] = Operation_Is_String();
        self.Operations['is string'] = Operation_Is_String();
        self.Operations['isuppercase'] = Operation_Is_Uppercase();
        self.Operations['is.uppercase'] = Operation_Is_Uppercase();
        self.Operations['is uppercase'] = Operation_Is_Uppercase();
        self.Operations['isupper'] = Operation_Is_Uppercase();
        self.Operations['isws'] = Operation_Is_Whitespace();
        self.Operations['is.ws'] = Operation_Is_Whitespace();
        self.Operations['is ws'] = Operation_Is_Whitespace();
        self.Operations['iswhitespace'] = Operation_Is_Whitespace();
        self.Operations['is.whitespace'] = Operation_Is_Whitespace();
        self.Operations['is whitespace'] = Operation_Is_Whitespace();
        self.Operations['whitespace'] = Operation_Is_Whitespace();
        self.Operations['lastchar'] = Operation_Last_Char();
        self.Operations['last.char'] = Operation_Last_Char();
        self.Operations['last char'] = Operation_Last_Char();
        self.Operations['length'] = Operation_Length();
        self.Operations['len'] = Operation_Length();
        self.Operations['string.length'] = Operation_Length();
        self.Operations['string length'] = Operation_Length();
        self.Operations['<='] = Operation_Less_Equal();
        self.Operations['le'] = Operation_Less_Equal();
        self.Operations['<'] = Operation_Less_Than();
        self.Operations['lt'] = Operation_Less_Than();
        self.Operations['list.get'] = Operation_List_Get();
        self.Operations['list get'] = Operation_List_Get();
        self.Operations['lget'] = Operation_List_Get();
        self.Operations['list.last'] = Operation_List_Last();
        self.Operations['list last'] = Operation_List_Last();
        self.Operations['llast'] = Operation_List_Last();
        self.Operations['list.length'] = Operation_List_Length();
        self.Operations['list length'] = Operation_List_Length();
        self.Operations['llen'] = Operation_List_Length();
        self.Operations['llength'] = Operation_List_Length();
        self.Operations['pop'] = Operation_List_Pop();
        self.Operations['list pop'] = Operation_List_Pop();
        self.Operations['list.pop'] = Operation_List_Pop();
        self.Operations['lpop'] = Operation_List_Pop();
        self.Operations['lowercase'] = Operation_Lowercase();
        self.Operations['lower'] = Operation_Lowercase();
        self.Operations['module class name new'] = Operation_Module_Class_Name_New();
        self.Operations['mod'] = Operation_Modulo();
        self.Operations['*'] = Operation_Multiply();
        self.Operations['multiply'] = Operation_Multiply();
        self.Operations['mult'] = Operation_Multiply();
        self.Operations['times'] = Operation_Multiply();
        self.Operations['name'] = Operation_Name();
        self.Operations['new'] = Operation_New();
        self.Operations['new my class'] = Operation_New_My_Class();
        self.Operations['new our class'] = Operation_New_Our_Class();
        self.Operations['next'] = Operation_Next();
        self.Operations['next ^'] = Operation_Next_Global();
        self.Operations['not'] = Operation_Not();
        self.Operations['!'] = Operation_Not();
        self.Operations['ne'] = Operation_Not_Equal();
        self.Operations['!='] = Operation_Not_Equal();
        self.Operations['<>'] = Operation_Not_Equal();
        self.Operations['not null'] = Operation_Not_Null();
        self.Operations['notnull'] = Operation_Not_Null();
        self.Operations['not.null'] = Operation_Not_Null();
        self.Operations['? :'] = Operation_Ternary();
        self.Operations['ternary'] = Operation_Ternary();
        self.Operations['test'] = Operation_Test();
        self.Operations['now string'] = Operation_Time_String();
        self.Operations['number'] = Operation_Number();
        self.Operations['or'] = Operation_Or();
        self.Operations['|'] = Operation_Or();
        self.Operations['||'] = Operation_Or();
        self.Operations['outcome'] = Operation_Outcome();
        self.Operations['power'] = Operation_Power();
        self.Operations['pow'] = Operation_Power();
        self.Operations['**'] = Operation_Power();
        self.Operations['prev'] = Operation_Prev();
        self.Operations['previous'] = Operation_Prev();
        self.Operations['prev ^'] = Operation_Prev_Global();
        self.Operations['previous ^'] = Operation_Prev_Global();
        self.Operations['qlength'] = Operation_QLength();
        self.Operations['ql'] = Operation_QLength();
        self.Operations['qsubscript'] = Operation_QSubscript();
        self.Operations['qs'] = Operation_QSubscript();
        self.Operations['randint'] = Operation_Random_Integer();
        self.Operations['rand_int'] = Operation_Random_Integer();
        self.Operations['random integer'] = Operation_Random_Integer();
        self.Operations['rand int'] = Operation_Random_Integer();
        self.Operations['random percent'] = Operation_Random_Percent();
        self.Operations['rand'] = Operation_Random_Percent();
        self.Operations['round'] = Operation_Round();
        self.Operations['shift'] = Operation_Shift();
        self.Operations['list.shift'] = Operation_Shift();
        self.Operations['list shift'] = Operation_Shift();
        self.Operations['lshift'] = Operation_Shift();
        self.Operations['split'] = Operation_Split();
        self.Operations['sql array'] = Operation_Sql_Array();
        self.Operations['sql object'] = Operation_Sql_Object();
        self.Operations['sqrt'] = Operation_Square_Root();
        self.Operations['square root'] = Operation_Square_Root();
        self.Operations['append'] = Operation_String_Append();
        self.Operations['s+'] = Operation_String_Append();
        self.Operations['s='] = Operation_String_Equal();
        self.Operations['seq'] = Operation_String_Equal();
        self.Operations['string ='] = Operation_String_Equal();
        self.Operations['s ='] = Operation_String_Equal();
        self.Operations['s>='] = Operation_String_Greater_Equal();
        self.Operations['sge'] = Operation_String_Greater_Equal();
        self.Operations['string >='] = Operation_String_Greater_Equal();
        self.Operations['s >='] = Operation_String_Greater_Equal();
        self.Operations['string ge'] = Operation_String_Greater_Equal();
        self.Operations['s ge'] = Operation_String_Greater_Equal();
        self.Operations['string.gt'] = Operation_String_Greater();
        self.Operations['sgt'] = Operation_String_Greater();
        self.Operations['s>'] = Operation_String_Greater();
        self.Operations['string greater'] = Operation_String_Greater();
        self.Operations['s >'] = Operation_String_Greater();
        self.Operations['s gt'] = Operation_String_Greater();
        self.Operations['string.le'] = Operation_String_Less_Equal();
        self.Operations['s<='] = Operation_String_Less_Equal();
        self.Operations['sle'] = Operation_String_Less_Equal();
        self.Operations['string <='] = Operation_String_Less_Equal();
        self.Operations['s <='] = Operation_String_Less_Equal();
        self.Operations['s le'] = Operation_String_Less_Equal();
        self.Operations['string le'] = Operation_String_Less_Equal();
        self.Operations['s<'] = Operation_String_Less();
        self.Operations['slt'] = Operation_String_Less();
        self.Operations['string <'] = Operation_String_Less();
        self.Operations['s <'] = Operation_String_Less();
        self.Operations['s!='] = Operation_String_Not_Equal();
        self.Operations['sne'] = Operation_String_Not_Equal();
        self.Operations['string !='] = Operation_String_Not_Equal();
        self.Operations['s !='] = Operation_String_Not_Equal();
        self.Operations['string'] = Operation_String();
        self.Operations['substring'] = Operation_Substring();
        self.Operations['subtract'] = Operation_Subtract();
        self.Operations['-'] = Operation_Subtract();
        self.Operations['minus'] = Operation_Subtract();
        self.Operations['then'] = Operation_Then();
        self.Operations['titlecase'] = Operation_Titlecase();
        self.Operations['title case'] = Operation_Titlecase();
        self.Operations['tilde'] = Operation_Tilda();
        self.Operations['tilda'] = Operation_Tilda();
        self.Operations['~'] = Operation_Tilda();
        self.Operations['to json'] = Operation_To_Json();
        self.Operations['tokenmode'] = Operation_Token_Mode();
        self.Operations['token.mode'] = Operation_Token_Mode();
        self.Operations['token mode'] = Operation_Token_Mode();
        self.Operations['uppercase'] = Operation_Uppercase();
        self.Operations['upper'] = Operation_Uppercase();
        self.Operations['uuid'] = Operation_Uuid();
        self.Operations['guid'] = Operation_Uuid();
        self.Operations['we'] = Operation_We();
        self.Syntaxes['array'] = Syntax_Array();
        self.Syntaxes['arr'] = Syntax_Array();
        self.Syntaxes['attribute'] = Syntax_Attribute();
        self.Syntaxes['att'] = Syntax_Attribute();
        self.Syntaxes['~'] = Syntax_Attribute();
        self.Syntaxes['await'] = Syntax_Await();
        self.Syntaxes['behavior'] = Syntax_Behavior();
        self.Syntaxes['class.attribute'] = Syntax_Class_Attribute();
        self.Syntaxes['class.att'] = Syntax_Class_Attribute();
        self.Syntaxes['classatt'] = Syntax_Class_Attribute();
        self.Syntaxes['class attribute'] = Syntax_Class_Attribute();
        self.Syntaxes['class att'] = Syntax_Class_Attribute();
        self.Syntaxes['class ~'] = Syntax_Class_Attribute();
        self.Syntaxes['class'] = Syntax_Class();
        self.Syntaxes['class of'] = Syntax_Class();
        self.Syntaxes['classes'] = Syntax_Classes();
        self.Syntaxes['class.name'] = Syntax_Class_Name();
        self.Syntaxes['class name'] = Syntax_Class_Name();
        self.Syntaxes['classname'] = Syntax_Class_Name();
        self.Syntaxes[':'] = Syntax_Class_Property();
        self.Syntaxes['count'] = Syntax_Count();
        self.Syntaxes['dict'] = Syntax_Dictionary();
        self.Syntaxes['dictionary'] = Syntax_Dictionary();
        self.Syntaxes['hash'] = Syntax_Dictionary();
        self.Syntaxes['remember'] = Syntax_Remember();
        self.Syntaxes['exclude'] = Syntax_Exclude();
        self.Syntaxes['false'] = Syntax_False();
        self.Syntaxes['flag'] = Syntax_Flag();
        self.Syntaxes['bool'] = Syntax_Flag();
        self.Syntaxes['boolean'] = Syntax_Flag();
        self.Syntaxes['fptr'] = Syntax_Function_Pointer();
        self.Syntaxes['function pointer'] = Syntax_Function_Pointer();
        self.Syntaxes['future'] = Syntax_Future();
        self.Syntaxes['generator'] = Syntax_Generator();
        self.Syntaxes['glvn'] = Syntax_Glvn();
        self.Syntaxes['key'] = Syntax_Glvn();
        self.Syntaxes['implementers of'] = Syntax_Implementers_Of();
        self.Syntaxes['indent'] = Syntax_Indent();
        self.Syntaxes['init'] = Syntax_Init();
        self.Syntaxes['integer'] = Syntax_Integer();
        self.Syntaxes['int'] = Syntax_Integer();
        self.Syntaxes['is'] = Syntax_Is();
        self.Syntaxes['ismain'] = Syntax_Is_Main();
        self.Syntaxes['is main'] = Syntax_Is_Main();
        self.Syntaxes['job'] = Syntax_Job();
        self.Syntaxes['language elements'] = Syntax_Language_Elements();
        self.Syntaxes['line'] = Syntax_Line();
        self.Syntaxes['list'] = Syntax_List();
        self.Syntaxes['method'] = Syntax_Method();
        self.Syntaxes['mildbeard'] = Syntax_Mildbeard();
        self.Syntaxes['module class'] = Syntax_Module_Class();
        self.Syntaxes['my.attribute'] = Syntax_My_Attribute();
        self.Syntaxes['my attribute'] = Syntax_My_Attribute();
        self.Syntaxes['my att'] = Syntax_My_Attribute();
        self.Syntaxes['my.att'] = Syntax_My_Attribute();
        self.Syntaxes['my ~'] = Syntax_My_Attribute();
        self.Syntaxes['my~'] = Syntax_My_Attribute();
        self.Syntaxes['my.class'] = Syntax_My_Class();
        self.Syntaxes['my class'] = Syntax_My_Class();
        self.Syntaxes['my.class'] = Syntax_My_Class();
        self.Syntaxes['self.class'] = Syntax_My_Class();
        self.Syntaxes['self class'] = Syntax_My_Class();
        self.Syntaxes['my'] = Syntax_My();
        self.Syntaxes['i'] = Syntax_My();
        self.Syntaxes['new list'] = Syntax_New_List();
        self.Syntaxes['node'] = Syntax_Node();
        self.Syntaxes['number'] = Syntax_Number();
        self.Syntaxes['null'] = Syntax_Null();
        self.Syntaxes['entity'] = Syntax_Object();
        self.Syntaxes['object'] = Syntax_Object();
        self.Syntaxes['optional'] = Syntax_Optional();
        self.Syntaxes['optrep'] = Syntax_Optrep();
        self.Syntaxes['optional repeating'] = Syntax_Optrep();
        self.Syntaxes['our'] = Syntax_Our();
        self.Syntaxes['we'] = Syntax_Our();
        self.Syntaxes['outcomes'] = Syntax_Outcomes();
        self.Syntaxes['output'] = Syntax_Output();
        self.Syntaxes['.'] = Syntax_Property();
        self.Syntaxes['property'] = Syntax_Property();
        self.Syntaxes['propchain'] = Syntax_Property();
        self.Syntaxes['property lookup'] = Syntax_Property_Lookup();
        self.Syntaxes['repeating'] = Syntax_Repeating();
        self.Syntaxes['request'] = Syntax_Request();
        self.Syntaxes['roster floor'] = Syntax_Roster_Floor();
        self.Syntaxes['self'] = Syntax_Self();
        self.Syntaxes['me'] = Syntax_Self();
        self.Syntaxes['sequence'] = Syntax_Sequence();
        self.Syntaxes['seq'] = Syntax_Sequence();
        self.Syntaxes['session'] = Syntax_Session();
        self.Syntaxes['sql connection'] = Syntax_Sql_Connection();
        self.Syntaxes['string'] = Syntax_String();
        self.Syntaxes['tab'] = Syntax_Tab();
        self.Syntaxes['tilde'] = Syntax_Tilda();
        self.Syntaxes['tilda'] = Syntax_Tilda();
        self.Syntaxes['~'] = Syntax_Tilda();
        self.Syntaxes['true'] = Syntax_True();
        self.Syntaxes['us'] = Syntax_Us();
        self.Syntaxes['our class'] = Syntax_Us();
        self.Syntaxes['variant'] = Syntax_Variant();
        return True
class Gs_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Gs(self)])
        return True
    def Infer_Gs(self):
        Verbose = True
        Error_Fail = True
        Elem = None
        I = None
        Number = 0
        Error = None
        Mumps_Append = ''
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Gs()
                Elem.Gs = I.Gs
                Number += 1
            except Exception:
                pass
        for Elem in self.Elements.Symbol_Value:
            if Error_Fail:
                I = Elem.Classification
                I.Infer_Gs()
                Elem.Gs = I.Gs
                Number += 1
            else:
                try:
                    I = Elem.Classification
                    I.Infer_Gs()
                    Elem.Gs = I.Gs
                    Number += 1
                except Exception as Error:
                    self.Status = False
                    # comment 'debug;';
                    Elem.Error = Error
                    if Verbose:
                        print('Error fallback element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
            try:
                I.Infer_Mumps()
                if str(I.Mumps_Outer_Declaration) > "":
                    Mumps_Append += str(I.Mumps_Outer_Declaration)
                    # comment 'verbosemumps:  Mumps_Append';
            except Exception:
                pass
        if not self.Status:
            return False
        Top = self.Elements.Symbol_Value[-1]
        try:
            undef = Top.Gs
        except (ValueError, AttributeError):
            Top.Infer_Gs()
        Code = str(Top.Gs) + str(Mumps_Append)
        self.Gs = Code
        self.Code = Code
        return True
        return True
class Inference_Gs (Inference):
    def Infer(self):
        if not self.Owner.Infer_Gs():
            return False
        return True
class Statement_Statement:
    def Infer_Gs(self):
        zdebug.zbreak()
        Code = 'statement ' + str(self.Name.Gs) + str(self.Gal_Key_Suffix)
        if self.Ancestor is not None:
            Code += ' ' + str(self.Ancestor.Gs)
        Code += str(self.Gs_Block())
        self.Gs = Code
        return True
# comment '**** Javascript.gal ****';
# comment 'author Tara Zoltan;';
class Goal_Javascript (Goal):
    pass
class Spell_Javascript (Spell):
    pass
class Javascript_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Javascript(self)])
        return True
    def Infer_Javascript(self):
        Verbose = False
        Elem = None
        I = None
        Number = 0
        Error = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Javascript()
                Elem.Javascript = I.Javascript
                Number += 1
            except Exception as Error:
                self.Status = False
                Elem.Error = Error
                # comment 'debug';
                if Verbose:
                    print('Error javascript element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        if not self.Status:
            return
        Top = self.Elements.Symbol_Value[-1]
        # comment 'debug';
        Code = str(Top.Javascript)
        self.Javascript = Code
        self.Code = Code
        return True
class Inference_Javascript (Inference):
    def Infer(self):
        if not self.Owner.Infer_Javascript():
            return False
        return True
# comment 'TODO:statement class property';
class Statement_Classpropget:
    def Infer_Javascript(self):
        Class_Name = None
        Property_Name = None
        if self.Second is not None:
            Class_Name = self.First.Javascript
            Property_Name = self.Second.Javascript
        else:
            Class_Name = 'this.constructor'
            Context = self.Method_Context()
            if Context and isinstance(Context, Class_Method_Statement):
                Class_Name = 'this'
            Property_Name = self.First.Javascript
        Code = str(Class_Name) + '.' + str(Property_Name)
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Class_Name = None
        Property_Name = None
        if self.Second is not None:
            Class_Name = self.First.Python
            Property_Name = self.Second.Python
        else:
            Class_Name = 'this.constructor'
            Context = self.Method_Context()
            if Context and isinstance(Context, Class_Method_Statement):
                Class_Name = 'this'
            Property_Name = self.First.Python
        Code = str(Class_Name) + '.' + str(Property_Name)
        self.Python = Code
        return True
class Statement_Contains_binary:
    def Infer_Javascript(self):
        Gen = str(self.String.Javascript) + '.includes(' + str(self.Search.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Search.Python) + ' in ' + str(self.String.Python)
        self.Python = Gen
        return True
class Statement_Key_exists:
    def Infer_Javascript(self):
        Gen = str(self.Key.Javascript) + ' in ' + str(self.Dictionary.Javascript)
        self.Javascript = Gen
        return True
class Statement_Is_a_binary:
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' instanceof ' + str(self.Class_Name.Javascript)
        self.Javascript = Gen
        return True
class Statement_Is_null:
    def Infer_Javascript(self):
        Gen = '(' + str(self.Variable.Javascript) + ' == null || ' + str(self.Variable.Javascript) + ' == "")'
        self.Javascript = Gen
        return True
class Statement_List_Get:
    def Infer_Javascript(self):
        if not self.List.Javascript is not None:
            raise Exception(str(self.Failure_Message('List Javascript missing')))
        if not self.Node.Javascript is not None:
            raise Exception(str(self.Failure_Message('Node Javascript missing')))
        Code = str(self.List.Javascript) + '[' + str(self.Node.Javascript) + ']'
        self.Javascript = Code
        return True
class Statement_List_Last:
    def Infer_Javascript(self):
        if not self.First.Javascript is not None:
            raise Exception(str(self.Failure_Message('List Javascript missing')))
        Code = str(self.First.Javascript) + '[' + str(self.First.Javascript) + '.length-1]'
        self.Javascript = Code
        return True
class Statement_List_Length:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.length'
        self.Javascript = Gen
        return True
class Statement_List_Pop:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.pop()'
        self.Javascript = Gen
        return True
class Statement_List_Shift:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.shift()'
        self.Javascript = Gen
        return True
class Statement_Lowercase:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.toLowerCase()'
        self.Javascript = Gen
        return True
class Statement_Islowercase:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.match(/[a-z]/)'
        self.Javascript = Gen
        return True
class Statement_Isalpha:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.match(/[a-zA-Z]/)'
        self.Javascript = Gen
        return True
class Statement_New:
    def Infer_Javascript(self):
        Gen = 'new ' + str(self.Class_Name.Javascript) + '(' + str(self.Javascript_Args(', ')) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Variable.Python) + ' = ' + str(self.Class.Python) + '(' + str(self.Python_Args(', ')) + ')'
        self.Python = Gen
        return True
class Statement_Not_Null:
    def Infer_Javascript(self):
        Gen = '(' + str(self.Variable.Javascript) + ' != null && ' + str(self.Variable.Javascript) + ' > "")'
        self.Javascript = Gen
        return True
class Statement_Round:
    def Infer_Javascript(self):
        Gen = str(self.Number.Javascript) + '.toFixed(' + str(self.Decimals.Javascript) + ')'
        self.Javascript = Gen
        return True
class Statement_String_Length:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.length'
        self.Javascript = Gen
        return True
class Statement_Substring:
    def Infer_Javascript(self):
        Code = str(self.String_Value.Javascript) + '.substr(' + str(self.Start_Index.Javascript)
        if self.Length is not None:
            Code += ', ' + str(self.Length.Javascript)
        Code += ')'
        self.Javascript = Code
        return True
class Statement_Time_String:
    def Infer_Javascript(self):
        Gen = '(new Date().toISOString())'
        self.Javascript = Gen
        return True
class Statement_Uppercase:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.toUpperCase()'
        self.Javascript = Gen
        return True
class Statement_Isuppercase:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.match(/[A-Z]/)'
        self.Javascript = Gen
        return True
class Statement_Whitespace:
    def Infer_Javascript(self):
        Gen = '!' + str(self.First.Javascript) + '.match(/\\S/)'
        self.Javascript = Gen
        return True
class Statement_List_Delete:
    def Infer_Javascript(self):
        Gen = str(self.List.Javascript) + '.splice(' + str(self.Index.Javascript) + ', ' + str(self.Count.Javascript) + ');'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'del ' + str(self.List.Python) + '[' + str(self.Index.Python) + ':' + str(self.Index.Python) + '+' + str(self.Count.Python) + ']'
        self.Python = Gen
        return True
class Statement_Our_Equal:
    def Infer_Javascript(self):
        Gen = 'this.' + str(self.Property.Javascript) + ' = ' + str(self.Expression.Javascript) + ';'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = 'cls.' + str(self.Property.Python) + ' = ' + str(self.Expression.Python)
        self.Python = Gen
        return True
class Statement_Read_Line:
    def Infer_Javascript(self):
        Argument = None
        Argument_Javascript = None
        Code = ''
        Between = ''
        for Argument in self.Arguments:
            Argument_Javascript = Argument.Javascript
            if isinstance(Argument, Quote):
                pass
            if isinstance(Argument, Token_Name):
                Code += str(Between) + str(Argument_Javascript) + ' = console.input();'
                Between = '\n'
            else:
                Code += str(Between) + 'console.log(' + str(Argument_Javascript) + ');'
                Between = '\n'
        self.Javascript = Code
        return True
    def Infer_Python(self):
        Argument = None
        Argument_Python = None
        Code = ''
        for Argument in self.Arguments:
            Argument_Python = Argument.Python
            Between = ''
            if isinstance(Argument, Token_Name):
                Code += str(Between) + str(Argument_Python) + ' = input()'
                Between = '\n'
            else:
                Code += str(Between) + "print(" + str(Argument_Python) + ",sep='',end='')"
                Between = '\n'
        self.Python = Code
        return True
class Operation_Firstchar:
    def Infer_Javascript(self):
        Gen = str(self.String_Value.Javascript) + '.charAt(0)'
        self.Javascript = Gen
        return True
class Operation_Lastchar:
    def Infer_Javascript(self):
        Gen = str(self.String_Value.Javascript) + '.charAt(' + str(self.String_Value.Javascript) + '.length-1)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.String_Value.Python) + '[-1]'
        self.Python = Gen
        return True
class Statement_Undef:
    def Infer_Javascript(self):
        Ifargs = ""
        Between = ""
        Argument = None
        for Argument in self.Listargs:
            Ifargs += str(Between) + str(Argument.Javascript) + " == null"
            Between = " || "
        Block = str(self.Javascript_Block())
        Code = "if (" + str(Ifargs) + ")" + str(Block)
        self.Javascript = Code
        return True
class Statement_New_Line:
    def Infer_Javascript(self):
        Gen = str(self.Variable.Javascript) + ' = new ' + str(self.Class.Javascript) + '(' + str(self.Javascript_Args(', ')) + ');'
        self.Javascript = Gen
        return True
class Operation_Dictionary_Get:
    def Infer_Javascript(self):
        Gen = str(self.Dictionary.Javascript) + '[' + str(self.Key.Javascript) + ']'
        self.Javascript = Gen
        return True
class Operation_Key_Exists:
    def Infer_Javascript(self):
        Gen = str(self.Key.Javascript) + ' in ' + str(self.Dictionary.Javascript)
        self.Javascript = Gen
        return True
class Operation_List_Shift:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.shift()'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.pop(0)'
        self.Python = Gen
        return True
class Operation_List_Split:
    def Infer_Javascript(self):
        Gen = str(self.String.Javascript) + '.split(' + str(self.Delimiter.Javascript) + ')'
        self.Javascript = Gen
        return True
class Operation_Is_Alpha:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.match(/[a-zA-Z]/)'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.isalpha()'
        self.Python = Gen
        return True
class Operation_String_Length:
    def Infer_Javascript(self):
        Gen = str(self.First.Javascript) + '.length'
        self.Javascript = Gen
        return True
# comment "(append `generate Operation_Whitespace` [line] `            '!' [my First Javascript] '.match(/\S/)';`)";
class Operation_Whitespace:
    def Infer_Javascript(self):
        Gen = '/\\s/.test(' + str(self.First.Javascript) + ')'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.First.Python) + '.isspace()'
        self.Python = Gen
        return True
class Syntax_Colon:
    def Infer_Javascript(self):
        Gen = str(self.Javascript_Arguments('.'))
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Python_Arguments('.'))
        self.Python = Gen
        return True
class Syntax_Key:
    def Infer_Javascript(self):
        Gen = str(self.Dictionary.Javascript) + '[' + str(self.Key.Javascript) + ']'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = str(self.Dictionary.Python) + '[' + str(self.Key.Python) + ']'
        self.Python = Gen
        return True
class Syntax_Backslash:
    def Infer_Javascript(self):
        Code = "gal.backslash("
        if self.Count is not None:
            Code += str(self.Count.Javascript)
        Code += ')'
        self.Javascript = Code
        return True
class Syntax_Infinity:
    def Infer_Javascript(self):
        Gen = 'Infinity'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = "float('inf')"
        self.Python = Gen
        return True
class Syntax_Negative_Infinity:
    def Infer_Javascript(self):
        Gen = 'Number.NEGATIVE_INFINITY'
        self.Javascript = Gen
        return True
    def Infer_Python(self):
        Gen = "-float('inf')"
        self.Python = Gen
        return True
# comment 'TODO:Syntax_Module_Class Module_Expression has to be evaluated';
# comment '**** Python.gal ****';
# comment 'authorTara Zoltan';
class Goal_Python (Goal):
    pass
class Spell_Python (Spell):
    pass
class Python_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Python(self)])
        return True
    def Infer_Python(self):
        Verbose = False
        Elem = None
        I = None
        Number = 0
        Error = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Python()
                Elem.Python = I.Python
                Number += 1
            except Exception as Error:
                self.Status = False
                # comment 'debug';
                Elem.Error = Error
                if Verbose:
                    print('Error python element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        if not self.Status:
            return False
        Top = self.Elements.Symbol_Value[-1]
        # comment 'debug';
        Code = str(Top.Python)
        self.Python = Code
        self.Code = Code
        return True
class Inference_Python (Inference):
    def Infer(self):
        if not self.Owner.Infer_Python():
            return False
        return True
# comment 'TODO:statement class property';
# comment '**** Html.gal ****';
class Goal_Html (Goal):
    pass
class Spell_Html (Spell):
    pass
class Html_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
        self.Entity_Number = 0
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Html(self)])
        return True
    def Infer_Html(self):
        Verbose = False
        Elem = None
        I = None
        Number = 0
        Error = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Html()
                Elem.Html = I.Html
                Number += 1
            except Exception as Error:
                self.Status = False
                Elem.Error = Error
                # comment 'debug';
                if Verbose:
                    print('Error html element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        if not self.Status:
            return
        Top = self.Elements.Symbol_Value[-1]
        Preamble = str('''<!DOCTYPE html>'''  +  '\n'  +  '''<html><head><title>goalspell</title>'''  +  '\n'  +  '''<style>'''  +  '\n'  +  '''    .codebox '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        display: block;'''  +  '\n'  +  '''        unicode-bidi: embed;'''  +  '\n'  +  '''        font-family: monospace;'''  +  '\n'  +  '''        white-space: pre-wrap;'''  +  '\n'  +  '''        border-width: 1px;'''  +  '\n'  +  '''        border-style: solid;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    .note'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        font-style: italic;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    th'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        vertical-align: top;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    .dropbtn '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        background-color: purple;'''  +  '\n'  +  '''        color: white;'''  +  '\n'  +  '''        padding: 8px;'''  +  '\n'  +  '''        border: none;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    .dropdown '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        position: relative;'''  +  '\n'  +  '''        display: inline-block;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    .dropdown a '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        color: white;'''  +  '\n'  +  '''        padding: 8px;'''  +  '\n'  +  '''        text-decoration: none;'''  +  '\n'  +  '''        display: block;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    .dropdown-content '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        display: none;'''  +  '\n'  +  '''        position: absolute;'''  +  '\n'  +  '''        background-color: pink;'''  +  '\n'  +  '''        color: black;'''  +  '\n'  +  '''        min-width: 160px;'''  +  '\n'  +  '''        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);'''  +  '\n'  +  '''        z-index: 1;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    .dropdown:hover'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        color: black;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    .dropdown-content a '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        color: black;'''  +  '\n'  +  '''        padding: 8px;'''  +  '\n'  +  '''        text-decoration: none;'''  +  '\n'  +  '''        display: block;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    .dropdown-content a:hover '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        background-color: #ddd;'''  +  '\n'  +  '''        color: black;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    .dropdown:hover .dropdown-content '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        color: black;'''  +  '\n'  +  '''        display: block;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''    .dropdown:hover .dropbtn '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        color: black;'''  +  '\n'  +  '''        background-color: violet;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    h1 '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        font-size: 60px;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    h2 '''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        font-size: 30px;'''  +  '\n'  +  '''        color: purple;'''  +  '\n'  +  '''        font-family: helvetica;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''    h3'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        padding-top: 30px;'''  +  '\n'  +  '''    }'''  +  '\n'  +  ''''''  +  '\n'  +  '''</style>'''  +  '\n'  +  '''<script>'''  +  '\n'  +  '''    function code_box(Name, Text)'''  +  '\n'  +  '''    {'''  +  '\n'  +  '''        //debugger;'''  +  '\n'  +  '''        //console.log('codebox', Name, Text);'''  +  '\n'  +  '''        var Element = document.getElementById(Name);'''  +  '\n'  +  '''        Element.innerText = Text;'''  +  '\n'  +  '''    }'''  +  '\n'  +  '''</script></head><body>'''  +  '\n'  +  '''''')
        Body = str(Top.Html)
        Code = str(Preamble) + str(Body) + str(''''''  +  '\n'  +  '''</body></html>''')
        self.Html = Code
        self.Code = Code
        return True
class Inference_Html (Inference):
    def Infer(self):
        if not self.Owner.Infer_Html():
            return False
        return True
class C:
    Variable_Number = 0
    Behavior = '<<<UNKNOWN BEHAVIOR in C.gal>>>'
    Test = '<<<UNKNOWN TEST in C.gal>>>'
    Map = '<<<UNKNOWN MAP in C.gal>>>'
    Floor = '<<<UNKNOWN Floor in C.gal>>>'
    Inits = []
    @classmethod
    def Get_Variable(cls):
        C.Variable_Number += 1
        Variable = '_v' + str(C.Variable_Number)
        return Variable
class C_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_C(self)])
        return True
    def Infer_C(self):
        Verbose = True
        self.Compiled_Inheritance()
        Elem = None
        I = None
        Number = 0
        Error = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_C()
                Elem.C = I.C
                Number += 1
            except Exception as Error:
                self.Status = False
                Elem.Error = Error
                # comment 'debug';
                if Verbose:
                    print('Error C element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        if not self.Status:
            return
        Top = self.Elements.Symbol_Value[-1]
        # comment 'debug';
        Code = str(Top.C)
        self.C = Code
        self.Code = Code
        return True
class Inference_C (Inference):
    def Infer(self):
        if not self.Owner.Infer_C():
            return False
        return True
# comment '**** Fallback.gal ****';
class Fallback_Generator (Generator):
    Example_Number = 0
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    # comment 'infers Parse';
    # comment 'infers Generate';
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Fallback(self)])
        self.Inferences.Symbol_Value.extend([Inference_Fallback(self)])
        return True
    @classmethod
    def Next_Example(cls):
        Fallback_Generator.Example_Number += 1
        Name = "Example" + str(Fallback_Generator.Example_Number)
        return Name
    def Infer_Fallback(self):
        Verbose = False
        self.Status = True
        Elem = None
        I = None
        Error = None
        Status = True
        EF = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Gs()
                Elem.Gs = I.Gs
                I.Infer_Fallback()
            except Exception:
                pass
        Number = 0
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                if Verbose:
                    print('fallback generating ', I.__class__.__name__, sep='')
                I.Infer_Gs()
                Elem.Gs = I.Gs
                Status &= I.Infer_Fallback()
                Elem.Error = I.Error
                Elem.Fallback = I.Fallback
                Number += 1
                if Verbose:
                    print(Number, ' ', I.__class__.__name__, ': ', Elem.Fallback, '\n', sep='')
            except Exception as Error:
                Status = False
                I.Error = Error
                Elem.Error = Error
                Error_Message = str(Error)
                EF = 'error ' + str(Elem.Enquote(Error_Message)) + ';'
                I.Fallback = EF
                Elem.Fallback = EF
                if Verbose:
                    print('Error fallback element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        self.Status = Status
        if not Status:
            return Status
        Top = self.Elements.Symbol_Value[-1]
        Code = str(Top.Fallback)
        self.Fallback = Code
        self.Code = Code
        return self.Status
        return True
class Inference_Fallback (Inference):
    def Infer(self):
        if not self.Owner.Infer_Fallback():
            return False
        return True
class Statement_Isa:
    def Infer_Fallback(self):
        zdebug.zbreak()
        # comment 'TODO:fall back to an appropriate class set statement';
        return True
class Statement_Compile_Runtime:
    def Infer_Fallback(self):
        Gen = str(self.Target.Fallback) + ' = (Runtime:Compile ' + str(self.Enquote(self.From.Fallback)) + ' ' + str(self.Enquote(self.To.Fallback)) + ' ' + str(self.Source.Fallback) + ');'
        self.Fallback = Gen
        return True
class Statement_Atomic_Runtime:
    def Infer_Fallback(self):
        Gen = str(self.Gs_Variable.Fallback) + ' = (Runtime:Atomic ' + str(self.Atomic_Variable.Fallback) + ');'
        self.Fallback = Gen
        return True
class Statement_Translation_Test:
    def Infer_Fallback(self):
        Gen = 'comment `Translation Test ' + str(self.Name.Fallback) + '`;' + str('\n') + str(self.Block.Fallback_Statements)
        self.Fallback = Gen
        return True
# comment "(append `` [line] `        generate Statement_File_Readall` [line] `            Variable ' = (Runtime:File_Readall ' File_Name ');';` [line] ``)";
# comment "(append `` [line] `        generate Statement_File_Append` [line] `            'Runtime:File_Append ' File_Text ' ' File_Name ';';` [line] ``)";
class Syntax_Try_At_Of:
    def Infer_Fallback(self):
        Implementer = str(self.Implementer.Fallback)
        Test = str(self.Test.Fallback)
        Goal_Name = str(self.Goal_Name.Fallback)
        Code = 'todo "try ' + str(Implementer) + ' at ' + str(Test) + ' of ' + str(Goal_Name) + '";'
        self.Fallback = Code
        return True
# comment '**** Canonical.gal ****';
class Canonical_Generator (Generator):
    Example_Number = 0
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    # comment 'infers Parse';
    # comment 'infers Generate';
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Canonical(self)])
        self.Inferences.Symbol_Value.extend([Inference_Canonical(self)])
        return True
    @classmethod
    def Next_Example(cls):
        Canonical_Generator.Example_Number += 1
        Name = "Example" + str(Canonical_Generator.Example_Number)
        return Name
    def Infer_Canonical(self):
        Verbose = False
        self.Status = True
        Elem = None
        I = None
        Error = None
        Status = True
        EF = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Gs()
                Elem.Gs = I.Gs
                I.Infer_Canonical()
            except Exception:
                pass
        Number = 0
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                if Verbose:
                    print('canonical generating ', I.__class__.__name__, sep='')
                I.Infer_Gs()
                Elem.Gs = I.Gs
                Status &= I.Infer_Canonical()
                Elem.Error = I.Error
                Elem.Canonical = I.Canonical
                Number += 1
                if Verbose:
                    print(Number, ' ', I.__class__.__name__, ': ', Elem.Canonical, '\n', sep='')
            except Exception as Error:
                Status = False
                I.Error = Error
                Elem.Error = Error
                Error_Message = str(Error)
                EF = 'error ' + str(Elem.Enquote(Error_Message)) + ';'
                I.Canonical = EF
                Elem.Canonical = EF
                if Verbose:
                    print('Error canonical element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        self.Status = Status
        if not Status:
            return Status
        Code = ''
        for Elem in self.Elements.Symbol_Value:
            if Elem.Canonical is not None:
                Code += 'canonical ' + str(Elem.__class__.__name__) + ' ' + str(Elem.Enquote(Elem.Canonical)) + ';' + str('\n')
        self.Canonical = Code
        self.Code = Code
        return self.Status
        return True
class Inference_Canonical (Inference):
    def Infer(self):
        if not self.Owner.Infer_Canonical():
            return False
        return True
class Inference_Parse (Inference):
    def Infer(self):
        if not self.Owner.Infer_Parse():
            return False
        return True
class Inference_Generate (Inference):
    def Infer(self):
        if not self.Owner.Infer_Generate():
            return False
        return True
# comment '[line]******** [line]* BNF.gs [line]******** [line]';
class Goal_BNF (Goal):
    pass
class Spell_BNF (Spell):
    pass
class Dialect_BNF (Dialect):
    def Initialize(self):
        return True
class BNF_Parser (Parser):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
        self.Dialect = Dialect_BNF()
    def propinit(self):
        self.Dialect = Dialect_BNF
        self.Inferences = List(self)
        self.Tokens = List(self)
        self.Elements = List(self)
        self.Position = 0
    def Initialize(self):
        Verbose = True
        if Verbose:
            print(self.__class__.__name__, 'Inits', sep='')
        self.Dialect.Initialize()
        self.Inferences.Symbol_Value.extend([Inference_Tokens(self)])
        self.Inferences.Symbol_Value.extend([Inference_Elements(self)])
        return True
    def Parse_Token(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Name_Token(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Name_Token):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Quote(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Quote):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Token_Comment(self, Parent_Elements):
        Top_Token = self.Top_Token()
        if not isinstance(Top_Token, Token_Comment):
            return False
        Parent_Elements.extend([Top_Token])
        self.Consume_Token()
        return True
    def Parse_Program(self, Parent_Elements):
        # comment 'sequence Program';
        Start = self.Position
        My_Elements = []
        # comment 'repeating Rule';
        if not self.Parse_Rule(My_Elements):
            return False
        while True:
            if not self.Parse_Rule(My_Elements):
                break
        End = self.Position
        Element = Program()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Rule(self, Parent_Elements):
        # comment 'either Rule';
        if self.Parse_Sequence_Rule(Parent_Elements):
            return True
        if self.Parse_Either_Rule(Parent_Elements):
            return True
        if self.Parse_Ending_Comment(Parent_Elements):
            return True
        return False
    def Parse_Sequence_Rule(self, Parent_Elements):
        # comment 'sequence Sequence_Rule';
        Start = self.Position
        My_Elements = []
        if not self.Parse_Rule_Name(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Sequence_Rule expected Rule_Name.")
            return False
        if not self.Parse_Token(My_Elements, "::="):
            zdebug.zbreak()
            self.Rollback(Start, "Sequence_Rule expected "  +  "::="  +  ".")
            return False
        # comment 'repeating Term';
        if not self.Parse_Term(My_Elements):
            return False
        while True:
            if not self.Parse_Term(My_Elements):
                break
        if not self.Parse_Line_End(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Sequence_Rule expected Line_End.")
            return False
        End = self.Position
        Element = Sequence_Rule()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Either_Rule(self, Parent_Elements):
        # comment 'sequence Either_Rule';
        Start = self.Position
        My_Elements = []
        if not self.Parse_Rule_Name(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Either_Rule expected Rule_Name.")
            return False
        if not self.Parse_Token(My_Elements, "::="):
            zdebug.zbreak()
            self.Rollback(Start, "Either_Rule expected "  +  "::="  +  ".")
            return False
        if not self.Parse_Term(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Either_Rule expected Term.")
            return False
        # comment 'repeating Either_Tail';
        if not self.Parse_Either_Tail(My_Elements):
            return False
        while True:
            if not self.Parse_Either_Tail(My_Elements):
                break
        if not self.Parse_Line_End(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Either_Rule expected Line_End.")
            return False
        End = self.Position
        Element = Either_Rule()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Either_Tail(self, Parent_Elements):
        # comment 'sequence Either_Tail';
        Start = self.Position
        My_Elements = []
        if not self.Parse_Token(My_Elements, "|"):
            zdebug.zbreak()
            self.Rollback(Start, "Either_Tail expected "  +  "|"  +  ".")
            return False
        if not self.Parse_Term(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Either_Tail expected Term.")
            return False
        End = self.Position
        Element = Either_Tail()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Term(self, Parent_Elements):
        # comment 'either Term';
        if self.Parse_Token_Quote(Parent_Elements):
            return True
        if self.Parse_Rule_Name(Parent_Elements):
            return True
        return False
    def Parse_Rule_Name(self, Parent_Elements):
        # comment 'sequence Rule_Name';
        Start = self.Position
        My_Elements = []
        if not self.Parse_Token(My_Elements, "<"):
            zdebug.zbreak()
            self.Rollback(Start, "Rule_Name expected "  +  "<"  +  ".")
            return False
        if not self.Parse_Name_Token(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Rule_Name expected Name_Token.")
            return False
        if not self.Parse_Token(My_Elements, ">"):
            zdebug.zbreak()
            self.Rollback(Start, "Rule_Name expected "  +  ">"  +  ".")
            return False
        End = self.Position
        Element = Rule_Name()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Line_End(self, Parent_Elements):
        # comment 'either Line_End';
        if self.Parse_Ending_Comment(Parent_Elements):
            return True
        if self.Parse_Ending_Line(Parent_Elements):
            return True
        return False
    def Parse_Ending_Comment(self, Parent_Elements):
        # comment 'sequence Ending_Comment';
        Start = self.Position
        My_Elements = []
        if not self.Parse_Token_Comment(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Ending_Comment expected Token_Comment.")
            return False
        # comment 'optional.repeating [line]';
        while True:
            if not self.Parse_Token(My_Elements, '\n'):
                break
        End = self.Position
        Element = Ending_Comment()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Ending_Line(self, Parent_Elements):
        # comment 'sequence Ending_Line';
        Start = self.Position
        My_Elements = []
        # comment 'repeating [line]';
        if not self.Parse_Token(My_Elements, '\n'):
            return False
        while True:
            if not self.Parse_Token(My_Elements, '\n'):
                break
        End = self.Position
        Element = Ending_Line()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Infer_Tokens(self):
        O = self.Owner
        Verbose = False
        if Verbose:
            print('TOKENIZE BNF BEGIN')
        Ignore = None
        Mode = None
        C = None
        Next = None
        Q = ''
        Position = None
        Input = str(self.Owner.Input.Symbol_Value)
        if Verbose:
            print("Input: ", Input, sep='')
        Last = len(Input) - 1
        Mode = 'Initial'
        T = None
        for Position in range(0, Last+1):
            Next = Input[Position:(Position)+(2)]
            C = Next[0]
            if Verbose:
                print(Mode, ' [', C, ']', sep='')
            if Position == Last:
                Next = ''
            else:
                Next = Next[-1]
            if str(Mode) == 'Initial':
                pass
            elif str(Mode) == 'Quote':
                T.Input += str(C)
                T.Location.End_Position = Position
                if self.Balanced_Quotes(Q, C):
                    Mode = 'Initial'
                    continue
            elif str(Mode) == 'Whitespace':
                if str(C) == str('\n'):
                    Mode = 'Initial'
                elif not(re.match(r"\S",C)):
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                Mode = 'Initial'
            elif str(Mode) == 'Number':
                if C in '0123456789.':
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                Mode = 'Initial'
            elif str(Mode) == 'Name':
                if C.isalpha() or C in "0123456789_":
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
                else:
                    Mode = 'Initial'
            elif str(Mode) == 'Keyword':
                if not(re.match(r"\S",C)) or C in "|:#":
                    Mode = 'Initial'
                elif C in '`"' or "'" == str(C):
                    Mode = 'Initial'
                else:
                    T.Input += str(C)
                    T.Location.End_Position = Position
                    continue
            elif str(Mode) == 'Comment':
                if str(C) == str('\n'):
                    Mode = 'Initial'
                    continue
            elif str(Mode) == 'Token':
                zdebug.zbreak()
                # comment 'This should not occur?';
            else:
                zdebug.zbreak()
                raise Exception('Unknown Token Mode ' + str(Mode))
            if str(Mode) == 'Initial':
                if str(C) == "'" or C in '"`«‘“‹':
                    Q = C
                    T = Token_Quote(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Quote'
                if C in '|:=':
                    T = Token_Keyword(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Keyword'
                if C in '#;':
                    T = Token_Comment(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Comment'
                elif C in '~!@$%^&*_-+{[()]}\\;?,./':
                    T = Token_Token(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif '<' == str(C):
                    T = Token_Name_Special(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Name_Special'
                elif str(C) == str('\n'):
                    T = Token_Token(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif not(re.match(r"\S",C)):
                    T = Token_Whitespace(self, C, Position, Position)
                    # comment 'Whitespace tokens are not appended to the token list.= ModeWhitespace';
                elif C.isupper() or C.islower():
                    T = Token_Name(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Name'
                elif C in '01234567890' or C in '-.' and Next in '01234567890':
                    T = Token_Number(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Number'
                else:
                    zdebug.zbreak()
                    T = Token_Token(self, C, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
        if Verbose:
            Position = 0
            for T in self.Tokens.Symbol_Value:
                print(Position, ' ', T.__class__.__name__, ' ', T.Input, sep='')
                Position += 1
        if Verbose:
            print('TOKENIZE BNF END')
        return True
class ANTLR_BNF_Parser (Parser):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
        self.Dialect = Dialect_Gs()
    def propinit(self):
        self.Dialect = Dialect_BNF
        self.Inferences = List(self)
        self.Tokens = List(self)
        self.Elements = List(self)
        self.Position = 0
        self.Dialect = Dialect_Gs
        self.Inferences = List(self)
        self.Tokens = List(self)
        self.Elements = List(self)
        self.Position = 0
    def Initialize(self):
        Verbose = True
        if Verbose:
            print(self.__class__.__name__, 'Inits', sep='')
        self.Dialect.Initialize()
        self.Inferences.Symbol_Value.extend([Inference_Tokens(self)])
        self.Inferences.Symbol_Value.extend([Inference_Elements(self)])
        return True
    def Initialize(self):
        Verbose = True
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Dialect.Initialize()
        self.Inferences.Symbol_Value.extend([Inference_Tokens(self)])
        self.Inferences.Symbol_Value.extend([Inference_Elements(self)])
        return True
    def Infer_Tokens(self):
        O = self.Owner
        Verbose = True
        Ignore = None
        Mode = None
        C = None
        Next = None
        Q = ''
        Position = None
        Input = str(self.Owner.Input.Symbol_Value)
        if Verbose:
            print("Input: ", Input, sep='')
        Last = len(Input) - 1
        Mode = 'Initial'
        T = None
        Field_Boundaries = str('\n') + ',' + '"'
        for Position in range(0, Last+1):
            Next = Input[Position:(Position)+(2)]
            C = Next[0]
            if Verbose:
                print(Mode, ' [', C, ']', sep='')
            if Position == Last:
                Next = ''
            else:
                Next = Next[-1]
            if str(Mode) == 'Initial':
                # comment 'skip other handlers';
                pass
            elif str(Mode) == 'Field':
                if Char in Field_Boundaries:
                    def Parse_mode(self, Parent_Elements):
                        Top_Token = self.Top_Token()
                        if not isinstance(Top_Token, mode):
                            return False
                        Parent_Elements.extend([Top_Token])
                        self.Consume_Token()
                        return True
                else:
                    def Parse_append(self, Parent_Elements):
                        Top_Token = self.Top_Token()
                        if not isinstance(Top_Token, append):
                            return False
                        Parent_Elements.extend([Top_Token])
                        self.Consume_Token()
                        return True
            elif str(Mode) == 'Quote':
                def Parse_append(self, Parent_Elements):
                    Top_Token = self.Top_Token()
                    if not isinstance(Top_Token, append):
                        return False
                    Parent_Elements.extend([Top_Token])
                    self.Consume_Token()
                    return True
                if str(Char) == '\\' and str(Next) == '"':
                    def Parse_mode(self, Parent_Elements):
                        Top_Token = self.Top_Token()
                        if not isinstance(Top_Token, mode):
                            return False
                        Parent_Elements.extend([Top_Token])
                        self.Consume_Token()
                        return True
                    continue
                if str(Char) == '"' and str(Next) == '"':
                    def Parse_mode(self, Parent_Elements):
                        Top_Token = self.Top_Token()
                        if not isinstance(Top_Token, mode):
                            return False
                        Parent_Elements.extend([Top_Token])
                        self.Consume_Token()
                        return True
                    continue
                if str(Char) == '"':
                    def Parse_mode(self, Parent_Elements):
                        Top_Token = self.Top_Token()
                        if not isinstance(Top_Token, mode):
                            return False
                        Parent_Elements.extend([Top_Token])
                        self.Consume_Token()
                        return True
                    continue
            elif str(Mode) == 'Escape_Quote':
                def Parse_append(self, Parent_Elements):
                    Top_Token = self.Top_Token()
                    if not isinstance(Top_Token, append):
                        return False
                    Parent_Elements.extend([Top_Token])
                    self.Consume_Token()
                    return True
                def Parse_mode(self, Parent_Elements):
                    Top_Token = self.Top_Token()
                    if not isinstance(Top_Token, mode):
                        return False
                    Parent_Elements.extend([Top_Token])
                    self.Consume_Token()
                    return True
                continue
            else:
                zdebug.zbreak()
                raise Exception('Unknown Token Mode ' + str(Mode))
            # comment 'this must go at the end to allow other handlers to delegate to Initial mode.';
            if str(Mode) == 'Initial':
                if str(Char) == '/' and str(Next) == '*':
                    T = Token_Comment(self, Char, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Comment'
                elif Char in ":;()?+*|()[]{}<->~":
                    T = Token_Punct(self, Char, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Initial'
                elif str(Char) == '"' or str(Char) == '`' or str(Char) == "'":
                    T = Token_Quote(self, Char, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Quote'
                elif str(Char) == '\\':
                    T = Token_Escape(self, Char, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Escape'
                elif Char.isalpha() or Char in "0123456789_":
                    T = Token_Ident(self, Char, Position, Position)
                    self.Tokens.Symbol_Value.extend([T])
                    Mode = 'Ident'
                elif not(re.match(r"\S",Char)):
                    T = Token_Whitespace(self, Char, Position, Position)
                    # comment 'Whitespace tokens are not appended to the token list.';
                    Mode = 'Whitespace'
                else:
                    zdebug.zbreak()
        if Verbose:
            Position = 0
            for T in self.Tokens.Symbol_Value:
                if Verbose:
                    print(Position, ' ', T.__class__.__name__, ' ', T.Input, sep='')
                Position += 1
    def Parse_Program(self, Parent_Elements):
        # comment 'either Program';
        if self.Parse_EBNF_Rulelist(Parent_Elements):
            return True
        return False
    def Parse_EBNF_Rulelist(self, Parent_Elements):
        # comment 'sequence EBNF_Rulelist';
        Start = self.Position
        My_Elements = []
        # comment 'optional.repeating EBNF_Rule';
        while True:
            if not self.Parse_EBNF_Rule(My_Elements):
                break
        if not self.Parse_EOF(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Rulelist expected EOF.")
            return False
        End = self.Position
        Element = EBNF_Rulelist()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_EBNF_Rule(self, Parent_Elements):
        # comment 'sequence EBNF_Rule';
        Start = self.Position
        My_Elements = []
        if not self.Parse_EBNF_Lhs(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Rule expected EBNF_Lhs.")
            return False
        if not self.Parse_Token(My_Elements, ':'):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Rule expected "  +  ':'  +  ".")
            return False
        if not self.Parse_EBNF_Rhs(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Rule expected EBNF_Rhs.")
            return False
        End = self.Position
        Element = EBNF_Rule()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_EBNF_Lhs(self, Parent_Elements):
        # comment 'either EBNF_Lhs';
        if self.Parse_EBNF_ID(Parent_Elements):
            return True
        return False
    def Parse_EBNF_Rhs(self, Parent_Elements):
        # comment 'either EBNF_Rhs';
        if self.Parse_EBNF_Alternatives(Parent_Elements):
            return True
        return False
    def Parse_EBNF_Alternatives(self, Parent_Elements):
        # comment 'sequence EBNF_Alternatives';
        Start = self.Position
        My_Elements = []
        if not self.Parse_EBNF_Alternative(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Alternatives expected EBNF_Alternative.")
            return False
        # comment 'optional.repeating EBNF_Bar_Tail';
        while True:
            if not self.Parse_EBNF_Bar_Tail(My_Elements):
                break
        End = self.Position
        Element = EBNF_Alternatives()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_EBNF_Alternative(self, Parent_Elements):
        # comment 'either EBNF_Alternative';
        # comment 'optional.repeating EBNF_Element';
        while True:
            if not self.Parse_EBNF_Element(My_Elements):
                break
        return False
    def Parse_EBNF_Element(self, Parent_Elements):
        # comment 'either EBNF_Element';
        if self.Parse_EBNF_Optional(Parent_Elements):
            return True
        if self.Parse_EBNF_Zeroormore(Parent_Elements):
            return True
        if self.Parse_EBNF_Text(Parent_Elements):
            return True
        if self.Parse_EBNF_ID(Parent_Elements):
            return True
        return False
    def Parse_EBNF_Optional(self, Parent_Elements):
        # comment 'sequence EBNF_Optional';
        Start = self.Position
        My_Elements = []
        if not self.Parse_EBNF_REND(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Optional expected EBNF_REND.")
            return False
        if not self.Parse_EBNF_Alternatives(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Optional expected EBNF_Alternatives.")
            return False
        if not self.Parse_EBNF_LEND(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Optional expected EBNF_LEND.")
            return False
        End = self.Position
        Element = EBNF_Optional()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_EBNF_Zeroormore(self, Parent_Elements):
        # comment 'sequence EBNF_Zeroormore';
        Start = self.Position
        My_Elements = []
        if not self.Parse_EBNF_RBRACE(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Zeroormore expected EBNF_RBRACE.")
            return False
        if not self.Parse_EBNF_Alternatives(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Zeroormore expected EBNF_Alternatives.")
            return False
        if not self.Parse_EBNF_LBRACE(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_Zeroormore expected EBNF_LBRACE.")
            return False
        End = self.Position
        Element = EBNF_Zeroormore()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_Oneormore(self, Parent_Elements):
        # comment 'sequence Oneormore';
        Start = self.Position
        My_Elements = []
        if not self.Parse_EBNF_RPAREN(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Oneormore expected EBNF_RPAREN.")
            return False
        if not self.Parse_EBNF_Alternatives(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Oneormore expected EBNF_Alternatives.")
            return False
        if not self.Parse_EBNF_LPAREN(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "Oneormore expected EBNF_LPAREN.")
            return False
        End = self.Position
        Element = Oneormore()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_EBNF_Text(self, Parent_Elements):
        # comment 'either EBNF_Text';
        if self.Parse_EBNF_ID(Parent_Elements):
            return True
        return False
    def Parse_EBNF_ID(self, Parent_Elements):
        # comment 'sequence EBNF_ID';
        Start = self.Position
        My_Elements = []
        if not self.Parse_EBNF_LT(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_ID expected EBNF_LT.")
            return False
        if not self.Parse_EBNF_Ruleid(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_ID expected EBNF_Ruleid.")
            return False
        if not self.Parse_EBNF_GT(My_Elements):
            zdebug.zbreak()
            self.Rollback(Start, "EBNF_ID expected EBNF_GT.")
            return False
        End = self.Position
        Element = EBNF_ID()
        Element.Start_Position = Start
        Element.End_Position = End
        Element.Document = self
        Element.Elements = My_Elements
        self.Add_Element(Element)
        Parent_Elements.extend([Element])
        return True
    def Parse_EBNF_Ruleid(self, Parent_Elements):
        # comment 'either EBNF_Ruleid';
        if self.Parse_EBNF_ID(Parent_Elements):
            return True
        return False
class EBNF (Element):
    pass
class EBNF_Rulelist (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Rule (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Lhs (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Rhs (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Alternatives (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Alternative (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Bar_Tail (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_BAR (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Element (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Optional (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Zeroormore (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Text (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_ID (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_REND (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_LEND (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_LT (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_GT (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_Ruleid (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_RBRACE (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_LBRACE (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_RPAREN (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class EBNF_LPAREN (EBNF):
    def Infer_(self):
        Input = str(self.Get_Input())
        zdebug.zbreak()
class Bnf_Gs_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Gs(self)])
        return True
class Inference_Bnf_Gs (Inference):
    def Infer(self):
        if not self.Owner.Infer_Bnf_Gs():
            return False
        return True
class Inference_Mumps (Inference):
    def Infer(self):
        if not self.Owner.Infer_Mumps():
            return False
        return True
class Mumps:
    Label_Number = 0
    Variable_Number = 0
    Current_Class = None
    @classmethod
    def Get_Label(cls):
        Mumps.Label_Number += 1
        Label = 'L' + str(Mumps.Label_Number)
        return Label
    @classmethod
    def Get_Variable(cls):
        Mumps.Variable_Number += 1
        Var_Ref = '%(' + str(Mumps.Variable_Number) + ')'
        return Var_Ref
    @classmethod
    def Get_Reference(cls, Mumps):
        Verbose = True
        if str(Mumps[0:(0)+(5)]) == '$name':
            return Mumps
        Code = '$name(' + str(Mumps) + ')'
        if Verbose:
            print('Mumps:Get_Reference ', Mumps, sep='')
        return Code
    @classmethod
    def De_Reference(cls, Mumps):
        Code = '@(' + str(Mumps) + ')'
        return Code
    @classmethod
    def Add_Subscripts(cls, Root, Subscripts):
        Code = '@' + str(Root) + '@(' + str(Subscripts) + ')'
        return Code
    @classmethod
    def Glvn(cls, Input):
        Verbose = False
        if Verbose:
            print('          >>> glvn ', Input, sep='')
        return Input
    @classmethod
    def String(cls, Input):
        Verbose = False
        Code = str(Input)
        if str(Code[0]) == '@':
            Code = '$name('  +  Code  +  ')'
        if Verbose:
            print('          >>> string ', Code, sep='')
        return Code
class Mumps_File (File):
    def Say(self):
        Verbose = False
        Parent = self.Symbol_Object
        Generator = Parent.Generator
        Elements = Generator.Elements.Symbol_Value
        Elem = None
        Imp = None
        Class_Name = None
        File_Name = None
        Genfile = None
        for Elem in Elements:
            Imp = Elem.Classification
            if (Imp in (None, "")):
                continue
            Genfile = isinstance(Imp, Class_Statement) or isinstance(Imp, Statement_Module)
            if not Genfile:
                continue
            Mumps.Current_Class = Imp
            Imp.Re_Mumps()
            try:
                Class_Name = Imp.Name.Mumps
            except Exception as Error:
                Class_Name = Imp.Class_Name
            File_Name = '/tmp/ramdisk/m/'  +  Class_Name  +  '.m'
            try:
                if Verbose:
                    print("Writing ", File_Name, sep='')
                _FH = open(File_Name, "w")
                _FH.write(Imp.Mumps)
                _FH.close()
            except Exception as Error:
                print("ERROR: ", Error, " creating file ", File_Name, sep='')
        return True
class Mumps_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Language_Name = 'Mumps'
        self.Property_Name = 'Mumps'
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Mumps(self)])
        return True
    def Infer_Mumps(self):
        self.Compiled_Inheritance()
        Verbose = True
        Elem = None
        I = None
        Number = 0
        Error = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Mumps()
                Elem.Mumps = I.Mumps
                Number += 1
                if str(I.Mumps_Outer_Declaration) > "":
                    if Verbose:
                        print("Found Outer Declaration", '\n', I.Mumps_Outer_Declaration, sep='')
            except Exception as Error:
                self.Status = False
                # comment 'debug';
                Elem.Error = Error
                if Verbose:
                    print('Error mumps element ', Number, ': ', I.__class__.__name__, ', <', Error, '>', ', source ', I.Get_Input(), sep='')
        if not self.Status:
            print("Error Stack")
            for Elem in self.Elements.Symbol_Value:
                I = Elem.Classification
                I.Infer_Mumps()
                Elem.Mumps = I.Mumps
                Number += 1
            return False
        Top = self.Elements.Symbol_Value[-1]
        Top.Infer_Mumps()
        Code = str(Top.Mumps)
        self.Mumps = Code
        self.Code = Code
        return True
# comment ‘“ (append `` [line] `class.append ~ { method flag Infer_Mumps` [line] `{` [line] `    verbosity [true];` [line] `    string Code 'todo';` [line] `    debug;` [line] `    verbose "    ~ " Code;` [line] `    my= Mumps Code;` [line] `}}` [line] ``) ”’;
class Goal_Raku (Goal):
    pass
class Spell_Raku (Spell):
    pass
class Raku_Parser:
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
        self.Dialect = Dialect_Gs()
    def propinit(self):
        self.Dialect = Dialect_Gs
        self.Inferences = List(self)
        self.Tokens = List(self)
        self.Elements = List(self)
        self.Position = 0
    def Initialize(self):
        Verbose = True
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Dialect.Initialize()
        return True
class Raku_Generator (Generator):
    def __init__(self, Owner):
        super().__init__()
        self.propinit()
        self.Owner = Owner
    def propinit(self):
        self.Language_Name = 'Raku'
        self.Property_Name = 'Raku'
        self.Elements = List(self)
        self.Inferences = List(self)
    def Initialize(self):
        Verbose = False
        if Verbose:
            print(self.__class__.__name__, ' Inits', sep='')
        self.Inferences.Symbol_Value.extend([Inference_Raku(self)])
        return True
    def Infer_Raku(self):
        Verbose = False
        Elem = None
        I = None
        Number = 0
        Error = None
        for Elem in self.Elements.Symbol_Value:
            try:
                I = Elem.Classification
                I.Infer_Raku()
                Elem.Raku = I.Raku
                Number += 1
            except Exception as Error:
                self.Status = False
                Elem.Error = Error
                if Verbose:
                    print('Error raku element ', Number, ': ', I.__class__.__name__, ', <', Error, '>, source ', I.Get_Input(), sep='')
        if not self.Status:
            return False
        Top = self.Elements.Symbol_Value[-1]
        Top.Infer_Raku()
        Code = str(Top.Raku)
        self.Raku = Code
        self.Code = Code
        return True
class Inference_Raku (Inference):
    def Infer(self):
        if not self.Owner.Infer_Raku():
            return False
        return True
class Variable_Statement (Line_Statement):
    Variable_Number = 0
    def __init__(self):
        super().__init__()
        self.Variable_Name = ''
    def Generate(self):
        self.Infer_Fallback()
        self.Gal = self.Fallback
        self.Code = self.Fallback
    def Inner_Code(self):
        self.Generate()
        Arg = None
        Code = ''
        Child_Code = None
        for Arg in self.Arguments:
            if isinstance(Arg, Name):
                continue
            if isinstance(Arg, Variable_Statement):
                Child_Code = Arg.Inner_Code()
                Code += str(Child_Code)
            else:
                zdebug.zbreak()
        Code += str("    ") + str(self.Fallback) + str('\n')
        return Code
    def Generate_Implementer(self):
        Code = str(self.Inner_Code()) + str("    ") + 'return ' + str(self.Variable_Name) + ';'
        return Code
    def Unique_Variable(self):
        if str(self.Variable_Name) == '':
            Variable_Statement.Variable_Number += 1
            Text = str(self.Variable_Prefix) + str(Variable_Statement.Variable_Number)
            self.Variable_Name = Text
        return self.Variable_Name
    def Wipe_Variables(self):
        self.Variable_Name = ''
        self.Definition = ''
        Arg = None
        for Arg in self.Arguments:
            Arg.Wipe_Variables()
    def Expression_Generate(self):
        if (self.Expression in (None, "")):
            Prefix = str(self.Unique_Variable()) + ' = '
            Expression = str(self.Code)
            Expression = Expression.replace(Prefix, '')
            self.Expression = Expression
        if (self.Reference in (None, "")):
            self.Reference = self.Unique_Variable()
    def Is_Expression(self):
        return True
class Flag_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'F'
        self.Data_Type = 'flag'
class Integer_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'I'
        self.Data_Type = 'integer'
class Number_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'N'
        self.Data_Type = 'number'
class String_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'S'
        self.Data_Type = 'string'
class List_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'L'
        self.Data_Type = 'list'
class Dictionary_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'D'
        self.Data_Type = 'dictionary'
class Object_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'O'
        self.Data_Type = 'object'
class Variant_Variable_Statement (Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Variable_Prefix = 'V'
        self.Data_Type = 'variant'
class Statement_Variable_Dot (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string .'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + '.' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.' + str(self.Op2.Unique_Variable()) + ';'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'object':
            return False
        if str(Preds[1].Data_Type) != 'property':
            return False
        return True
class Statement_Variable_And (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag and'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' and ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' and ' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' && ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' && ' + str(self.Op2.Unique_Variable()) + ';'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'flag':
            return False
        if str(Preds[1].Data_Type) != 'flag':
            return False
        return True
class Statement_Variable_Or (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag or'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' or ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' or ' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' || ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' || ' + str(self.Op2.Unique_Variable()) + ';'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'flag':
            return False
        if str(Preds[1].Data_Type) != 'flag':
            return False
        return True
class Statement_Variable_Not (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag not'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (not ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = not ' + str(self.Op1.Reference)
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = !' + str(self.Op1.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = !' + str(self.Op1.Unique_Variable()) + ';'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'flag':
            return False
        return True
class Statement_Variable_Append (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string append'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' append ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' + ' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' + ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'char* ' + str(self.Unique_Variable()) + ' = ' + 'strcat(' + str(self.Op1.Unique_Variable()) + ', ' + str(self.Op2.Unique_Variable()) + ');'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Firstchar (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string firstchar'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.Unique_Variable()) + ' (firstchar ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[0]'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.charAt(0);'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'char ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[0];'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Lastchar (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string lastchar'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.Unique_Variable()) + ' (lastchar ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[-1]'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.charAt(' + str(self.Op1.Unique_Variable()) + '.length -1);'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'char ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[strlen(' + str(self.Op1.Unique_Variable()) + ')-1];'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Lowercase (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string lowercase'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.Unique_Variable()) + ' (lowercase ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.lower()'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + 'toLowerCase();'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'for(int i = 0; Op1[i]; i++) { Op1[i] = tolower(Op1[i]); }'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Uppercase (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string uppercase'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.Unique_Variable()) + ' (uppercase ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.upper()'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.toUpperCase();'
        self.Javascript = Code
    def Infer_C(self):
        Code = str('for(int i = 0; Op1[i]; i++)'  +  '\n'  +  '        {'  +  '\n'  +  '            Op1[i] = toupper(Op1[i]);'  +  '\n'  +  '        }')
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Titlecase (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string titlecase'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.Unique_Variable()) + ' (titlecase ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.title()'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = goalspell.titlecase(' + str(self.Op1.Unique_Variable()) + ');'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'todo'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Substring (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string substring'
        self.String_Value = Argument(self)
        self.Start_Index = Argument(self)
        self.Length = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument String_Value')
        self.String_Value = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Start_Index')
        self.Start_Index = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Length = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.String_Value.Unique_Variable()) + ' ' + str(self.Start_Index.Unique_Variable())
        if self.Length is not None:
            Code += ' ' + str(self.Length.Reference)
        Code += ');'
        self.Fallback = Code
    def Infer_Python(self):
        SVal = str(self.String_Value.Unique_Variable())
        Start = str(self.Start_Index.Unique_Variable())
        Code = str(self.Unique_Variable()) + ' = '
        if self.Length is not None:
            Len = str(self.Length.Reference)
            if str(Len) == '1':
                Code += str(SVal  +  '['  +  Start  +  ']')
            else:
                Code += str(SVal  +  '['  +  Start  +  ':('  +  Start  +  ')+('  +  Len  +  ')]')
        else:
            Code += str(SVal  +  '['  +  Start  +  ':]')
        self.Python = Code
    def Infer_Javascript(self):
        Code = str(self.String_Value.Unique_Variable()) + '.substr(' + str(self.Start_Index.Unique_Variable())
        if self.Length is not None:
            Code += ', ' + str(self.Length.Reference)
        Code += ');'
        self.Javascript = Code
    def Infer_C(self):
        # comment `TODO: "substring functions seem complicated in C, I'm going to wait to do this one"`;
        pass
    def Can(self, Preds):
        if len(Preds) < 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'integer':
            return False
        if len(Preds) == 2:
            return True
        if str(Preds[2].Data_Type) != 'integer':
            return False
        if len(Preds) == 3:
            return True
        return False
class Statement_Variable_Begins (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag begins'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' begins ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[: len(' + str(self.Op2.Unique_Variable()) + ')] == ' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.substr(0, ' + str(self.Op2.Unique_Variable()) + '.length -1) == ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = strncmp(' + str(self.Op2.Unique_Variable()) + ', ' + str(self.Op1.Unique_Variable()) + ', strlen(' + str(self.Op2.Unique_Variable()) + ')) == 0;'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Contains (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag contains'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' contains ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op2.Unique_Variable()) + ' in ' + str(self.Op1.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.includes(' + str(self.Op2.Unique_Variable()) + ');'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = strstr(' + str(self.Op1.Unique_Variable()) + ', ' + str(self.Op2.Unique_Variable()) + ');'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Is_Null (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag isnull'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (is null ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + " in (None, '')"
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' == null || ' + str(self.Op1.Unique_Variable()) + " == '';"
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' == NULL;'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Is_Number (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag isnumber'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (is_number ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'isinstance(' + str(self.Op1.Unique_Variable()) + ', (int, float, complex))'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + '(typeof ' + str(self.Op1.Unique_Variable()) + " === 'number');"
        self.Javascript = Code
    # comment "TODO: 'come back to this'";
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = '
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Is_Punct (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag ispunct'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (is punct ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' in string.punctuation'
        self.Python = Code
    # comment "TODO: javascript 'write statement in Javascript.gal' 'TODO'";
    def Infer_C(self):
        Code = 'TODO'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Is_String (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag isstring'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (is string ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'isinstance(' + str(self.Op1.Unique_Variable()) + ', str)'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + '(typeof ' + str(self.Op1.Unique_Variable()) + " === 'string');"
        self.Javascript = Code
    # comment "TODO: 'come back to this'";
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = '
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Is_Uppercase (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag isupper'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (isupper ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.isupper()'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.match(/[A-Z]/);'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' >= A && ' + str(self.Op1.Unique_Variable()) + " <= 'Z';"
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Is_Lowercase (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag islower'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (islower ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.islower()'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.match(/[a-z]/);'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' >= a && ' + str(self.Op1.Unique_Variable()) + " <= 'z';"
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Is_Whitespace (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag iswhitespace'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (is whitespace ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = (' + str(self.Op1.Unique_Variable()) + " in ' \\n\\r\\t')"
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + "' \\t\\n\\r'.includes(" + str(self.Op1.Unique_Variable()) + ');'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = isspace(' + str(self.Op1.Unique_Variable()) + ');'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Not_Null (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag notnull'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (not (is null ' + str(self.Op1.Unique_Variable()) + '));'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + " > ''"
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + '(' + str(self.Op1.Unique_Variable()) + ' != null && ' + str(self.Op1.Unique_Variable()) + " > '');"
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' != NULL;'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_String_Equal (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag s='
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' s= ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'str(' + str(self.Op1.Unique_Variable()) + ') == str(' + str(self.Op2.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.toString() == ' + str(self.Op2.Unique_Variable()) + '.toString();'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = strcmp(' + str(self.Op1.Unique_Variable()) + ', ' + str(self.Op2.Unique_Variable()) + ');'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_String_Greater (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag sgt'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' sgt ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'str(' + str(self.Op1.Unique_Variable()) + ') > str(' + str(self.Op2.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.toString() > ' + str(self.Op2.Unique_Variable()) + '.toString();'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = '
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_String_Not_Equal (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag sne'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' sne ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'str(' + str(self.Op1.Unique_Variable()) + ') != str(' + str(self.Op2.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.toString() != ' + str(self.Op2.Unique_Variable()) + '.toString();'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = !(strcmp(' + str(self.Op1.Unique_Variable()) + ', ' + str(self.Op2.Unique_Variable()) + '));'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Char2int (Integer_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'integer char2int'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'integer ' + str(self.Unique_Variable()) + ' (chartoint ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'ord(' + str(self.Op1.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.charCodeAt(0);'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'int ' + str(self.Unique_Variable()) + ' = int ' + str(self.Op1.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ';'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_String_Length (Integer_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'integer length'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'integer ' + str(self.Unique_Variable()) + ' (length ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'len(' + str(self.Op1.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.length;'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'int ' + str(self.Unique_Variable()) + ' = strlen(' + str(self.Op1.Unique_Variable()) + ');'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_Equal (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag =='
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' = ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' == ' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' == ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' == ' + str(self.Op2.Unique_Variable())
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) == 'number':
            return False
        if str(Preds[1].Data_Type) == 'number':
            return False
        return True
class Statement_Variable_Greater (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag gt'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' gt ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' > ' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' > ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' > ' + str(self.Op2.Unique_Variable())
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) == 'number':
            return False
        if str(Preds[1].Data_Type) == 'number':
            return False
        return True
class Statement_Variable_Less (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag lt'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (' + str(self.Op1.Unique_Variable()) + ' lt ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' lt ' + str(self.Op2.Unique_Variable())
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' lt ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' lt ' + str(self.Op2.Unique_Variable())
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) == 'number':
            return False
        if str(Preds[1].Data_Type) == 'number':
            return False
        return True
class Statement_Variable_List_Split (List_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'list split'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'list ' + str(self.Unique_Variable()) + ' (split ' + str(self.Op1.Unique_Variable()) + ' ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.split(' + str(self.Op2.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.split(' + str(self.Op2.Unique_Variable()) + ');'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'char* ' + str(self.Unique_Variable()) + ' = '
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'string':
            return False
        if str(Preds[1].Data_Type) != 'string':
            return False
        return True
class Statement_Variable_List_Get (Variant_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'variant list get'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'variant ' + str(self.Unique_Variable()) + ' (list get ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[' + str(self.Op2.Unique_Variable()) + ']'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[' + str(self.Op2.Unique_Variable()) + '];'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'char ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[' + str(self.Op2.Unique_Variable()) + '];'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'list':
            return False
        if str(Preds[1].Data_Type) != 'integer':
            return False
        return True
class Statement_Variable_List_Last (Variant_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'variant list last'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'variant ' + str(self.Unique_Variable()) + ' (list last ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Op1.Unique_Variable()) + '[-1]'
        self.Python = Code
    def Infer_Javascript(self):
        Code = str(self.Op1.Unique_Variable()) + '.slice(-1)'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'char ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '[sizeof(' + str(self.Op1.Unique_Variable()) + ')-1];'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'list':
            return False
        return True
class Statement_Variable_List_Length (Integer_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'integer list length'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'integer ' + str(self.Unique_Variable()) + ' (list length ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'len(' + str(self.Op1.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + '.length;'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'int ' + str(self.Unique_Variable()) + ' = sizeof(' + str(self.Op1.Unique_Variable()) + ');'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'list':
            return False
        return True
class Statement_Variable_Isa (Flag_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'flag isa'
        self.Op1 = Argument(self)
        self.Op2 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op2')
        self.Op2 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'flag ' + str(self.Unique_Variable()) + ' (isa ' + str(self.Op1.Unique_Variable()) + ' ' + str(self.Op2.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = str(self.Unique_Variable()) + ' = ' + 'isinstance(' + str(self.Op1.Unique_Variable()) + ', Main_Module.' + str(self.Op2.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ' instanceof ' + str(self.Op2.Unique_Variable()) + ';'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'bool ' + str(self.Unique_Variable()) + ' = '
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 2:
            return False
        if str(Preds[0].Data_Type) != 'object':
            return False
        if str(Preds[1].Data_Type) != 'class':
            return False
        return True
class Statement_Variable_Int2char (String_Variable_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'string int2char'
        self.Op1 = Argument(self)
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Op1')
        self.Op1 = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Code = 'string ' + str(self.Unique_Variable()) + ' = (int2char ' + str(self.Op1.Unique_Variable()) + ');'
        self.Fallback = Code
    def Infer_Python(self):
        Code = 'chr(' + str(self.Op1.Unique_Variable()) + ')'
        self.Python = Code
    def Infer_Javascript(self):
        Code = 'var ' + str(self.Unique_Variable()) + ' = String.fromCharCode(' + str(self.Op1.Unique_Variable()) + ');'
        self.Javascript = Code
    def Infer_C(self):
        Code = 'char ' + str(self.Unique_Variable()) + ' = char ' + str(self.Op1.Unique_Variable()) + ' = ' + str(self.Op1.Unique_Variable()) + ';'
        self.C = Code
    def Can(self, Preds):
        if len(Preds) != 1:
            return False
        if str(Preds[0].Data_Type) != 'integer':
            return False
        return True
# comment '**************[line]* Parallel.txt [line]**************';
class Statement_Abstract (Scoped_Statement):
    def __init__(self):
        super().__init__()
        self.Keyword = 'abstract'
        self.Name = Argument(self)
        self.Default_Keyword = None
        self.Ancestor = None
    def Attributes(self):
        if len(self.Listargs) == 0:
            raise Exception('missing required argument Name')
        self.Name = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Default_Keyword = self.Listargs.pop(0)
        if len(self.Listargs) > 0:
            self.Ancestor = self.Listargs.pop(0)
    def Infer_Fallback(self):
        Name = str(self.Name.Fallback)
        Default_Keyword = str(self.Default_Keyword.Fallback)
        Ancestor = str(self.Ancestor.Fallback)
        Class_Declaration = 'class ' + str(Name) + ' [is ' + str(Ancestor) + '];'
        Statement_Declaration = 'statement ' + str(Name) + ' ' + str(Default_Keyword) + ' Abstract;'
        Code = 'comment ' + str(self.Enquote('abstract '  +  Name  +  ' '  +  Default_Keyword  +  ' '  +  Ancestor  +  ';')) + str('\n') + str(Class_Declaration) + str('\n') + str(Statement_Declaration) + str('\n')
        self.Fallback = Code
        return True
# comment '**** Location.gal ****';
class Inference_Location (Inference):
    def Infer(self):
        if not self.Owner.Infer_Location():
            return False
        return True
# comment '**** Tokens.gal ****';
class Goal_Tokens (Goal):
    pass
class Spell_Tokens (Spell):
    pass
class Tokens (List):
    pass
class Inference_Tokens (Inference):
    def Infer(self):
        if not self.Owner.Infer_Tokens():
            return False
        return True
# comment '**** Classification.gal ****';
class Goal_Classification (Goal):
    pass
class Spell_Verb (Spell):
    pass
class Inference_Verb (Inference):
    def Infer(self):
        if not self.Owner.Infer_Verb():
            return False
        return True
class Spell_Classification (Spell):
    pass
class Inference_Classification (Inference):
    def Infer(self):
        if not self.Owner.Infer_Classification():
            return False
        return True
# comment '**** Components.gal ****';
class Goal_Components (Goal):
    pass
class Syntax_Set:
    def Allow_Suffix(self, Suffix):
        if Suffix  +  ' ' in " = ":
            return True
        self.Error = 'Unexpected extra keywords "'  +  Suffix  +  '".'
        return False
class Spell_Components (Spell):
    pass
class Components (List):
    def Infer(self):
        if not self.Symbol_Object.Infer_Components():
            return False
        return True
class Inference_Components (Inference):
    def Infer(self):
        if not self.Owner.Infer_Components():
            return False
        return True
class Inference_Attributes (Inference):
    def Infer(self):
        if not self.Owner.Infer_Attributes():
            return False
        return True
class Inference_Structure (Inference):
    def Infer(self):
        if not self.Owner.Infer_Structure():
            return False
        return True
# comment '**** Data_Types.gal ****';
class Goal_Data_Types (Goal):
    pass
class Spell_Data_Types (Spell):
    pass
class Data_Type (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
class Inference_Data_Types (Inference):
    def Infer(self):
        if not self.Owner.Infer_Data_Types():
            return False
        return True
# comment '**** Human.gal ****';
class Goal_Value (Goal):
    pass
class Spell_Value (Spell):
    pass
class Contest:
    def __init__(self):
        super().__init__()
        self.Score = Number(self)
        self.Winner = Object(self)
class Currency:
    Instances = Class_List()
    def __init__(self):
        super().__init__()
        self.Amount = Number(self)
        self.Owner = Object(self)
class Contest_Value (Contest):
    def __init__(self):
        super().__init__()
        self.Score = Number(self)
        self.Winner = Object(self)
class Currency_Value (Currency):
    Instances = Class_List()
    def __init__(self):
        super().__init__()
        self.propinit()
        self.__class__.Instances.extend([self])
    def propinit(self):
        self.Amount = Number(self)
        self.Owner = Object(self)
class Goal_Human (Goal):
    pass
class Spell_Human (Spell):
    pass
class Human_Beings:
    Everyone = Class_List()
class Currency_Support_Gratitude (Currency):
    Instances = Class_List()
    def __init__(self):
        super().__init__()
        self.propinit()
        self.__class__.Instances.extend([self])
    def propinit(self):
        self.Amount = Number(self)
        self.Owner = Object(self)
    @classmethod
    def Cycle(cls):
        Status = True
        Person = None
        Supporter = None
        for Person in Human_Beings.Everyone.Symbol_Value:
            Outcome = Person.Outcome.Symbol_Value
            Outcome_Certainty = Person.Outcome.Certainty.Symbol_Value
            Weighted_Outcome = Outcome * Outcome_Certainty
            Person_Weight = 0
            for Supporter in Person.Outcome.Outcome_Supports.Symbol_Value:
                Support_Weight = Supporter.Support_Weight.Symbol_Value
                Support_Certainty = Supporter.Certainty.Symbol_Value
                Person_Weight += Support_Weight * Support_Certainty
            for Supporter in Person.Outcome.Outcome_Supports.Symbol_Value:
                Support_Weight = Supporter.Support_Weight.Symbol_Value
                Support_Certainty = Supporter.Certainty.Symbol_Value
                Gratitude_Amount = Weighted_Outcome / Support_Weight * Support_Certainty
                # comment 'TODO:what information is relevant when paying?';
                None.Pay(Person, Supporter.Symbol_Value, Gratitude_Amount)
        return Status
class Outcome_Support (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
        self.Support_Weight = Number(self)
        self.Support_Gratitude = Object(self)
class Human_Outcome (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
        self.Inverse_Outcome = None
        self.Outcome_Supports = List(self)
class Human_Identity (Symbol):
    def __init__(self, Object):
        super().__init__()
        self.propinit()
        self.Symbol_Object = Object
    def propinit(self):
        self.Symbol_Object = None
        self.Symbol_Value = None
    # comment 'TODO:';
class Human_Being:
    def __init__(self):
        super().__init__()
        self.Identity = Human_Identity(self)
        self.Outcome = Human_Outcome(self)
class Goal_Altruism (Goal):
    pass
class Spell_Altruism (Spell):
    pass
class Inference_Altruism (Inference):
    def Infer(self):
        if not self.Owner.Infer_Altruism():
            return False
        return True
class Choice:
    def Infer_Altruism(self):
        # comment 'TODO:infer the degree to which this choice serves altruism';
        zdebug.zbreak()
        return True
class Inference_Choice (Inference):
    def Infer(self):
        if not self.Owner.Infer_Choice():
            return False
        return True
# comment 'TODO:infer the choice that best serves altruism';
# comment '**** Main.gal ****';
class Runtime_Translator:
    def Compile(self, Text):
        Verbose = False
        Trans = Translator()
        Trans.Input.Symbol_Value = Text
        Trans.Parser = Gs_Parser(Trans)
        Trans.Generator = Gs_Generator(Trans)
        Status = Trans.Initialize()
        if not Status:
            self.Error = 'Error intiailizing Goalspell Translator'
            return False
        Status = Trans.Parser.Infer()
        if not Status:
            self.Error = Trans.Parser.Error_Report()
            print(self.Error)
            return ''
        Top = Trans.Parser.Elements.Symbol_Value[-1]
        if isinstance(Top, Keyword_Token):
            if " "  +  Text  +  " " in " quit q exit bye ":
                return "exit"
            print("Unknown command ", Text, sep='')
            return ""
        elif isinstance(Top, Operation) or isinstance(Top, Syntax) or isinstance(Top, Token):
            Write_Source = 'writeline ' + str(Text) + ';'
            Trans.Input.Symbol_Value = Write_Source
            Trans.Parser = Gs_Parser(Trans)
            Trans.Initialize()
            Status = Trans.Parser.Infer()
            if not Status:
                self.Error = 'Error intiailizing Expression Translator'
                return False
        Trans.Generator.Elements = Trans.Parser.Elements
        Status = Trans.Generator.Infer()
        Gs = str(Trans.Generator.Code)
        if not Status:
            return True
        if Verbose:
            print('goalspell ', Gs, sep='')
        Fallback = str(Gs)
        Fb_Gen = Fallback_Generator(Trans)
        Fb_Gen.Elements = Trans.Parser.Elements
        Status = Fb_Gen.Initialize()
        Status = Fb_Gen.Infer()
        Fallback = str(Fb_Gen.Code)
        if Verbose:
            print('fallback ', Fallback, sep='')
        Atomic = str(Fallback)
        if str(Fallback) != str(Gs):
            Atomic_Trans = Translator()
            Atomic_Trans.Input.Symbol_Value = Fallback
            Atomic_Trans.Parser = Gs_Parser(Atomic_Trans)
            Atomic_Trans.Generator = Fallback_Generator(Atomic_Trans)
            Status = Atomic_Trans.Initialize()
            if not Status:
                raise Exception('Error intiailizing Atomic Translator')
            Status = Atomic_Trans.Parser.Infer()
            if not Status:
                raise Exception(str(Atomic_Trans.Parser.Error_Report()))
            Atomic_Trans.Generator.Elements = Atomic_Trans.Parser.Elements
            Status = Atomic_Trans.Generator.Infer()
            Atomic = Atomic_Trans.Generator.Code
            if Verbose:
                print('atomic ', Atomic, sep='')
        Compiled = ''
        if Status:
            Target_Trans = Translator()
            Target_Trans.Input.Symbol_Value = Atomic
            Target_Trans.Parser = Gs_Parser(Target_Trans)
            Target_Trans.Generator = Python_Generator(Target_Trans)
            Status = Target_Trans.Initialize()
            if not Status:
                zdebug.zbreak()
            Status = Target_Trans.Parser.Infer()
            if not Status:
                zdebug.zbreak()
            Target_Trans.Generator.Elements = Target_Trans.Parser.Elements
            Status = Target_Trans.Generator.Infer()
            if not Status:
                print(Target_Trans.Generator.Code)
            else:
                Compiled = Target_Trans.Generator.Code
            if Verbose:
                print('compiled ', Compiled, sep='')
        return Compiled
class Translation_Factory:
    # comment 'TODO:How do we add initializations.';
    def Get_Translator(self, Input_Format, Output_Format):
        Verbose = False
        Trans = Translator()
        if str(Input_Format) == 'gal':
            Trans.Parser = Gal_Parser(Trans)
        elif str(Input_Format) == 'goalspell' or str(Input_Format) == 'gs':
            Trans.Parser = Gs_Parser(Trans)
        elif str(Input_Format) == 'generator' or str(Input_Format) == 'gen':
            Parser = Gs_Parser(Trans)
            Trans.Parser = Parser
        elif str(Input_Format) == 'bnf':
            Trans.Parser = BNF_Parser(Trans)
        elif str(Input_Format) == 'antlr':
            Trans.Parser = ANTLR_BNF_Parser(Trans)
        elif str(Input_Format) == 'raku':
            Trans.Parser = Raku_Parser(Trans)
        else:
            raise Exception('Unknown input format ' + str(Input_Format))
        # comment 'debug';
        if str(Output_Format) == 'gal':
            Trans.Generator = Gal_Generator(Trans)
        elif str(Output_Format) == 'goalspell' or str(Output_Format) == 'gs':
            Trans.Generator = Gs_Generator(Trans)
        elif str(Output_Format) == 'c':
            Trans.Generator = C_Generator(Trans)
        elif str(Output_Format) == 'javascript' or str(Output_Format) == 'js':
            Trans.Generator = Javascript_Generator(Trans)
        elif str(Output_Format) == 'python' or str(Output_Format) == 'py':
            Trans.Generator = Python_Generator(Trans)
        elif str(Output_Format) == 'html':
            Trans.Generator = Html_Generator(Trans)
        elif str(Output_Format) == 'java':
            Trans.Generator = Java_Generator(Trans)
            # comment 'TODO:Java file per class';
        elif str(Output_Format) == 'fallback' or str(Output_Format) == 'fb':
            Trans.Generator = Fallback_Generator(Trans)
        elif str(Output_Format) == 'raku':
            Trans.Generator = Raku_Generator(Trans)
        elif str(Output_Format) == 'canonical':
            Trans.Generator = Canonical_Generator(Trans)
        elif str(Output_Format) == 'mumps' or str(Output_Format) == 'm':
            Trans.Generator = Mumps_Generator(Trans)
            Trans.Output = Mumps_File(Trans)
        elif str(Output_Format) == 'php':
            Trans.Generator = PHP_Generator(Trans)
        elif str(Output_Format) == 'example':
            Trans.Generator = Example_Generator(Trans)
        elif str(Output_Format) == 'bnfgs':
            Trans.Generator = Bnf_Gs_Generator(Trans)
        elif str(Output_Format) == 'perl':
            Trans.Generator = Perl_Generator(Trans)
        elif str(Output_Format) == 'tests':
            Trans.Generator = Test_Generator(Trans)
        else:
            raise Exception('Unknown output format ' + str(Output_Format))
        return Trans
if __name__ == '__main__':
    try:
        (Input_Format, Output_Format, Input_File, Output_File) = sys.argv[1:]
    except:
        pass
    Verbose = False
    Interactive = True
    try:
        Interactive = (Output_File in (None, ""))
    except Exception:
        pass
    if Interactive:
        RT = Runtime_Translator()
        Input = None
        while True:
            print('~ ',sep='',end='')
            Input = input()
            if (Input in (None, "")):
                break
            # comment 'compile Compiled Input;';
            Compiled = str(RT.Compile(Input))
            if str(Compiled) == "exit":
                break
            if (Compiled is not None and str(Compiled) > ""):
                if Verbose:
                    print('example', '\n', '{', '\n', Input, '\n', '}', '\n', sep='')
                if Verbose:
                    print('code box Prompt_', Fallback_Generator.Next_Example(), ' { pane "goalspell prompt" ‹~ ', Input, sep='')
                try:
                    exec(Compiled, globals())
                except Exception as Error:
                    print("Executing compiled code: ", Compiled, sep='')
                    print("ERROR: ", Error, sep='')
                if Verbose:
                    print('~ ›;}', '\n', sep='')
            else:
                print("    ", 'Warning, no compiled code.', sep='')
        print()
        # comment 'exit 0';
    else:
        if Verbose:
            print("Translate ", Input_File, " from ", Input_Format, " to ", Output_Format, " in ", Output_File, sep='')
        Factory = Translation_Factory()
        Trans = Factory.Get_Translator(Input_Format, Output_Format)
        Trans.Input.File_Name = Input_File
        Trans.Output.File_Name = Output_File
        if Verbose:
            print('Running Translator')
        # comment "Translator.Initialize doesn't take an argument.";
        Status = Trans.Initialize()
        Status &= Trans.Run()
        if not Status:
            print('ERROR status returned.')
            if not Trans.Parser.Status:
                print(Trans.Parser.Error_Report())
            if not Trans.Generator.Status:
                print(Trans.Generator.Error_Report())
        if Verbose:
            print('Result: ', Status, sep='')
        # comment 'verboseFile Text:  [attribute Trans Output]';
        # comment 'exit (not Status)';
